<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>나의 작은 테라리움 - Spirit Garden</title>
    <link href="https://fonts.googleapis.com/css2?family=Nanum+Myeongjo:wght@400;700;800&family=Gowun+Batang:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg: #fafaf8;
            --text: #2a2a2a;
            --border: #e0e0dc;
            --card: #ffffff;
            --shadow: rgba(0, 0, 0, 0.06);
            
            --fire: #ff6b4a;
            --water: #4a9eff;
            --wind: #7bdb8f;
            --earth: #d4a574;
            --light: #ffd94a;
            --dark: #8e7cc3;
        }

        body {
            font-family: 'Gowun Batang', serif;
            background: var(--bg);
            color: var(--text);
            line-height: 1.6;
            padding: 20px;
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            font-family: 'Nanum Myeongjo', serif;
            font-size: 2.5rem;
            font-weight: 800;
            text-align: center;
            margin-bottom: 10px;
            letter-spacing: -1px;
        }

        .subtitle {
            text-align: center;
            font-size: 0.9rem;
            color: #888;
            margin-bottom: 40px;
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            border-bottom: 1px solid var(--border);
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: none;
        }
        
        .tabs::-webkit-scrollbar {
            display: none;
        }

        .tab {
            padding: 12px 24px;
            background: none;
            border: none;
            font-family: 'Gowun Batang', serif;
            font-size: 1rem;
            cursor: pointer;
            color: #888;
            transition: all 0.3s;
            border-bottom: 2px solid transparent;
            white-space: nowrap;
            flex-shrink: 0;
        }

        .tab.active {
            color: var(--text);
            border-bottom-color: var(--text);
        }

        .tab:hover {
            color: var(--text);
        }

        .section {
            display: none;
        }

        .section.active {
            display: block;
        }

        .main-layout {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        .inventory-panel {
            background: var(--card);
            border: 1px solid var(--border);
            padding: 24px;
            height: fit-content;
            position: sticky;
            top: 20px;
        }

        .inventory-title {
            font-family: 'Nanum Myeongjo', serif;
            font-size: 1.2rem;
            font-weight: 700;
            margin-bottom: 16px;
        }

        .inventory-section {
            margin-bottom: 20px;
        }

        .inventory-label {
            font-size: 0.85rem;
            color: #888;
            margin-bottom: 8px;
        }

        .inventory-items {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .inventory-item {
            padding: 6px 12px;
            background: var(--bg);
            border: 1px solid var(--border);
            font-size: 0.85rem;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .spirits-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 20px;
        }

        .spirit-card {
            background: var(--card);
            border: 1px solid var(--border);
            padding: 24px;
            transition: all 0.3s;
        }

        .spirit-card:hover {
            box-shadow: 0 4px 20px var(--shadow);
            transform: translateY(-2px);
        }

        .spirit-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 16px;
        }

        .spirit-icon {
            font-size: 3rem;
            line-height: 1;
        }

        .spirit-info {
            flex: 1;
            margin-left: 16px;
        }

        .spirit-name {
            font-family: 'Nanum Myeongjo', serif;
            font-size: 1.2rem;
            font-weight: 700;
            margin-bottom: 4px;
            cursor: pointer;
        }

        .spirit-name:hover {
            color: var(--fire);
        }

        .spirit-stage {
            font-size: 0.85rem;
            color: #888;
        }

        .progress-bar {
            height: 6px;
            background: var(--border);
            margin-bottom: 8px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--light), var(--fire));
            transition: width 0.5s;
        }

        .progress-text {
            font-size: 0.8rem;
            color: #888;
            margin-bottom: 16px;
        }

        .parameters {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            margin-bottom: 16px;
            padding: 12px;
            background: var(--bg);
            border: 1px solid var(--border);
        }

        .param {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.85rem;
        }

        .param-icon {
            font-size: 1.1rem;
        }

        .environment {
            margin-bottom: 16px;
            padding: 12px;
            background: var(--bg);
            border: 1px solid var(--border);
        }

        .env-title {
            font-size: 0.85rem;
            font-weight: 700;
            margin-bottom: 8px;
        }

        .env-bars {
            display: grid;
            gap: 6px;
        }

        .env-bar {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.8rem;
        }

        .env-bar-bg {
            flex: 1;
            height: 8px;
            background: var(--border);
            position: relative;
            overflow: hidden;
        }

        .env-bar-fill {
            height: 100%;
            transition: width 0.5s;
        }

        .spirit-status {
            font-size: 0.85rem;
            color: #888;
            margin-bottom: 4px;
            min-height: 40px;
        }

        .action-buttons {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        button {
            padding: 10px 16px;
            border: 1px solid var(--border);
            background: var(--card);
            font-family: 'Gowun Batang', serif;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            user-select: none;
            -webkit-user-select: none;
        }

        button:hover {
            background: var(--bg);
            border-color: var(--text);
        }

        button:active {
            transform: scale(0.98);
        }

        button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        select {
            padding: 8px 12px;
            border: 1px solid var(--border);
            background: var(--card);
            color: var(--text);
            font-family: 'Gowun Batang', serif;
            font-size: 0.9rem;
            border-radius: 4px;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            -webkit-appearance: none;
            appearance: none;
        }
        
        select:focus {
            outline: 2px solid var(--fire);
            outline-offset: 2px;
        }

        .new-spirit-btn {
            width: 100%;
            padding: 16px;
            font-size: 1rem;
            font-weight: 700;
            margin-top: 20px;
        }

        .walk-btn {
            width: 100%;
            padding: 16px;
            font-size: 1rem;
            font-weight: 700;
            margin-bottom: 20px;
            background: var(--light);
            border-color: var(--light);
            color: #000 !important;
        }

        .walk-btn:hover {
            background: var(--fire);
            border-color: var(--fire);
            color: #000 !important;
        }

        .walk-btn:disabled {
            color: #666 !important;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.6);
            z-index: 1000;
            align-items: flex-start;
            justify-content: center;
            padding: 20px;
            padding-top: 180px;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: var(--card);
            padding: 32px;
            max-width: 500px;
            width: 100%;
            border: 1px solid var(--border);
            margin-bottom: 40px;
        }

        .modal-title {
            font-family: 'Nanum Myeongjo', serif;
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 20px;
        }

        .food-grid, .music-grid, .decor-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-bottom: 20px;
        }

        .option-btn {
            padding: 16px;
            text-align: left;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .option-icon {
            font-size: 1.5rem;
        }

        .option-info {
            flex: 1;
        }

        .option-name {
            font-weight: 700;
            margin-bottom: 2px;
        }

        .option-effect {
            font-size: 0.8rem;
            color: #888;
        }

        .close-btn {
            width: 100%;
            margin-top: 16px;
        }

        .collection-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 20px;
        }
        
        .encyclopedia-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .encyclopedia-card {
            background: var(--card);
            border: 2px solid var(--border);
            padding: 20px;
            text-align: center;
            position: relative;
            min-height: 120px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        .encyclopedia-card.unlocked {
            border-color: #4CAF50;
        }
        
        .encyclopedia-card.locked {
            background: repeating-linear-gradient(
                45deg,
                var(--card),
                var(--card) 10px,
                var(--border) 10px,
                var(--border) 11px
            );
            opacity: 0.6;
        }
        
        .encyclopedia-icon {
            font-size: 3rem;
            margin-bottom: 8px;
        }
        
        .encyclopedia-name {
            font-family: 'Nanum Myeongjo', serif;
            font-size: 1rem;
            font-weight: 700;
            color: var(--text);
        }
        
        .encyclopedia-count {
            font-size: 0.85rem;
            color: #888;
            margin-top: 4px;
        }

        .collection-card {
            background: var(--card);
            border: 1px solid var(--border);
            padding: 24px;
            text-align: center;
        }

        .collection-icon {
            font-size: 4rem;
            margin-bottom: 12px;
        }

        .collection-name {
            font-family: 'Nanum Myeongjo', serif;
            font-size: 1.2rem;
            font-weight: 700;
            margin-bottom: 8px;
        }

        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #888;
        }

        .empty-icon {
            font-size: 3rem;
            margin-bottom: 16px;
            opacity: 0.3;
        }

        .time-display {
            text-align: center;
            font-size: 0.9rem;
            color: #888;
            margin-bottom: 20px;
        }

        .notification {
            position: fixed;
            top: 80px;
            right: 20px;
            background: var(--card);
            border: 1px solid var(--border);
            padding: 16px 24px;
            box-shadow: 0 4px 20px var(--shadow);
            z-index: 999;
            animation: slideIn 0.3s ease-out;
            max-width: 300px;
            word-wrap: break-word;
        }

        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes slideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(400px);
                opacity: 0;
            }
        }

        .name-input {
            width: 100%;
            padding: 12px;
            font-family: 'Gowun Batang', serif;
            font-size: 1rem;
            border: 1px solid var(--border);
            margin-bottom: 16px;
        }

        .decor-btn:disabled::after {
            content: '재료 부족';
            position: absolute;
            top: 8px;
            right: 8px;
            font-size: 0.7rem;
            padding: 2px 6px;
            background: #f44;
            color: white;
            border-radius: 2px;
        }

        @media (max-width: 900px) {
            .main-layout {
                grid-template-columns: 1fr;
            }

            .inventory-panel {
                position: static;
            }
        }

        .light-toggle {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 60px;
            height: 32px;
            background: #4CAF50;
            border: none;
            border-radius: 16px;
            cursor: pointer;
            transition: background-color 0.3s ease;
            z-index: 1000;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            padding: 0;
        }
        
        /* 플로팅 스크롤 버튼 */
        .scroll-buttons {
            position: fixed;
            right: 20px;
            bottom: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 10000;
        }
        
        .scroll-btn {
            width: 45px;
            height: 45px;
            border: none;
            border-radius: 50%;
            background: var(--card);
            color: var(--text);
            cursor: pointer;
            font-size: 1.3rem;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            border: 1px solid var(--border);
            transition: all 0.2s ease;
        }
        
        .scroll-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        
        .scroll-btn:active {
            transform: scale(0.95);
        }
        
        /* 모바일 반응형 */
        @media (max-width: 768px) {
            .scroll-buttons {
                right: 15px;
                bottom: 15px;
            }
            
            .scroll-btn {
                width: 40px;
                height: 40px;
                font-size: 1.1rem;
            }
            
            /* 상점 레이아웃 1열로 변경 */
            .shop-grid {
                grid-template-columns: 1fr !important;
                gap: 15px !important;
            }
            
            /* 테라리움 장식물 목록 1열로 변경 */
            #installedDecorList > div,
            #terrariumDecorList > div {
                grid-template-columns: 1fr !important;
            }
            
            /* 상점 섹션 패딩 조정 */
            .shop-section {
                padding: 20px !important;
            }
            
            /* 제목 크기 조정 */
            h1 {
                font-size: 1.8rem !important;
            }
            
            h2 {
                font-size: 1.5rem !important;
            }
            
            /* 탭 버튼 크기 조정 */
            .tab {
                padding: 10px 15px !important;
                font-size: 0.9rem !important;
            }
            
            /* 상점 제목 크기 조정 */
            .shop-section h3 {
                font-size: 1.1rem !important;
            }
            
            /* 전체 여백 조정 */
            body {
                padding: 10px !important;
            }
        }

        .light-toggle::before {
            content: '';
            position: absolute;
            width: 26px;
            height: 26px;
            border-radius: 50%;
            background: white;
            top: 3px;
            left: 3px;
            transition: transform 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        body.dark-mode .light-toggle {
            background: #666;
        }

        body.dark-mode .light-toggle::before {
            transform: translateX(28px);
        }

        .light-toggle #lightIcon {
            display: none;
        }

        body.dark-mode {
            --bg: #1a1a1a;
            --card: #2d2d2d;
            --text: #e0e0e0;
            --border: #404040;
        }

        body.dark-mode .spirit-name,
        body.dark-mode .spirit-stage,
        body.dark-mode .progress-text,
        body.dark-mode .param,
        body.dark-mode .spirit-status,
        body.dark-mode .env-title,
        body.dark-mode .modal-title,
        body.dark-mode .option-name,
        body.dark-mode .option-effect,
        body.dark-mode .inventory-label,
        body.dark-mode .collection-name,
        body.dark-mode h1,
        body.dark-mode h2,
        body.dark-mode .subtitle,
        body.dark-mode .time-display {
            color: #e0e0e0;
        }

        body.dark-mode button {
            color: #e0e0e0;
        }

        body.dark-mode button:disabled {
            color: #888;
        }
        
        /* 미니게임 모바일 대응 */
        @media (max-width: 768px) {
            #minigameArea {
                height: 200px !important;
            }
            
            #minigameSpirit {
                font-size: 2rem !important;
                bottom: 5px !important;
            }
            
            #shieldEffect {
                width: 60px !important;
                height: 60px !important;
            }
            
            .minigame-word {
                font-size: 0.8rem !important;
                padding: 5px 8px !important;
            }
            
            #minigameInput {
                font-size: 1rem !important;
                padding: 12px !important;
            }
            
            /* 미니게임 플레이 중 화면 고정 */
            body.minigame-active {
                overflow: hidden;
                position: fixed;
                width: 100%;
                height: 100%;
            }
            
            body.minigame-active #minigamePlay {
                position: fixed;
                left: 0;
                right: 0;
                bottom: 0;
                z-index: 9999;
                background: var(--bg);
                padding: 0;
                display: flex !important;
                flex-direction: column;
            }
            
            body.minigame-active #minigamePlay > div:first-child {
                /* 상태바 (하트, 점수, 포기버튼) */
                margin: 0;
                border-radius: 0;
                padding: 10px 15px !important;
            }
            
            body.minigame-active #minigameArea {
                flex: 0 0 auto;
                height: 220px !important;
                border-radius: 0;
                border-left: none;
                border-right: none;
                margin: 0;
            }
            
            body.minigame-active #minigamePlay > div:last-child {
                /* 입력창 컨테이너 */
                margin: 0 !important;
            }
            
            body.minigame-active #minigameInput {
                border-radius: 0;
                border-left: none;
                border-right: none;
                border-bottom: none;
            }
        }
        
        /* 튜토리얼 버튼 강조 효과 */
        @keyframes tutorialPulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 193, 7, 0.7); }
            50% { box-shadow: 0 0 20px 10px rgba(255, 193, 7, 0.4); }
            100% { box-shadow: 0 0 0 0 rgba(255, 193, 7, 0.7); }
        }
        
        .tutorial-highlight {
            animation: tutorialPulse 1.5s infinite !important;
            border: 3px solid #ffc107 !important;
            position: relative;
            z-index: 100;
        }
        
        .tutorial-highlight::after {
            content: '👇';
            position: absolute;
            top: -30px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 1.5rem;
            animation: bounce 0.5s infinite alternate;
        }
        
        @keyframes bounce {
            from { transform: translateX(-50%) translateY(0); }
            to { transform: translateX(-50%) translateY(-5px); }
        }
    </style>
</head>
<body>
    <!-- 오프닝 스토리 팝업 -->
    <div id="openingModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 99999; justify-content: center; align-items: center;">
        <div style="max-width: 500px; width: 90%; padding: 40px; text-align: center; display: flex; flex-direction: column; align-items: center;">
            <div style="min-height: 120px; display: flex; align-items: center; justify-content: center;">
                <div id="openingText" style="color: #e0e0e0; font-family: 'Nanum Myeongjo', serif; font-size: 1.1rem; line-height: 2; opacity: 0; transition: opacity 1s; word-break: keep-all;">
                </div>
            </div>
            <div style="height: 80px; display: flex; align-items: flex-start; justify-content: center; padding-top: 20px;">
                <button id="openingNextBtn" onclick="nextOpeningScene()" style="display: none; padding: 12px 40px; background: transparent; border: 1px solid #888; color: #888; font-family: 'Gowun Batang', serif; font-size: 1rem; cursor: pointer; transition: all 0.3s;">
                    다음
                </button>
            </div>
            <button id="openingSkipBtn" onclick="skipOpening()" style="position: absolute; top: 20px; right: 20px; background: none; border: none; color: #666; font-size: 0.9rem; cursor: pointer;">
                건너뛰기
            </button>
        </div>
    </div>

    <!-- 제목 영역 -->
    <div style="display: flex; justify-content: center; align-items: center; position: relative; margin-bottom: 10px;">
        <h1 style="margin: 0;">나의 작은 테라리움</h1>
        <button id="settingsBtn" onclick="switchTab('settings')" style="position: absolute; right: 0; background: none; border: none; cursor: pointer; font-size: 1.2rem; opacity: 0.5;" onmouseover="this.style.opacity='1'" onmouseout="this.style.opacity='0.5'">⚙️</button>
    </div>
    <div class="subtitle">Spirit Garden</div>

    <div class="time-display" id="timeDisplay"></div>

    <div class="tabs">
        <button class="tab active" onclick="switchTab('garden')">육성</button>
        <button class="tab" onclick="switchTab('terrarium')">테라리움</button>
        <button class="tab" onclick="switchTab('lab')">연구실</button>
        <button class="tab" onclick="switchTab('shop')">상점 💰<span id="coinDisplay">0</span></button>
        <button class="tab" onclick="switchTab('minigame')">미니게임</button>
        <button class="tab" onclick="switchTab('encyclopedia')">도감</button>
        <button class="tab" onclick="switchTab('album')">앨범</button>
        <button class="tab" onclick="switchTab('journal')">일지</button>
        <!-- 일시정지 / 조명 버튼 -->
        <button id="pauseBtn" onclick="togglePause()" style="padding: 8px 12px; background: #ff9800; color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 1.2rem; margin-left: auto;">⏸️</button>
        <button id="lightBtn" onclick="toggleLight()" style="padding: 8px 12px; background: #2196F3; color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 1.2rem;"><span id="lightIcon">☀️</span></button>
    </div>

    <div id="gardenSection" class="section active">
        <div class="main-layout">
            <div class="inventory-panel">
                <div style="margin-bottom: 16px;">
                    <label for="titleSelect" style="display: block; font-size: 0.9rem; margin-bottom: 6px; color: var(--text); font-weight: 600;">칭호 선택</label>
                    <select id="titleSelect" onchange="changeTitle()" style="width: 100%; padding: 10px; border: 2px solid var(--border); border-radius: 8px; background: var(--card); color: var(--text); font-size: 0.9rem; cursor: pointer;">
                        <option value="none">자동채집 (확률 절반)</option>
                        <option value="hawk_eye">매의 눈 (모든 채집물 확률 1.5배)</option>
                        <option value="gatherer">채집꾼 (먹이 확률 2배)</option>
                        <option value="musician">음악가 (레코드 확률 2배)</option>
                        <option value="collector">수집가 (테라리움 물품 확률 2배)</option>
                    </select>
                </div>

                <div style="margin-bottom: 16px;">
                    <label for="gatherLocationSelect" style="display: block; font-size: 0.9rem; margin-bottom: 6px; color: var(--text); font-weight: 600;">채집 장소</label>
                    <select id="gatherLocationSelect" onchange="changeGatherLocation()" style="width: 100%; padding: 10px; border: 2px solid var(--border); border-radius: 8px; background: var(--card); color: var(--text); font-size: 0.9rem; cursor: pointer;">
                        <option value="garden">🌸 정원 (모든 속성)</option>
                        <option value="lake">🌊 호수 (물·바람)</option>
                        <option value="forest">🌲 숲 (땅·불)</option>
                    </select>
                </div>

                <button class="walk-btn" onclick="goGather()" style="margin-bottom: 20px;">채집하기</button>

                <div class="inventory-title" onclick="toggleInventoryCollapse()" style="cursor: pointer; display: flex; justify-content: space-between; align-items: center;">
                    <span>내 소지품</span>
                    <span id="inventoryToggleIcon" style="font-size: 0.8rem; color: #888;">▼</span>
                </div>
                
                <div id="inventoryContent">
                    <div class="inventory-section">
                        <div class="inventory-label">🍎 먹이</div>
                        <div class="inventory-items" id="foodInventory">
                            <div class="inventory-item">없음</div>
                        </div>
                    </div>

                    <div class="inventory-section">
                        <div class="inventory-label">음악</div>
                        <div class="inventory-items" id="musicInventory">
                            <div class="inventory-item">없음</div>
                        </div>
                    </div>

                    <div class="inventory-section">
                        <div class="inventory-label">🌳 나무 & 장식물</div>
                        <div class="inventory-items" id="decorInventory">
                            <div class="inventory-item">없음</div>
                        </div>
                    </div>
                </div>
            </div>

            <div>
                <div class="spirits-grid" id="spiritsGrid"></div>
                <button class="new-spirit-btn" onclick="createNewSpirit()">+ 새로운 알 받기</button>
            </div>
        </div>
    </div>

    <div id="encyclopediaSection" class="section">
        <h2 style="text-align: center; font-family: 'Nanum Myeongjo', serif; font-size: 2rem; margin-bottom: 30px;">정령 도감</h2>
        <div class="encyclopedia-grid" id="encyclopediaGrid"></div>
    </div>

    <div id="albumSection" class="section">
        <h2 style="text-align: center; font-family: 'Nanum Myeongjo', serif; font-size: 2rem; margin-bottom: 30px;">💝 정령 앨범</h2>
        <div class="collection-grid" id="collectionGrid"></div>
    </div>
    
    <!-- 일지 섹션 -->
    <div id="labSection" class="section">
        <h2 style="text-align: center; font-family: 'Nanum Myeongjo', serif; font-size: 2rem; margin-bottom: 30px;">🔬 연구실</h2>
        
        <div style="max-width: 800px; margin: 0 auto;">
            <!-- 합성 영역 -->
            <div style="background: var(--card); border: 1px solid var(--border); border-radius: 12px; padding: 24px; margin-bottom: 20px;">
                <h3 style="font-family: 'Nanum Myeongjo', serif; font-size: 1.3rem; margin-bottom: 20px; text-align: center;">재료 합성</h3>
                
                <div style="display: flex; justify-content: center; align-items: center; gap: 15px; flex-wrap: wrap; margin-bottom: 20px;">
                    <!-- 슬롯 1 -->
                    <div id="labSlot1" onclick="openLabSlotModal(1)" style="width: 120px; height: 120px; border: 2px dashed var(--border); border-radius: 12px; display: flex; flex-direction: column; justify-content: center; align-items: center; cursor: pointer; background: var(--bg); transition: all 0.2s;">
                        <div style="font-size: 2rem; margin-bottom: 5px;">➕</div>
                        <div style="font-size: 0.8rem; color: #888;">재료 선택</div>
                    </div>
                    
                    <div style="font-size: 2rem; color: #888;">+</div>
                    
                    <!-- 슬롯 2 -->
                    <div id="labSlot2" onclick="openLabSlotModal(2)" style="width: 120px; height: 120px; border: 2px dashed var(--border); border-radius: 12px; display: flex; flex-direction: column; justify-content: center; align-items: center; cursor: pointer; background: var(--bg); transition: all 0.2s;">
                        <div style="font-size: 2rem; margin-bottom: 5px;">➕</div>
                        <div style="font-size: 0.8rem; color: #888;">재료 선택</div>
                    </div>
                    
                    <div style="font-size: 2rem; color: #888;">→</div>
                    
                    <!-- 결과 슬롯 -->
                    <div id="labResultSlot" style="width: 120px; height: 120px; border: 2px solid var(--border); border-radius: 12px; display: flex; flex-direction: column; justify-content: center; align-items: center; background: var(--bg);">
                        <div style="font-size: 2rem; margin-bottom: 5px;">❓</div>
                        <div style="font-size: 0.8rem; color: #888;">결과물</div>
                    </div>
                </div>
                
                <div style="text-align: center;">
                    <button id="synthesizeBtn" onclick="synthesize()" style="padding: 12px 40px; background: #9b59b6; color: white; border: none; border-radius: 8px; font-size: 1rem; font-weight: 700; cursor: pointer; opacity: 0.5;" disabled>
                        🔮 합성하기
                    </button>
                </div>
                
                <div id="labMessage" style="margin-top: 15px; text-align: center; font-size: 0.9rem; color: #888; min-height: 20px;"></div>
            </div>
            
            <!-- 레시피 목록 -->
            <div style="background: var(--card); border: 1px solid var(--border); border-radius: 12px; padding: 24px;">
                <h3 style="font-family: 'Nanum Myeongjo', serif; font-size: 1.3rem; margin-bottom: 20px;">📜 레시피 목록</h3>
                
                <!-- 카테고리 필터 -->
                <div style="margin-bottom: 20px;">
                    <select id="recipeFilterSelect" onchange="filterRecipes(this.value)" style="padding: 10px 16px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg); color: var(--text); font-size: 1rem; cursor: pointer; min-width: 150px;">
                        <option value="all">📋 전체</option>
                        <option value="food">🍎 먹이</option>
                        <option value="decoration">🌳 장식물</option>
                    </select>
                </div>
                
                <div id="recipeList" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 12px;"></div>
            </div>
        </div>
    </div>
    
    <div id="journalSection" class="section">
        <h2 style="text-align: center; font-family: 'Nanum Myeongjo', serif; font-size: 2rem; margin-bottom: 30px;">📖 일지</h2>
        <div style="max-width: 600px; margin: 0 auto; text-align: center; padding: 60px 20px;">
            <div style="font-size: 4rem; margin-bottom: 20px;">🚧</div>
            <p style="font-size: 1.2rem; color: var(--text-muted); font-family: 'Gowun Batang', serif;">준비중...</p>
        </div>
    </div>
    
    <!-- 설정 섹션 -->
    <div id="settingsSection" class="section">
        <h2 style="text-align: center; font-family: 'Nanum Myeongjo', serif; font-size: 2rem; margin-bottom: 30px;">설정</h2>
        
        <div style="max-width: 600px; margin: 0 auto;">
            <!-- 데이터 관리 -->
            <div style="background: var(--card); padding: 24px; border: 1px solid var(--border); border-radius: 12px; margin-bottom: 20px;">
                <h3 style="font-family: 'Nanum Myeongjo', serif; font-size: 1.3rem; margin-bottom: 20px; color: var(--text);">데이터 관리</h3>
                
                <div style="display: flex; flex-direction: column; gap: 12px;">
                    <button onclick="exportGameData()" style="padding: 14px; background: var(--water); color: white; border: none; border-radius: 8px; font-size: 1rem; font-weight: 700; cursor: pointer;">
                        게임 데이터 내보내기
                    </button>
                    
                    <button onclick="importGameData()" style="padding: 14px; background: var(--wind); color: white; border: none; border-radius: 8px; font-size: 1rem; font-weight: 700; cursor: pointer;">
                        게임 데이터 불러오기
                    </button>
                    
                    <button onclick="manualRebuildEncyclopedia()" style="padding: 14px; background: var(--earth); color: white; border: none; border-radius: 8px; font-size: 1rem; font-weight: 700; cursor: pointer;">
                        앨범에서 도감 복구
                    </button>
                    
                    <button onclick="showAlbumBackupRestore()" style="padding: 14px; background: #e67e22; color: white; border: none; border-radius: 8px; font-size: 1rem; font-weight: 700; cursor: pointer;">
                        앨범 백업 복구
                    </button>
                    
                    <button onclick="repairBrokenSpirits()" style="padding: 14px; background: #9b59b6; color: white; border: none; border-radius: 8px; font-size: 1rem; font-weight: 700; cursor: pointer;">
                        🔧 교배 정령 관리
                    </button>
                </div>
                
                <div style="margin-top: 16px; padding: 12px; background: var(--bg); border-radius: 8px; font-size: 0.85rem; color: #888;">
                    💡 데이터 내보내기를 통해 게임 진행상황을 백업할 수 있습니다.<br>
                    다른 기기나 브라우저에서 불러오기를 통해 복원할 수 있습니다.<br>
                    📚 앨범 백업 복구: 정령 완성 시 자동 저장된 백업에서 앨범을 복구합니다.
                </div>
            </div>
            
            <!-- 화면 설정 -->
            <div style="background: var(--card); padding: 24px; border: 1px solid var(--border); border-radius: 12px; margin-bottom: 20px;">
                <h3 style="font-family: 'Nanum Myeongjo', serif; font-size: 1.3rem; margin-bottom: 20px; color: var(--text);">화면 설정</h3>
                
                <div style="display: flex; justify-content: space-between; align-items: center; padding: 12px; background: var(--bg); border-radius: 8px;">
                    <div>
                        <div style="font-weight: 700; margin-bottom: 4px;">다크 모드 고정</div>
                        <div style="font-size: 0.85rem; color: #888;">활성화 시 조명 상태와 무관하게 다크 모드 유지</div>
                    </div>
                    <label style="position: relative; display: inline-block; width: 60px; height: 32px;">
                        <input type="checkbox" id="darkModeToggle" onchange="toggleDarkModeLock()" style="opacity: 0; width: 0; height: 0;">
                        <span style="position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 32px;">
                            <span id="darkModeSlider" style="position: absolute; content: ''; height: 24px; width: 24px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%;"></span>
                        </span>
                    </label>
                </div>
            </div>
            
            <!-- 이벤트 코드 -->
            <div style="background: var(--card); padding: 24px; border: 1px solid var(--border); border-radius: 12px; margin-bottom: 20px;">
                <h3 style="font-family: 'Nanum Myeongjo', serif; font-size: 1.3rem; margin-bottom: 20px; color: var(--text);">이벤트 코드</h3>
                
                <p style="font-size: 0.9rem; color: #888; margin-bottom: 16px;">이벤트 코드를 입력하면 시즌 정령 알을 받을 수 있습니다!</p>
                
                <div style="display: flex; gap: 8px; margin-bottom: 12px;">
                    <input type="text" id="eventCodeInput" placeholder="SGEVENT-로 시작하는 코드 입력..." style="flex: 1; padding: 12px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg); color: var(--text); font-family: monospace;">
                    <button onclick="redeemEventCode()" style="padding: 12px 20px; background: #333; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 700;">
                        사용
                    </button>
                </div>
            </div>
            
            <!-- 게임 초기화 -->
            <div style="background: var(--card); padding: 24px; border: 1px solid var(--border); border-radius: 12px; margin-bottom: 20px;">
                <h3 style="font-family: 'Nanum Myeongjo', serif; font-size: 1.3rem; margin-bottom: 20px; color: var(--text);">게임 초기화</h3>
                
                <button onclick="resetGame()" style="width: 100%; padding: 14px; background: #e74c3c; color: white; border: none; border-radius: 8px; font-size: 1rem; font-weight: 700; cursor: pointer;">
                    🔄 게임 초기화
                </button>
                
                <div style="margin-top: 16px; padding: 12px; background: var(--bg); border-radius: 8px; font-size: 0.85rem; color: #e74c3c;">
                    ⚠️ 주의: 모든 정령, 아이템, 진행 상황이 삭제됩니다.<br>
                    초기화 전 데이터 내보내기를 권장합니다.
                </div>
            </div>
            
            <!-- 게임 정보 -->
            <div style="background: var(--card); padding: 24px; border: 1px solid var(--border); border-radius: 12px;">
                <h3 style="font-family: 'Nanum Myeongjo', serif; font-size: 1.3rem; margin-bottom: 20px; color: var(--text);">게임 정보</h3>
                
                <div style="display: flex; flex-direction: column; gap: 12px; font-size: 0.9rem; color: var(--text);">
                    <div style="display: flex; justify-content: space-between; padding: 8px 0;">
                        <span>버전</span>
                        <span style="font-weight: 700;">베타</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- 앨범 상세 정보 모달 -->
    <div id="albumDetailModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 10000; justify-content: center; align-items: center;">
        <div id="albumDetailContent" style="background: var(--card); border: 2px solid var(--border); border-radius: 12px; padding: 30px; max-width: 500px; width: 90%; max-height: 80vh; overflow-y: auto;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <h2 id="modalTitle" style="font-family: 'Nanum Myeongjo', serif; font-size: 1.5rem; color: var(--text); margin: 0;"></h2>
                <button onclick="closeAlbumDetail()" style="background: none; border: none; font-size: 1.5rem; cursor: pointer; color: var(--text);">✕</button>
            </div>
            <div id="modalContent"></div>
            <div style="margin-top: 15px; text-align: center;">
                <button onclick="saveAlbumDetailImage()" style="padding: 10px 20px; background: var(--water); color: white; border: none; border-radius: 8px; font-size: 0.9rem; font-weight: 600; cursor: pointer;">
                    📷 이미지로 저장
                </button>
            </div>
        </div>
    </div>

    <div id="shopSection" class="section">
        <div style="max-width: 1000px; margin: 0 auto;">
            <!-- 상점 주인 대사 -->
            <div id="shopkeeperArea" style="background: var(--card); border: 1px solid var(--border); border-radius: 12px; padding: 20px; margin-bottom: 20px; display: flex; align-items: center; gap: 15px;">
                <div style="text-align: center;">
                    <div style="font-size: 3rem;">👤</div>
                    <div style="font-size: 0.8rem; font-weight: 600; color: var(--text-muted);">상점 주인</div>
                </div>
                <div style="flex: 1; font-family: 'Gowun Batang', serif; font-size: 1.1rem; color: var(--text); font-style: italic;" id="shopkeeperDialogue">
                    어서오세요...
                </div>
            </div>
            
            <div style="text-align: center; margin-bottom: 30px;">
                <h2 style="font-family: 'Nanum Myeongjo', serif; font-size: 2rem; margin-bottom: 10px;">🏪 정령 상점</h2>
                <div style="font-size: 1.5rem; font-weight: 700; color: var(--fire); margin-bottom: 20px;">보유 코인: <span id="shopCoinDisplay">0</span> 💰</div>
                
                <!-- 카테고리 선택 드롭다운 -->
                <select id="shopCategorySelect" onchange="changeShopCategory()" style="padding: 12px 20px; font-size: 1rem; border: 2px solid var(--border); border-radius: 8px; background: var(--card); color: var(--text); cursor: pointer; min-width: 200px;">
                    <option value="all">📦 전체</option>
                    <option value="food">🍎 먹이</option>
                    <option value="decoration">🌳 장식물</option>
                    <option value="music">레코드</option>
                </select>
            </div>

            <div class="shop-grid" style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 30px;">
                <!-- 판매 (소지품 → 코인) -->
                <div class="shop-section" style="background: var(--card); border: 1px solid var(--border); padding: 32px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                        <h3 style="font-family: 'Nanum Myeongjo', serif; font-size: 1.3rem; margin: 0; color: var(--fire);">💸 판매하기</h3>
                        <select id="sellFilterSelect" onchange="changeSellFilter()" style="padding: 8px 12px; font-size: 0.9rem; border: 1px solid var(--border); border-radius: 6px; background: var(--card); color: var(--text); cursor: pointer;">
                            <option value="all">전체</option>
                            <option value="fire">🔥 불</option>
                            <option value="water">💧 물</option>
                            <option value="wind">🌬️ 바람</option>
                            <option value="earth">🌱 땅</option>
                            <option value="light">✨ 빛</option>
                            <option value="dark">🌙 어둠</option>
                            <option value="intelligence">🧠 지력</option>
                            <option value="strength">💪 체력</option>
                            <option value="charm">💖 매력</option>
                        </select>
                    </div>
                    <div id="sellList"></div>
                </div>

                <!-- 구매 (코인 → 아이템) -->
                <div class="shop-section" style="background: var(--card); border: 1px solid var(--border); padding: 32px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                        <h3 style="font-family: 'Nanum Myeongjo', serif; font-size: 1.3rem; margin: 0; color: var(--water);">🛒 구매하기</h3>
                        <select id="buyFilterSelect" onchange="changeBuyFilter()" style="padding: 8px 12px; font-size: 0.9rem; border: 1px solid var(--border); border-radius: 6px; background: var(--card); color: var(--text); cursor: pointer;">
                            <option value="all">전체</option>
                            <option value="fire">🔥 불</option>
                            <option value="water">💧 물</option>
                            <option value="wind">🌬️ 바람</option>
                            <option value="earth">🌱 땅</option>
                            <option value="light">✨ 빛</option>
                            <option value="dark">🌙 어둠</option>
                            <option value="intelligence">🧠 지력</option>
                            <option value="strength">💪 체력</option>
                            <option value="charm">💖 매력</option>
                        </select>
                    </div>
                    <div id="buyList"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- 미니게임 섹션 -->
    <div id="minigameSection" class="section">
        <div style="max-width: 800px; margin: 0 auto;">
            <h2 style="text-align: center; font-family: 'Nanum Myeongjo', serif; font-size: 2rem; margin-bottom: 10px;">🎮 정령 지키기</h2>
            <p style="text-align: center; color: #888; margin-bottom: 30px;">떨어지는 해충과 독버섯으로부터 정령을 지켜주세요!</p>
            
            <!-- 게임 시작 전 화면 -->
            <div id="minigameIntro" style="background: var(--card); border: 1px solid var(--border); padding: 40px; text-align: center;">
                <div style="font-size: 4rem; margin-bottom: 20px;">🛡️</div>
                <h3 style="font-family: 'Nanum Myeongjo', serif; font-size: 1.5rem; margin-bottom: 20px;">게임 방법</h3>
                <div style="text-align: left; max-width: 400px; margin: 0 auto 30px; line-height: 1.8; color: var(--text);">
                    <p>• 위에서 해충과 독버섯이 떨어집니다</p>
                    <p>• 단어를 타이핑해서 제거하세요</p>
                    <p>• 바닥에 닿으면 정령이 다칩니다</p>
                    <p>• 목숨 3개가 모두 소진되면 게임 오버!</p>
                </div>
                <div style="margin-bottom: 20px;">
                    <label style="font-weight: 600; margin-right: 10px;">난이도:</label>
                    <select id="minigameDifficulty" style="padding: 10px 20px; font-size: 1rem; border: 2px solid var(--border); border-radius: 8px; background: var(--card); color: var(--text);">
                        <option value="easy" selected>쉬움</option>
                        <option value="hard">어려움 (보상 2배)</option>
                    </select>
                </div>
                <button onclick="startMinigame()" style="padding: 16px 48px; font-size: 1.2rem; font-weight: 700; background: var(--fire); color: white; border: none; border-radius: 12px; cursor: pointer;">
                    게임 시작
                </button>
            </div>
            
            <!-- 게임 플레이 화면 -->
            <div id="minigamePlay" style="display: none;">
                <!-- 게임 상태 바 -->
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; padding: 15px 20px; background: var(--card); border: 1px solid var(--border); border-radius: 8px;">
                    <div style="font-size: 1.2rem;">
                        <span style="color: #e74c3c;">❤️</span> 
                        <span id="minigameLives">❤️❤️❤️</span>
                    </div>
                    <div style="font-size: 1.3rem; font-weight: 700; color: var(--fire);">
                        ⏱️ <span id="minigameTimer">60</span>초
                    </div>
                    <div style="font-size: 1.3rem; font-weight: 700; color: var(--text);">
                        점수: <span id="minigameScore">0</span>
                    </div>
                    <button onclick="endMinigame()" style="padding: 8px 16px; background: #888; color: white; border: none; border-radius: 6px; cursor: pointer;">포기</button>
                </div>
                
                <!-- 게임 영역 -->
                <div id="minigameArea" style="position: relative; width: 100%; height: 500px; background: linear-gradient(180deg, #87CEEB 0%, #E0F6FF 50%, #90EE90 95%, #228B22 100%); border: 3px solid var(--border); border-radius: 12px; overflow: hidden; user-select: none;">
                    <!-- 떨어지는 단어들이 여기에 생성됨 -->
                    
                    <!-- 정령 (하단) -->
                    <div id="minigameSpirit" style="position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); font-size: 4rem; transition: all 0.3s; filter: drop-shadow(0 4px 8px rgba(0,0,0,0.3));">
                        🐛
                    </div>
                    
                    <!-- 보호막 이펙트 -->
                    <div id="shieldEffect" style="position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%); width: 120px; height: 120px; border-radius: 50%; background: radial-gradient(circle, rgba(100,200,255,0.3) 0%, transparent 70%); opacity: 0; transition: opacity 0.2s;"></div>
                </div>
                
                <!-- 입력 영역 -->
                <div style="margin-top: 15px;">
                    <input type="text" id="minigameInput" placeholder="단어를 입력하세요..." autocomplete="off" autocapitalize="off" spellcheck="false"
                        style="width: 100%; padding: 18px 24px; font-size: 1.3rem; border: 3px solid var(--border); border-radius: 12px; text-align: center; font-family: 'Gowun Batang', serif; background: var(--card); color: var(--text); box-sizing: border-box;">
                </div>
            </div>
            
            <!-- 게임 결과 화면 -->
            <div id="minigameResult" style="display: none; background: var(--card); border: 1px solid var(--border); padding: 40px; text-align: center;">
                <div id="resultIcon" style="font-size: 5rem; margin-bottom: 20px;">🎉</div>
                <h3 id="resultTitle" style="font-family: 'Nanum Myeongjo', serif; font-size: 1.8rem; margin-bottom: 15px;">게임 종료!</h3>
                <div style="font-size: 1.5rem; margin-bottom: 10px; color: var(--text);">
                    최종 점수: <span id="finalScore" style="font-weight: 700; color: var(--fire);">0</span>
                </div>
                <div style="font-size: 1.1rem; margin-bottom: 30px; color: #888;">
                    처치한 해충: <span id="defeatedCount">0</span>마리
                </div>
                
                <!-- 보상 선택 -->
                <div id="rewardSection" style="margin-bottom: 30px;">
                    <h4 style="font-size: 1.2rem; margin-bottom: 20px; color: var(--text);">보상을 선택하세요</h4>
                    <div style="display: flex; gap: 20px; justify-content: center; flex-wrap: wrap;">
                        <button onclick="claimReward('coin')" class="reward-btn" style="padding: 20px 30px; background: linear-gradient(135deg, #FFD700, #FFA500); color: #333; border: none; border-radius: 12px; cursor: pointer; min-width: 150px;">
                            <div style="font-size: 2rem; margin-bottom: 8px;">💰</div>
                            <div style="font-weight: 700;">코인 받기</div>
                            <div id="coinRewardAmount" style="font-size: 0.9rem; margin-top: 4px;">+0</div>
                        </button>
                        <button onclick="claimReward('item')" class="reward-btn" style="padding: 20px 30px; background: linear-gradient(135deg, #9B59B6, #8E44AD); color: white; border: none; border-radius: 12px; cursor: pointer; min-width: 150px;">
                            <div style="font-size: 2rem; margin-bottom: 8px;">🎁</div>
                            <div style="font-weight: 700;">아이템 받기</div>
                            <div style="font-size: 0.9rem; margin-top: 4px;">랜덤 보상</div>
                        </button>
                    </div>
                </div>
                
                <button onclick="backToMinigameIntro()" style="padding: 14px 40px; font-size: 1rem; background: var(--border); color: var(--text); border: none; border-radius: 8px; cursor: pointer;">
                    돌아가기
                </button>
            </div>
        </div>
    </div>

    <div id="terrariumSection" class="section">
        <div style="max-width: 800px; margin: 0 auto;">
            <!-- 테라리움 환경 -->
            <div style="background: var(--card); border: 1px solid var(--border); padding: 32px; margin-bottom: 20px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <h2 style="font-family: 'Nanum Myeongjo', serif; font-size: 1.5rem; margin: 0;">테라리움 환경</h2>
                    <div style="display: flex; align-items: center; gap: 8px; padding: 8px 16px; background: #f0f0f0; border-radius: 8px;">
                        <span style="font-weight: 600; color: #666;">전체 품질:</span>
                        <span id="terrariumQuality" style="font-size: 1.2rem; font-weight: 700; color: #ff9800;">0.0</span>
                    </div>
                </div>
                <div class="env-bars" style="display: grid; gap: 12px;">
                    <div class="env-bar" style="display: flex; align-items: center; gap: 12px;">
                        <span style="font-size: 1.5rem;">🔥</span>
                        <div class="env-bar-bg" style="flex: 1; height: 12px; background: var(--border);">
                            <div class="env-bar-fill" id="terrFireBar" style="height: 100%; background: var(--fire); width: 0%;"></div>
                        </div>
                        <span id="terrFireValue" style="min-width: 30px; text-align: right;">0</span>
                    </div>
                    <div class="env-bar" style="display: flex; align-items: center; gap: 12px;">
                        <span style="font-size: 1.5rem;">💧</span>
                        <div class="env-bar-bg" style="flex: 1; height: 12px; background: var(--border);">
                            <div class="env-bar-fill" id="terrWaterBar" style="height: 100%; background: var(--water); width: 0%;"></div>
                        </div>
                        <span id="terrWaterValue" style="min-width: 30px; text-align: right;">0</span>
                    </div>
                    <div class="env-bar" style="display: flex; align-items: center; gap: 12px;">
                        <span style="font-size: 1.5rem;">🌬️</span>
                        <div class="env-bar-bg" style="flex: 1; height: 12px; background: var(--border);">
                            <div class="env-bar-fill" id="terrWindBar" style="height: 100%; background: var(--wind); width: 0%;"></div>
                        </div>
                        <span id="terrWindValue" style="min-width: 30px; text-align: right;">0</span>
                    </div>
                    <div class="env-bar" style="display: flex; align-items: center; gap: 12px;">
                        <span style="font-size: 1.5rem;">🌱</span>
                        <div class="env-bar-bg" style="flex: 1; height: 12px; background: var(--border);">
                            <div class="env-bar-fill" id="terrEarthBar" style="height: 100%; background: var(--earth); width: 0%;"></div>
                        </div>
                        <span id="terrEarthValue" style="min-width: 30px; text-align: right;">0</span>
                    </div>
                    <div class="env-bar" style="display: flex; align-items: center; gap: 12px;">
                        <span style="font-size: 1.5rem;">✨</span>
                        <div class="env-bar-bg" style="flex: 1; height: 12px; background: var(--border);">
                            <div class="env-bar-fill" id="terrLightBar" style="height: 100%; background: var(--light); width: 0%;"></div>
                        </div>
                        <span id="terrLightValue" style="min-width: 30px; text-align: right;">0</span>
                    </div>
                    <div class="env-bar" style="display: flex; align-items: center; gap: 12px;">
                        <span style="font-size: 1.5rem;">🌙</span>
                        <div class="env-bar-bg" style="flex: 1; height: 12px; background: var(--border);">
                            <div class="env-bar-fill" id="terrDarkBar" style="height: 100%; background: var(--dark); width: 0%;"></div>
                        </div>
                        <span id="terrDarkValue" style="min-width: 30px; text-align: right;">0</span>
                    </div>
                </div>
            </div>

            <!-- 설치된 장식물 -->
            <div style="background: var(--card); border: 1px solid var(--border); padding: 32px; margin-bottom: 20px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                    <h2 style="font-family: 'Nanum Myeongjo', serif; font-size: 1.5rem; margin: 0;">설치된 장식물</h2>
                    <button onclick="removeAllDecorations()" style="padding: 6px 12px; background: var(--fire); color: white; border: none; border-radius: 4px; font-size: 0.85rem; cursor: pointer;">
                        전체 해제
                    </button>
                </div>
                <div style="font-size: 0.9rem; color: #888; margin-bottom: 20px;" id="installedCount">0 / 20</div>
                <div id="installedDecorList"></div>
            </div>

            <!-- 인벤토리 장식물 -->
            <div style="background: var(--card); border: 1px solid var(--border); padding: 32px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <h2 style="font-family: 'Nanum Myeongjo', serif; font-size: 1.5rem; margin: 0;">인벤토리 장식물</h2>
                    <div id="terrariumFilterArea" style="display: flex; gap: 8px;"></div>
                </div>
                <div id="terrariumDecorList"></div>
            </div>
        </div>
    </div>

    <!-- Name Modal -->
    <div class="modal" id="nameModal">
        <div class="modal-content">
            <div class="modal-title">정령의 이름을 지어주세요</div>
            <input type="text" class="name-input" id="nameInput" placeholder="이름을 입력하세요" maxlength="10" onkeypress="if(event.key === 'Enter') confirmName()">
            <button onclick="confirmName()" style="width: 100%;">확인</button>
        </div>
    </div>

    <!-- Feed Modal -->
    <div class="modal" id="feedModal">
        <div class="modal-content">
            <div class="modal-title">무엇을 먹일까요?</div>
            <div class="food-grid">
                <!-- 초기 더미 버튼 (renderFeedOptions()로 동적 생성됨) -->
            </div>
            <button class="close-btn" onclick="closeModal('feedModal')">닫기</button>
        </div>
    </div>

    <!-- Music Modal -->
    <div class="modal" id="musicModal">
        <div class="modal-content">
            <div class="modal-title">어떤 음악을 들려줄까요?</div>
            <div id="musicOptions"></div>
            <button class="close-btn" onclick="closeModal('musicModal')">닫기</button>
        </div>
    </div>

    <!-- Decorate Modal -->
    <div class="modal" id="decorateModal">
        <div class="modal-content">
            <div class="modal-title">테라리움 꾸미기</div>
            <div id="decorOptions"></div>
            <button class="close-btn" onclick="closeModal('decorateModal')">닫기</button>
        </div>
    </div>

    <!-- 커스텀 확인 모달 -->
    <div id="confirmModal" class="modal">
        <div class="modal-content" style="max-width: 400px;">
            <h3 id="confirmTitle" style="font-family: 'Nanum Myeongjo', serif; font-size: 1.3rem; margin-bottom: 15px; color: var(--text);"></h3>
            <p id="confirmMessage" style="margin-bottom: 25px; line-height: 1.6; color: var(--text); white-space: pre-line;"></p>
            <div style="display: flex; gap: 10px; justify-content: flex-end;">
                <button id="confirmCancelBtn" style="background: #888; color: white;">취소</button>
                <button id="confirmOkBtn" style="background: var(--fire); color: white;">확인</button>
            </div>
        </div>
    </div>

    <script>      let spirits = [];
        let collection = [];
        let encyclopedia = {}; // 도감: { evolutionKey: count }
        let darkModeLocked = false; // 다크 모드 고정 여부
        let inventory = {
            music: [],
            decorations: [],
            food: ['fire', 'fire', 'fire', 'water', 'water', 'water', 'wind', 'wind', 'wind', 'earth', 'earth', 'earth'],
            medicine: [] // 약초
        };
        let terrarium = {
            fire: 0,
            water: 0,
            wind: 0,
            earth: 0,
            light: 0,
            dark: 0
        };
        let installedDecorations = []; // 설치된 장식물 목록 (객체 배열: { type, index })
        let lightMode = true; // 조명 모드 (true: 빛, false: 어둠)
        let coins = 0; // 화폐
        let hasVisitedShop = false; // 상점 첫 방문 여부
        let currentSpiritId = null;
        let pendingSpirit = null;
        let lastGatherTime = null;
        let currentTab = 'garden'; // 현재 활성 탭
        let currentTitle = 'none'; // 현재 칭호 (none, hawk_eye, gatherer, musician, collector)
        let currentShopCategory = 'all'; // 현재 상점 카테고리 (all, food, decoration, music)
        let sellFilter = 'all'; // 판매 필터 (all, fire, water, wind, earth, light, dark, intelligence, strength, charm)
        let buyFilter = 'all'; // 구매 필터 (all, fire, water, wind, earth, light, dark, intelligence, strength, charm)
        let terrariumInvFilter = 'all'; // 테라리움 인벤토리 필터 (all, fire, water, wind, earth, light, dark, event)
        let terrariumQualityFilter = 'all'; // 테라리움 품질 필터 (all, common, rare, epic)
        let currentGatherLocation = 'garden'; // 현재 채집 장소 (garden, lake, forest)
        let lightToggleHistory = []; // 조명 변경 기록 (타임스탬프 배열)
        let isPaused = false; // 게임 일시정지 상태
        let pausedAt = null; // 일시정지 시작 시간
        let totalPausedTime = 0; // 총 일시정지 시간
        let activatedEvents = []; // 활성화된 이벤트 목록
        let lowSatisfactionStartTime = {}; // 정령별 불만 상태 시작 시간

        // 랜덤 문구 시스템
        const RANDOM_MESSAGES = {
            // 알 상태 기본 행동
            egg_basic: [
                '{name}이(가) 가만히 있습니다.',
                '{name}이(가) 조용히 놓여 있습니다.',
                '{name}에서 미세한 온기가 느껴집니다.',
                '{name}의 껍질이 살짝 흔들립니다.',
                '{name}에서 작은 소리가 들리는 것 같습니다.',
                '{name}이(가) 희미하게 빛납니다.',
                '{name}의 표면에 이슬이 맺혀 있습니다.',
                '{name}이(가) 따뜻하게 품어지길 기다리는 듯합니다.',
                '{name} 안에서 무언가 움직이는 것 같습니다.',
                '{name}이(가) 부화를 준비하고 있는 것 같습니다.'
            ],
            // 번데기 상태 기본 행동
            pupa_basic: [
                '{name}이(가) 미동도 하지 않습니다.',
                '{name}이(가) 조용히 변태 중입니다.',
                '{name}에서 약한 진동이 느껴집니다.',
                '{name}의 껍질이 아주 살짝 꿈틀거립니다.',
                '{name}이(가) 고요히 잠들어 있습니다.',
                '{name} 안에서 변화가 일어나고 있는 것 같습니다.',
                '{name}의 표면이 희미하게 빛납니다.',
                '{name}이(가) 나비가 될 꿈을 꾸고 있는 것 같습니다.',
                '{name}이(가) 새로운 모습을 준비하고 있습니다.',
                '{name}에서 신비로운 기운이 느껴집니다.'
            ],
            // 기본 행동 (조건 없음) - 애벌레용
            basic: [
                '{name}이(가) 꿈틀거립니다.',
                '{name}이(가) 몸을 부르르 떱니다.',
                '{name}이(가) 주변을 두리번거립니다.',
                '{name}이(가) 작게 울음소리를 냅니다.',
                '{name}이(가) 가만히 웅크리고 있습니다.',
                '{name}이(가) 천천히 움직입니다.',
                '{name}이(가) 테라리움 유리에 몸을 문지릅니다.',
                '{name}이(가) 몸을 살짝 떨고 있습니다.',
                '{name}이(가) 자신의 몸을 정리합니다.',
                '{name}이(가) 무언가를 찾는 듯합니다.',
                '{name}이(가) 외로워합니다.',
                '{name}이(가) 심심해 보입니다.',
                '{name}이(가) 한숨을 쉽니다.'
            ],
            // 알 상태 배고픔
            egg_hungry: [
                '{name}에서 허기진 기운이 느껴집니다.',
                '{name}이(가) 영양분이 필요한 것 같습니다.',
                '{name}의 빛이 조금 약해진 것 같습니다.',
                '{name}이(가) 힘없이 놓여 있습니다.'
            ],
            // 번데기 상태 배고픔
            pupa_hungry: [
                '{name}이(가) 힘없이 축 처져 있습니다.',
                '{name}에서 약한 기운이 느껴집니다.',
                '{name}의 변태가 느려진 것 같습니다.',
                '{name}이(가) 에너지가 부족해 보입니다.'
            ],
            // 배고픔 - 애벌레용
            hungry: [
                '{name}이(가) 배고파 보입니다.',
                '{name}이(가) 먹이를 찾고 있습니다.',
                '{name}이(가) 허기진 눈빛으로 당신을 봅니다.',
                '{name}이(가) 입맛을 다십니다.',
                '{name}이(가) 배를 움켜쥐고 있습니다.'
            ],
            // 알 상태 낮잠
            egg_napLight: [
                '{name}이(가) 햇살 아래에서 따뜻합니다.',
                '{name}에서 평온한 기운이 느껴집니다.',
                '{name}이(가) 포근하게 놓여 있습니다.'
            ],
            // 알 상태 밤잠
            egg_sleepDark: [
                '{name}이(가) 어둠 속에서 고요합니다.',
                '{name}이(가) 조용히 쉬고 있습니다.',
                '{name}에서 잔잔한 숨소리가 들리는 듯합니다.'
            ],
            // 번데기 상태 낮잠
            pupa_napLight: [
                '{name}이(가) 햇살 아래에서 변태 중입니다.',
                '{name}이(가) 따뜻한 빛을 받으며 쉬고 있습니다.',
                '{name}의 껍질이 햇살에 빛납니다.'
            ],
            // 번데기 상태 밤잠
            pupa_sleepDark: [
                '{name}이(가) 어둠 속에서 깊이 잠들어 있습니다.',
                '{name}이(가) 고요한 밤에 변화하고 있습니다.',
                '{name}이(가) 달빛 아래 조용히 쉬고 있습니다.'
            ],
            // 낮잠 (조명 켜짐) - 애벌레용
            napLight: [
                '{name}이(가) 낮잠을 자고 있습니다.',
                '{name}이(가) 햇살 아래에서 졸고 있습니다.',
                '{name}이(가) 편안하게 눈을 감고 있습니다.',
                '{name}이(가) 스르륵 잠이 들었습니다.',
                '{name}이(가) 나뭇잎 위에서 낮잠을 즐깁니다.'
            ],
            // 밤잠 (조명 꺼짐) - 애벌레용
            sleepDark: [
                '{name}이(가) 잠을 자고 있습니다.',
                '{name}이(가) 깊은 잠에 빠졌습니다.',
                '{name}이(가) 고요히 잠들어 있습니다.',
                '{name}이(가) 어둠 속에서 편히 쉬고 있습니다.',
                '{name}이(가) 조용히 꿈나라로 떠났습니다.'
            ],
            // 알 상태 애정도 낮음
            egg_affectionLow: [
                '{name}이(가) 쓸쓸해 보입니다.',
                '{name}에서 외로운 기운이 느껴집니다.',
                '{name}이(가) 관심이 필요한 것 같습니다.'
            ],
            // 번데기 상태 애정도 낮음
            pupa_affectionLow: [
                '{name}이(가) 외로워 보입니다.',
                '{name}에서 쓸쓸한 기운이 느껴집니다.',
                '{name}이(가) 보살핌이 필요해 보입니다.'
            ],
            // 애정도 낮음 (0-10) - 애벌레용
            affectionVeryLow: [
                '{name}이(가) 당신을 피해 테라리움 구석에 숨습니다.',
                '{name}이(가) 당신을 경계하며 멀리 떨어집니다.',
                '{name}이(가) 고개를 돌려 당신을 외면합니다.',
                '{name}이(가) 불안한 듯 몸을 떨고 있습니다.',
                '{name}이(가) 당신 앞에서 움츠러듭니다.'
            ],
            // 애정도 낮음 (10-30)
            affectionLow: [
                '{name}이(가) 당신을 빤히 바라봅니다.',
                '{name}이(가) 조심스럽게 당신을 관찰합니다.',
                '{name}이(가) 살짝 당신에게 다가옵니다.',
                '{name}이(가) 당신에게 관심을 보이기 시작합니다.',
                '{name}이(가) 호기심 어린 눈으로 당신을 봅니다.'
            ],
            // 애정도 중간 (30-50)
            affectionMedium: [
                '{name}이(가) 당신의 손에 뺨을 부빕니다.',
                '{name}이(가) 당신 주변을 빙글빙글 돕니다.',
                '{name}이(가) 당신의 손가락을 살짝 건드립니다.',
                '{name}이(가) 당신에게 애교를 부립니다.',
                '{name}이(가) 당신 곁에 가까이 다가옵니다.'
            ],
            // 애정도 높음 (50-100)
            affectionHigh: [
                '{name}이(가) 당신을 보며 행복해합니다.',
                '{name}이(가) 당신의 손바닥에서 뒹굽니다.',
                '{name}이(가) 당신에게 애정 어린 눈빛을 보냅니다.',
                '{name}이(가) 당신의 손을 꼭 붙잡습니다.',
                '{name}이(가) 당신과 함께 있어 즐거워 보입니다.'
            ],
            // 애정도 매우 높음 (100+)
            affectionVeryHigh: [
                '{name}이(가) 당신을 깊이 신뢰하고 있습니다.',
                '{name}이(가) 당신의 품에 파고듭니다.',
                '{name}이(가) 당신을 향한 사랑을 표현합니다.',
                '{name}이(가) 당신의 손에 입맞춤합니다.',
                '{name}이(가) 당신 없이는 못 산다는 듯 쳐다봅니다.'
            ],
            // 음악 관련 (최근에 음악 들음) - 애벌레용
            music: [
                '{name}이(가) {music}을(를) 흥얼거립니다.',
                '{name}이(가) {music}에 맞춰 춤을 춥니다.',
                '{name}이(가) {music}의 선율을 떠올립니다.',
                '{name}이(가) 음악에 취해 있습니다.',
                '{name}이(가) {music}의 여운에 젖어 있습니다.'
            ],
            // 알 상태 음악 관련
            egg_music: [
                '{name}에서 {music}에 반응하는 진동이 느껴집니다.',
                '{name}의 껍질이 {music}에 맞춰 희미하게 빛납니다.',
                '{name}이(가) {music}의 선율에 반응합니다.',
                '{name} 안에서 음악을 즐기는 듯한 기운이 느껴집니다.'
            ],
            // 번데기 상태 음악 관련
            pupa_music: [
                '{name}에서 {music}에 반응하는 약한 진동이 느껴집니다.',
                '{name}의 껍질이 {music}에 맞춰 살짝 떨립니다.',
                '{name}이(가) {music}의 선율에 미세하게 반응합니다.',
                '{name} 안에서 음악을 즐기는 듯한 기운이 느껴집니다.'
            ],
            // 장식물 관련 (30개 전체)
            decorations: {
                // 불 속성
                fire_common1: [
                    '{name}이(가) 용암석에서 흐르는 열기를 바라봅니다.',
                    '{name}이(가) 용암석의 불을 신기하게 쳐다봅니다.',
                    '{name}이(가) 뜨거운 용암석 근처에서 따뜻함을 느낍니다.'
                ],
                fire_common2: [
                    '{name}이(가) 화산재를 톡톡 건드립니다.',
                    '{name}이(가) 화산재의 향을 맡고 있습니다.',
                    '{name}이(가) 화산재 더미 옆에서 놀고 있습니다.'
                ],
                fire_rare1: [
                    '{name}이(가) 불꽃 조각상을 경외하며 바라봅니다.',
                    '{name}이(가) 불꽃 조각상의 아름다움에 매료되어 있습니다.',
                    '{name}이(가) 불꽃 조각상 주변을 빙글빙글 돕니다.'
                ],
                fire_rare2: [
                    '{name}이(가) 타오르는 램프의 불빛을 구경합니다.',
                    '{name}이(가) 램프 불빛에 그림자를 드리웁니다.',
                    '{name}이(가) 램프의 따뜻한 빛을 즐깁니다.'
                ],
                fire_epic: [
                    '{name}이(가) 불사조 깃털의 신비로운 기운을 느낍니다.',
                    '{name}이(가) 불사조 깃털이 내뿜는 불꽃에 감탄합니다.',
                    '{name}이(가) 불사조 깃털 앞에서 경건해집니다.'
                ],
                
                // 물 속성
                water_common1: [
                    '{name}이(가) 분수의 물줄기를 구경합니다.',
                    '{name}이(가) 분수 물소리에 귀를 기울입니다.',
                    '{name}이(가) 분수에서 튀는 물방울과 놀고 있습니다.'
                ],
                water_common2: [
                    '{name}이(가) 조약돌을 톡톡 두드립니다.',
                    '{name}이(가) 매끈한 조약돌을 굴리고 있습니다.',
                    '{name}이(가) 조약돌 위에서 쉬고 있습니다.'
                ],
                water_rare1: [
                    '{name}이(가) 산호 장식의 색깔에 감탄합니다.',
                    '{name}이(가) 산호 사이를 헤엄치듯 움직입니다.',
                    '{name}이(가) 산호의 신비로운 모습을 관찰합니다.'
                ],
                water_rare2: [
                    '{name}이(가) 물방울 구슬에 자신의 모습을 비춰봅니다.',
                    '{name}이(가) 구슬 속 물방울을 신기하게 쳐다봅니다.',
                    '{name}이(가) 물방울 구슬을 굴리며 놀고 있습니다.'
                ],
                water_epic: [
                    '{name}이(가) 인어의 눈물이 빛나는 모습에 넋을 잃습니다.',
                    '{name}이(가) 인어의 눈물에서 나오는 물의 기운을 느낍니다.',
                    '{name}이(가) 인어의 눈물 앞에서 경건해집니다.'
                ],
                
                // 바람 속성
                wind_common1: [
                    '{name}이(가) 바람개비를 신기하게 바라봅니다.',
                    '{name}이(가) 바람개비가 도는 모습에 감탄합니다.',
                    '{name}이(가) 바람개비와 함께 빙글빙글 돕니다.'
                ],
                wind_common2: [
                    '{name}이(가) 부드러운 깃털을 살짝 만집니다.',
                    '{name}이(가) 깃털이 흔들리는 모습을 구경합니다.',
                    '{name}이(가) 깃털 위에서 가볍게 뛰어놉니다.'
                ],
                wind_rare1: [
                    '{name}이(가) 풍경 소리에 귀를 기울입니다.',
                    '{name}이(가) 풍경이 울리는 소리를 즐깁니다.',
                    '{name}이(가) 풍경과 함께 리듬을 타고 있습니다.'
                ],
                wind_rare2: [
                    '{name}이(가) 민들레 솜털의 씨앗이 날아가는 것을 바라봅니다.',
                    '{name}이(가) 민들레 솜털에 살짝 입김을 불어봅니다.',
                    '{name}이(가) 민들레 솜털 사이에서 숨바꼭질을 합니다.'
                ],
                wind_epic: [
                    '{name}이(가) 하늘의 깃털에서 나오는 바람을 느낍니다.',
                    '{name}이(가) 하늘의 깃털이 빛나는 모습에 감탄합니다.',
                    '{name}이(가) 하늘의 깃털 앞에서 경건해집니다.'
                ],
                
                // 땅 속성
                earth_common1: [
                    '{name}이(가) 화분의 흙냄새를 맡고 있습니다.',
                    '{name}이(가) 화분 속 식물을 살펴봅니다.',
                    '{name}이(가) 화분 주변을 기어다닙니다.'
                ],
                earth_common2: [
                    '{name}이(가) 이끼돌의 촉촉한 표면을 만집니다.',
                    '{name}이(가) 이끼 사이를 탐험하고 있습니다.',
                    '{name}이(가) 이끼돌에서 자연의 기운을 느낍니다.'
                ],
                earth_rare1: [
                    '{name}이(가) 나무 조각의 나이테를 세어봅니다.',
                    '{name}이(가) 나무 조각의 질감을 즐깁니다.',
                    '{name}이(가) 나무 조각 위를 오르내리고 있습니다.'
                ],
                earth_rare2: [
                    '{name}이(가) 버섯 군락을 신기하게 쳐다봅니다.',
                    '{name}이(가) 버섯 사이를 헤집고 다닙니다.',
                    '{name}이(가) 버섯의 포자 향을 맡고 있습니다.'
                ],
                earth_epic: [
                    '{name}이(가) 세계수 가지의 생명력을 느낍니다.',
                    '{name}이(가) 세계수 가지에서 나오는 고대의 기운에 압도됩니다.',
                    '{name}이(가) 세계수 가지 앞에서 경건해집니다.'
                ],
                
                // 빛 속성
                light_common1: [
                    '{name}이(가) 수정에 자신의 얼굴을 비춰봅니다.',
                    '{name}이(가) 빛나는 수정을 구경합니다.',
                    '{name}이(가) 수정이 반사하는 무지개를 쫓아갑니다.'
                ],
                light_common2: [
                    '{name}이(가) 반짝이 가루를 톡톡 건드립니다.',
                    '{name}이(가) 반짝이는 가루에 뒹굽니다.',
                    '{name}이(가) 반짝이 가루가 빛나는 모습을 즐깁니다.'
                ],
                light_rare1: [
                    '{name}이(가) 빛나는 보석의 광채에 넋을 잃습니다.',
                    '{name}이(가) 보석이 만들어내는 빛의 향연을 감상합니다.',
                    '{name}이(가) 보석 옆에서 함께 빛나고 있습니다.'
                ],
                light_rare2: [
                    '{name}이(가) 태양석의 따뜻한 빛을 쬡니다.',
                    '{name}이(가) 태양석 앞에서 몸을 쭉 펴고 있습니다.',
                    '{name}이(가) 태양석의 광채를 온몸으로 받고 있습니다.'
                ],
                light_epic: [
                    '{name}이(가) 별의 파편이 빛나는 모습에 경외합니다.',
                    '{name}이(가) 별의 파편에서 나오는 우주의 기운을 느낍니다.',
                    '{name}이(가) 별의 파편 앞에서 경건해집니다.'
                ],
                
                // 어둠 속성
                dark_common1: [
                    '{name}이(가) 흑요석의 깊은 어둠에 빠져듭니다.',
                    '{name}이(가) 흑요석의 매끈한 표면을 쓰다듬습니다.',
                    '{name}이(가) 흑요석 옆에서 조용히 명상합니다.'
                ],
                dark_common2: [
                    '{name}이(가) 검은 모래를 파헤치고 있습니다.',
                    '{name}이(가) 검은 모래 위에 그림을 그립니다.',
                    '{name}이(가) 검은 모래의 감촉을 즐깁니다.'
                ],
                dark_rare1: [
                    '{name}이(가) 달빛석을 조용히 바라봅니다.',
                    '{name}이(가) 달빛석의 은은한 빛에 잠깁니다.',
                    '{name}이(가) 달빛석과 함께 밤의 기운을 느낍니다.'
                ],
                dark_rare2: [
                    '{name}이(가) 그림자 수정 속을 들여다봅니다.',
                    '{name}이(가) 그림자 수정의 신비로운 모습에 매료됩니다.',
                    '{name}이(가) 그림자 수정이 만들어내는 어둠을 즐깁니다.'
                ],
                dark_epic: [
                    '{name}이(가) 밤의 정수에서 나오는 어둠의 힘을 느낍니다.',
                    '{name}이(가) 밤의 정수가 품은 신비에 압도됩니다.',
                    '{name}이(가) 밤의 정수 앞에서 경건해집니다.'
                ]
            },
            // 정령 간 상호작용
            interaction: {
                decoration: [
                    '{name1}과(와) {name2}이(가) 함께 {deco}을(를) 구경합니다.',
                    '{name1}이(가) {name2}에게 {deco}을(를) 보여줍니다.',
                    '{name1}과(와) {name2}이(가) {deco} 주위를 빙글빙글 돕니다.',
                    '{name1}과(와) {name2}이(가) {deco} 옆에서 함께 쉬고 있습니다.',
                    '{name1}이(가) {name2}와(과) {deco}을(를) 함께 즐기고 있습니다.'
                ],
                sharing: [
                    '{name1}이(가) {name2}에게 먹이를 나눠줍니다.',
                    '{name1}이(가) {name2}와(과) 먹이를 함께 먹습니다.',
                    '{name1}과(와) {name2}이(가) 서로의 먹이를 나누고 있습니다.'
                ],
                fight: [
                    '{name1}과(와) {name2}이(가) 서로를 깨뭅니다.',
                    '{name1}이(가) {name2}와(과) 장난스럽게 싸웁니다.',
                    '{name1}과(와) {name2}이(가) 으르렁거리며 대치합니다.',
                    '{name1}이(가) {name2}를(을) 쫓아다닙니다.'
                ],
                rest: [
                    '{name1}과(와) {name2}이(가) 서로에게 기대어 잠이 듭니다.',
                    '{name1}이(가) {name2} 옆에서 편안히 쉬고 있습니다.',
                    '{name1}과(와) {name2}이(가) 나란히 낮잠을 자고 있습니다.',
                    '{name1}이(가) {name2}를(을) 베개 삼아 잠들었습니다.',
                    '{name1}과(와) {name2}이(가) 함께 꿈나라로 떠났습니다.'
                ],
                song: [
                    '{name1}이(가) {name2}에게 자신이 좋아하는 노래를 불러줍니다.',
                    '{name1}과(와) {name2}이(가) 함께 노래를 부릅니다.',
                    '{name1}이(가) {name2}를(을) 위해 음악을 연주합니다.',
                    '{name1}이(가) {name2}와(과) 함께 춤을 춥니다.'
                ],
                play: [
                    '{name1}과(와) {name2}이(가) 숨바꼭질을 하고 있습니다.',
                    '{name1}이(가) {name2}와(과) 술래잡기를 즐깁니다.',
                    '{name1}과(와) {name2}이(가) 재미있게 놀고 있습니다.',
                    '{name1}이(가) {name2}를(을) 간지럽힙니다.',
                    '{name1}과(와) {name2}이(가) 함께 웃고 떠들고 있습니다.'
                ],
                talk: [
                    '{name1}과(와) {name2}이(가) 수다를 떨고 있습니다.',
                    '{name1}이(가) {name2}에게 무언가 이야기하고 있습니다.',
                    '{name1}과(와) {name2}이(가) 즐겁게 대화를 나눕니다.',
                    '{name1}이(가) {name2}의 이야기를 경청하고 있습니다.'
                ]
            }
        };

        const STAGE_REQUIREMENTS = {
            egg: 0,
            larva1: 10,
            larva2: 25,
            larva3: 45,
            pupa: 70,
            adult: 100
        };

        const STAGE_ICONS = {
            egg: '🥚',
            larva1: '🐛',
            larva2: '🐛',
            larva3: '🐛',
            pupa: '🫛',
            adult: '🦋'
        };

        const STAGE_NAMES = {
            egg: '알',
            larva1: '애벌레 I',
            larva2: '애벌레 II',
            larva3: '애벌레 III',
            pupa: '번데기',
            adult: '성충'
        };
        
        // 성장 단계별 속성 외형 묘사
        const APPEARANCE_DESCRIPTIONS = {
            egg: {
                fire: '껍질이 따뜻하고 미세한 열기가 느껴집니다.',
                water: '촉촉하고 투명한 광택이 흐릅니다.',
                wind: '껍질이 부드럽고 가볍습니다.',
                earth: '단단하고 거친 질감이 있습니다.',
                light: '은은한 빛이 내부에서 비칩니다.',
                dark: '짙은 색으로 깊이를 알 수 없습니다.',
                normal: '평범한 흰색 알입니다.'
            },
            larva1: {
                fire: '몸이 붉게 물들고 따뜻한 기운이 느껴집니다.',
                water: '촉촉한 피부에서 물방울이 맺힙니다.',
                wind: '몸이 가볍고 바람에 흔들립니다.',
                earth: '단단한 갈색 피부로 덮여있습니다.',
                light: '온몸에서 은은한 빛이 납니다.',
                dark: '어두운 보라빛 몸을 하고 있습니다.',
                normal: '투명한 초록빛 몸을 하고 있습니다.'
            },
            larva2: {
                fire: '외견이 붉고, 만졌을 때 따뜻하며 머리카락이 불꽃처럼 일렁입니다.',
                water: '푸른빛이 도는 몸에서 시원한 기운이 나며, 몸 표면에 물결 무늬가 있습니다.',
                wind: '연한 하늘색 몸에 깃털 같은 솜털이 돋아있고, 공중에 둥둥 떠오릅니다.',
                earth: '갈색빛 몸에 작은 이끼가 자라고, 만지면 흙 냄새가 납니다.',
                light: '금빛으로 빛나는 몸에서 따뜻한 빛이 발산되며, 주변을 밝힙니다.',
                dark: '깊은 남색 몸에 별빛 같은 반점이 있고, 주변의 빛을 흡수합니다.',
                normal: '투명한 몸에 무지개빛이 은은하게 감돕니다.',
                // 혼합 속성
                'dark-earth': '어두운 갈색 몸에 밤 이슬이 맺히고 흙의 향기가 납니다.',
                'dark-fire': '검붉은 몸에서 어두운 열기가 피어오르며 신비로운 빛이 깜빡입니다.',
                'dark-light': '반은 빛나고 반은 어두운 몸이 황혼의 아름다움을 담고 있습니다.',
                'dark-water': '짙은 청색 몸에서 심해의 물결 무늬가 흐르고 차가운 기운이 납니다.',
                'dark-wind': '검은 솜털이 돋은 몸이 밤바람처럼 가볍게 흔들립니다.',
                'earth-fire': '붉은 흙빛 몸에 작은 불꽃 무늬가 있고 따뜻한 온기가 느껴집니다.',
                'earth-light': '황금빛 몸에 작은 새싹이 돋아나고 생명의 빛을 발합니다.',
                'earth-water': '청록색 몸에 이끼와 물방울이 함께 맺혀있고 촉촉합니다.',
                'earth-wind': '연두색 몸에서 풀잎 향기가 나고 산들바람에 흔들립니다.',
                'fire-light': '눈부신 황금빛 몸에서 태양 같은 열기와 빛이 뿜어져 나옵니다.',
                'fire-water': '붉은 보라빛 몸에서 증기가 피어오르고 열기와 습기가 뒤섞입니다.',
                'fire-wind': '주황색 몸 주변으로 뜨거운 바람이 일렁이며 흐릅니다.',
                'light-water': '맑은 하늘빛 몸에서 은은한 빛과 시원한 물방울이 흐릅니다.',
                'light-wind': '빛나는 흰 솜털에 둘러싸여 빛의 바람을 타고 떠오릅니다.',
                'water-wind': '하늘색 몸 주변에 물안개가 감돌고 산들바람이 불어옵니다.'
            },
            larva3: {
                fire: '온몸이 주황빛 불꽃으로 감싸여 있고, 숨을 쉴 때마다 작은 불똥이 튑니다.',
                water: '깊은 청록색 몸에서 작은 물줄기가 흘러내리고, 주변 공기가 축축합니다.',
                wind: '은빛 날개 비늘이 돋아나고, 움직일 때마다 바람이 일어납니다.',
                earth: '단단한 나무껍질 같은 외피에 작은 꽃봉오리가 피어있습니다.',
                light: '눈부신 황금빛으로 빛나며, 주변에 무지개 후광이 보입니다.',
                dark: '칠흑 같은 몸에 은하수 같은 빛의 띠가 흐르고, 그림자가 춤춥니다.',
                normal: '맑고 투명한 몸에 모든 색이 은은하게 어우러집니다.',
                // 혼합 속성
                'dark-earth': '검은 나무껍질 같은 외피에 밤꽃이 피어있고 어둠의 향기가 납니다.',
                'dark-fire': '검붉은 불꽃이 어둠 속에서 타오르며 작은 불똥과 그림자가 춤춥니다.',
                'dark-light': '빛과 어둠이 교차하는 몸에서 새벽과 황혼의 기운이 동시에 느껴집니다.',
                'dark-water': '깊은 남색 몸에서 밤바다의 물결이 흐르고 신비로운 물방울이 맺힙니다.',
                'dark-wind': '검은 날개 비늘이 돋아나며 밤바람이 소용돌이치고 그림자가 흩날립니다.',
                'earth-fire': '적갈색 몸에서 용암 같은 열기가 뿜어져 나오고 작은 꽃불이 핍니다.',
                'earth-light': '황금빛 나무껍질에 빛나는 꽃들이 만개하고 생명의 후광이 빛납니다.',
                'earth-water': '청록색 몸에 이끼와 물이끼가 자라고 계곡물이 흘러내립니다.',
                'earth-wind': '연두빛 몸에서 새싹이 돋아나고 봄바람에 실려 향기가 퍼집니다.',
                'fire-light': '찬란한 태양빛 불꽃이 온몸을 감싸고 눈부신 황금빛이 폭발합니다.',
                'fire-water': '붉은 몸에서 뜨거운 증기가 솟아오르고 물과 불이 역동적으로 충돌합니다.',
                'fire-wind': '주황빛 몸 주변으로 열풍이 소용돌이치고 불꽃이 바람을 타고 춤춥니다.',
                'light-water': '은은한 청백색 몸에서 맑은 빛과 물방울이 조화롭게 흐릅니다.',
                'light-wind': '빛나는 은빛 날개 비늘이 빛의 바람을 일으키며 무지개빛으로 반짝입니다.',
                'water-wind': '하늘빛 몸 주변에 물보라와 바람이 소용돌이치며 아름다운 안개를 만듭니다.'
            },
            pupa: {
                fire: '붉은 수정 같은 번데기에서 열기가 피어오르고, 내부에 불꽃이 춤춥니다.',
                water: '푸른 얼음 같은 번데기 속에서 물결이 일렁이며 변화가 일어납니다.',
                wind: '하얀 구름 같은 번데기가 공중에 떠있고, 바람에 맞춰 회전합니다.',
                earth: '나무 옹이 같은 번데기에서 새순이 돋아나고 있습니다.',
                light: '빛나는 크리스탈 번데기에서 무지개빛이 퍼져나옵니다.',
                dark: '검은 보석 같은 번데기에서 신비로운 별빛이 깜빡입니다.',
                normal: '순백의 번데기가 조용히 변화를 준비하고 있습니다.',
                // 혼합 속성 (15개 조합)
                'dark-earth': '짙은 갈색 번데기에서 밤의 기운과 대지의 향기가 뒤섞입니다.',
                'dark-fire': '검붉은 번데기에서 어둠 속 불꽃이 타오르며 신비로운 열기가 납니다.',
                'dark-light': '흑백이 교차하는 번데기에서 빛과 어둠이 조화롭게 춤춥니다.',
                'dark-water': '짙은 남색 번데기 속에서 심해의 물결이 일렁입니다.',
                'dark-wind': '검은 구름 같은 번데기가 밤바람을 타고 천천히 회전합니다.',
                'earth-fire': '붉은 흙빛 번데기에서 용암의 열기와 대지의 생명력이 느껴집니다.',
                'earth-light': '황금빛 나무 번데기에서 따뜻한 빛과 생명의 기운이 넘칩니다.',
                'earth-water': '청록색 번데기에서 숲의 이슬과 대지의 향기가 섞여 나옵니다.',
                'earth-wind': '연두빛 번데기가 미풍에 흔들리며 새싹의 향기를 풍깁니다.',
                'fire-light': '찬란한 황금빛 번데기에서 태양 같은 빛과 열기가 뿜어져 나옵니다.',
                'fire-water': '붉은 수증기로 둘러싸인 번데기에서 불과 물이 역동적으로 섞입니다.',
                'fire-wind': '주황빛 번데기 주변으로 뜨거운 바람이 소용돌이칩니다.',
                'light-water': '은은한 청백색 번데기에서 맑은 빛과 시원한 기운이 퍼집니다.',
                'light-wind': '빛나는 백색 번데기가 빛의 바람을 타고 부드럽게 떠오릅니다.',
                'water-wind': '하늘빛 번데기 주변에 물안개와 산들바람이 감돕니다.'
            }
        };

        const PARAM_ICONS = {
            intelligence: '🧠',
            strength: '💪',
            charm: '💖',
            affection: '❤️'
        };

        const ENV_ICONS = {
            fire: '🔥',
            water: '💧',
            wind: '🌬️',
            earth: '🌱',
            light: '✨',
            dark: '🌙'
        };

        const MUSIC_TYPES = {
            classic: { name: '클래식 🎻', icon: '🎻', effect: '지력 +10' },
            jazz: { name: '재즈 🎷', icon: '🎷', effect: '매력 +10' },
            rock: { name: '록 🎸', icon: '🎸', effect: '체력 +10' },
            pop: { name: '팝 🎤', icon: '🎤', effect: '지력 +5, 매력 +5' },
            ballad: { name: '발라드 🎹', icon: '🎹', effect: '체력 +5, 매력 +5' }
        };

        const DECORATION_TYPES = {
            // 불 속성 (6개)
            fire_common1: { name: '용암석', icon: '🔥', attr: 'fire', power: 1, quality: 'common', price: 30 },
            fire_common2: { name: '화산재', icon: '🌋', attr: 'fire', power: 1, quality: 'common', price: 30 },
            fire_rare1: { name: '불꽃 조각상', icon: '🔆', attr: 'fire', power: 2, quality: 'rare', price: 60 },
            fire_rare2: { name: '타오르는 램프', icon: '🏮', attr: 'fire', power: 2, quality: 'rare', price: 60 },
            fire_epic: { name: '불사조 깃털', icon: '🦅', attr: 'fire', power: 3, quality: 'epic', price: 100 },
            fire_legendary: { name: '태초의 불꽃', icon: '🔱', attr: 'fire', power: 5, quality: 'legendary', price: 999 },
            
            // 물 속성 (6개)
            water_common1: { name: '분수', icon: '💧', attr: 'water', power: 1, quality: 'common', price: 30 },
            water_common2: { name: '조약돌', icon: '🪨', attr: 'water', power: 1, quality: 'common', price: 30 },
            water_rare1: { name: '산호 장식', icon: '🪸', attr: 'water', power: 2, quality: 'rare', price: 60 },
            water_rare2: { name: '물방울 구슬', icon: '💎', attr: 'water', power: 2, quality: 'rare', price: 60 },
            water_epic: { name: '인어의 눈물', icon: '🧜', attr: 'water', power: 3, quality: 'epic', price: 100 },
            water_legendary: { name: '심해의 심장', icon: '🫀', attr: 'water', power: 5, quality: 'legendary', price: 999 },
            
            // 바람 속성 (6개)
            wind_common1: { name: '바람개비', icon: '🌬️', attr: 'wind', power: 1, quality: 'common', price: 30 },
            wind_common2: { name: '부드러운 깃털', icon: '🪶', attr: 'wind', power: 1, quality: 'common', price: 30 },
            wind_rare1: { name: '풍경', icon: '🎐', attr: 'wind', power: 2, quality: 'rare', price: 60 },
            wind_rare2: { name: '민들레 솜털', icon: '🌾', attr: 'wind', power: 2, quality: 'rare', price: 60 },
            wind_epic: { name: '하늘의 깃털', icon: '☁️', attr: 'wind', power: 3, quality: 'epic', price: 100 },
            wind_legendary: { name: '폭풍의 눈', icon: '🌀', attr: 'wind', power: 5, quality: 'legendary', price: 999 },
            
            // 땅 속성 (6개)
            earth_common1: { name: '화분', icon: '🌱', attr: 'earth', power: 1, quality: 'common', price: 30 },
            earth_common2: { name: '이끼돌', icon: '🪵', attr: 'earth', power: 1, quality: 'common', price: 30 },
            earth_rare1: { name: '나무 조각', icon: '🌳', attr: 'earth', power: 2, quality: 'rare', price: 60 },
            earth_rare2: { name: '버섯 군락', icon: '🍄', attr: 'earth', power: 2, quality: 'rare', price: 60 },
            earth_epic: { name: '세계수 가지', icon: '🌲', attr: 'earth', power: 3, quality: 'epic', price: 100 },
            earth_legendary: { name: '대지의 정수', icon: '💎', attr: 'earth', power: 5, quality: 'legendary', price: 999 },
            
            // 빛 속성 (6개)
            light_common1: { name: '수정', icon: '✨', attr: 'light', power: 1, quality: 'common', price: 30 },
            light_common2: { name: '반짝이 가루', icon: '⭐', attr: 'light', power: 1, quality: 'common', price: 30 },
            light_rare1: { name: '빛나는 보석', icon: '💠', attr: 'light', power: 2, quality: 'rare', price: 60 },
            light_rare2: { name: '태양석', icon: '☀️', attr: 'light', power: 2, quality: 'rare', price: 60 },
            light_epic: { name: '별의 파편', icon: '🌟', attr: 'light', power: 3, quality: 'epic', price: 100 },
            light_legendary: { name: '천상의 광휘', icon: '👼', attr: 'light', power: 5, quality: 'legendary', price: 999 },
            
            // 어둠 속성 (6개)
            dark_common1: { name: '흑요석', icon: '🌙', attr: 'dark', power: 1, quality: 'common', price: 30 },
            dark_common2: { name: '검은 모래', icon: '🖤', attr: 'dark', power: 1, quality: 'common', price: 30 },
            dark_rare1: { name: '달빛석', icon: '🌑', attr: 'dark', power: 2, quality: 'rare', price: 60 },
            dark_rare2: { name: '그림자 수정', icon: '🔮', attr: 'dark', power: 2, quality: 'rare', price: 60 },
            dark_epic: { name: '밤의 정수', icon: '🌌', attr: 'dark', power: 3, quality: 'epic', price: 100 },
            dark_legendary: { name: '영원한 어둠', icon: '🕳️', attr: 'dark', power: 5, quality: 'legendary', price: 999 },
            
            // 복합 속성 (희귀)
            dual_fire_water: { name: '증기의 오르골', icon: '♨️', attr: 'dual', power: 1, quality: 'rare', price: 80, dualAttr: ['fire', 'water'] },
            dual_earth_wind: { name: '사막의 모래시계', icon: '⏳', attr: 'dual', power: 1, quality: 'rare', price: 80, dualAttr: ['earth', 'wind'] },
            dual_light_dark: { name: '황혼의 거울', icon: '🪞', attr: 'dual', power: 1, quality: 'rare', price: 80, dualAttr: ['light', 'dark'] },
            all_elements: { name: '무지개 프리즘', icon: '🌈', attr: 'all', power: 1, quality: 'rare', price: 120 },
            
            // 합성 장식물
            flame_lamp: { name: '화염 램프', icon: '🏮', attr: 'fire', power: 3, quality: 'rare', price: 0 },
            aqua_fountain: { name: '아쿠아 분수', icon: '⛲', attr: 'water', power: 3, quality: 'rare', price: 0 },
            wind_chime: { name: '바람의 종', icon: '🔔', attr: 'wind', power: 3, quality: 'rare', price: 0 },
            earth_statue: { name: '대지의 석상', icon: '🗿', attr: 'earth', power: 3, quality: 'rare', price: 0 },
            light_orb: { name: '빛의 오브', icon: '💡', attr: 'light', power: 3, quality: 'rare', price: 0 },
            shadow_crystal: { name: '그림자 결정', icon: '🔳', attr: 'dark', power: 3, quality: 'rare', price: 0 }
        };

        const FOOD_NAMES = {
            fire: '불꽃열매',
            water: '맑은이슬',
            wind: '바람꿀',
            earth: '대지버섯',
            light: '빛나는 넥타',
            dark: '검은 꽃가루'
        };
        
        // 약초 아이템
        const MEDICINE = {
            name: '만병통치 약초',
            icon: '🌿',
            price: 50,
            description: '정령의 질병을 치료합니다'
        };

        // ===== 연구실 합성 시스템 =====
        // 합성 아이템 정의 (결과물)
        const SYNTH_ITEMS = {
            // 먹이 합성 결과물 (단일 속성)
            fire_tart: { name: '불꽃열매 타르트', icon: '🥧', type: 'food', attr: 'fire', attrGain: 6, affectionGain: 3, growthGain: 3 },
            water_jelly: { name: '이슬 에이드', icon: '🥤', type: 'food', attr: 'water', attrGain: 6, affectionGain: 3, growthGain: 3 },
            wind_candy: { name: '바람꿀차', icon: '🍵', type: 'food', attr: 'wind', attrGain: 6, affectionGain: 3, growthGain: 3 },
            earth_pie: { name: '대지버섯 볶음', icon: '🥘', type: 'food', attr: 'earth', attrGain: 6, affectionGain: 3, growthGain: 3 },
            light_cookie: { name: '넥타르', icon: '🍯', type: 'food', attr: 'light', attrGain: 6, affectionGain: 3, growthGain: 3 },
            dark_chocolate: { name: '다크 초콜릿', icon: '🍫', type: 'food', attr: 'dark', attrGain: 6, affectionGain: 3, growthGain: 3 },
            rainbow_cake: { name: '무지개 케이크', icon: '🎂', type: 'food', attr: 'all', attrGain: 3, affectionGain: 5, growthGain: 5 },
            
            // 먹이 합성 결과물 (혼합 속성)
            fire_water_steam: { name: '스팀 푸딩', icon: '♨️', type: 'food', attr: 'dual', dualAttr: ['fire', 'water'], attrGain: 3, affectionGain: 3, growthGain: 5 },
            fire_wind_heat: { name: '열풍 크래커', icon: '🌪️', type: 'food', attr: 'dual', dualAttr: ['fire', 'wind'], attrGain: 3, affectionGain: 3, growthGain: 5 },
            fire_earth_lava: { name: '화산 스프', icon: '🍲', type: 'food', attr: 'dual', dualAttr: ['fire', 'earth'], attrGain: 3, affectionGain: 3, growthGain: 5 },
            fire_light_sun: { name: '태양 타르트', icon: '🌅', type: 'food', attr: 'dual', dualAttr: ['fire', 'light'], attrGain: 3, affectionGain: 3, growthGain: 5 },
            fire_dark_ash: { name: '잿빛 머랭쿠키', icon: '🖤', type: 'food', attr: 'dual', dualAttr: ['fire', 'dark'], attrGain: 3, affectionGain: 3, growthGain: 5 },
            water_wind_mist: { name: '안개 캔디', icon: '🌫️', type: 'food', attr: 'dual', dualAttr: ['water', 'wind'], attrGain: 3, affectionGain: 3, growthGain: 5 },
            water_earth_pond: { name: '연못 샐러드', icon: '🥗', type: 'food', attr: 'dual', dualAttr: ['water', 'earth'], attrGain: 3, affectionGain: 3, growthGain: 5 },
            water_light_ice: { name: '빙하 아이스바', icon: '🧊', type: 'food', attr: 'dual', dualAttr: ['water', 'light'], attrGain: 3, affectionGain: 3, growthGain: 5 },
            water_dark_deep: { name: '심해 젤리', icon: '🪼', type: 'food', attr: 'dual', dualAttr: ['water', 'dark'], attrGain: 3, affectionGain: 3, growthGain: 5 },
            wind_earth_desert: { name: '황야 비스킷', icon: '🏜️', type: 'food', attr: 'dual', dualAttr: ['wind', 'earth'], attrGain: 3, affectionGain: 3, growthGain: 5 },
            wind_light_cloud: { name: '구름 솜사탕', icon: '☁️', type: 'food', attr: 'dual', dualAttr: ['wind', 'light'], attrGain: 3, affectionGain: 3, growthGain: 5 },
            wind_dark_night: { name: '밤바람청', icon: '🌃', type: 'food', attr: 'dual', dualAttr: ['wind', 'dark'], attrGain: 3, affectionGain: 3, growthGain: 5 },
            earth_light_sprout: { name: '새싹 파이', icon: '🌿', type: 'food', attr: 'dual', dualAttr: ['earth', 'light'], attrGain: 3, affectionGain: 3, growthGain: 5 },
            earth_dark_mushroom: { name: '동굴 버섯 수프', icon: '🍄', type: 'food', attr: 'dual', dualAttr: ['earth', 'dark'], attrGain: 3, affectionGain: 3, growthGain: 5 },
            
            // 장식물 합성 결과물
            flame_lamp: { name: '화염 램프', icon: '🏮', type: 'decoration', attr: 'fire', power: 3, quality: 'rare' },
            aqua_fountain: { name: '아쿠아 분수', icon: '⛲', type: 'decoration', attr: 'water', power: 3, quality: 'rare' },
            wind_chime: { name: '바람의 종', icon: '🔔', type: 'decoration', attr: 'wind', power: 3, quality: 'rare' },
            earth_statue: { name: '대지의 석상', icon: '🗿', type: 'decoration', attr: 'earth', power: 3, quality: 'rare' },
            light_orb: { name: '빛의 오브', icon: '💡', type: 'decoration', attr: 'light', power: 3, quality: 'rare' },
            shadow_crystal: { name: '그림자 결정', icon: '🔳', type: 'decoration', attr: 'dark', power: 3, quality: 'rare' }
        };
        
        // 합성 레시피 정의
        const RECIPES = {
            // 먹이 합성 (같은 먹이 5+5 = 타르트류 3개)
            fire_tart: {
                ingredients: [
                    { type: 'fire', category: 'food', count: 5 },
                    { type: 'fire', category: 'food', count: 5 }
                ],
                result: { type: 'fire_tart', count: 3 },
                category: 'food'
            },
            water_jelly: {
                ingredients: [
                    { type: 'water', category: 'food', count: 5 },
                    { type: 'water', category: 'food', count: 5 }
                ],
                result: { type: 'water_jelly', count: 3 },
                category: 'food'
            },
            wind_candy: {
                ingredients: [
                    { type: 'wind', category: 'food', count: 5 },
                    { type: 'wind', category: 'food', count: 5 }
                ],
                result: { type: 'wind_candy', count: 3 },
                category: 'food'
            },
            earth_pie: {
                ingredients: [
                    { type: 'earth', category: 'food', count: 5 },
                    { type: 'earth', category: 'food', count: 5 }
                ],
                result: { type: 'earth_pie', count: 3 },
                category: 'food'
            },
            light_cookie: {
                ingredients: [
                    { type: 'light', category: 'food', count: 5 },
                    { type: 'light', category: 'food', count: 5 }
                ],
                result: { type: 'light_cookie', count: 3 },
                category: 'food'
            },
            dark_chocolate: {
                ingredients: [
                    { type: 'dark', category: 'food', count: 5 },
                    { type: 'dark', category: 'food', count: 5 }
                ],
                result: { type: 'dark_chocolate', count: 3 },
                category: 'food'
            },
            rainbow_cake: {
                ingredients: [
                    { type: 'light', category: 'food', count: 3 },
                    { type: 'dark', category: 'food', count: 3 }
                ],
                result: { type: 'rainbow_cake', count: 1 },
                category: 'food'
            },
            // 혼합 속성 먹이 (서로 다른 속성 3+3 = 혼합 먹이 2개)
            fire_water_steam: {
                ingredients: [
                    { type: 'fire', category: 'food', count: 3 },
                    { type: 'water', category: 'food', count: 3 }
                ],
                result: { type: 'fire_water_steam', count: 2 },
                category: 'food'
            },
            fire_wind_heat: {
                ingredients: [
                    { type: 'fire', category: 'food', count: 3 },
                    { type: 'wind', category: 'food', count: 3 }
                ],
                result: { type: 'fire_wind_heat', count: 2 },
                category: 'food'
            },
            fire_earth_lava: {
                ingredients: [
                    { type: 'fire', category: 'food', count: 3 },
                    { type: 'earth', category: 'food', count: 3 }
                ],
                result: { type: 'fire_earth_lava', count: 2 },
                category: 'food'
            },
            fire_light_sun: {
                ingredients: [
                    { type: 'fire', category: 'food', count: 3 },
                    { type: 'light', category: 'food', count: 3 }
                ],
                result: { type: 'fire_light_sun', count: 2 },
                category: 'food'
            },
            fire_dark_ash: {
                ingredients: [
                    { type: 'fire', category: 'food', count: 3 },
                    { type: 'dark', category: 'food', count: 3 }
                ],
                result: { type: 'fire_dark_ash', count: 2 },
                category: 'food'
            },
            water_wind_mist: {
                ingredients: [
                    { type: 'water', category: 'food', count: 3 },
                    { type: 'wind', category: 'food', count: 3 }
                ],
                result: { type: 'water_wind_mist', count: 2 },
                category: 'food'
            },
            water_earth_pond: {
                ingredients: [
                    { type: 'water', category: 'food', count: 3 },
                    { type: 'earth', category: 'food', count: 3 }
                ],
                result: { type: 'water_earth_pond', count: 2 },
                category: 'food'
            },
            water_light_ice: {
                ingredients: [
                    { type: 'water', category: 'food', count: 3 },
                    { type: 'light', category: 'food', count: 3 }
                ],
                result: { type: 'water_light_ice', count: 2 },
                category: 'food'
            },
            water_dark_deep: {
                ingredients: [
                    { type: 'water', category: 'food', count: 3 },
                    { type: 'dark', category: 'food', count: 3 }
                ],
                result: { type: 'water_dark_deep', count: 2 },
                category: 'food'
            },
            wind_earth_desert: {
                ingredients: [
                    { type: 'wind', category: 'food', count: 3 },
                    { type: 'earth', category: 'food', count: 3 }
                ],
                result: { type: 'wind_earth_desert', count: 2 },
                category: 'food'
            },
            wind_light_cloud: {
                ingredients: [
                    { type: 'wind', category: 'food', count: 3 },
                    { type: 'light', category: 'food', count: 3 }
                ],
                result: { type: 'wind_light_cloud', count: 2 },
                category: 'food'
            },
            wind_dark_night: {
                ingredients: [
                    { type: 'wind', category: 'food', count: 3 },
                    { type: 'dark', category: 'food', count: 3 }
                ],
                result: { type: 'wind_dark_night', count: 2 },
                category: 'food'
            },
            earth_light_sprout: {
                ingredients: [
                    { type: 'earth', category: 'food', count: 3 },
                    { type: 'light', category: 'food', count: 3 }
                ],
                result: { type: 'earth_light_sprout', count: 2 },
                category: 'food'
            },
            earth_dark_mushroom: {
                ingredients: [
                    { type: 'earth', category: 'food', count: 3 },
                    { type: 'dark', category: 'food', count: 3 }
                ],
                result: { type: 'earth_dark_mushroom', count: 2 },
                category: 'food'
            },
            // 장식물 합성 (같은 속성 common 장식물 2개 = rare 장식물 1개)
            flame_lamp: {
                ingredients: [
                    { type: 'fire_common1', category: 'decoration', count: 1 },
                    { type: 'fire_common2', category: 'decoration', count: 1 }
                ],
                result: { type: 'flame_lamp', count: 1 },
                category: 'decoration'
            },
            aqua_fountain: {
                ingredients: [
                    { type: 'water_common1', category: 'decoration', count: 1 },
                    { type: 'water_common2', category: 'decoration', count: 1 }
                ],
                result: { type: 'aqua_fountain', count: 1 },
                category: 'decoration'
            },
            wind_chime: {
                ingredients: [
                    { type: 'wind_common1', category: 'decoration', count: 1 },
                    { type: 'wind_common2', category: 'decoration', count: 1 }
                ],
                result: { type: 'wind_chime', count: 1 },
                category: 'decoration'
            },
            earth_statue: {
                ingredients: [
                    { type: 'earth_common1', category: 'decoration', count: 1 },
                    { type: 'earth_common2', category: 'decoration', count: 1 }
                ],
                result: { type: 'earth_statue', count: 1 },
                category: 'decoration'
            },
            light_orb: {
                ingredients: [
                    { type: 'light_common1', category: 'decoration', count: 1 },
                    { type: 'light_common2', category: 'decoration', count: 1 }
                ],
                result: { type: 'light_orb', count: 1 },
                category: 'decoration'
            },
            shadow_crystal: {
                ingredients: [
                    { type: 'dark_common1', category: 'decoration', count: 1 },
                    { type: 'dark_common2', category: 'decoration', count: 1 }
                ],
                result: { type: 'shadow_crystal', count: 1 },
                category: 'decoration'
            }
        };
        
        // 연구실 슬롯 상태
        let labSlot1 = null; // { type: 'fire', category: 'food', count: 5 }
        let labSlot2 = null;
        let currentLabSlot = null; // 현재 선택 중인 슬롯
        let discoveredRecipes = []; // 발견한 레시피 목록
        const ENCYCLOPEDIA_HINTS = {
            // 전설
            'titania': '나비를 거느리는 정령들의 군주.',
            'oberon': '나방을 거느리는 정령들의 군주.',
            
            // 백의 정령
            'nostat-normal': '순수한 백색. 아무 속성도 깃들지 않은 정령.',
            'intelligent-low-normal': '지혜롭지만 순수한 정령.',
            'intelligent-mid-normal': '지적이며 순수한 정령.',
            'intelligent-high-normal': '세상의 지혜를 담은 순수한 정령.',
            'strong-low-normal': '튼튼하지만 순수한 정령.',
            'strong-mid-normal': '강하며 순수한 정령.',
            'strong-high-normal': '세상의 힘을 담은 순수한 정령.',
            'beautiful-low-normal': '귀엽고 순수한 정령.',
            'beautiful-mid-normal': '아름답고 순수한 정령.',
            'beautiful-high-normal': '세상의 아름다움을 담은 순수한 정령.',
            
            // 불 속성
            'nostat-fire': '불의 기운이 느껴지는 정령.',
            'intelligent-low-fire': '똑똑한 불의 정령.',
            'intelligent-mid-fire': '지적인 불의 정령.',
            'intelligent-high-fire': '세상의 불을 다스리는 지혜로운 정령.',
            'strong-low-fire': '튼튼한 불의 정령.',
            'strong-mid-fire': '강한 불의 정령.',
            'strong-high-fire': '세상의 불을 다스리는 강인한 정령.',
            'beautiful-low-fire': '귀여운 불의 정령.',
            'beautiful-mid-fire': '아름다운 불의 정령.',
            'beautiful-high-fire': '세상의 불을 다스리는 매혹적인 정령.',
            
            // 물 속성
            'nostat-water': '물의 기운이 느껴지는 정령.',
            'intelligent-low-water': '똑똑한 물의 정령.',
            'intelligent-mid-water': '지적인 물의 정령.',
            'intelligent-high-water': '세상의 물을 다스리는 지혜로운 정령.',
            'strong-low-water': '튼튼한 물의 정령.',
            'strong-mid-water': '강한 물의 정령.',
            'strong-high-water': '세상의 물을 다스리는 강인한 정령.',
            'beautiful-low-water': '귀여운 물의 정령.',
            'beautiful-mid-water': '아름다운 물의 정령.',
            'beautiful-high-water': '세상의 물을 다스리는 매혹적인 정령.',
            
            // 바람 속성
            'nostat-wind': '바람의 기운이 느껴지는 정령.',
            'intelligent-low-wind': '똑똑한 바람의 정령.',
            'intelligent-mid-wind': '지적인 바람의 정령.',
            'intelligent-high-wind': '세상의 바람을 다스리는 지혜로운 정령.',
            'strong-low-wind': '튼튼한 바람의 정령.',
            'strong-mid-wind': '강한 바람의 정령.',
            'strong-high-wind': '세상의 바람을 다스리는 강인한 정령.',
            'beautiful-low-wind': '귀여운 바람의 정령.',
            'beautiful-mid-wind': '아름다운 바람의 정령.',
            'beautiful-high-wind': '세상의 바람을 다스리는 매혹적인 정령.',
            
            // 땅 속성
            'nostat-earth': '땅의 기운이 느껴지는 정령.',
            'intelligent-low-earth': '똑똑한 땅의 정령.',
            'intelligent-mid-earth': '지적인 땅의 정령.',
            'intelligent-high-earth': '세상의 땅을 다스리는 지혜로운 정령.',
            'strong-low-earth': '튼튼한 땅의 정령.',
            'strong-mid-earth': '강한 땅의 정령.',
            'strong-high-earth': '세상의 땅을 다스리는 강인한 정령.',
            'beautiful-low-earth': '귀여운 땅의 정령.',
            'beautiful-mid-earth': '아름다운 땅의 정령.',
            'beautiful-high-earth': '세상의 땅을 다스리는 매혹적인 정령.',
            
            // 빛 속성
            'nostat-light': '빛의 기운이 강하게 느껴지는 정령.',
            'intelligent-low-light': '똑똑한 빛의 정령.',
            'intelligent-mid-light': '지적인 빛의 정령.',
            'intelligent-high-light': '세상의 빛을 다스리는 지혜로운 정령.',
            'strong-low-light': '튼튼한 빛의 정령.',
            'strong-mid-light': '강한 빛의 정령.',
            'strong-high-light': '세상의 빛을 다스리는 강인한 정령.',
            'beautiful-low-light': '귀여운 빛의 정령.',
            'beautiful-mid-light': '아름다운 빛의 정령.',
            'beautiful-high-light': '세상의 빛을 다스리는 매혹적인 정령.',
            
            // 어둠 속성
            'nostat-dark': '어둠의 기운이 강하게 느껴지는 정령.',
            'intelligent-low-dark': '똑똑한 어둠의 정령.',
            'intelligent-mid-dark': '지적인 어둠의 정령.',
            'intelligent-high-dark': '세상의 어둠을 다스리는 지혜로운 정령.',
            'strong-low-dark': '튼튼한 어둠의 정령.',
            'strong-mid-dark': '강한 어둠의 정령.',
            'strong-high-dark': '세상의 어둠을 다스리는 강인한 정령.',
            'beautiful-low-dark': '귀여운 어둠의 정령.',
            'beautiful-mid-dark': '아름다운 어둠의 정령.',
            'beautiful-high-dark': '세상의 어둠을 다스리는 매혹적인 정령.',
            
            // 복합 속성 (간략하게)
            'nostat-fire-water': '불과 물의 기운이 느껴지는 정령.',
            'nostat-fire-wind': '불과 바람의 기운이 느껴지는 정령.',
            'nostat-fire-earth': '불과 땅의 기운이 느껴지는 정령.',
            'nostat-fire-light': '불과 빛의 기운이 느껴지는 정령.',
            'nostat-fire-dark': '불과 어둠의 기운이 느껴지는 정령.',
            'nostat-water-wind': '물과 바람의 기운이 느껴지는 정령.',
            'nostat-water-earth': '물과 땅의 기운이 느껴지는 정령.',
            'nostat-water-light': '물과 빛의 기운이 느껴지는 정령.',
            'nostat-water-dark': '물과 어둠의 기운이 느껴지는 정령.',
            'nostat-wind-earth': '바람과 땅의 기운이 느껴지는 정령.',
            'nostat-wind-light': '바람과 빛의 기운이 느껴지는 정령.',
            'nostat-wind-dark': '바람과 어둠의 기운이 느껴지는 정령.',
            'nostat-earth-light': '땅과 빛의 기운이 느껴지는 정령.',
            'nostat-earth-dark': '땅과 어둠의 기운이 느껴지는 정령.',
            'nostat-light-dark': '빛과 어둠이 공존하는 신비로운 정령.',
            'nostat-balanced': '모든 속성이 조화롭게 균형잡힌 정령.',
            'nostat-multi': '여러 속성이 뒤섞인 혼돈의 정령.'
        };

        // 상태 키워드 시스템
        function getStatusKeywords(spirit) {
            const keywords = [];
            const keywordColor = '#2a2a2a';  // 검정색 통일
            
            // 애정도 기반
            if (spirit.parameters.affection >= 100) {
                keywords.push({ text: '사랑이 가득한', color: keywordColor });
            } else if (spirit.parameters.affection >= 70) {
                keywords.push({ text: '애정 어린', color: keywordColor });
            } else if (spirit.parameters.affection <= 10) {
                keywords.push({ text: '경계하는', color: keywordColor });
            }
            
            // 질병 상태
            if (spirit.isSick) {
                keywords.push({ text: '질병에 걸린', color: keywordColor });
            }
            
            // 음악 청취 횟수 (musicListened 카운트)
            if (spirit.musicListened >= 10) {
                keywords.push({ text: '음악을 사랑하는', color: keywordColor });
            }
            
            // 스탯 기반
            if (spirit.parameters.intelligence >= 80) {
                keywords.push({ text: '현명한', color: keywordColor });
            }
            if (spirit.parameters.strength >= 80) {
                keywords.push({ text: '강인한', color: keywordColor });
            }
            if (spirit.parameters.charm >= 80) {
                keywords.push({ text: '매혹적인', color: keywordColor });
            }
            
            // 성장 단계 기반
            const stage = getStage(spirit.growth);
            if (stage === 'adult' && !spirit.isCompleted) {
                keywords.push({ text: '번데기가 된', color: keywordColor });
            }
            
            // 만족도 기반
            if (spirit.satisfaction === 'high') {
                keywords.push({ text: '행복한', color: keywordColor });
            } else if (spirit.satisfaction === 'low') {
                keywords.push({ text: '불만족스러운', color: keywordColor });
            }
            
            // 방치 시간 기반 (30분 이상)
            const timeSinceInteraction = Date.now() - (spirit.lastInteraction || Date.now());
            if (timeSinceInteraction > 30 * 60 * 1000) {
                keywords.push({ text: '외로운', color: keywordColor });
            }
            
            // 테라리움 환경과 속성 일치도
            const dominantAttr = getDominantAttribute(spirit);
            const terrariumEnv = Object.keys(terrarium).reduce((a, b) => 
                terrarium[a] > terrarium[b] ? a : b
            );
            if (dominantAttr === terrariumEnv && terrarium[terrariumEnv] >= 30) {
                keywords.push({ text: '환경에 적응한', color: keywordColor });
            }
            
            // 빛/어둠 시간 기반
            if (spirit.lightTime >= 10) {
                keywords.push({ text: '태양을 동경하는', color: keywordColor });
            }
            if (spirit.darkTime >= 10) {
                keywords.push({ text: '달을 숭배하는', color: keywordColor });
            }
            
            // 먹이 횟수 (feedCount 카운트)
            if (spirit.feedCount >= 20) {
                keywords.push({ text: '미식가', color: keywordColor });
            }
            
            return keywords;
        }

                // 상점 가격표
        const SHOP_PRICES = {
            // 판매 가격 (인벤토리 → 코인)
            sell: {
                food_common: 8,    // 일반 먹이 판매
                food_rare: 15,     // 희귀 먹이 판매
                decoration: 15,    // 장식물 1개 = 15코인
                music: 25          // 음악 1개 = 25코인
            },
            // 구매 가격 (코인 → 인벤토리)
            buy: {
                food_common: 20,   // 일반 먹이 (화수풍지)
                food_rare: 40,     // 희귀 먹이 (빛암)
                music: 80,         // 음악 레코드
                decoration: 50     // 장식물
            }
        };

        const EVOLUTION_TYPES = {
            // 노멀 (모든 스탭이 10 미만)
            normal: { name: '백의 정령', icon: '🤍', desc: '순수한 빛을 간직한 정령. 모든 정령의 시작이자 근원.' },
            
            // 지적인 계열 (intelligence 최고)
            'intelligent-low': { prefix: '똑똑한', icon: '✨' },
            'intelligent-mid': { prefix: '지적인', icon: '💎' },
            'intelligent-high': { prefix: '세상의 비밀을 아는', icon: '🔮' },
            
            // 강한 계열 (strength 최고)
            'strong-low': { prefix: '튼튼한', icon: '✨' },
            'strong-mid': { prefix: '강한', icon: '💪' },
            'strong-high': { prefix: '세상을 받치는', icon: '⚡' },
            
            // 아름다운 계열 (charm 최고)
            'beautiful-low': { prefix: '귀여운', icon: '✨' },
            'beautiful-mid': { prefix: '아름다운', icon: '🌸' },
            'beautiful-high': { prefix: '세상을 매혹하는', icon: '🌺' },
            
            // 현자 계열 (모든 스탯 100)
            'sage': { prefix: '현자', icon: '🧙' }
        };
        
        // 속성별 정령 이름
        const ATTRIBUTE_NAMES = {
            normal: { name: '백의 정령', icon: '⚪', desc: '순수한 백색의 빛을 지닌 정령.' },
            fire: { name: '화염의 정령', icon: '🔥', desc: '타오르는 열정을 간직한 화염의 정령.' },
            water: { name: '빙하의 정령', icon: '💧', desc: '차가운 지혜를 품은 물의 정령.' },
            wind: { name: '질풍의 정령', icon: '🌬️', desc: '자유로운 바람을 담은 질풍의 정령.' },
            earth: { name: '대지의 정령', icon: '🌱', desc: '견고한 대지의 힘을 지닌 정령.' },
            light: { name: '광명의 정령', icon: '✨', desc: '찬란한 빛으로 가득한 광명의 정령.' },
            dark: { name: '암흑의 정령', icon: '🌙', desc: '신비로운 어둠을 담은 암흑의 정령.' },
            
            // 2속성 조합
            'fire-water': { name: '증기의 정령', icon: '💨', desc: '불과 물이 만나 탄생한 증기의 정령.' },
            'fire-wind': { name: '폭풍의 정령', icon: '🌪️', desc: '불과 바람이 만든 뜨거운 폭풍의 정령.' },
            'fire-earth': { name: '용암의 정령', icon: '🌋', desc: '불과 대지가 빚어낸 용암의 정령.' },
            'fire-light': { name: '태양의 정령', icon: '☀️', desc: '불과 빛이 합쳐진 태양의 정령.' },
            'fire-dark': { name: '연기의 정령', icon: '💨', desc: '불과 어둠이 만든 연기의 정령.' },
            'water-wind': { name: '구름의 정령', icon: '☁️', desc: '물과 바람이 만든 구름의 정령.' },
            'water-earth': { name: '진흙의 정령', icon: '🪨', desc: '물과 대지가 섞인 진흙의 정령.' },
            'water-light': { name: '무지개의 정령', icon: '🌈', desc: '물과 빛이 만든 무지개의 정령.' },
            'water-dark': { name: '안개의 정령', icon: '🌫️', desc: '물과 어둠이 만든 안개의 정령.' },
            'earth-wind': { name: '모래의 정령', icon: '🏜️', desc: '바람과 대지가 만든 모래의 정령.' },
            'light-wind': { name: '오로라의 정령', icon: '🌌', desc: '바람과 빛이 만든 오로라의 정령.' },
            'dark-wind': { name: '회오리의 정령', icon: '🌀', desc: '바람과 어둠이 만든 회오리의 정령.' },
            'earth-light': { name: '수정의 정령', icon: '💎', desc: '대지와 빛이 만든 수정의 정령.' },
            'dark-earth': { name: '동굴의 정령', icon: '⛰️', desc: '대지와 어둠이 만든 동굴의 정령.' },
            'dark-light': { name: '환혹의 정령', icon: '✨🌙', desc: '빛과 어둠이 공존하는 환혹의 정령.' },
            
            // 3속성 이상 (복합)
            balanced: { name: '조화의 정령', icon: '⚖️', desc: '모든 속성이 조화롭게 균형 잡힌 정령.' },
            multi: { name: '혼돈의 정령', icon: '🌪️', desc: '여러 속성이 뒤섞인 혼돈의 정령.' }
        };
        
        // 합성 전용 정령
        const FUSION_TYPES = {
            // 같은 속성 상위 버전
            'fusion-fire': { name: '이프리트', icon: '🔥💥', desc: '두 화염이 합쳐져 탄생한 극한의 불꽃 정령.', recipe: ['fire', 'fire'], rarity: 'rare' },
            'fusion-water': { name: '엘라임', icon: '💧🌊', desc: '두 물결이 합쳐져 탄생한 깊은 바다의 정령.', recipe: ['water', 'water'], rarity: 'rare' },
            'fusion-wind': { name: '미네르바', icon: '🌬️🌪️', desc: '두 바람이 합쳐져 탄생한 거대한 폭풍의 정령.', recipe: ['wind', 'wind'], rarity: 'rare' },
            'fusion-earth': { name: '노아스', icon: '🌱🏔️', desc: '두 대지가 합쳐져 탄생한 산맥의 정령.', recipe: ['earth', 'earth'], rarity: 'rare' },
            'fusion-light': { name: '루미엘', icon: '✨⚡', desc: '두 빛이 합쳐져 탄생한 눈부신 섬광의 정령.', recipe: ['light', 'light'], rarity: 'rare' },
            'fusion-dark': { name: '녹투스', icon: '🌙🕳️', desc: '두 어둠이 합쳐져 탄생한 끝없는 심연의 정령.', recipe: ['dark', 'dark'], rarity: 'rare' },
            
            // 상극 속성 (균형 계열)
            'fusion-balance-flame': { name: '에테르나', icon: '🔥💧', desc: '불과 물의 상극이 만들어낸 영원의 정령.', recipe: ['fire', 'water'], rarity: 'epic' },
            'fusion-balance-storm': { name: '사일렌시아', icon: '🌬️🌱', desc: '바람과 대지의 상극이 만들어낸 고요의 정령.', recipe: ['wind', 'earth'], rarity: 'epic' },
            'fusion-balance-twilight': { name: '트와일라', icon: '✨🌙', desc: '빛과 어둠의 상극이 만들어낸 황혼의 정령.', recipe: ['light', 'dark'], rarity: 'epic' },
            
            // 특수 조합
            'fusion-phoenix': { name: '솔라리스', icon: '🔥🐦', desc: '불과 빛이 합쳐져 탄생한 태양의 정령.', recipe: ['fire', 'light'], rarity: 'legendary' },
            'fusion-leviathan': { name: '아비수스', icon: '💧🐉', desc: '물과 어둠이 합쳐져 탄생한 심해의 정령.', recipe: ['water', 'dark'], rarity: 'legendary' },
            'fusion-dragon': { name: '템페스타', icon: '🔥🌬️', desc: '불과 바람이 합쳐져 탄생한 폭염의 정령.', recipe: ['fire', 'wind'], rarity: 'legendary' },
            'fusion-golem': { name: '크리스탈리아', icon: '🌱💎', desc: '대지와 빛이 합쳐져 탄생한 수정의 정령.', recipe: ['earth', 'light'], rarity: 'legendary' },
            'fusion-spirit-king': { name: '엘리멘타', icon: '👑✨', desc: '모든 속성이 조화롭게 합쳐진 정령들의 왕.', recipe: ['balanced', 'balanced'], rarity: 'legendary' },
            
            // 스탯 기반 합성
            'fusion-sage': { name: '사피엔스', icon: '📚🧙', desc: '뛰어난 지력을 가진 정령들이 합쳐진 지혜의 정령.', recipe: ['intelligent', 'intelligent'], rarity: 'epic' },
            'fusion-titan': { name: '포르티스', icon: '💪🏛️', desc: '강력한 힘을 가진 정령들이 합쳐진 강인의 정령.', recipe: ['strong', 'strong'], rarity: 'epic' },
            'fusion-siren': { name: '카리스마', icon: '💖🎵', desc: '매혹적인 정령들이 합쳐진 매력의 정령.', recipe: ['beautiful', 'beautiful'], rarity: 'epic' },
            
            // 전설 정령 교배
            'fusion-oblivion': { name: '오블리비온', icon: '🦋🌌', desc: '정령의 군주들 사이에서 태어난 망각의 정령.', recipe: ['titania', 'oberon'], rarity: 'mythic' }
        };
        
        // ========== 이벤트 정령 시스템 ==========
        const EVENT_TYPES = {
            'christmas2025': {
                name: '크리스마스 정령',
                icon: '🎄',
                attribute: 'event_christmas',
                desc: '크리스마스의 따뜻한 마음을 담은 특별한 정령.',
                validUntil: '2026-01-31',
                stages: {
                    egg: '🎁',
                    baby: '⭐',
                    child: '🎄',
                    adult: '🎅'
                },
                rewards: [
                    { type: 'decoration', id: 'christmas_tree', name: '크리스마스 트리', icon: '🎄' },
                    { type: 'decoration', id: 'christmas_gift', name: '선물 상자', icon: '🎁' },
                    { type: 'food', id: 'christmas_cookie', name: '크리스마스 쿠키', icon: '🍪' },
                    { type: 'music', id: 'christmas_carol', name: '크리스마스 캐롤', icon: '🎵' }
                ],
                // 이로치 버전 (25% 확률)
                shiny: {
                    name: '눈꽃 정령',
                    icon: '❄️',
                    desc: '겨울의 신비로운 기운을 담은 희귀한 정령.',
                    stages: {
                        egg: '🤍',
                        baby: '❄️',
                        child: '🌨️',
                        adult: '⛄'
                    },
                    chance: 0.4 // 40% 확률
                }
            }
        };
        
        // 이벤트 전용 아이템 정의
        const EVENT_ITEMS = {
            // 크리스마스 장식
            'christmas_tree': {
                name: '크리스마스 트리',
                icon: '🎄',
                type: 'decoration',
                event: 'christmas2025',
                quality: 'legendary',
                effects: { fire: 5, water: 5, wind: 5, earth: 5, light: 10, dark: 0 },
                desc: '크리스마스 정령에게서 받은 특별한 트리. 모든 속성을 높여줍니다.'
            },
            // 크리스마스 선물상자
            'christmas_gift': {
                name: '선물 상자',
                icon: '🎁',
                type: 'decoration',
                event: 'christmas2025',
                quality: 'legendary',
                effects: { fire: 3, water: 3, wind: 3, earth: 3, light: 5, dark: 5 },
                desc: '크리스마스 정령에게서 받은 선물 상자. 무엇이 들어있을까요?'
            },
            // 크리스마스 먹이
            'christmas_cookie': {
                name: '크리스마스 쿠키',
                icon: '🍪',
                type: 'food',
                event: 'christmas2025',
                effects: { intelligence: 5, strength: 5, charm: 5, growth: 10 },
                desc: '크리스마스 정령에게서 받은 특별한 쿠키. 모든 스탯을 크게 올려줍니다.'
            },
            // 크리스마스 음악
            'christmas_carol': {
                name: '크리스마스 캐롤',
                icon: '🎵',
                type: 'music',
                event: 'christmas2025',
                effects: { affection: 10, charm: 5 },
                desc: '크리스마스 정령에게서 받은 특별한 캐롤. 애정도를 크게 올려줍니다.'
            }
        };
        
        // 이벤트 코드 생성 함수
        function generateEventCode(eventType) {
            const event = EVENT_TYPES[eventType];
            if (!event) return null;
            
            const data = {
                e: eventType,
                ts: Date.now()
            };
            
            try {
                const json = JSON.stringify(data);
                const base64 = btoa(unescape(encodeURIComponent(json)));
                return 'SGEVENT-' + base64;
            } catch (e) {
                console.error('이벤트 코드 생성 오류:', e);
                return null;
            }
        }
        
        // 이벤트 코드 해석 함수
        function decodeEventCode(code) {
            try {
                if (!code.startsWith('SGEVENT-')) return null;
                const base64 = code.substring(8);
                const json = decodeURIComponent(escape(atob(base64)));
                const data = JSON.parse(json);
                
                if (!data.e || !EVENT_TYPES[data.e]) return null;
                
                const event = EVENT_TYPES[data.e];
                
                // 유효기간 체크
                if (event.validUntil && new Date() > new Date(event.validUntil)) {
                    return { expired: true, eventType: data.e };
                }
                
                return {
                    eventType: data.e,
                    event: event,
                    timestamp: data.ts
                };
            } catch (e) {
                console.error('이벤트 코드 해석 오류:', e);
                return null;
            }
        }
        
        // 이벤트 알 생성 함수
        function createEventSpirit(eventType) {
            const event = EVENT_TYPES[eventType];
            if (!event) return null;
            
            // 이로치 확률 체크
            const isShiny = event.shiny && Math.random() < event.shiny.chance;
            
            const timestamp = new Date().toLocaleString('ko-KR', {
                month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit'
            });
            
            const spiritName = isShiny ? event.shiny.name : event.name;
            const birthMessage = isShiny 
                ? `✨ 이벤트 코드로 희귀한 ${spiritName}의 알이 태어났습니다!`
                : `🎄 이벤트 코드로 특별한 알이 태어났습니다!`;
            
            const spirit = {
                id: Date.now(),
                name: spiritName,
                originalName: spiritName,
                growth: 0,
                parameters: {
                    intelligence: 0,
                    strength: 0,
                    charm: 0,
                    affection: 0
                },
                hiddenAttributes: {
                    fire: 0, water: 0, wind: 0, earth: 0, light: 0, dark: 0
                },
                satisfaction: 'mid',
                lastFed: null,
                lastMusic: null,
                lastPat: null,
                lastDecorate: null,
                lastInteraction: Date.now(),
                status: isShiny ? '희귀한 알이 은은하게 빛나고 있습니다...' : '특별한 알이 빛나고 있습니다...',
                birthTime: Date.now(),
                logs: [
                    { time: timestamp, message: birthMessage }
                ],
                lightTime: 0,
                darkTime: 0,
                musicListened: 0,
                feedCount: 0,
                // 이벤트 전용 속성
                isEventSpirit: true,
                eventType: eventType,
                isShiny: isShiny // 이로치 여부
            };
            
            return spirit;
        }
        
        // 이벤트 정령 스테이지 아이콘 가져오기
        function getEventStageIcon(spirit) {
            if (!spirit.isEventSpirit || !spirit.eventType) return null;
            const event = EVENT_TYPES[spirit.eventType];
            if (!event) return null;
            
            const stage = getStage(spirit.growth);
            
            // 이로치면 이로치 스테이지 아이콘 사용
            if (spirit.isShiny && event.shiny && event.shiny.stages) {
                return event.shiny.stages[stage] || event.shiny.icon;
            }
            
            return event.stages[stage] || event.icon;
        }
        
        // 이벤트 정령 완성 시 보상 지급
        function giveEventRewards(eventType) {
            const event = EVENT_TYPES[eventType];
            if (!event || !event.rewards) return;
            
            event.rewards.forEach(reward => {
                if (reward.type === 'decoration') {
                    if (!inventory.decorations) inventory.decorations = [];
                    inventory.decorations.push(reward.id);
                } else if (reward.type === 'food') {
                    if (!inventory.food) inventory.food = [];
                    inventory.food.push(reward.id);
                } else if (reward.type === 'music') {
                    if (!inventory.music) inventory.music = [];
                    inventory.music.push(reward.id);
                }
            });
            
            const rewardNames = event.rewards.map(r => `${r.icon} ${r.name}`).join(', ');
            showNotification(`🎁 이벤트 보상 획득! ${rewardNames}`);
        }
        
        // 합성 관련 변수
        let fusionSlot1Spirit = null;
        let fusionSlot2Spirit = null;
        const FUSION_COST = 100;
        const BREED_COST = 50;
        
        // 모달 z-index 관리
        let currentZIndex = 10000;
        function getNextZIndex() {
            currentZIndex += 10;
            return currentZIndex;
        }

        function loadGame() {
            const saved = localStorage.getItem('spiritGardenV2');
            if (saved) {
                const data = JSON.parse(saved);
                spirits = data.spirits || [];
                collection = data.collection || [];
                encyclopedia = data.encyclopedia || {};
                
                // 기존 도감 데이터 호환성 처리 - 존재하지 않는 진화 타입 제거 (이벤트 정령은 유지)
                collection = collection.filter(item => {
                    // 이벤트 정령은 항상 유지
                    if (item.type && item.type.startsWith('event_')) return true;
                    // 일반 정령은 EVOLUTION_TYPES에 있는지 확인
                    return EVOLUTION_TYPES[item.type] !== undefined;
                });
                
                inventory = data.inventory || { 
                    music: [], 
                    decorations: [],
                    food: ['fire', 'fire', 'fire', 'water', 'water', 'water', 'wind', 'wind', 'wind', 'earth', 'earth', 'earth']
                };
                
                // 잘못된 음악 키 제거 (quest, lullaby 등 → classic, jazz 등)
                if (inventory.music) {
                    const validMusicKeys = ['classic', 'jazz', 'rock', 'pop', 'ballad'];
                    inventory.music = inventory.music.filter(m => validMusicKeys.includes(m));
                }
                
                // 기존 장식물 키를 새 형식으로 변환 (fire → fire_common1 등)
                const oldToNewDecoMapping = {
                    fire: 'fire_common1',
                    water: 'water_common1',
                    wind: 'wind_common1',
                    earth: 'earth_common1',
                    light: 'light_common1',
                    dark: 'dark_common1'
                };
                
                if (inventory.decorations) {
                    inventory.decorations = inventory.decorations.map(d => {
                        // 이미 새 형식이면 그대로, 아니면 변환
                        return oldToNewDecoMapping[d] || d;
                    });
                }
                
                if (installedDecorations) {
                    installedDecorations = installedDecorations.map(d => {
                        return oldToNewDecoMapping[d] || d;
                    });
                }
                
                terrarium = data.terrarium || {
                    fire: 0, water: 0, wind: 0, earth: 0, light: 0, dark: 0
                };
                installedDecorations = data.installedDecorations || [];
                
                // 기존 문자열 배열을 객체 배열로 변환 (하위 호환성)
                installedDecorations = installedDecorations.map((d, index) => {
                    if (typeof d === 'string') {
                        return { type: d, index: index };
                    }
                    return d;
                });
                
                lightMode = data.lightMode !== undefined ? data.lightMode : true;
                coins = data.coins || 0;
                lastGatherTime = data.lastGatherTime || null;
                currentTitle = data.currentTitle || 'none';
                isPaused = data.isPaused || false;
                darkModeLocked = data.darkModeLocked || false;
                activatedEvents = data.activatedEvents || [];
                lowSatisfactionStartTime = data.lowSatisfactionStartTime || {};
                hasVisitedShop = data.hasVisitedShop || false;
                discoveredRecipes = data.discoveredRecipes || [];

                // 칭호 UI 반영
                const titleSelect = document.getElementById('titleSelect');
                if (titleSelect) {
                    titleSelect.value = currentTitle;
                }
                
                // 일시정지 버튼 UI 반영
                const pauseBtn = document.getElementById('pauseBtn');
                if (pauseBtn && isPaused) {
                    pauseBtn.textContent = '▶️';
                    pauseBtn.classList.add('paused');
                    pauseBtn.title = '재개';
                }

                // 설치된 장식물로 환경 재계산
                if (installedDecorations.length > 0) {
                    recalculateTerrariumEnvironment();
                }
                
                // 기존 정령들의 만족도 초기화 (하위 호환성)
                spirits.forEach(spirit => {
                    if (!spirit.satisfaction) {
                        spirit.satisfaction = 'mid';
                    }
                });

                // 조명 상태 적용
                applyLightMode();
            }
        }

        function saveGame() {
            localStorage.setItem('spiritGardenV2', JSON.stringify({
                spirits,
                collection,
                encyclopedia,
                inventory,
                terrarium,
                installedDecorations,
                lightMode,
                coins,
                lastGatherTime,
                currentTitle,
                currentGatherLocation,
                isPaused,
                darkModeLocked,
                activatedEvents,
                lowSatisfactionStartTime,
                hasVisitedShop,
                discoveredRecipes
            }));
        }

        const EGG_NAMES = [
            '반짝이는 알', '매끈매끈한 알', '얼룩무늬 알', '보라색 알',
            '투명한 알', '황금빛 알', '은빛 알', '검은색 알',
            '하얀색 알', '무지개 알', '작은 알', '큰 알',
            '따뜻한 알', '차가운 알', '부드러운 알', '단단한 알'
        ];
        
        function generateSpiritName() {
            return EGG_NAMES[Math.floor(Math.random() * EGG_NAMES.length)];
        }

        function addLog(spirit, message) {
            if (!spirit.logs) spirit.logs = [];
            const timestamp = new Date().toLocaleString('ko-KR', {
                month: '2-digit',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit'
            });
            spirit.logs.unshift({ time: timestamp, message }); // 최신이 위로
            if (spirit.logs.length > 50) spirit.logs.pop(); // 최대 50개 유지
            
            // 일지 추가 시에만 전체 렌더링
            renderSpirits();
        }

        function createNewSpirit() {
            if (spirits.length >= 6) {
                showNotification('정원이 가득 찼습니다 (최대 6마리)');
                return;
            }

            const randomName = EGG_NAMES[Math.floor(Math.random() * EGG_NAMES.length)];

            const spirit = {
                id: Date.now(),
                name: randomName,
                growth: 0,
                // 공개 스탯
                parameters: {
                    intelligence: 0,  // 지력
                    strength: 0,      // 체력
                    charm: 0,         // 매력
                    affection: 0      // 애정
                },
                // 숨겨진 속성 (진화 결정)
                hiddenAttributes: {
                    fire: 0,
                    water: 0,
                    wind: 0,
                    earth: 0,
                    light: 0,
                    dark: 0
                },
                satisfaction: 'mid',  // 만족도: 'high', 'mid', 'low'
                lastFed: null,
                lastMusic: null,
                lastPat: null,
                lastDecorate: null,
                lastInteraction: Date.now(),  // 마지막 상호작용 시간
                status: '배고파 보입니다...',
                birthTime: Date.now(),
                logs: [],  // 일지
                lightTime: 0,  // 빛 모드 누적 시간 (초)
                darkTime: 0,   // 어둠 모드 누적 시간 (초)
                musicListened: 0,  // 음악 청취 횟수
                feedCount: 0       // 먹이 횟수
            };

            spirits.push(spirit);
            saveGame();
            renderSpirits();
            showNotification(`${randomName}이(가) 태어났습니다! 🥚`);
            
            // 튜토리얼 체크
            checkTutorialAction('getEgg');
        }

        function showAppearance(spiritId) {
            const spirit = spirits.find(s => s.id === spiritId);
            if (!spirit) return;
            
            const appearance = getAppearanceDescription(spirit);
            if (appearance) {
                showNotification(`${spirit.name}의 모습: ${appearance}`);
            } else {
                showNotification(`${spirit.name}의 모습을 자세히 볼 수 없습니다.`);
            }
        }

        function changeName(spiritId) {
            currentSpiritId = spiritId;
            const spirit = spirits.find(s => s.id === spiritId);
            document.getElementById('nameInput').value = spirit.name;
            document.getElementById('nameModal').classList.add('active');
            
            // 튜토리얼: 이름 클릭 액션 체크
            checkTutorialAction('clickName');
        }
        
        // 이름 확인 함수
        function confirmName() {
            const spirit = spirits.find(s => s.id === currentSpiritId);
            if (!spirit) return;
            
            const newName = document.getElementById('nameInput').value.trim();
            if (!newName) {
                showNotification('이름을 입력해주세요');
                return;
            }
            spirit.name = newName;
            closeModal('nameModal');
            saveGame();
            updateSpiritCard(spirit);
            showNotification('이름을 변경했습니다');
            
            // 튜토리얼: 이름 변경 완료 액션 체크
            checkTutorialAction('rename');
        }

        // 정령의 주요 속성 찾기
        function getDominantAttribute(spirit) {
            if (!spirit.hiddenAttributes) {
                return 'normal';
            }
            
            let maxAttr = 'normal';
            let maxValue = 0;
            
            for (let attr in spirit.hiddenAttributes) {
                if (spirit.hiddenAttributes[attr] > maxValue) {
                    maxValue = spirit.hiddenAttributes[attr];
                    maxAttr = attr;
                }
            }
            
            // 최고 속성값이 50 미만이면 normal (백의 정령)
            if (maxValue < 50) {
                return 'normal';
            }
            
            return maxAttr;
        }

                function getStage(growth) {
            if (growth >= STAGE_REQUIREMENTS.adult) return 'adult';
            if (growth >= STAGE_REQUIREMENTS.pupa) return 'pupa';
            if (growth >= STAGE_REQUIREMENTS.larva3) return 'larva3';
            if (growth >= STAGE_REQUIREMENTS.larva2) return 'larva2';
            if (growth >= STAGE_REQUIREMENTS.larva1) return 'larva1';
            return 'egg';
        }
        
        // 현재 속성에 따른 외형 묘사 가져오기
        function getAppearanceDescription(spirit) {
            const stage = getStage(spirit.growth);
            
            // 성충이면 외형 묘사 없음
            if (stage === 'adult') return null;
            
            // 이벤트 정령 외형 묘사
            if (spirit.isEventSpirit && spirit.eventType) {
                const eventAppearances = {
                    christmas2025: {
                        normal: {
                            egg: '빨간색과 초록색 줄무늬의 알록달록한 알입니다.',
                            larva1: '초록색 몸에 빨간색 점 무늬가 있습니다.',
                            larva2: '초록색 몸에 빨간색 점 무늬가 있으며 머리 위에 별모양 더듬이가 있습니다.',
                            larva3: '초록색 몸에 빨간색 점 무늬가 있으며 머리 위의 별모양 더듬이가 반짝이고 있습니다.',
                            pupa: '반짝이는 금색 실로 감싸진 번데기입니다. 안에서 은은한 빛이 새어나옵니다.'
                        },
                        shiny: {
                            egg: '은은한 파란빛이 감도는 하얀 알입니다. 차가운 기운이 느껴집니다.',
                            larva1: '연한 파란색 몸에 은색 점 무늬가 있습니다.',
                            larva2: '연한 파란색 몸에 은색 점 무늬가 있으며 머리 위에 눈꽃 모양 더듬이가 있습니다.',
                            larva3: '연한 파란색 몸에 은색 점 무늬가 있으며 머리 위의 눈꽃 더듬이에서 눈이 흩날립니다.',
                            pupa: '반짝이는 은색 얼음으로 감싸진 번데기입니다. 안에서 푸른 빛이 새어나옵니다.'
                        }
                    }
                };
                
                const eventDesc = eventAppearances[spirit.eventType];
                if (eventDesc) {
                    const variant = spirit.isShiny ? 'shiny' : 'normal';
                    if (eventDesc[variant] && eventDesc[variant][stage]) {
                        return eventDesc[variant][stage];
                    }
                }
            }
            
            // 알 ~ 번데기만 외형 묘사 있음
            if (!APPEARANCE_DESCRIPTIONS[stage]) return null;
            
            // 현재 속성 계산 (먹이 70% + 테라리움 30%)
            const foodAttrs = spirit.hiddenAttributes || { fire: 0, water: 0, wind: 0, earth: 0, light: 0, dark: 0 };
            const finalAttrs = {};
            for (let attr in foodAttrs) {
                finalAttrs[attr] = (foodAttrs[attr] * 0.7) + (terrarium[attr] * 0.3);
            }
            
            // 속성을 내림차순으로 정렬
            const sortedAttrs = Object.entries(finalAttrs)
                .sort((a, b) => b[1] - a[1]);
            
            const firstAttr = sortedAttrs[0][0];
            const firstValue = sortedAttrs[0][1];
            const secondAttr = sortedAttrs[1][0];
            const secondValue = sortedAttrs[1][1];
            
            // 속성이 10 미만이면 normal
            if (firstValue < 10) {
                return APPEARANCE_DESCRIPTIONS[stage]['normal'] || '평범한 모습입니다.';
            }
            
            // 2개 속성이 비슷한지 확인 (차이가 30% 이하)
            // larva2, larva3, pupa만 혼합 외형 있음
            if ((stage === 'larva2' || stage === 'larva3' || stage === 'pupa') && secondValue >= 10) {
                const diffPercent = ((firstValue - secondValue) / firstValue) * 100;
                
                if (diffPercent <= 30) {
                    // 혼합 속성!
                    const comboKey = [firstAttr, secondAttr].sort().join('-');
                    const mixedDesc = APPEARANCE_DESCRIPTIONS[stage][comboKey];
                    
                    if (mixedDesc) {
                        return mixedDesc;
                    }
                }
            }
            
            // 단일 속성
            return APPEARANCE_DESCRIPTIONS[stage][firstAttr] || '평범한 모습입니다.';
        }
        
        // 품질 등급을 점수로 변환
        function getQualityScore(quality) {
            const qualityScores = {
                'common': 1,     // 낮음
                'rare': 3,       // 보통
                'epic': 5,       // 높음
                'legendary': 7   // 전설
            };
            return qualityScores[quality] || 1;
        }
        
        // 테라리움 전체 품질 계산
        function calculateTerrariumQuality() {
            if (installedDecorations.length === 0) return 0;
            
            let totalQuality = 0;
            installedDecorations.forEach(deco => {
                // 문자열 또는 객체 모두 지원
                const key = typeof deco === 'string' ? deco : deco.type;
                const decoData = DECORATION_TYPES[key];
                const eventItem = EVENT_ITEMS[key];
                
                if (decoData) {
                    totalQuality += getQualityScore(decoData.quality);
                } else if (eventItem && eventItem.quality) {
                    totalQuality += getQualityScore(eventItem.quality);
                }
            });
            
            // 평균 품질 반환 (소수점 1자리)
            return Math.round((totalQuality / installedDecorations.length) * 10) / 10;
        }
        
        // 정령별 불만 상태 지속 시간 체크 및 업데이트
        function updateLowSatisfactionTimer() {
            spirits.forEach(spirit => {
                if (spirit.isDead || spirit.isCompleted) return;
                
                const satisfaction = calculateSatisfaction(spirit);
                
                if (satisfaction === 'low') {
                    // 불만 상태인데 타이머가 없으면 시작
                    if (!lowSatisfactionStartTime[spirit.id]) {
                        lowSatisfactionStartTime[spirit.id] = Date.now();
                    }
                } else {
                    // 불만 상태가 아니면 타이머 리셋
                    delete lowSatisfactionStartTime[spirit.id];
                }
            });
        }
        
        // 정령이 상호작용을 거부하는 상태인지 확인 (불만 상태가 10분 이상 지속)
        function isSpiritRefusing(spiritId) {
            const startTime = lowSatisfactionStartTime[spiritId];
            if (!startTime) return false;
            const elapsed = Date.now() - startTime;
            return elapsed >= 10 * 60 * 1000; // 10분
        }
        
        // 거부 대사 반환
        function getRefusalMessage(spiritName, action) {
            const messages = {
                feed: [
                    `${spiritName}이(가) 고개를 돌립니다. 환경이 마음에 안 드는 것 같습니다.`,
                    `${spiritName}이(가) 먹이를 거부합니다. 기분이 안 좋아 보입니다.`,
                    `${spiritName}이(가) 슬픈 눈으로 쳐다봅니다. 불만이 쌓인 것 같습니다.`,
                    `${spiritName}이(가) 입을 꾹 다뭅니다. 무언가 불편한 것 같습니다.`,
                    `${spiritName}이(가) 무기력하게 있습니다. 힘이 없어 보입니다.`
                ],
                pet: [
                    `${spiritName}이(가) 손길을 피합니다. 환경이 마음에 안 드는 것 같습니다.`,
                    `${spiritName}이(가) 쓰다듬기를 거부합니다. 기분이 안 좋아 보입니다.`,
                    `${spiritName}이(가) 몸을 웅크립니다. 불만이 쌓인 것 같습니다.`,
                    `${spiritName}이(가) 고개를 저습니다. 무언가 불편한 것 같습니다.`,
                    `${spiritName}이(가) 삐진 듯 등을 돌립니다. 토라진 것 같습니다.`
                ]
            };
            const list = messages[action] || messages.feed;
            return list[Math.floor(Math.random() * list.length)];
        }
        
        // 만족도 계산 함수
        function calculateSatisfaction(spirit) {
            const stage = getStage(spirit.growth);
            
            // 죽었거나 완성된 정령은 만족도 계산 안 함
            if (spirit.isDead || spirit.isCompleted) return spirit.satisfaction || 'mid';
            
            // 장식물이 없으면 낮음
            if (installedDecorations.length === 0) return 'low';
            
            // 테라리움 전체 품질
            const avgQuality = calculateTerrariumQuality();
            
            // 성장 단계별 품질 요구치
            // 알/애벌레1: 기본 (2.0 / 3.0)
            // 애벌레2: 중간 (2.5 / 3.5)
            // 애벌레3: 높음 (3.0 / 4.0)
            // 번데기: 최고 (3.5 / 4.5)
            let qualityThresholdMid, qualityThresholdHigh;
            
            if (stage === 'egg' || stage === 'larva1') {
                qualityThresholdMid = 2.0;
                qualityThresholdHigh = 3.0;
            } else if (stage === 'larva2') {
                qualityThresholdMid = 2.5;
                qualityThresholdHigh = 3.5;
            } else if (stage === 'larva3') {
                qualityThresholdMid = 3.0;
                qualityThresholdHigh = 4.0;
            } else { // pupa
                qualityThresholdMid = 3.5;
                qualityThresholdHigh = 4.5;
            }
            
            // 알 ~ 애벌레1: 품질만 확인
            if (stage === 'egg' || stage === 'larva1') {
                // 품질 평균이 요구치를 초과하면 만족
                if (avgQuality >= qualityThresholdHigh) return 'high';
                else if (avgQuality >= qualityThresholdMid) return 'mid';
                else return 'low';
            }
            // 애벌레2, 애벌레3, 번데기: 품질 + 속성 유사도 (난이도 완화)
            else {
                // 정령의 현재 속성 계산
                const foodAttrs = spirit.hiddenAttributes || { fire: 0, water: 0, wind: 0, earth: 0, light: 0, dark: 0 };
                const spiritAttrs = {};
                for (let attr in foodAttrs) {
                    spiritAttrs[attr] = (foodAttrs[attr] * 0.7) + (terrarium[attr] * 0.3);
                }
                
                // 정령의 주 속성 찾기 (가장 높은 속성)
                let maxAttr = null;
                let maxValue = 0;
                for (let attr in spiritAttrs) {
                    if (spiritAttrs[attr] > maxValue) {
                        maxValue = spiritAttrs[attr];
                        maxAttr = attr;
                    }
                }
                
                // 속성이 10 미만이면 속성이 명확하지 않음
                if (maxValue < 10) {
                    // 품질만으로 판단
                    if (avgQuality >= qualityThresholdHigh + 0.5) return 'high';
                    else if (avgQuality >= qualityThresholdMid) return 'mid';
                    else return 'low';
                }
                
                // 테라리움의 주 속성과 정령의 주 속성 비교
                const terrariumMaxAttr = Object.entries(terrarium)
                    .sort((a, b) => b[1] - a[1])[0][0];
                
                // 속성 일치 확인 (완화: 정령 속성이 테라리움 상위 2개 안에 있으면 OK)
                const topTerrariumAttrs = Object.entries(terrarium)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 2)
                    .map(([attr]) => attr);
                
                if (topTerrariumAttrs.includes(maxAttr)) {
                    // 속성 일치 + 품질 적정 = 만족
                    return avgQuality >= qualityThresholdMid + 0.5 ? 'high' : 'mid';
                } else {
                    // 속성 불일치
                    if (avgQuality >= qualityThresholdHigh + 0.5) return 'mid';
                    else return 'low';
                }
            }
        }

        function getNextStageRequirement(growth) {
            const stage = getStage(growth);
            const stages = Object.keys(STAGE_REQUIREMENTS);
            const currentIndex = stages.indexOf(stage);
            if (currentIndex < stages.length - 1) {
                return STAGE_REQUIREMENTS[stages[currentIndex + 1]];
            }
            return STAGE_REQUIREMENTS.adult;
        }

        function canDoAction(spirit, action) {
            const now = Date.now();
            const cooldown = 10000; // 10초

            if (action === 'feed') {
                return !spirit.lastFeed || (now - spirit.lastFeed > cooldown);
            }
            if (action === 'music') {
                return !spirit.lastMusic || (now - spirit.lastMusic > cooldown);
            }
            if (action === 'pat') {
                return !spirit.lastPat || (now - spirit.lastPat > cooldown);
            }
            if (action === 'decorate') {
                return !spirit.lastDecorate || (now - spirit.lastDecorate > cooldown);
            }
            return false;
        }

        // 커스텀 확인 창 표시
        function showConfirm(title, message, onConfirm) {
            return new Promise((resolve) => {
                const modal = document.getElementById('confirmModal');
                const titleEl = document.getElementById('confirmTitle');
                const messageEl = document.getElementById('confirmMessage');
                const okBtn = document.getElementById('confirmOkBtn');
                const cancelBtn = document.getElementById('confirmCancelBtn');
                
                titleEl.textContent = title;
                messageEl.textContent = message;
                
                // 동적 z-index 적용
                modal.style.zIndex = getNextZIndex();
                modal.classList.add('active');
                
                // 이전 이벤트 리스너 제거
                const newOkBtn = okBtn.cloneNode(true);
                const newCancelBtn = cancelBtn.cloneNode(true);
                okBtn.parentNode.replaceChild(newOkBtn, okBtn);
                cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);
                
                // 확인 버튼
                document.getElementById('confirmOkBtn').onclick = () => {
                    modal.classList.remove('active');
                    if (onConfirm) onConfirm();
                    resolve(true);
                };
                
                // 취소 버튼
                document.getElementById('confirmCancelBtn').onclick = () => {
                    modal.classList.remove('active');
                    resolve(false);
                };
            });
        }

        function openFeedModal(spiritId) {
            const spirit = spirits.find(s => s.id === spiritId);
            if (!canDoAction(spirit, 'feed')) {
                showNotification('아직 배가 부릅니다');
                return;
            }
            if (!inventory.food) inventory.food = [];
            if (inventory.food.length === 0) {
                showNotification('먹이가 없습니다. 채집을 해보세요!');
                return;
            }
            currentSpiritId = spiritId;
            renderFeedOptions();
            document.getElementById('feedModal').classList.add('active');
        }

        function renderFeedOptions() {
            if (!inventory.food) inventory.food = [];
            
            const modal = document.getElementById('feedModal');
            const spirit = spirits.find(s => s.id === currentSpiritId);
            
            const foodCounts = {};
            inventory.food.forEach(f => {
                foodCounts[f] = (foodCounts[f] || 0) + 1;
            });
            
            // medicine을 foodCounts에서 분리
            const medicineCount = foodCounts['medicine'] || 0;
            delete foodCounts['medicine'];
            
            let medicineSection = '';
            if (spirit && spirit.isSick && medicineCount > 0) {
                medicineSection = `
                    <button class="option-btn" onclick="giveMedicineFromModal(${currentSpiritId})">
                        <span class="option-icon">🌿</span>
                        <div class="option-info">
                            <div class="option-name">${MEDICINE.name} ×${medicineCount}</div>
                            <div class="option-effect">병을 완전히 치료합니다</div>
                        </div>
                    </button>
                `;
            } else if (spirit && spirit.isSick) {
                medicineSection = `
                    <div style="margin-bottom: 10px; padding: 10px; background: var(--card); border: 1px solid var(--border);">
                        <div style="font-size: 0.9rem; color: #666;">정령이 아픕니다! 약초가 필요합니다.</div>
                    </div>
                `;
            }
            
            // 이벤트 먹이와 일반 먹이 분리 (고정 순서)
            const FOOD_ORDER = ['fire', 'water', 'wind', 'earth', 'light', 'dark'];
            const eventFoods = [];
            const normalFoods = [];
            const synthFoods = [];
            
            // 고정된 순서대로 정렬
            FOOD_ORDER.forEach(type => {
                if (foodCounts[type]) {
                    normalFoods.push([type, foodCounts[type]]);
                }
            });
            
            // 이벤트 먹이 (이벤트 아이템 키 순서대로)
            Object.keys(EVENT_ITEMS).forEach(type => {
                if (foodCounts[type] && EVENT_ITEMS[type].type === 'food') {
                    eventFoods.push([type, foodCounts[type]]);
                }
            });
            
            // 합성 먹이
            Object.keys(SYNTH_ITEMS).forEach(type => {
                if (foodCounts[type] && SYNTH_ITEMS[type].type === 'food') {
                    synthFoods.push([type, foodCounts[type]]);
                }
            });

            const content = `
                <div class="modal-title">무엇을 먹일까요?</div>
                ${eventFoods.length > 0 ? `
                    <div style="font-weight: 600; margin-bottom: 10px; color: #c41e3a;">🎄 이벤트 먹이</div>
                    <div class="food-grid" style="margin-bottom: 15px;">
                        ${eventFoods.map(([type, count]) => {
                            const item = EVENT_ITEMS[type];
                            return `
                                <button class="option-btn" style="border: 2px solid #c41e3a;" onclick="feedSpiritFromInventory(${currentSpiritId}, '${type}')">
                                    <span class="option-icon">${item.icon}</span>
                                    <div class="option-info">
                                        <div class="option-name">${item.name} ×${count}</div>
                                        <div class="option-effect" style="color: #c41e3a;">모든 스탯+5, 성장+10</div>
                                    </div>
                                </button>
                            `;
                        }).join('')}
                    </div>
                ` : ''}
                ${synthFoods.length > 0 ? `
                    <div style="font-weight: 600; margin-bottom: 10px; color: #9b59b6;">🔬 합성 먹이</div>
                    <div class="food-grid" style="margin-bottom: 15px;">
                        ${synthFoods.map(([type, count]) => {
                            const item = SYNTH_ITEMS[type];
                            let effectText;
                            if (item.attr === 'all') {
                                effectText = `전속성+${item.attrGain}`;
                            } else if (item.attr === 'dual' && item.dualAttr) {
                                effectText = `${item.dualAttr.join('+')} 각+${item.attrGain}`;
                            } else {
                                effectText = `${item.attr}+${item.attrGain}`;
                            }
                            return `
                                <button class="option-btn" style="border: 2px solid #9b59b6;" onclick="feedSpiritFromInventory(${currentSpiritId}, '${type}')">
                                    <span class="option-icon">${item.icon}</span>
                                    <div class="option-info">
                                        <div class="option-name">${item.name} ×${count}</div>
                                        <div class="option-effect" style="color: #9b59b6;">${effectText}, 애정+${item.affectionGain}</div>
                                    </div>
                                </button>
                            `;
                        }).join('')}
                    </div>
                ` : ''}
                <div style="font-weight: 600; margin-bottom: 10px; color: var(--text);">🍎 먹이</div>
                <div class="food-grid">
                    ${medicineSection}
                    ${normalFoods.map(([type, count]) => {
                        const isRare = type === 'light' || type === 'dark';
                        const gain = isRare ? 2 : 1;
                        const growth = isRare ? 3 : 2;
                        return `
                            <button class="option-btn" onclick="feedSpiritFromInventory(${currentSpiritId}, '${type}')">
                                <span class="option-icon">${ENV_ICONS[type]}</span>
                                <div class="option-info">
                                    <div class="option-name">${FOOD_NAMES[type]} ×${count}</div>
                                    <div class="option-effect">${ENV_ICONS[type]}+${gain} 성장+${growth}</div>
                                </div>
                            </button>
                        `;
                    }).join('')}
                </div>
                <button class="close-btn" onclick="closeModal('feedModal')">닫기</button>
            `;
            modal.querySelector('.modal-content').innerHTML = content;
        }
        
        function giveMedicineFromModal(spiritId) {
            giveMedicine(spiritId);
            closeModal('feedModal');
        }

        function feedSpiritFromInventory(spiritId, foodType) {
            if (isPaused) {
                showNotification('게임이 일시정지 상태입니다');
                return;
            }
            
            const spirit = spirits.find(s => s.id === spiritId);
            if (!spirit) return;
            
            // 불만 상태가 10분 이상 지속되면 거부
            if (isSpiritRefusing(spiritId)) {
                spirit.status = getRefusalMessage(spirit.name, 'feed');
                addLog(spirit, spirit.status);
                closeModal('feedModal');
                renderSpirits();
                showNotification('😢 정령이 먹이를 거부합니다...');
                return;
            }

            if (!inventory.food) inventory.food = [];
            const foodIndex = inventory.food.indexOf(foodType);
            if (foodIndex === -1) {
                showNotification('먹이가 없습니다');
                return;
            }

            // 먹이 소모
            inventory.food.splice(foodIndex, 1);

            // 이벤트 먹이 체크
            const eventItem = EVENT_ITEMS[foodType];
            if (eventItem && eventItem.type === 'food') {
                // 이벤트 먹이 효과 적용
                const effects = eventItem.effects;
                spirit.parameters.intelligence = Math.min(100, spirit.parameters.intelligence + (effects.intelligence || 0));
                spirit.parameters.strength = Math.min(100, spirit.parameters.strength + (effects.strength || 0));
                spirit.parameters.charm = Math.min(100, spirit.parameters.charm + (effects.charm || 0));
                // 질병 상태가 아닐 때만 성장
                if (!spirit.isSick) {
                    spirit.growth += effects.growth || 0;
                }
                spirit.parameters.affection += 3;
                
                spirit.lastFeed = Date.now();
                spirit.lastFed = Date.now();
                spirit.lastInteraction = Date.now();
                spirit.status = '특별한 음식을 먹었습니다!';
                
                if (!spirit.feedCount) spirit.feedCount = 0;
                spirit.feedCount += 1;
                
                addLog(spirit, `🎄 ${eventItem.name}을(를) 먹었습니다!`);
                addLog(spirit, '모든 능력이 크게 올랐습니다!');
                
                if (spirit.growth >= STAGE_REQUIREMENTS.adult && !spirit.isCompleted) {
                    completeSpirit(spirit);
                }
                
                closeModal('feedModal');
                saveGame();
                renderSpirits();
                renderInventory();
                showNotification(`${eventItem.icon} ${eventItem.name}을(를) 주었습니다! (모든 스탯 +5, 성장 +10)`);
                return;
            }
            
            // 합성 먹이 체크
            const synthItem = SYNTH_ITEMS[foodType];
            if (synthItem && synthItem.type === 'food') {
                // 합성 먹이 효과 적용
                if (!spirit.hiddenAttributes) {
                    spirit.hiddenAttributes = { fire: 0, water: 0, wind: 0, earth: 0, light: 0, dark: 0 };
                }
                
                // 속성 증가
                if (synthItem.attr === 'all') {
                    // 전체 속성 증가
                    Object.keys(spirit.hiddenAttributes).forEach(attr => {
                        spirit.hiddenAttributes[attr] = Math.min(500, spirit.hiddenAttributes[attr] + synthItem.attrGain);
                    });
                } else if (synthItem.attr === 'dual' && synthItem.dualAttr) {
                    // 혼합 속성 증가 (두 속성 모두)
                    synthItem.dualAttr.forEach(attr => {
                        spirit.hiddenAttributes[attr] = Math.min(500, spirit.hiddenAttributes[attr] + synthItem.attrGain);
                    });
                } else {
                    spirit.hiddenAttributes[synthItem.attr] = Math.min(500, spirit.hiddenAttributes[synthItem.attr] + synthItem.attrGain);
                }
                
                // 애정도 증가
                spirit.parameters.affection += synthItem.affectionGain || 0;
                
                // 질병 상태가 아닐 때만 성장
                if (!spirit.isSick) {
                    spirit.growth += synthItem.growthGain || 0;
                }
                
                spirit.lastFeed = Date.now();
                spirit.lastFed = Date.now();
                spirit.lastInteraction = Date.now();
                spirit.status = '특별한 음식을 먹었습니다!';
                
                if (!spirit.feedCount) spirit.feedCount = 0;
                spirit.feedCount += 1;
                
                addLog(spirit, `${synthItem.icon} ${synthItem.name}을(를) 먹었습니다!`);
                
                if (spirit.growth >= STAGE_REQUIREMENTS.adult && !spirit.isCompleted) {
                    completeSpirit(spirit);
                }
                
                closeModal('feedModal');
                saveGame();
                renderSpirits();
                renderInventory();
                
                let effectMsg;
                if (synthItem.attr === 'all') {
                    effectMsg = `전속성 +${synthItem.attrGain}`;
                } else if (synthItem.attr === 'dual' && synthItem.dualAttr) {
                    effectMsg = `${synthItem.dualAttr.join('+')} 각 +${synthItem.attrGain}`;
                } else {
                    effectMsg = `${synthItem.attr} +${synthItem.attrGain}`;
                }
                showNotification(`${synthItem.icon} ${synthItem.name}을(를) 주었습니다! (${effectMsg}, 애정도 +${synthItem.affectionGain})`);
                return;
            }

            const isRare = foodType === 'light' || foodType === 'dark';
            const attrGain = isRare ? 6 : 3;  // 희귀 +6, 일반 +3
            const growthGain = isRare ? 3 : 2;

            // 정령의 숨겨진 속성 증가
            if (!spirit.hiddenAttributes) {
                spirit.hiddenAttributes = {
                    fire: 0, water: 0, wind: 0, earth: 0, light: 0, dark: 0
                };
            }
            spirit.hiddenAttributes[foodType] = Math.min(500, spirit.hiddenAttributes[foodType] + attrGain);

            // 질병 상태가 아닐 때만 성장
            if (!spirit.isSick) {
                spirit.growth += growthGain;
            }
            spirit.lastFeed = Date.now();
            spirit.lastFed = Date.now();  // 배고픔 체크용
            spirit.lastInteraction = Date.now();  // 상호작용 시간 업데이트
            spirit.status = '맛있게 먹었습니다!';
            spirit.parameters.affection += 1;
            
            // 먹이 횟수 증가
            if (!spirit.feedCount) spirit.feedCount = 0;
            spirit.feedCount += 1;

            // 일지 추가
            addLog(spirit, `${FOOD_NAMES[foodType]}를 먹었습니다`);
            addLog(spirit, '맛있게 먹었습니다!');

            // 성충 체크 (100 이상이면 무조건 완료)
            if (spirit.growth >= STAGE_REQUIREMENTS.adult && !spirit.isCompleted) {
                completeSpirit(spirit);
            }

            closeModal('feedModal');
            saveGame();
            renderSpirits();  // 전체 렌더링으로 쿨타임 표시 업데이트
            renderInventory();
            showNotification(`${ENV_ICONS[foodType]} ${FOOD_NAMES[foodType]}를 주었습니다`);
            
            // 튜토리얼 체크
            checkTutorialAction('feed');
            
            // 속성 불균형 튜토리얼 체크
            checkImbalanceAndTutorial(spirit);
        }

        function openMusicModal(spiritId) {
            const spirit = spirits.find(s => s.id === spiritId);
            if (!canDoAction(spirit, 'music')) {
                showNotification('아직 음악을 듣고 있습니다');
                return;
            }
            if (inventory.music.length === 0) {
                showNotification('보유한 음악이 없습니다. 채집을 해보세요!');
                return;
            }
            currentSpiritId = spiritId;
            renderMusicOptions();
            document.getElementById('musicModal').classList.add('active');
        }

        function renderMusicOptions() {
            const container = document.getElementById('musicOptions');
            
            // 음악 개수 세기
            const musicCounts = {};
            inventory.music.forEach(m => {
                musicCounts[m] = (musicCounts[m] || 0) + 1;
            });
            
            // 이벤트 음악과 일반 음악 분리 (고정 순서)
            const eventMusic = [];
            const normalMusic = [];
            
            // 일반 음악 순서
            const musicOrder = ['classic', 'jazz', 'rock', 'pop', 'ballad'];
            musicOrder.forEach(type => {
                if (musicCounts[type]) {
                    normalMusic.push([type, musicCounts[type]]);
                }
            });
            
            // 이벤트 음악 (이벤트 아이템 키 순서대로)
            Object.keys(EVENT_ITEMS).forEach(type => {
                if (musicCounts[type] && EVENT_ITEMS[type].type === 'music') {
                    eventMusic.push([type, musicCounts[type]]);
                }
            });
            
            // 이벤트 음악 HTML
            const eventMusicHTML = eventMusic.map(([type, count]) => {
                const item = EVENT_ITEMS[type];
                return `
                    <button class="option-btn" style="border: 2px solid #c41e3a;" onclick="playMusicByType('${type}')">
                        <span class="option-icon">${item.icon}</span>
                        <div class="option-info">
                            <div class="option-name">${item.name} ×${count}</div>
                            <div class="option-effect" style="color: #c41e3a;">애정도+10, 매력+5</div>
                        </div>
                    </button>
                `;
            }).join('');
            
            // 일반 음악 HTML
            const musicHTML = normalMusic.map(([type, count]) => {
                const musicData = MUSIC_TYPES[type];
                return `
                    <button class="option-btn" onclick="playMusicByType('${type}')">
                        <span class="option-icon">${musicData.icon}</span>
                        <div class="option-info">
                            <div class="option-name">${musicData.name} ×${count}</div>
                            <div class="option-effect">${musicData.effect}</div>
                        </div>
                    </button>
                `;
            }).join('');
            
            let html = '<div class="music-grid">';
            if (eventMusicHTML) {
                html += `<div style="width: 100%; font-weight: 600; color: #c41e3a; margin-bottom: 10px;">🎄 이벤트 음악</div>`;
                html += eventMusicHTML;
                if (musicHTML) {
                    html += `<div style="width: 100%; font-weight: 600; color: var(--text); margin: 15px 0 10px;">🎵 일반 음악</div>`;
                }
            }
            html += musicHTML + '</div>';
            container.innerHTML = html;
        }

        function playMusicByType(musicType) {
            const spiritId = currentSpiritId;
            
            // 해당 타입의 음악 찾기
            const musicIndex = inventory.music.indexOf(musicType);
            if (musicIndex === -1) {
                showNotification('해당 음악이 없습니다');
                return;
            }
            
            // 기존 playMusic 함수 호출
            playMusic(spiritId, musicType, musicIndex);
        }

        function playMusic(spiritId, musicType, inventoryIndex) {
            if (isPaused) {
                showNotification('게임이 일시정지 상태입니다');
                return;
            }
            
            const spirit = spirits.find(s => s.id === spiritId);
            if (!spirit) return;

            // 이벤트 음악 체크
            const eventItem = EVENT_ITEMS[musicType];
            if (eventItem && eventItem.type === 'music') {
                const effects = eventItem.effects;
                spirit.parameters.affection += effects.affection || 0;
                spirit.parameters.charm = Math.min(100, spirit.parameters.charm + (effects.charm || 0));
                
                spirit.lastMusic = Date.now();
                spirit.lastInteraction = Date.now();
                spirit.lastMusicType = musicType;
                
                if (!spirit.musicListened) spirit.musicListened = 0;
                spirit.musicListened += 1;
                
                // 성장 단계별 이벤트 음악 대사
                const eventStage = getStage(spirit.growth);
                if (eventStage === 'egg') {
                    spirit.status = `${spirit.name}에서 크리스마스 캐롤에 반응하는 따뜻한 진동이 느껴집니다.`;
                } else if (eventStage === 'pupa') {
                    spirit.status = `${spirit.name}이(가) 크리스마스 캐롤에 미세하게 꿈틀거립니다.`;
                } else {
                    spirit.status = `${spirit.name}이(가) 크리스마스 캐롤에 맞춰 행복해합니다!`;
                }
                addLog(spirit, `🎄 ${eventItem.name}을(를) 들었습니다!`);
                
                inventory.music.splice(inventoryIndex, 1);
                
                closeModal('musicModal');
                saveGame();
                renderSpirits();
                renderInventory();
                showNotification(`${eventItem.icon} ${eventItem.name}을(를) 들려주었습니다! (애정도 +10, 매력 +5)`);
                return;
            }

            const musicData = MUSIC_TYPES[musicType];
            
            // 만족도 즉시 계산
            spirit.satisfaction = calculateSatisfaction(spirit);
            const singleStatBonus = spirit.satisfaction === 'high' ? 2 : 0; // 단일 스탯 +2
            const dualStatBonus = spirit.satisfaction === 'high' ? 1 : 0;   // 복수 스탯 각 +1
            
            // 효과 적용 (만족도 높으면 보너스)
            if (musicType === 'classic') {
                spirit.parameters.intelligence = Math.min(100, spirit.parameters.intelligence + 10 + singleStatBonus);
            } else if (musicType === 'jazz') {
                spirit.parameters.charm = Math.min(100, spirit.parameters.charm + 10 + singleStatBonus);
            } else if (musicType === 'rock') {
                spirit.parameters.strength = Math.min(100, spirit.parameters.strength + 10 + singleStatBonus);
            } else if (musicType === 'pop') {
                spirit.parameters.intelligence = Math.min(100, spirit.parameters.intelligence + 5 + dualStatBonus);
                spirit.parameters.charm = Math.min(100, spirit.parameters.charm + 5 + dualStatBonus);
            } else if (musicType === 'ballad') {
                spirit.parameters.strength = Math.min(100, spirit.parameters.strength + 5 + dualStatBonus);
                spirit.parameters.charm = Math.min(100, spirit.parameters.charm + 5 + dualStatBonus);
            }

            // 애정도 증가 (만족도 높으면 +1 보너스)
            const affectionBonus = spirit.satisfaction === 'high' ? 3 : 2;
            spirit.parameters.affection += affectionBonus;

            spirit.lastMusic = Date.now();
            spirit.lastInteraction = Date.now();  // 상호작용 시간 업데이트
            spirit.lastMusicType = musicType; // 마지막으로 들은 음악 저장
            
            // 음악 청취 횟수 증가
            if (!spirit.musicListened) spirit.musicListened = 0;
            spirit.musicListened += 1;
            
            // 성장 단계 확인
            const stage = getStage(spirit.growth);
            const isEgg = stage === 'egg';
            const isPupaStage = stage === 'pupa';
            
            // 음악 관련 랜덤 메시지 (성장 단계별)
            let musicMessages = [];
            
            if (isEgg) {
                // 알 상태 음악 반응
                musicMessages = [
                    `${spirit.name}에서 음악에 반응하는 진동이 느껴집니다.`,
                    `${spirit.name}이(가) ${musicData.name}의 선율에 미세하게 떨립니다.`,
                    `${spirit.name}의 껍질이 음악에 맞춰 희미하게 빛납니다.`,
                    `${spirit.name} 안에서 음악을 좋아하는 것 같은 기운이 느껴집니다.`,
                    `${spirit.name}이(가) ${musicData.name}을(를) 듣고 평온해 보입니다.`
                ];
            } else if (isPupaStage) {
                // 번데기 상태 음악 반응
                musicMessages = [
                    `${spirit.name}에서 음악에 반응하는 약한 진동이 느껴집니다.`,
                    `${spirit.name}이(가) ${musicData.name}의 선율에 미세하게 꿈틀거립니다.`,
                    `${spirit.name}의 껍질이 음악에 맞춰 살짝 떨립니다.`,
                    `${spirit.name} 안에서 음악을 즐기는 것 같은 기운이 느껴집니다.`,
                    `${spirit.name}이(가) ${musicData.name}을(를) 들으며 변태를 준비합니다.`
                ];
            } else {
                // 애벌레 상태 음악 반응 (기존)
                musicMessages = [
                    `${spirit.name}이(가) ${musicData.name}을(를) 흥얼거립니다.`,
                    `${spirit.name}이(가) ${musicData.name}에 맞춰 춤을 춥니다.`,
                    `${spirit.name}이(가) ${musicData.name}의 선율을 떠올립니다.`,
                    `${spirit.name}이(가) 음악에 취해 있습니다.`,
                    `${spirit.name}이(가) ${musicData.name}의 여운에 젖어 있습니다.`
                ];
            }
            spirit.status = musicMessages[Math.floor(Math.random() * musicMessages.length)];

            // 일지 추가
            addLog(spirit, `${musicData.name}을(를) 들었습니다`);

            // 음악 소모
            inventory.music.splice(inventoryIndex, 1);

            closeModal('musicModal');
            saveGame();
            renderSpirits();  // 전체 렌더링으로 쿨타임 표시 업데이트
            renderInventory();
            const bonusText = spirit.satisfaction === 'high' ? ' (만족 보너스!)' : '';
            showNotification(`${musicData.name}을(를) 들려주었습니다${bonusText}`);
            
            // 튜토리얼 체크
            checkTutorialAction('music');
        }

        function patSpirit(spiritId) {
            if (isPaused) {
                showNotification('게임이 일시정지 상태입니다');
                return;
            }
            
            const spirit = spirits.find(s => s.id === spiritId);
            if (!spirit) return;
            
            // 불만 상태가 10분 이상 지속되면 거부
            if (isSpiritRefusing(spiritId)) {
                spirit.status = getRefusalMessage(spirit.name, 'pet');
                addLog(spirit, spirit.status);
                renderSpirits();
                showNotification('😢 정령이 쓰다듬기를 거부합니다...');
                return;
            }

            if (!canDoAction(spirit, 'pat')) {
                showNotification('아직 쓰다듬을 수 없습니다');
                return;
            }

            // 만족도 즉시 계산
            spirit.satisfaction = calculateSatisfaction(spirit);
            
            const currentAffection = spirit.parameters.affection || 0;
            const affectionBonus = spirit.satisfaction === 'high' ? 2 : 1;
            spirit.parameters.affection += affectionBonus;
            spirit.lastPat = Date.now();
            spirit.lastInteraction = Date.now();  // 상호작용 시간 업데이트
            
            // 성장 단계 확인
            const stage = getStage(spirit.growth);
            const isEgg = stage === 'egg';
            const isPupaStage = stage === 'pupa';
            
            // 애정도에 따른 반응 메시지
            let messages = [];
            let notificationEmoji = '';
            
            // 알 상태 대사
            if (isEgg) {
                if (currentAffection < 10) {
                    messages = [
                        `${spirit.name}에서 차가운 기운이 느껴집니다.`,
                        `${spirit.name}이(가) 아직 낯선 온기에 적응 중입니다.`,
                        `${spirit.name}의 껍질이 살짝 떨립니다.`
                    ];
                    notificationEmoji = '😟';
                } else if (currentAffection < 50) {
                    messages = [
                        `${spirit.name}에서 따뜻한 기운이 느껴집니다.`,
                        `${spirit.name}이(가) 당신의 온기를 좋아하는 것 같습니다.`,
                        `${spirit.name}의 껍질에서 미세한 진동이 느껴집니다.`
                    ];
                    notificationEmoji = '😊';
                } else {
                    messages = [
                        `${spirit.name}에서 행복한 기운이 전해집니다.`,
                        `${spirit.name}이(가) 당신의 손길에 반응합니다.`,
                        `${spirit.name} 안에서 무언가 기뻐하는 것 같습니다.`,
                        `${spirit.name}이(가) 포근한 온기에 만족해합니다.`
                    ];
                    notificationEmoji = '🥰';
                }
            }
            // 번데기 상태 대사
            else if (isPupaStage) {
                if (currentAffection < 10) {
                    messages = [
                        `${spirit.name}에서 미약한 반응이 느껴집니다.`,
                        `${spirit.name}이(가) 아직 당신의 손길에 익숙하지 않은 것 같습니다.`,
                        `${spirit.name}의 껍질이 살짝 경직됩니다.`
                    ];
                    notificationEmoji = '😟';
                } else if (currentAffection < 50) {
                    messages = [
                        `${spirit.name}에서 따뜻한 진동이 느껴집니다.`,
                        `${spirit.name}이(가) 당신의 손길에 편안해하는 것 같습니다.`,
                        `${spirit.name}의 껍질이 부드럽게 반응합니다.`
                    ];
                    notificationEmoji = '😊';
                } else {
                    messages = [
                        `${spirit.name}에서 행복한 진동이 전해집니다.`,
                        `${spirit.name}이(가) 당신의 손길을 기다렸던 것 같습니다.`,
                        `${spirit.name} 안에서 기쁨이 느껴집니다.`,
                        `${spirit.name}이(가) 당신의 사랑을 느끼고 있습니다.`
                    ];
                    notificationEmoji = '🥰';
                }
            }
            // 애벌레 상태 대사 (기존)
            else if (currentAffection < 10) {
                // 낯설어함, 경계함
                messages = [
                    `${spirit.name}이(가) 당신을 낯설어합니다...`,
                    `${spirit.name}이(가) 경계하며 물러섭니다`,
                    `${spirit.name}이(가) 조심스럽게 바라봅니다`,
                    `${spirit.name}이(가) 당신의 손길을 두려워합니다`,
                    `${spirit.name}이(가) 불안해하며 몸을 움츠립니다`,
                    `${spirit.name}이(가) 당신이 누구인지 궁금해합니다`,
                    `${spirit.name}이(가) 천천히 다가옵니다...`
                ];
                notificationEmoji = '😟';
            } else if (currentAffection < 50) {
                // 익숙해짐
                messages = [
                    `${spirit.name}이(가) 당신에게 익숙해졌습니다`,
                    `${spirit.name}이(가) 편안해 보입니다`,
                    `${spirit.name}이(가) 당신의 손길을 받아들입니다`,
                    `${spirit.name}이(가) 조금씩 마음을 엽니다`,
                    `${spirit.name}이(가) 당신을 신뢰하기 시작합니다`,
                    `${spirit.name}이(가) 기분이 좋아 보입니다`,
                    `${spirit.name}이(가) 당신 곁에 머뭅니다`
                ];
                notificationEmoji = '😊';
            } else {
                // 친해짐, 잘 따름
                messages = [
                    `${spirit.name}이(가) 당신을 무척 좋아합니다!`,
                    `${spirit.name}이(가) 당신을 따라다닙니다`,
                    `${spirit.name}이(가) 행복하게 당신을 바라봅니다`,
                    `${spirit.name}이(가) 당신에게 애교를 부립니다`,
                    `${spirit.name}이(가) 당신의 손을 비빕니다`,
                    `${spirit.name}이(가) 기뻐하며 펄쩍 뜁니다!`,
                    `${spirit.name}이(가) 당신 곁을 떠나지 않으려 합니다`,
                    `${spirit.name}이(가) 당신의 사랑을 온몸으로 느낍니다`
                ];
                notificationEmoji = '🥰';
            }
            
            spirit.status = messages[Math.floor(Math.random() * messages.length)];

            // 일지 추가
            addLog(spirit, '쓰다듬었습니다');
            addLog(spirit, spirit.status);

            saveGame();
            renderSpirits();  // 전체 렌더링으로 쿨타임 표시 업데이트
            const bonusText = spirit.satisfaction === 'high' ? ' (만족 보너스!)' : '';
            showNotification(`쓰다듬었습니다 (애정 +${affectionBonus}${bonusText})`);
            
            // 튜토리얼 체크
            checkTutorialAction('pat');
        }
        
        // 약 먹이기 함수
        function giveMedicine(spiritId) {
            if (isPaused) {
                showNotification('게임이 일시정지 상태입니다');
                return;
            }
            
            const spirit = spirits.find(s => s.id === spiritId);
            if (!spirit) return;
            
            if (!spirit.isSick) {
                showNotification('이 정령은 건강합니다');
                return;
            }
            
            if (!inventory.food) inventory.food = [];
            const medicineIndex = inventory.food.indexOf('medicine');
            if (medicineIndex === -1) {
                showNotification('약초가 없습니다. 상점에서 구매하세요!');
                return;
            }
            
            // 약초 소모
            inventory.food.splice(medicineIndex, 1);
            
            // 병 치료
            spirit.isSick = false;
            spirit.sickWarned = false;
            delete spirit.sickTime;
            spirit.lastInteraction = Date.now(); // 상호작용 시간 업데이트
            
            const healMessages = [
                `${spirit.name}이(가) 약초를 먹고 건강해졌습니다! 💚`,
                `${spirit.name}의 병이 완전히 나았습니다!`,
                `${spirit.name}이(가) 활기를 되찾았습니다! 🌟`,
                `${spirit.name}이(가) 당신의 보살핌에 감사합니다`
            ];
            
            spirit.status = healMessages[Math.floor(Math.random() * healMessages.length)];
            
            // 일지 추가
            addLog(spirit, '약초를 먹고 건강해졌습니다');
            addLog(spirit, spirit.status);
            
            // 질병 튜토리얼: 약초 사용 액션 체크
            checkSickTutorialAction('useMedicine');
            
            saveGame();
            updateSpiritCard(spirit);
            renderInventory();
            showNotification(`${spirit.name}의 병이 나았습니다!`);
        }

        let inventoryCollapsed = localStorage.getItem('inventoryCollapsed') === 'true';
        
        function toggleInventoryCollapse() {
            inventoryCollapsed = !inventoryCollapsed;
            localStorage.setItem('inventoryCollapsed', inventoryCollapsed);
            updateInventoryCollapseUI();
        }
        
        function updateInventoryCollapseUI() {
            const content = document.getElementById('inventoryContent');
            const icon = document.getElementById('inventoryToggleIcon');
            
            if (content) {
                content.style.display = inventoryCollapsed ? 'none' : 'block';
            }
            if (icon) {
                icon.textContent = inventoryCollapsed ? '▶' : '▼';
            }
        }

        function changeTitle() {
            const select = document.getElementById('titleSelect');
            currentTitle = select.value;
            
            const titleNames = {
                'none': '자동채집',
                'hawk_eye': '🦅 매의 눈',
                'gatherer': '🍎 채집꾼',
                'musician': '음악가',
                'collector': '💎 수집가'
            };
            
            // 자동 채집 상태 업데이트
            if (currentTitle === 'none') {
                showNotification(`칭호를 ${titleNames[currentTitle]}(으)로 변경했습니다`);
            } else {
                showNotification(`칭호를 ${titleNames[currentTitle]}(으)로 변경했습니다`);
            }
            
            updateGatherButton();
            saveGame();
        }
        
        function changeShopCategory() {
            const select = document.getElementById('shopCategorySelect');
            currentShopCategory = select.value;
            renderShop();
        }

        function changeGatherLocation() {
            const select = document.getElementById('gatherLocationSelect');
            currentGatherLocation = select.value;
            saveGame();
            
            const locationNames = {
                garden: '🌸 정원',
                lake: '🌊 호수',
                forest: '🌲 숲'
            };
            showNotification(`채집 장소를 ${locationNames[currentGatherLocation]}(으)로 변경했습니다`);
        }

        function goGather() {
            if (isPaused) {
                showNotification('게임이 일시정지 상태입니다');
                return;
            }
            
            const now = Date.now();
            const gatherCooldown = 15000; // 15초

            // 쿨다운 체크
            if (lastGatherTime && (now - lastGatherTime < gatherCooldown)) {
                const remainingTime = Math.ceil((gatherCooldown - (now - lastGatherTime)) / 1000);
                showNotification(`${remainingTime}초 후에 다시 채집할 수 있습니다`);
                return;
            }
            
            // 선택된 장소에서 바로 채집
            gatherAtLocation(currentGatherLocation);
        }
        
        function gatherAtLocation(location, isAuto = false) {
            const now = Date.now();

            if (!inventory.food) inventory.food = [];
            if (!inventory.music) inventory.music = [];
            if (!inventory.decorations) inventory.decorations = [];

            const discoveries = [];
            
            // 자동 채집일 경우 확률 0.5배, 아닐 경우 1.0배
            const autoGatherMultiplier = isAuto ? 0.5 : 1.0;
            
            // 칭호별 확률 보너스
            const titleBonus = {
                hawk_eye: 1.5,    // 매의 눈: 모든 확률 1.5배
                gatherer: 1.0,    // 채집꾼: 먹이만 2배 (아래서 따로 처리)
                musician: 1.0,    // 음악가: 레코드만 2배 (아래서 따로 처리)
                collector: 1.0    // 수집가: 테라리움만 2배 (아래서 따로 처리)
            };
            
            const baseBonus = currentTitle !== 'none' && titleBonus[currentTitle] ? titleBonus[currentTitle] : 1.0;
            const foodBonus = currentTitle === 'gatherer' ? 2.0 : baseBonus;
            
            // 장소별 먹이 타입
            let locationFoodTypes = [];
            let locationDecoTypes = [];
            
            if (location === 'garden') {
                locationFoodTypes = ['fire', 'water', 'wind', 'earth'];  // 정원: 모든 기본 속성
                locationDecoTypes = ['fire', 'water', 'wind', 'earth'];
            } else if (location === 'lake') {
                locationFoodTypes = ['water', 'wind'];  // 호수: 물, 바람
                locationDecoTypes = ['water', 'wind'];
            } else if (location === 'forest') {
                locationFoodTypes = ['earth', 'fire'];  // 숲: 땅, 불
                locationDecoTypes = ['earth', 'fire'];
            }
            
            // 80% 확률로 일반 먹이 발견 (장소 고정)
            if (Math.random() < (0.8 * foodBonus * autoGatherMultiplier)) {
                const randomFood = locationFoodTypes[Math.floor(Math.random() * locationFoodTypes.length)];
                inventory.food.push(randomFood);
                discoveries.push(`🍎 ${FOOD_NAMES[randomFood]}`);
            }

            // 40% 확률로 희귀 먹이 발견 (빛암)
            if (Math.random() < (0.4 * foodBonus * autoGatherMultiplier)) {
                const rareFoodTypes = ['light', 'dark'];
                const randomRareFood = rareFoodTypes[Math.floor(Math.random() * rareFoodTypes.length)];
                inventory.food.push(randomRareFood);
                discoveries.push(`${FOOD_NAMES[randomRareFood]}`);
            }

            // 장식물 채집 (장소별 + 등급별 확률)
            const decoBonus = currentTitle === 'collector' ? 2.0 : baseBonus;
            
            // 합성 전용 장식물 목록 (채집 불가)
            const synthOnlyDecos = ['flame_lamp', 'aqua_fountain', 'wind_chime', 'earth_statue', 'light_orb', 'shadow_crystal'];
            
            // 50% 확률로 일반(common) 장식물 (장소 고정)
            if (Math.random() < (0.5 * decoBonus * autoGatherMultiplier)) {
                const commonDecos = Object.keys(DECORATION_TYPES).filter(key => {
                    const deco = DECORATION_TYPES[key];
                    return deco.quality === 'common' && locationDecoTypes.includes(deco.attr) && !synthOnlyDecos.includes(key);
                });
                if (commonDecos.length > 0) {
                    const randomDeco = commonDecos[Math.floor(Math.random() * commonDecos.length)];
                    inventory.decorations.push(randomDeco);
                    discoveries.push(`${DECORATION_TYPES[randomDeco].icon} ${DECORATION_TYPES[randomDeco].name}`);
                }
            }
            
            // 20% 확률로 희귀(rare) 장식물 (장소 고정)
            if (Math.random() < (0.2 * decoBonus * autoGatherMultiplier)) {
                const rareDecos = Object.keys(DECORATION_TYPES).filter(key => {
                    const deco = DECORATION_TYPES[key];
                    return deco.quality === 'rare' && locationDecoTypes.includes(deco.attr) && !synthOnlyDecos.includes(key);
                });
                if (rareDecos.length > 0) {
                    const randomDeco = rareDecos[Math.floor(Math.random() * rareDecos.length)];
                    inventory.decorations.push(randomDeco);
                    discoveries.push(`${DECORATION_TYPES[randomDeco].icon} ${DECORATION_TYPES[randomDeco].name}`);
                }
            }
            
            // 8% 확률로 최상급(epic) 장식물 (장소 고정) - 자동 채집에서는 제외
            if (!isAuto && Math.random() < (0.08 * decoBonus)) {
                const epicDecos = Object.keys(DECORATION_TYPES).filter(key => {
                    const deco = DECORATION_TYPES[key];
                    return deco.quality === 'epic' && locationDecoTypes.includes(deco.attr) && !synthOnlyDecos.includes(key);
                });
                if (epicDecos.length > 0) {
                    const randomDeco = epicDecos[Math.floor(Math.random() * epicDecos.length)];
                    inventory.decorations.push(randomDeco);
                    discoveries.push(`${DECORATION_TYPES[randomDeco].icon} ${DECORATION_TYPES[randomDeco].name} (최상급!)`);
                }
            }

            // 15% 확률로 음악 레코드 발견
            const musicBonus = currentTitle === 'musician' ? 2.0 : baseBonus;
            if (Math.random() < (0.15 * musicBonus * autoGatherMultiplier)) {
                const musicKeys = Object.keys(MUSIC_TYPES);
                const randomMusic = musicKeys[Math.floor(Math.random() * musicKeys.length)];
                inventory.music.push(randomMusic);
                discoveries.push(`${MUSIC_TYPES[randomMusic].name}`);
            }

            if (discoveries.length === 0) {
                if (!isAuto) {
                    showNotification('아무것도 발견하지 못했습니다...');
                }
            } else {
                const locationNames = { garden: '🌸 정원', lake: '🌊 호수', forest: '🌲 숲' };
                if (isAuto) {
                    showNotification(`자동 채집: ${discoveries.join(', ')}`);
                } else {
                    showNotification(`${locationNames[location]} 채집: ${discoveries.join(', ')}`);
                }
            }

            lastGatherTime = now;
            saveGame();
            renderInventory();
            updateGatherButton();
        }
        
        // 자동 채집 (칭호 없음일 때만 작동)
        let autoGatherInterval = null;
        
        function startAutoGather() {
            if (autoGatherInterval) {
                clearInterval(autoGatherInterval);
            }
            
            autoGatherInterval = setInterval(() => {
                // 칭호가 없음(none)일 때만 자동 채집
                if (currentTitle !== 'none') return;
                
                // 일시정지 상태면 스킵
                if (isPaused) return;
                
                // 자동 채집 실행
                gatherAtLocation(currentGatherLocation, true);
            }, 15000); // 15초마다
        }
        
        function stopAutoGather() {
            if (autoGatherInterval) {
                clearInterval(autoGatherInterval);
                autoGatherInterval = null;
            }
        }

        function updateGatherButton() {
            const gatherBtn = document.querySelector('.walk-btn');
            if (!gatherBtn) return;

            const now = Date.now();
            const gatherCooldown = 15000; // 15초
            
            // 자동 채집 활성화 여부
            const isAutoGatherActive = currentTitle === 'none';
            
            // 일시정지 중이면 버튼 비활성화
            if (isPaused) {
                gatherBtn.disabled = true;
                gatherBtn.textContent = '채집하기 (일시정지)';
                return;
            }

            if (lastGatherTime && (now - lastGatherTime < gatherCooldown)) {
                gatherBtn.disabled = true;
                const remainingTime = Math.ceil((gatherCooldown - (now - lastGatherTime)) / 1000);
                if (isAutoGatherActive) {
                    gatherBtn.textContent = `자동 채집 (${remainingTime}초)`;
                } else {
                    gatherBtn.textContent = `채집하기 (${remainingTime}초)`;
                }
            } else {
                gatherBtn.disabled = false;
                if (isAutoGatherActive) {
                    gatherBtn.textContent = '자동 채집 중';
                } else {
                    gatherBtn.textContent = '채집하기';
                }
            }
        }

        function confirmDeleteSpirit(spiritId) {
            const spirit = spirits.find(s => s.id === spiritId);
            if (!spirit) return;
            
            // 교배로 태어난 정령인 경우 코드 반환 옵션 제공
            if (spirit.isBred && spirit.breedCode) {
                showBreedDeleteConfirm(spirit);
            } else {
                showConfirm(
                    '정령 보내기',
                    `정말로 ${spirit.name}을(를) 보내시겠습니까?\n\n이 작업은 되돌릴 수 없습니다.`,
                    () => deleteSpirit(spiritId, false)
                );
            }
        }
        
        async function showBreedDeleteConfirm(spirit) {
            // 교배 정령 삭제 시 선택지 제공
            const modal = document.createElement('div');
            modal.className = 'modal active';
            modal.id = 'breedDeleteModal';
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 400px;">
                    <h3 style="margin-bottom: 16px;">🥚 교배 정령 보내기</h3>
                    <p style="margin-bottom: 8px;">${spirit.name}은(는) 교배로 태어난 정령입니다.</p>
                    <p style="color: #888; font-size: 0.9rem; margin-bottom: 20px;">보내기 방식을 선택해주세요.</p>
                    
                    <div style="display: flex; flex-direction: column; gap: 10px;">
                        <button onclick="deleteSpirit(${spirit.id}, false); closeBreedDeleteModal();" style="padding: 12px; background: var(--card); border: 1px solid var(--border); border-radius: 8px; cursor: pointer;">
                            🌿 그냥 보내기<br>
                            <span style="font-size: 0.8rem; color: #888;">교배 코드는 사용된 상태로 유지</span>
                        </button>
                        <button onclick="deleteSpirit(${spirit.id}, true); closeBreedDeleteModal();" style="padding: 12px; background: linear-gradient(135deg, #667eea, #764ba2); color: white; border: none; border-radius: 8px; cursor: pointer;">
                            🔄 코드 반환하고 보내기<br>
                            <span style="font-size: 0.85rem; opacity: 0.9;">교배 코드를 다시 사용 가능하게</span>
                        </button>
                        <button onclick="closeBreedDeleteModal();" style="padding: 10px; background: transparent; border: 1px solid var(--border); border-radius: 8px; cursor: pointer; color: #888;">
                            취소
                        </button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }
        
        function closeBreedDeleteModal() {
            const modal = document.getElementById('breedDeleteModal');
            if (modal) modal.remove();
        }

        function deleteSpirit(spiritId, returnBreedCode = false) {
            const spirit = spirits.find(s => s.id === spiritId);
            if (!spirit) return;
            
            // 교배 코드 반환 처리
            if (returnBreedCode && spirit.breedCode) {
                // 앨범에서도 해당 코드 사용 기록 제거
                if (collection) {
                    collection.forEach(s => {
                        if (s.breedCode === spirit.breedCode) {
                            delete s.breedCode;
                        }
                    });
                }
                showNotification('🔄 교배 코드가 반환되었습니다. 다시 사용 가능합니다!');
            }
            
            spirits = spirits.filter(s => s.id !== spiritId);
            saveGame();
            renderSpirits();
            showNotification('정령을 떠나보냈습니다');
        }

        function renderInventory() {
            // 먹이가 없으면 초기화
            if (!inventory.food) {
                inventory.food = [];
            }

            // 먹이 인벤토리 (순서 고정: fire, water, wind, earth, light, dark + 이벤트 아이템)
            const foodContainer = document.getElementById('foodInventory');
            if (inventory.food.length === 0) {
                foodContainer.innerHTML = '<div class="inventory-item">없음</div>';
            } else {
                const foodCounts = {};
                inventory.food.forEach(f => {
                    foodCounts[f] = (foodCounts[f] || 0) + 1;
                });
                const foodOrder = ['fire', 'water', 'wind', 'earth', 'light', 'dark', 'medicine'];
                let foodHTML = foodOrder
                    .filter(type => foodCounts[type])
                    .map(type => {
                        const icon = type === 'medicine' ? MEDICINE.icon : ENV_ICONS[type];
                        return `
                            <div class="inventory-item">
                                ${icon} ×${foodCounts[type]}
                            </div>
                        `;
                    }).join('');
                
                // 이벤트 먹이 아이템 추가
                Object.keys(foodCounts).forEach(key => {
                    if (EVENT_ITEMS[key] && EVENT_ITEMS[key].type === 'food') {
                        foodHTML += `
                            <div class="inventory-item" title="${EVENT_ITEMS[key].name}">
                                ${EVENT_ITEMS[key].icon} ×${foodCounts[key]}
                            </div>
                        `;
                    }
                });
                
                foodContainer.innerHTML = foodHTML || '<div class="inventory-item">없음</div>';
            }

            // 음악 인벤토리 (순서 고정: classic, jazz, rock, pop, ballad + 이벤트 아이템)
            const musicContainer = document.getElementById('musicInventory');
            if (!inventory.music) inventory.music = [];
            
            if (inventory.music.length === 0) {
                musicContainer.innerHTML = '<div class="inventory-item">없음</div>';
            } else {
                const musicCounts = {};
                inventory.music.forEach(m => {
                    musicCounts[m] = (musicCounts[m] || 0) + 1;
                });
                const musicOrder = ['classic', 'jazz', 'rock', 'pop', 'ballad'];
                let musicHTML = musicOrder
                    .filter(type => musicCounts[type])
                    .map(type => `
                        <div class="inventory-item">
                            ${MUSIC_TYPES[type].icon} ×${musicCounts[type]}
                        </div>
                    `).join('');
                
                // 이벤트 음악 아이템 추가
                Object.keys(musicCounts).forEach(key => {
                    if (EVENT_ITEMS[key] && EVENT_ITEMS[key].type === 'music') {
                        musicHTML += `
                            <div class="inventory-item" title="${EVENT_ITEMS[key].name}">
                                ${EVENT_ITEMS[key].icon} ×${musicCounts[key]}
                            </div>
                        `;
                    }
                });
                
                musicContainer.innerHTML = musicHTML || '<div class="inventory-item">없음</div>';
            }

            // 장식물 인벤토리 (등급별 표시 + 이벤트 아이템)
            const decorContainer = document.getElementById('decorInventory');
            if (!inventory.decorations) inventory.decorations = [];
            
            if (inventory.decorations.length === 0) {
                decorContainer.innerHTML = '<div class="inventory-item">없음</div>';
            } else {
                const decorCounts = {};
                inventory.decorations.forEach(d => {
                    decorCounts[d] = (decorCounts[d] || 0) + 1;
                });
                
                const decorHTML = Object.keys(decorCounts).map(key => {
                    // 일반 장식물 체크
                    const decoData = DECORATION_TYPES[key];
                    if (decoData) {
                        const qualityLabel = decoData.quality === 'epic' ? '⭐' : decoData.quality === 'rare' ? '💎' : '';
                        return `
                            <div class="inventory-item" title="${decoData.name} (${decoData.attr} +${decoData.power})">
                                ${qualityLabel}${decoData.icon} ×${decorCounts[key]}
                            </div>
                        `;
                    }
                    
                    // 이벤트 장식물 체크
                    const eventItem = EVENT_ITEMS[key];
                    if (eventItem && eventItem.type === 'decoration') {
                        return `
                            <div class="inventory-item" title="${eventItem.name}">
                                ${eventItem.icon} ×${decorCounts[key]}
                            </div>
                        `;
                    }
                    
                    return '';
                }).join('');
                
                decorContainer.innerHTML = decorHTML || '<div class="inventory-item">없음</div>';
            }
        }

        function manualCompleteSpirit(spiritId) {
            if (isPaused) {
                showNotification('게임이 일시정지 상태입니다');
                return;
            }
            
            const spirit = spirits.find(s => s.id === spiritId);
            if (!spirit) {
                showNotification('정령을 찾을 수 없습니다.');
                return;
            }
            
            if (spirit.growth >= 100 && !spirit.isCompleted) {
                try {
                    completeSpirit(spirit);
                    saveGame();
                    renderSpirits();
                    showNotification('✨ 정령이 진화합니다!');
                } catch (error) {
                    console.error('진화 오류:', error);
                    showNotification('진화 중 오류가 발생했습니다: ' + error.message);
                }
            } else {
                showNotification(`아직 진화할 수 없습니다. (성장도: ${Math.floor(spirit.growth)}/100)`);
            }
        }

        function completeSpirit(spirit) {
            // 이벤트 정령 별도 처리
            if (spirit.isEventSpirit && spirit.eventType) {
                const event = EVENT_TYPES[spirit.eventType];
                if (event) {
                    spirit.isCompleted = true;
                    
                    // 이로치 여부에 따라 다른 데이터 설정
                    const isShiny = spirit.isShiny && event.shiny;
                    const spiritName = isShiny ? event.shiny.name : event.name;
                    const spiritIcon = isShiny ? event.shiny.stages.adult : event.stages.adult;
                    const spiritDesc = isShiny ? event.shiny.desc : event.desc;
                    const eventTypeKey = isShiny ? `event_${spirit.eventType}_shiny` : `event_${spirit.eventType}`;
                    
                    spirit.evolutionData = {
                        type: eventTypeKey,
                        attributeType: event.attribute,
                        name: spiritName,
                        icon: spiritIcon,
                        desc: spiritDesc,
                        wingType: null,
                        isEvent: true,
                        isShiny: isShiny
                    };
                    
                    saveGame();
                    renderSpirits();
                    
                    if (isShiny) {
                        showNotification(`✨ ${spiritName}이(가) 완성되었습니다! 희귀한 정령이에요!`);
                    } else {
                        showNotification(`🎄 ${spiritName}이(가) 완성되었습니다! 육성 탭에서 확인해주세요.`);
                    }
                    return;
                }
            }
            
            // 교배 정령 전용 진화 (40% 확률)
            if (spirit.isBred && spirit.fusionType && FUSION_TYPES[spirit.fusionType]) {
                if (Math.random() < 0.4) {
                    const fusion = FUSION_TYPES[spirit.fusionType];
                    spirit.isCompleted = true;
                    
                    // 날개 타입 결정
                    if (!spirit.lightTime) spirit.lightTime = 0;
                    if (!spirit.darkTime) spirit.darkTime = 0;
                    let wingType = spirit.lightTime > spirit.darkTime ? 'butterfly' : 'moth';
                    
                    spirit.evolutionData = {
                        type: spirit.fusionType,
                        attributeType: spirit.fusionType,
                        name: fusion.name,
                        icon: fusion.icon,
                        desc: fusion.desc,
                        wingType: wingType,
                        isFusion: true,
                        fusionRarity: fusion.rarity
                    };
                    
                    // 도감 등록
                    if (!encyclopedia[spirit.fusionType]) {
                        encyclopedia[spirit.fusionType] = { firstSeen: new Date().toISOString(), count: 1 };
                        showNotification(`🎉 새로운 합성 정령 "${fusion.name}" 도감 등록!`);
                    } else {
                        encyclopedia[spirit.fusionType].count++;
                    }
                    
                    saveGame();
                    renderSpirits();
                    showNotification(`🧬 ${fusion.name}이(가) 완성되었습니다! 교배의 힘이 발현되었어요!`);
                    return;
                }
                // 40% 실패 시 일반 육성 진화로 진행 (아래 코드 계속)
            }
            
            // 스탯으로 진화 결정
            const params = spirit.parameters;
            const maxStat = Math.max(params.intelligence, params.strength, params.charm);
            
            // 노멀 진화 체크 (모든 스탯이 20 미만)
            // 하지만 속성이 있으면 속성 진화 가능
            const hasLowStats = maxStat < 20;
            
            // 스탯 계열 결정 (20 이상인 경우만)
            let statType = '';
            let evolutionKey = '';
            
            if (!hasLowStats) {
                // 현자 체크 (모든 스탯 100)
                if (params.intelligence >= 100 && params.strength >= 100 && params.charm >= 100) {
                    statType = 'sage';
                    evolutionKey = 'sage';
                } else {
                    // 최고 스탯 결정 (동점 시 랜덤)
                    const maxStats = [];
                    if (params.intelligence === maxStat) maxStats.push('intelligent');
                    if (params.strength === maxStat) maxStats.push('strong');
                    if (params.charm === maxStat) maxStats.push('beautiful');
                    
                    // 동점인 스탯 중 랜덤 선택
                    statType = maxStats[Math.floor(Math.random() * maxStats.length)];

                    // 진화 단계 결정 (스탯 수치 기준)
                    if (maxStat >= 80) {
                        evolutionKey = `${statType}-high`;  // 80+ : 세상의~
                    } else if (maxStat >= 50) {
                        evolutionKey = `${statType}-mid`;  // 50-79 : 지적인/강한/아름다운
                    } else {
                        evolutionKey = `${statType}-low`;  // 20-49 : 똑똑한/튼튼한/귀여운
                    }
                }
            }

            // 속성 분석 (먹이 50% + 테라리움 50%)
            const foodAttrs = spirit.hiddenAttributes || { fire: 0, water: 0, wind: 0, earth: 0, light: 0, dark: 0 };
            const terrariumAttrs = terrarium || { fire: 0, water: 0, wind: 0, earth: 0, light: 0, dark: 0 };
            
            // 최종 속성 = (먹이 속성 × 0.7) + (테라리움 속성 × 0.3)
            const finalAttrs = {};
            for (let attr in foodAttrs) {
                finalAttrs[attr] = (foodAttrs[attr] * 0.7) + (terrariumAttrs[attr] * 0.3);
            }
            
            const sortedAttrs = Object.entries(finalAttrs)
                .sort((a, b) => b[1] - a[1]); // 내림차순 정렬
            
            // 최고 속성값
            const maxAttrValue = sortedAttrs[0][1];
            
            let attributeKey = '';
            let attributeData = null;
            
            if (maxAttrValue < 50) {
                // 모든 속성이 50 미만 - 백의 정령
                attributeKey = 'normal';
                attributeData = { name: '백의 정령', icon: '🤍', desc: '속성이 깃들지 않은 순수한 정령.' };
            } else {
                // 50 이상인 속성들만 필터링
                const significantAttrs = sortedAttrs.filter(([_, value]) => value >= 50);
                
                if (significantAttrs.length === 1) {
                    // 단일 속성 (하나만 60 이상)
                    attributeKey = significantAttrs[0][0];
                    attributeData = ATTRIBUTE_NAMES[attributeKey];
                    if (!attributeData) {
                        console.error('Missing ATTRIBUTE_NAMES for:', attributeKey);
                        // 가장 높은 단일 속성으로 폴백
                        attributeKey = sortedAttrs[0][0];
                        attributeData = ATTRIBUTE_NAMES[attributeKey] || ATTRIBUTE_NAMES['fire'];
                    }
                } else if (significantAttrs.length === 2) {
                    // 2속성: 1위와 2위 차이가 40% 이하면 조합, 초과면 단일
                    const first = significantAttrs[0][1];
                    const second = significantAttrs[1][1];
                    const diffPercent = ((first - second) / first) * 100;
                    
                    if (diffPercent <= 40) {
                        // 2속성 조합
                        const attr1 = significantAttrs[0][0];
                        const attr2 = significantAttrs[1][0];
                        const comboKey = [attr1, attr2].sort().join('-');
                        attributeData = ATTRIBUTE_NAMES[comboKey];
                        attributeKey = comboKey;
                        if (!attributeData) {
                            console.error('Missing ATTRIBUTE_NAMES for combo:', comboKey);
                            // 조합이 없으면 1순위 단일 속성으로 폴백
                            attributeKey = attr1;
                            attributeData = ATTRIBUTE_NAMES[attr1] || ATTRIBUTE_NAMES['fire'];
                        }
                    } else {
                        // 단일 속성 (차이가 너무 큼)
                        attributeKey = significantAttrs[0][0];
                        attributeData = ATTRIBUTE_NAMES[attributeKey];
                        if (!attributeData) {
                            console.error('Missing ATTRIBUTE_NAMES for:', attributeKey);
                            // 가장 높은 속성으로 폴백
                            attributeKey = sortedAttrs[0][0];
                            attributeData = ATTRIBUTE_NAMES[attributeKey] || ATTRIBUTE_NAMES['fire'];
                        }
                    }
                } else if (significantAttrs.length >= 3) {
                    // 3속성 이상
                    const topValues = significantAttrs.slice(0, 3).map(a => a[1]);
                    const maxVal = Math.max(...topValues);
                    const minVal = Math.min(...topValues);
                    const diffPercent = ((maxVal - minVal) / maxVal) * 100;
                    
                    if (diffPercent <= 25) {
                        // 조화 (차이 25% 이하)
                        attributeKey = 'balanced';
                        attributeData = ATTRIBUTE_NAMES['balanced'];
                    } else {
                        // 혼돈 (차이 25% 초과)
                        attributeKey = 'multi';
                        attributeData = ATTRIBUTE_NAMES['multi'];
                    }
                    if (!attributeData) {
                        console.error('Missing ATTRIBUTE_NAMES for:', attributeKey);
                        // 가장 높은 단일 속성으로 폴백
                        attributeKey = significantAttrs[0][0];
                        attributeData = ATTRIBUTE_NAMES[attributeKey] || ATTRIBUTE_NAMES['fire'];
                    }
                }
            }
            
            // 최종 이름과 아이콘 조합
            let finalName = '';
            let finalIcon = '';
            let finalDesc = '';
            
            // 날개 타입 먼저 결정 (티타니아/오베론 판정에 필요)
            if (!spirit.lightTime) spirit.lightTime = 0;
            if (!spirit.darkTime) spirit.darkTime = 0;
            
            let wingType = null;
            if (spirit.lightTime > spirit.darkTime) {
                wingType = 'butterfly';
            } else if (spirit.darkTime > spirit.lightTime) {
                wingType = 'moth';
            } else {
                wingType = 'butterfly'; // 동점이면 나비
            }
            
            // 티타니아/오베론 조건 체크
            // 모든 스탯 70 이상 + 모든 속성 100 근접 (90 이상)
            const isPerfectStats = params.intelligence >= 70 && params.strength >= 70 && params.charm >= 70;
            const isPerfectAttributes = Object.values(finalAttrs).every(val => val >= 90);
            
            if (isPerfectStats && isPerfectAttributes) {
                // 완벽한 정령 - 티타니아/오베론
                if (wingType === 'butterfly') {
                    finalName = '티타니아';
                    finalIcon = '🦋✨';
                    finalDesc = '모든 힘을 완벽히 갖춘 나비의 여왕. 빛과 생명을 관장하는 전설적 존재.';
                } else {
                    finalName = '오베론';
                    finalIcon = '🦋🌙';
                    finalDesc = '모든 힘을 완벽히 갖춘 나방의 군주. 어둠과 신비를 지배하는 전설적 존재.';
                }
            } else if (attributeKey === 'normal') {
                // 속성 없음
                if (hasLowStats) {
                    // 스탯도 낮음 - 순수한 백의 정령
                    if (attributeData) {
                        finalName = attributeData.name;
                        finalIcon = attributeData.icon;
                        finalDesc = attributeData.desc;
                    } else {
                        finalName = '백의 정령';
                        finalIcon = '🤍';
                        finalDesc = '속성이 깃들지 않은 순수한 정령.';
                    }
                } else {
                    // 스탯은 높음 - "스탯 계열 + 백의 정령"
                    const evolution = EVOLUTION_TYPES[evolutionKey];
                    if (evolution && attributeData) {
                        finalName = `${evolution.prefix} ${attributeData.name}`;
                        finalIcon = `${evolution.icon}${attributeData.icon}`;
                        finalDesc = attributeData.desc;
                    } else if (evolution) {
                        // evolution은 있는데 attributeData가 없으면 백의 정령 사용
                        finalName = `${evolution.prefix} 백의 정령`;
                        finalIcon = `${evolution.icon}🤍`;
                        finalDesc = '속성이 깃들지 않은 순수한 정령.';
                    } else {
                        finalName = '백의 정령';
                        finalIcon = '🤍';
                        finalDesc = '속성이 깃들지 않은 순수한 정령.';
                    }
                }
            } else if (hasLowStats) {
                // 스탯 부족하지만 속성 있음 - 속성 이름만
                if (attributeData) {
                    finalName = attributeData.name;
                    finalIcon = attributeData.icon;
                    finalDesc = attributeData.desc;
                } else {
                    console.error('attributeData is undefined for key:', attributeKey);
                    // 가장 높은 단일 속성으로 폴백
                    const fallbackKey = sortedAttrs[0][0];
                    const fallbackData = ATTRIBUTE_NAMES[fallbackKey] || ATTRIBUTE_NAMES['fire'];
                    finalName = fallbackData.name;
                    finalIcon = fallbackData.icon;
                    finalDesc = fallbackData.desc;
                    attributeKey = fallbackKey;
                }
            } else {
                // 스탯도 있고 속성도 있음 - "스탯 계열 + 속성 이름" 형태
                const evolution = EVOLUTION_TYPES[evolutionKey];
                if (evolution && attributeData) {
                    finalName = `${evolution.prefix} ${attributeData.name}`;
                    finalIcon = `${evolution.icon}${attributeData.icon}`;
                    finalDesc = attributeData.desc;
                } else {
                    console.error('Evolution data missing:', { evolutionKey, attributeKey, evolution, attributeData });
                    // 폴백: 가장 높은 속성으로 진화
                    const fallbackKey = sortedAttrs[0][0];
                    const fallbackData = ATTRIBUTE_NAMES[fallbackKey] || ATTRIBUTE_NAMES['fire'];
                    const fallbackEvolution = EVOLUTION_TYPES[evolutionKey] || EVOLUTION_TYPES['intelligent-mid'];
                    if (fallbackEvolution && fallbackData) {
                        finalName = `${fallbackEvolution.prefix} ${fallbackData.name}`;
                        finalIcon = `${fallbackEvolution.icon}${fallbackData.icon}`;
                        finalDesc = fallbackData.desc;
                    } else {
                        finalName = fallbackData.name;
                        finalIcon = fallbackData.icon;
                        finalDesc = fallbackData.desc;
                    }
                    attributeKey = fallbackKey;
                }
            }
            
            // evolutionKey 설정 (도감 등록용)
            let finalEvolutionType = evolutionKey;
            if (isPerfectStats && isPerfectAttributes) {
                // 티타니아/오베론
                finalEvolutionType = wingType === 'butterfly' ? 'titania' : 'oberon';
            } else if (hasLowStats) {
                // 스탯 부족한 경우
                if (attributeKey === 'normal') {
                    finalEvolutionType = 'nostat';  // 스탯 낮고 속성도 없음 -> nostat-normal
                } else {
                    finalEvolutionType = 'nostat';  // 스탯 낮고 속성 있음 -> nostat-fire 등
                }
            } else if (attributeKey === 'normal') {
                // 스탯은 높은데 속성 없음 -> intelligent-high-normal 같은 형태 유지
                finalEvolutionType = evolutionKey;
            }
            
            // 정령을 완성 상태로 표시 (아직 제거하지 않음)
            spirit.isCompleted = true;
            spirit.evolutionData = {
                type: finalEvolutionType,
                attributeType: attributeKey,
                name: finalName,
                icon: finalIcon,
                desc: finalDesc,
                wingType: wingType
            };
            
            saveGame();
            renderSpirits();
            showNotification('🎉 정령이 성장을 완료했습니다! 육성 탭에서 확인해주세요.');
        }
        
        function confirmEvolution(spiritId) {
            const spirit = spirits.find(s => s.id === spiritId);
            if (!spirit || !spirit.isCompleted) {
                console.log('confirmEvolution failed:', { spirit, spiritId, isCompleted: spirit?.isCompleted });
                return;
            }
            
            const evolutionData = spirit.evolutionData;
            console.log('Evolution data:', evolutionData);
            
            const affection = spirit.parameters.affection || 0;
            
            // 애정도별 엔딩 메시지
            let endingMessage = '';
            
            if (affection >= 150) {
                endingMessage = `${spirit.name}은(는) 당신에게 "ㅁㅁㅁㅁ"라는 말을 남기고 떠납니다.\n\n정령어 사전을 찾아보면 그 말은 "사랑해요"라는 의미입니다.`;
            } else if (affection >= 100) {
                endingMessage = `${spirit.name}은(는) 당신의 뺨에 입맞춤을 남기고 떠납니다.`;
            } else if (affection >= 50) {
                endingMessage = `${spirit.name}은(는) 당신에게 감사의 인사를 남기고 떠납니다.`;
            } else {
                endingMessage = `${spirit.name}이(가) 떠나갑니다.`;
            }
            
            showConfirm(
                '정령 완성',
                endingMessage,
                () => {
                    // 앨범에 추가
                collection.push({
                    id: `album-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`, // 고유 ID
                    type: evolutionData.type,
                    attributeType: evolutionData.attributeType,
                    name: evolutionData.name,
                    icon: evolutionData.icon,
                    desc: evolutionData.desc,
                    parameters: { ...spirit.parameters },
                    hiddenAttributes: { ...spirit.hiddenAttributes },
                    originalName: spirit.name,
                    wingType: evolutionData.wingType,
                    lightTime: spirit.lightTime,
                    darkTime: spirit.darkTime,
                    completedAt: Date.now(),
                    // 이벤트 정령 정보 저장
                    isEventSpirit: spirit.isEventSpirit || false,
                    eventType: spirit.eventType || null
                });
                
                // 도감에 등록 (진화 타입별 카운트)
                let encyclopediaKey;
                if (evolutionData.type === 'titania' || evolutionData.type === 'oberon') {
                    // 전설적 존재는 고유 키 사용
                    encyclopediaKey = evolutionData.type;
                } else if (evolutionData.type === 'nostat') {
                    // 수식어 없는 정령
                    encyclopediaKey = `nostat-${evolutionData.attributeType}`;
                } else if (evolutionData.type && evolutionData.type.startsWith('event_')) {
                    // 이벤트 정령은 타입 그대로 사용
                    encyclopediaKey = evolutionData.type;
                } else {
                    // 일반 정령 (스탯-레벨-속성)
                    encyclopediaKey = `${evolutionData.type}-${evolutionData.attributeType}`;
                }
                
                if (!encyclopedia[encyclopediaKey]) {
                    encyclopedia[encyclopediaKey] = 0;
                }
                encyclopedia[encyclopediaKey]++;
                
                console.log('도감 등록:', encyclopediaKey, '카운트:', encyclopedia[encyclopediaKey]);
                
                // 코인 보상 (25코인)
                coins += 25;
                
                // 정령 제거
                spirits = spirits.filter(s => s.id !== spiritId);
                saveGame();
                updateCoinDisplay();
                
                // 자동 로컬 백업 (최근 10개 유지)
                try {
                    const backups = JSON.parse(localStorage.getItem('spiritGarden_autoBackups') || '[]');
                    backups.unshift({
                        timestamp: Date.now(),
                        collection: [...collection],
                        encyclopedia: {...encyclopedia}
                    });
                    // 최근 10개만 유지
                    if (backups.length > 10) backups.length = 10;
                    localStorage.setItem('spiritGarden_autoBackups', JSON.stringify(backups));
                } catch (e) {
                    console.warn('자동 백업 실패:', e);
                }
                
                    renderSpirits();
                    showNotification(`${evolutionData.icon} ${spirit.name}이(가) ${evolutionData.name}(으)로 앨범에 등록되었습니다 (+25💰)`);
                    
                    // 첫 번째 정령 완성 시 두 번째 튜토리얼 시작
                    if (collection.length === 1 && !localStorage.getItem('spiritGarden_tutorial2Seen')) {
                        setTimeout(() => {
                            startTutorial2();
                        }, 1500);
                    }
                }
            );
        }

        function showAlbumDetail(index) {
            const item = collection[index];
            if (!item) return;
            
            // 튜토리얼2: 앨범 상세 열기 액션 체크
            checkTutorialAction('openAlbumDetail');
            
            const modal = document.getElementById('albumDetailModal');
            const modalTitle = document.getElementById('modalTitle');
            const modalContent = document.getElementById('modalContent');
            
            // 최신 z-index 적용
            modal.style.zIndex = getNextZIndex();
            
            modalTitle.textContent = item.name;
            
            // 날개 정보
            let wingInfo = '';
            if (item.wingType === 'butterfly') {
                wingInfo = '🦋 나비의 날개';
            } else if (item.wingType === 'moth') {
                wingInfo = '🦋 나방의 날개';
            }
            
            // 조명 시간 계산
            const lightMinutes = Math.floor((item.lightTime || 0) / 60);
            const darkMinutes = Math.floor((item.darkTime || 0) / 60);
            
            // 숨겨진 속성 정보
            const hiddenAttrs = item.hiddenAttributes || { fire: 0, water: 0, wind: 0, earth: 0, light: 0, dark: 0 };
            
            // 애정도 체크
            const affection = item.parameters?.affection || 0;
            const canBreed = affection >= 50;
            
            modalContent.innerHTML = `
                <div style="text-align: center; margin-bottom: 20px;">
                    <div style="font-size: 4rem; margin-bottom: 10px;">${item.icon}${wingInfo ? '🦋' : ''}</div>
                    <div style="font-size: 0.9rem; color: #888;">본명: ${item.originalName || '이름 없음'}</div>
                    ${wingInfo ? `<div style="font-size: 0.9rem; color: #888; margin-top: 4px;">${wingInfo}</div>` : ''}
                    ${item.desc ? `<div style="font-size: 0.9rem; color: #888; margin-top: 8px; line-height: 1.4; font-style: italic;">"${item.desc}"</div>` : ''}
                </div>
                
                <div style="background: var(--bg); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                    <h3 style="font-size: 1rem; margin-bottom: 10px; color: var(--text);">📊 기본 스탯</h3>
                    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px;">
                        <div class="param">🧠 지력: ${item.parameters.intelligence}</div>
                        <div class="param">💪 체력: ${item.parameters.strength}</div>
                        <div class="param">💖 매력: ${item.parameters.charm}</div>
                        <div class="param">❤️ 애정도: ${affection}</div>
                    </div>
                </div>
                
                <div style="background: var(--bg); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                    <h3 style="font-size: 1rem; margin-bottom: 10px; color: var(--text);">🌈 숨겨진 속성</h3>
                    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px;">
                        <div style="font-size: 0.85rem; padding: 8px; background: var(--card); border-radius: 4px;">🔥 화: ${hiddenAttrs.fire}</div>
                        <div style="font-size: 0.85rem; padding: 8px; background: var(--card); border-radius: 4px;">💧 수: ${hiddenAttrs.water}</div>
                        <div style="font-size: 0.85rem; padding: 8px; background: var(--card); border-radius: 4px;">🌬️ 풍: ${hiddenAttrs.wind}</div>
                        <div style="font-size: 0.85rem; padding: 8px; background: var(--card); border-radius: 4px;">🌱 지: ${hiddenAttrs.earth}</div>
                        <div style="font-size: 0.85rem; padding: 8px; background: var(--card); border-radius: 4px;">✨ 빛: ${hiddenAttrs.light}</div>
                        <div style="font-size: 0.85rem; padding: 8px; background: var(--card); border-radius: 4px;">🌙 암: ${hiddenAttrs.dark}</div>
                    </div>
                </div>
                
                <div style="background: var(--bg); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                    <h3 style="font-size: 1rem; margin-bottom: 10px; color: var(--text);">⏱️ 육성 정보</h3>
                    <div style="font-size: 0.85rem; line-height: 1.6;">
                        <div>☀️ 빛 시간: ${lightMinutes}분</div>
                        <div>🌙 어둠 시간: ${darkMinutes}분</div>
                        <div style="margin-top: 8px; color: #888;">등록 날짜: ${new Date(item.completedAt).toLocaleString('ko-KR')}</div>
                    </div>
                </div>
                
                <!-- 교배 섹션 -->
                <div id="breedSection" style="background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1)); padding: 15px; border-radius: 8px; border: 1px solid rgba(102, 126, 234, 0.3);">
                    <h3 style="font-size: 1rem; margin-bottom: 10px; color: var(--text);">🧬 교배</h3>
                    ${canBreed ? `
                        <p style="font-size: 0.85rem; color: #888; margin-bottom: 12px;">이 정령의 코드를 공유해 다른 정령과 교배할 수 있어요.</p>
                        <div style="display: flex; gap: 8px;">
                            <button onclick="openBreedCodeModal(${index})" style="flex: 1; padding: 10px; background: linear-gradient(135deg, #667eea, #764ba2); color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.9rem;">
                                📤 코드 생성
                            </button>
                            <button onclick="openBreedWithCodeModal(${index})" style="flex: 1; padding: 10px; background: linear-gradient(135deg, #11998e, #38ef7d); color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.9rem;">
                                📥 교배하기
                            </button>
                        </div>
                    ` : `
                        <p style="font-size: 0.85rem; color: #e74c3c;">❤️ 애정도 50 이상이어야 교배할 수 있습니다. (현재: ${affection})</p>
                    `}
                </div>
            `;
            
            modal.style.display = 'flex';
        }
        
        // 교배 코드 생성 모달
        function openBreedCodeModal(albumIndex) {
            const item = collection[albumIndex];
            if (!item) return;
            
            // 앨범 아이템에 id가 없으면 생성
            const spiritForCode = {
                ...item,
                id: item.id || `album-${albumIndex}`,
                attributes: item.hiddenAttributes || {},
                albumIndex: albumIndex  // 자기 자신 교배 방지용
            };
            
            const code = encodeSpiritData(spiritForCode);
            
            const modal = document.createElement('div');
            modal.id = 'breedCodeModal';
            const zIndex = getNextZIndex();
            modal.style.cssText = `position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: ${zIndex}; display: flex; justify-content: center; align-items: center;`;
            modal.innerHTML = `
                <div style="background: var(--card); padding: 24px; border-radius: 12px; max-width: 400px; width: 90%; border: 1px solid var(--border);">
                    <h3 style="margin-bottom: 16px;">📤 교배 코드 생성</h3>
                    <div style="text-align: center; margin-bottom: 16px;">
                        <div style="font-size: 2.5rem;">${item.icon}</div>
                        <div style="font-weight: 700;">${item.name}</div>
                    </div>
                    <div style="margin-bottom: 12px;">
                        <input type="text" id="generatedBreedCode" value="${code}" readonly style="width: 100%; padding: 10px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg); color: var(--text); font-family: monospace; font-size: 0.8rem; box-sizing: border-box;">
                    </div>
                    <button onclick="copyGeneratedCode()" style="width: 100%; padding: 12px; background: var(--water); color: white; border: none; border-radius: 6px; cursor: pointer; margin-bottom: 8px;">
                        📋 코드 복사
                    </button>
                    <p style="font-size: 0.8rem; color: #888; text-align: center; margin-bottom: 12px;">📋 코드는 1회만 사용 가능합니다</p>
                    <button onclick="closeBreedCodeModal()" style="width: 100%; padding: 10px; background: var(--card); border: 1px solid var(--border); border-radius: 6px; cursor: pointer;">
                        닫기
                    </button>
                </div>
            `;
            document.body.appendChild(modal);
        }
        
        function copyGeneratedCode() {
            const input = document.getElementById('generatedBreedCode');
            input.select();
            document.execCommand('copy');
            showNotification('📋 코드가 복사되었습니다!');
        }
        
        function closeBreedCodeModal() {
            const modal = document.getElementById('breedCodeModal');
            if (modal) modal.remove();
        }
        
        // 교배하기 모달
        function openBreedWithCodeModal(albumIndex) {
            const item = collection[albumIndex];
            if (!item) return;
            
            const modal = document.createElement('div');
            modal.id = 'breedWithCodeModal';
            const zIndex = getNextZIndex();
            modal.style.cssText = `position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: ${zIndex}; display: flex; justify-content: center; align-items: center;`;
            modal.innerHTML = `
                <div style="background: var(--card); padding: 24px; border-radius: 12px; max-width: 450px; width: 90%; max-height: 80vh; overflow-y: auto; border: 1px solid var(--border);">
                    <h3 style="margin-bottom: 16px;">정령 코드로 교배</h3>
                    <div style="display: flex; align-items: center; gap: 12px; padding: 12px; background: var(--bg); border-radius: 8px; margin-bottom: 16px;">
                        <div style="font-size: 2rem;">${item.icon}</div>
                        <div>
                            <div style="font-weight: 700;">${item.name}</div>
                            <div style="font-size: 0.85rem; color: #888;">내 정령</div>
                        </div>
                    </div>
                    <div style="margin-bottom: 12px;">
                        <input type="text" id="friendBreedCodeInput" placeholder="정령 코드 입력..." style="width: 100%; padding: 12px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg); color: var(--text); font-family: monospace; box-sizing: border-box;">
                    </div>
                    <div id="friendBreedPreview" style="display: none; padding: 12px; background: var(--bg); border-radius: 8px; margin-bottom: 12px;"></div>
                    <div id="breedResultPreview" style="display: none; padding: 12px; background: linear-gradient(135deg, rgba(255,215,0,0.1), rgba(255,255,255,0.05)); border-radius: 8px; margin-bottom: 12px; text-align: center;"></div>
                    <button onclick="executeBreedFromAlbum(${albumIndex})" style="width: 100%; padding: 12px; background: linear-gradient(135deg, #667eea, #764ba2); color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 1rem; margin-bottom: 8px;">
                        🧬 교배하기 (50💰)
                    </button>
                    <p style="font-size: 0.8rem; color: #888; text-align: center; margin-bottom: 12px;">내 정령은 유지되고, 새로운 알이 태어납니다!</p>
                    <button onclick="closeBreedWithCodeModal()" style="width: 100%; padding: 10px; background: var(--card); border: 1px solid var(--border); border-radius: 6px; cursor: pointer;">
                        닫기
                    </button>
                </div>
            `;
            document.body.appendChild(modal);
            
            // 코드 입력 이벤트 리스너
            setTimeout(() => {
                const input = document.getElementById('friendBreedCodeInput');
                if (input) {
                    input.addEventListener('input', () => updateBreedPreviewInModal(albumIndex));
                }
            }, 100);
        }
        
        function closeBreedWithCodeModal() {
            const modal = document.getElementById('breedWithCodeModal');
            if (modal) modal.remove();
        }
        
        function updateBreedPreviewInModal(albumIndex) {
            const item = collection[albumIndex];
            const codeInput = document.getElementById('friendBreedCodeInput');
            const friendPreview = document.getElementById('friendBreedPreview');
            const resultPreview = document.getElementById('breedResultPreview');
            
            const code = codeInput.value.trim();
            if (!code) {
                friendPreview.style.display = 'none';
                resultPreview.style.display = 'none';
                return;
            }
            
            const friendData = decodeSpiritData(code);
            if (!friendData) {
                friendPreview.innerHTML = '❌ 유효하지 않은 코드입니다.';
                friendPreview.style.display = 'block';
                friendPreview.style.color = '#e74c3c';
                resultPreview.style.display = 'none';
                return;
            }
            
            // 자기 자신 체크 - 고유 ID 비교 (ID가 있으면 ID로, 없으면 스탯 비교)
            const isSameSpirit = (myItem, friend) => {
                // 둘 다 ID가 있으면 ID로 비교
                if (myItem.id && friend.id) {
                    return myItem.id === friend.id;
                }
                // ID가 없으면 핵심 데이터로 비교 (하위 호환성)
                return myItem.name === friend.name &&
                       (myItem.originalName || myItem.name) === (friend.originalName || friend.name) &&
                       (myItem.attributeType || myItem.attribute) === friend.attribute &&
                       (myItem.parameters?.intelligence || 0) === (friend.parameters?.intelligence || 0) &&
                       (myItem.parameters?.strength || 0) === (friend.parameters?.strength || 0) &&
                       (myItem.parameters?.charm || 0) === (friend.parameters?.charm || 0);
            };
            
            if (isSameSpirit(item, friendData)) {
                friendPreview.innerHTML = '❌ 자기 자신과는 교배할 수 없습니다.';
                friendPreview.style.display = 'block';
                friendPreview.style.color = '#e74c3c';
                resultPreview.style.display = 'none';
                return;
            }
            
            const attr = ATTRIBUTE_NAMES[friendData.attribute] || ATTRIBUTE_NAMES.normal;
            const friendAttrs = friendData.attributes || {};
            const attrDisplay = [];
            ['fire', 'water', 'wind', 'earth', 'light', 'dark'].forEach(a => {
                if (friendAttrs[a] && friendAttrs[a] > 0) {
                    attrDisplay.push(`${ENV_ICONS[a]}${friendAttrs[a]}`);
                }
            });
            
            const originalNameDisplay = (friendData.originalName && friendData.originalName !== friendData.name) 
                ? `<div style="color: #aaa; font-size: 0.8rem; font-style: italic;">본명: ${friendData.originalName}</div>` 
                : '';
            
            friendPreview.innerHTML = `
                <div style="display: flex; align-items: center; gap: 12px;">
                    <div style="font-size: 2rem;">${attr.icon}</div>
                    <div style="flex: 1;">
                        <div style="font-weight: 700;">✅ ${friendData.name}</div>
                        ${originalNameDisplay}
                        <div style="font-size: 0.85rem; color: #888;">${attr.name}</div>
                        <div style="font-size: 0.85rem; margin-top: 4px;">
                            🧠${friendData.parameters.intelligence} | 💪${friendData.parameters.strength} | 💖${friendData.parameters.charm}
                        </div>
                        ${attrDisplay.length > 0 ? `<div style="font-size: 0.8rem; margin-top: 4px;">${attrDisplay.join(' ')}</div>` : ''}
                    </div>
                </div>
            `;
            friendPreview.style.display = 'block';
            friendPreview.style.color = 'var(--text)';
            
            // 예상 결과 계산
            const mySpirit = {
                ...item,
                attributes: item.hiddenAttributes || {}
            };
            const prediction = predictBreedResult(mySpirit, friendData);
            
            // 예상 상속 스탯
            const inheritParams = {
                intelligence: Math.floor(((item.parameters?.intelligence || 0) + (friendData.parameters?.intelligence || 0)) / 2),
                strength: Math.floor(((item.parameters?.strength || 0) + (friendData.parameters?.strength || 0)) / 2),
                charm: Math.floor(((item.parameters?.charm || 0) + (friendData.parameters?.charm || 0)) / 2)
            };
            
            resultPreview.innerHTML = `
                <div style="font-size: 0.85rem; color: #888; margin-bottom: 8px;">🥚 예상 결과</div>
                <div style="font-size: 2rem;">${prediction.icon}</div>
                <div style="font-weight: 700; margin: 4px 0;">${prediction.name}</div>
                <div style="font-size: 0.8rem; color: ${getRarityColor(prediction.rarity)}; margin-bottom: 8px;">${getRarityText(prediction.rarity)}</div>
                <div style="font-size: 0.8rem; color: #888;">
                    📊 상속 스탯: 🧠${inheritParams.intelligence} | 💪${inheritParams.strength} | 💖${inheritParams.charm}
                </div>
            `;
            resultPreview.style.display = 'block';
        }
        
        async function executeBreedFromAlbum(albumIndex) {
            const item = collection[albumIndex];
            if (!item) return;
            
            const codeInput = document.getElementById('friendBreedCodeInput');
            const breedCode = codeInput.value.trim();
            
            if (!breedCode) {
                showNotification('❌ 정령 코드를 입력해주세요');
                return;
            }
            
            // 정령 슬롯 체크
            if (spirits.length >= 6) {
                showNotification('❌ 정원이 가득 찼습니다! (최대 6마리)');
                return;
            }
            
            // 중복 코드 체크
            const allSpiritsAndAlbum = [...spirits, ...(collection || [])];
            const usedCode = allSpiritsAndAlbum.find(s => s.breedCode === breedCode);
            if (usedCode) {
                showNotification('❌ 이미 사용된 정령 코드입니다!');
                return;
            }
            
            const friendData = decodeSpiritData(breedCode);
            if (!friendData) {
                showNotification('❌ 유효하지 않은 코드입니다');
                return;
            }
            
            // 자기 자신과 교배 방지 - 고유 ID 비교
            const isSameSpirit = (myItem, friend) => {
                // 둘 다 ID가 있으면 ID로 비교
                if (myItem.id && friend.id) {
                    return myItem.id === friend.id;
                }
                // ID가 없으면 핵심 데이터로 비교 (하위 호환성)
                return myItem.name === friend.name &&
                       (myItem.originalName || myItem.name) === (friend.originalName || friend.name) &&
                       (myItem.attributeType || myItem.attribute) === friend.attribute &&
                       (myItem.parameters?.intelligence || 0) === (friend.parameters?.intelligence || 0) &&
                       (myItem.parameters?.strength || 0) === (friend.parameters?.strength || 0) &&
                       (myItem.parameters?.charm || 0) === (friend.parameters?.charm || 0);
            };
            
            if (isSameSpirit(item, friendData)) {
                showNotification('❌ 자기 자신과는 교배할 수 없습니다!');
                return;
            }
            
            if (coins < BREED_COST) {
                showNotification(`❌ 코인이 부족합니다 (필요: ${BREED_COST}💰)`);
                return;
            }
            
            const mySpirit = {
                ...item,
                attributes: item.hiddenAttributes || {}
            };
            const prediction = predictBreedResult(mySpirit, friendData);
            
            // 먼저 모든 창 닫기
            closeBreedWithCodeModal();
            closeAlbumDetail();
            
            const confirmed = await showConfirm('교배 확인',
                `${item.name}와(과) ${friendData.name}을(를) 교배하시겠습니까?\n\n예상 결과: ${prediction.name} (${getRarityText(prediction.rarity)})\n비용: ${BREED_COST}💰`);
            
            if (!confirmed) return;
            
            // 교배 결과 계산
            const newParams = {
                intelligence: Math.floor(((item.parameters?.intelligence || 0) + (friendData.parameters?.intelligence || 0)) / 2),
                strength: Math.floor(((item.parameters?.strength || 0) + (friendData.parameters?.strength || 0)) / 2),
                charm: Math.floor(((item.parameters?.charm || 0) + (friendData.parameters?.charm || 0)) / 2),
                affection: 0
            };
            
            const myAttrs = item.hiddenAttributes || {};
            const friendAttrs = friendData.attributes || {};
            const newAttrs = {};
            ['fire', 'water', 'wind', 'earth', 'light', 'dark'].forEach(attr => {
                const avg = Math.floor(((myAttrs[attr] || 0) + (friendAttrs[attr] || 0)) / 2);
                if (avg > 0) newAttrs[attr] = avg;
            });
            
            const isFusionType = prediction.key && FUSION_TYPES[prediction.key];
            const isEventResult = prediction.isEventResult && prediction.eventType;
            
            const timestamp = new Date().toLocaleString('ko-KR', {
                month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit'
            });
            
            const inheritInfo = [];
            if (newParams.intelligence > 0) inheritInfo.push(`🧠${newParams.intelligence}`);
            if (newParams.strength > 0) inheritInfo.push(`💪${newParams.strength}`);
            if (newParams.charm > 0) inheritInfo.push(`💖${newParams.charm}`);
            const attrInfo = Object.entries(newAttrs).map(([k, v]) => `${ENV_ICONS[k]}${v}`).join(' ');
            
            let newSpirit;
            
            if (isEventResult) {
                // 이벤트 정령 교배 결과
                const event = EVENT_TYPES[prediction.eventType];
                newSpirit = {
                    id: Date.now(),
                    name: event.name,
                    originalName: event.name,
                    growth: 0,
                    parameters: newParams,
                    hiddenAttributes: {
                        fire: 0, water: 0, wind: 0, earth: 0, light: 0, dark: 0
                    },
                    satisfaction: 'mid',
                    lastFed: null,
                    lastMusic: null,
                    lastPat: null,
                    lastDecorate: null,
                    lastInteraction: Date.now(),
                    status: '특별한 알이 빛나고 있습니다...',
                    birthTime: Date.now(),
                    logs: [
                        { time: timestamp, message: `🎄 ${item.name}와(과) ${friendData.name}의 교배로 특별한 알이 태어났습니다!` },
                        { time: timestamp, message: `📊 부모에게서 물려받은 능력: ${inheritInfo.join(' ')}` }
                    ],
                    lightTime: 0,
                    darkTime: 0,
                    musicListened: 0,
                    feedCount: 0,
                    bredWith: friendData.name,
                    breedCode: breedCode,
                    isBred: true,
                    isEventSpirit: true,
                    eventType: prediction.eventType
                };
            } else {
                // 일반 교배 결과
                newSpirit = {
                    id: Date.now(),
                    name: isFusionType ? prediction.name : generateSpiritName(),
                    originalName: null,
                    growth: 0,
                    parameters: newParams,
                    hiddenAttributes: {
                        fire: newAttrs.fire || 0,
                        water: newAttrs.water || 0,
                        wind: newAttrs.wind || 0,
                        earth: newAttrs.earth || 0,
                        light: newAttrs.light || 0,
                        dark: newAttrs.dark || 0
                    },
                    satisfaction: 'mid',
                    lastFed: null,
                    lastMusic: null,
                    lastPat: null,
                    lastDecorate: null,
                    lastInteraction: Date.now(),
                    status: '알이 따뜻합니다...',
                    birthTime: Date.now(),
                    logs: [
                        { time: timestamp, message: `🔗 ${item.name}와(과) ${friendData.name}의 교배로 태어났습니다.` },
                        { time: timestamp, message: `📊 부모에게서 물려받은 능력: ${inheritInfo.join(' ')} ${attrInfo}` }
                    ],
                    lightTime: 0,
                    darkTime: 0,
                    musicListened: 0,
                    feedCount: 0,
                    bredWith: friendData.name,
                    breedCode: breedCode,
                    fusionType: prediction.key || null,
                    fusionRarity: prediction.rarity || 'common',
                    isBred: true
                };
            }
            
            spirits.push(newSpirit);
            coins -= BREED_COST;
            
            if (isFusionType && prediction.key) {
                if (!encyclopedia[prediction.key]) {
                    encyclopedia[prediction.key] = { firstSeen: new Date().toISOString(), count: 1 };
                    showNotification(`🎉 새로운 교배 정령 "${prediction.name}" 도감 등록!`);
                } else {
                    encyclopedia[prediction.key].count++;
                }
            }
            
            saveGame();
            renderSpirits();
            updateCoinDisplay();
            
            showNotification(`🎉 교배 성공! ${newSpirit.name}이(가) 태어났습니다!`);
            switchTab('garden');
        }
        
        function closeAlbumDetail() {
            const modal = document.getElementById('albumDetailModal');
            modal.style.display = 'none';
        }

        function applyGrowth() {
            if (isPaused) return; // 일시정지 중이면 성장 안 함
            
            spirits.forEach(spirit => {
                if (spirit.isDead || spirit.isCompleted) return;
                
                // 질병 상태면 성장 멈춤
                if (spirit.isSick) return;

                // 성장도 +1
                const previousGrowth = spirit.growth;
                spirit.growth += 1;

                console.log(`Spirit ${spirit.name}: growth ${previousGrowth} → ${spirit.growth}`);

                // 성충 체크 (100 이상이면 무조건 완료)
                if (spirit.growth >= STAGE_REQUIREMENTS.adult) {
                    console.log(`Completing spirit ${spirit.name} with growth ${spirit.growth}`);
                    completeSpirit(spirit);
                }
            });

            saveGame();
            updateAllSpiritCards();
        }

        function applyTerrariumGrowth() {
            if (isPaused) return; // 일시정지 중이면 실행 안 함
            
            spirits.forEach(spirit => {
                if (spirit.isDead || spirit.isCompleted) return;  // 죽었거나 완성된 정령 제외

                // 조명 누적 시간 추가 (300초 = 5분)
                if (!spirit.lightTime) spirit.lightTime = 0;
                if (!spirit.darkTime) spirit.darkTime = 0;
                
                if (lightMode) {
                    spirit.lightTime += 300;
                } else {
                    spirit.darkTime += 300;
                }

                // 정령의 숨겨진 속성에 테라리움 환경값 추가
                if (!spirit.hiddenAttributes) {
                    spirit.hiddenAttributes = {
                        fire: 0, water: 0, wind: 0, earth: 0, light: 0, dark: 0
                    };
                }

                // 테라리움의 각 속성값만큼 정령의 속성 증가 (최대 500)
                Object.keys(terrarium).forEach(attr => {
                    if (terrarium[attr] > 0) {
                        spirit.hiddenAttributes[attr] = Math.min(500, spirit.hiddenAttributes[attr] + terrarium[attr]);
                    }
                });
                
                // 질병 체크 (5분마다, 이미 아프지 않은 경우)
                if (!spirit.isSick) {
                    checkForDisease(spirit);
                }
            });

            saveGame();
            updateAllSpiritCards();
        }
        
        // 질병 체크 함수
        function checkForDisease(spirit) {
            // 이미 아프면 체크 안 함
            if (spirit.isSick) return;
            
            let shouldCheck = false;
            let reason = '';
            
            // 조건 1: 체력 20 이하
            if (spirit.parameters.strength <= 20) {
                shouldCheck = true;
                reason = '체력이 약해 병에 걸렸습니다';
            }
            
            // 조건 2: 속성 불균형 (최고 속성 50 이상 & 최저 속성 10 이하)
            if (!shouldCheck) {
                const attrs = spirit.hiddenAttributes || { fire: 0, water: 0, wind: 0, earth: 0, light: 0, dark: 0 };
                const attrValues = Object.values(attrs);
                const maxAttr = Math.max(...attrValues);
                const minAttr = Math.min(...attrValues);
                
                if (maxAttr >= 50 && minAttr <= 10) {
                    shouldCheck = true;
                    reason = '속성 불균형으로 인해 병에 걸렸습니다';
                }
            }
            
            // 조건 3: 30분 이상 상호작용 없음
            if (!shouldCheck) {
                const now = Date.now();
                const lastFeed = spirit.lastFed || spirit.birthTime;
                const lastMusic = spirit.lastMusic || spirit.birthTime;
                const lastPat = spirit.lastPat || spirit.birthTime;
                
                const lastInteraction = Math.max(lastFeed, lastMusic, lastPat);
                const minutesSinceInteraction = (now - lastInteraction) / 1000 / 60;
                
                if (minutesSinceInteraction >= 30) {
                    shouldCheck = true;
                    reason = '오랫동안 돌봄을 받지 못해 병에 걸렸습니다';
                }
            }
            
            // 조건 충족 시 20% 확률로 질병 발생
            if (shouldCheck && Math.random() < 0.2) {
                spirit.isSick = true;
                spirit.sickTime = Date.now();
                spirit.status = `${spirit.name}이(가) 아파 보입니다... 🤒`;
                addLog(spirit, reason);
                showNotification(`${spirit.name}이(가) 병에 걸렸습니다!`);
                
                // 첫 질병 시 튜토리얼 시작
                if (!localStorage.getItem('spiritGarden_sickTutorialSeen')) {
                    setTimeout(() => {
                        startSickTutorial();
                    }, 1000);
                }
            }
        }

        function checkSpiritStatus() {
            const now = Date.now();
            spirits.forEach(spirit => {
                if (!spirit.lastFed) {
                    spirit.lastFed = spirit.birthTime;
                }

                const timeSinceLastFed = now - spirit.lastFed;
                const hours = timeSinceLastFed / 1000 / 60 / 60;

                // 24시간 경과 - 사망만 체크 (배고픔 메시지는 getRandomMessage에서 처리)
                if (hours >= 24) {
                    if (getStage(spirit.growth) === 'egg') {
                        spirit.status = '❌ 알이 깨져서 미동이 없습니다...';
                        spirit.isDead = true;
                    } else {
                        spirit.status = '❌ 테라리움 밖으로 나가 사라졌습니다...';
                        spirit.isDead = true;
                    }
                }
            });
        }

        function updateAllSpiritCards() {
            // 정령별 불만 상태 지속 시간 체크
            updateLowSatisfactionTimer();
            
            spirits.forEach(spirit => {
                updateSpiritCard(spirit);
            });
        }

        // 쿨타임 텍스트만 업데이트 (성능 최적화)
        function updateCooldownDisplay() {
            if (currentTab !== 'garden' || isPaused) return;
            
            const now = Date.now();
            spirits.forEach((spirit, index) => {
                const cards = document.querySelectorAll('.spirit-card');
                const card = cards[index];
                if (!card) return;
                
                // 버튼들 찾기
                const buttons = card.querySelectorAll('button');
                buttons.forEach(button => {
                    const text = button.textContent;
                    
                    // 먹이주기 버튼
                    if (text.includes('먹이주기')) {
                        const canFeed = !isPaused && canDoAction(spirit, 'feed') && !spirit.isDead;
                        if (!canFeed && spirit.lastFeed) {
                            const remaining = Math.max(0, Math.ceil((10000 - (now - spirit.lastFeed)) / 1000));
                            button.textContent = `${spirit.isSick ? '🤢 ' : ''}먹이주기 (${remaining}초)`;
                        } else if (canFeed) {
                            button.textContent = `${spirit.isSick ? '🤢 ' : ''}먹이주기`;
                        }
                    }
                    
                    // 음악 듣기 버튼
                    if (text.includes('음악 듣기')) {
                        const canMusic = !isPaused && canDoAction(spirit, 'music') && !spirit.isDead;
                        if (!canMusic && spirit.lastMusic) {
                            const remaining = Math.max(0, Math.ceil((10000 - (now - spirit.lastMusic)) / 1000));
                            button.textContent = `음악 듣기 (${remaining}초)`;
                        } else if (canMusic) {
                            button.textContent = `음악 듣기`;
                        }
                    }
                    
                    // 쓰다듬기 버튼
                    if (text.includes('쓰다듬기')) {
                        const canPat = !isPaused && canDoAction(spirit, 'pat') && !spirit.isDead;
                        if (!canPat && spirit.lastPat) {
                            const remaining = Math.max(0, Math.ceil((10000 - (now - spirit.lastPat)) / 1000));
                            button.textContent = `쓰다듬기 (${remaining}초)`;
                        } else if (canPat) {
                            button.textContent = `쓰다듬기`;
                        }
                    }
                });
            });
        }

        function updateSpiritCard(spirit) {
            const cards = document.querySelectorAll('.spirit-card');
            const index = spirits.findIndex(s => s.id === spirit.id);
            if (index === -1 || !cards[index]) return;

            const card = cards[index];
            const stage = getStage(spirit.growth);
            const nextReq = getNextStageRequirement(spirit.growth);
            const progress = (spirit.growth / nextReq) * 100;
            
            const canFeed = canDoAction(spirit, 'feed') && !spirit.isDead;
            const canMusic = canDoAction(spirit, 'music') && !spirit.isDead;
            const canPat = canDoAction(spirit, 'pat') && !spirit.isDead;

            let icon = STAGE_ICONS[stage];
            
            // 이벤트 정령 아이콘
            if (spirit.isEventSpirit && spirit.eventType) {
                const eventIcon = getEventStageIcon(spirit);
                if (eventIcon) icon = eventIcon;
            }
            // 일반 진화 아이콘
            else if (stage === 'adult' && spirit.evolutionType) {
                const evolutionData = EVOLUTION_TYPES[spirit.evolutionType];
                if (evolutionData) {
                    icon = evolutionData.icon;
                }
            }
            if (spirit.isDead) {
                icon = stage === 'egg' ? '💔' : '👻';
            }

            // 아이콘 업데이트
            const iconElement = card.querySelector('.spirit-icon');
            if (iconElement && iconElement.textContent !== icon) {
                iconElement.textContent = icon;
            }

            // 이름 업데이트
            const nameElement = card.querySelector('.spirit-name');
            if (nameElement && nameElement.textContent !== spirit.name) {
                nameElement.textContent = spirit.name;
            }

            // 스테이지 업데이트
            const stageElement = card.querySelector('.spirit-stage');
            if (stageElement) {
                stageElement.textContent = STAGE_NAMES[stage];
            }

            // 진행도 업데이트
            const progressFill = card.querySelector('.progress-fill');
            if (progressFill) {
                progressFill.style.width = `${Math.min(progress, 100)}%`;
            }

            const progressText = card.querySelector('.progress-text');
            if (progressText) {
                progressText.textContent = `성장 ${spirit.growth} / ${nextReq}`;
            }

            // 파라미터 업데이트
            const params = card.querySelectorAll('.param');
            if (params.length >= 4) {
                params[0].innerHTML = `<span class="param-icon">🧠</span>지력 ${spirit.parameters.intelligence}`;
                params[1].innerHTML = `<span class="param-icon">💪</span>체력 ${spirit.parameters.strength}`;
                params[2].innerHTML = `<span class="param-icon">💖</span>매력 ${spirit.parameters.charm}`;
                params[3].innerHTML = `<span class="param-icon">❤️</span>애정 ${spirit.parameters.affection}`;
            }

            // 상태 메시지 업데이트
            const statusElement = card.querySelector('.spirit-status');
            if (statusElement) {
                statusElement.textContent = spirit.status;
            }

            // 버튼 상태 업데이트
            const actionButtons = card.querySelector('.action-buttons');
            if (actionButtons) {
                const buttons = actionButtons.querySelectorAll('button');
                if (buttons.length >= 4) {
                    buttons[0].disabled = !canFeed;
                    buttons[1].disabled = !canMusic;
                    buttons[2].disabled = !canPat;
                    // buttons[3]는 보내기 버튼이므로 항상 활성화
                }
            }
        }

        function toggleLogs(spiritId) {
            const logsDiv = document.getElementById(`logs${spiritId}`);
            const toggleIcon = document.getElementById(`logToggle${spiritId}`);
            
            if (logsDiv.style.display === 'none') {
                logsDiv.style.display = 'block';
                toggleIcon.textContent = '▲';
            } else {
                logsDiv.style.display = 'none';
                toggleIcon.textContent = '▼';
            }
        }

        function renderSpirits() {
            const grid = document.getElementById('spiritsGrid');
            const now = Date.now(); // 쿨타임 계산용
            
            if (spirits.length === 0) {
                grid.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-icon">🥚</div>
                        <div>아직 정령이 없습니다<br>새로운 알을 받아보세요</div>
                    </div>
                `;
                return;
            }

            grid.innerHTML = spirits.map(spirit => {
                const stage = getStage(spirit.growth);
                const nextReq = getNextStageRequirement(spirit.growth);
                const progress = (spirit.growth / nextReq) * 100;
                
                const canFeed = !isPaused && canDoAction(spirit, 'feed') && !spirit.isDead;
                const canMusic = !isPaused && canDoAction(spirit, 'music') && !spirit.isDead;
                const canPat = !isPaused && canDoAction(spirit, 'pat') && !spirit.isDead;

                let icon = STAGE_ICONS[stage];
                
                // 이벤트 정령 아이콘
                if (spirit.isEventSpirit && spirit.eventType) {
                    const eventIcon = getEventStageIcon(spirit);
                    if (eventIcon) icon = eventIcon;
                }
                // 일반 진화 아이콘
                else if (stage === 'adult' && spirit.evolutionType) {
                    const evolutionData = EVOLUTION_TYPES[spirit.evolutionType];
                    if (evolutionData) {
                        icon = evolutionData.icon;
                    }
                }
                if (spirit.isDead) {
                    icon = stage === 'egg' ? '💔' : '👻';
                }

                // 하위 호환성을 위한 파라미터 체크
                if (!spirit.parameters.affection && spirit.parameters.mystery !== undefined) {
                    spirit.parameters.affection = spirit.parameters.mystery;
                    delete spirit.parameters.mystery;
                }
                if (!spirit.hiddenAttributes) {
                    spirit.hiddenAttributes = {
                        fire: 0, water: 0, wind: 0, earth: 0, light: 0, dark: 0
                    };
                }
                if (!spirit.logs) {
                    spirit.logs = [];
                }
                if (!spirit.lightTime) {
                    spirit.lightTime = 0;
                }
                if (!spirit.darkTime) {
                    spirit.darkTime = 0;
                }
                if (!spirit.musicListened) {
                    spirit.musicListened = 0;
                }
                if (!spirit.feedCount) {
                    spirit.feedCount = 0;
                }
                
                // 완성된 정령인 경우 특별한 카드 표시
                if (spirit.isCompleted && spirit.evolutionData) {
                    return `
                        <div class="spirit-card" style="background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%); border: 3px solid #ffa500;">
                            <div style="text-align: center; padding: 20px;">
                                <div style="font-size: 4rem; margin-bottom: 15px;">${spirit.evolutionData.icon}</div>
                                <div style="font-size: 1.3rem; font-weight: 700; color: #333; margin-bottom: 10px;">
                                    🎉 번데기에서 정령이 부화했습니다! 🎉
                                </div>
                                <div style="font-size: 1rem; color: #555; margin-bottom: 8px;">
                                    ${spirit.name} → ${spirit.evolutionData.name}
                                </div>
                                <div style="font-size: 0.9rem; color: #666; margin-bottom: 20px;">
                                    애정도: ${spirit.parameters.affection || 0}
                                </div>
                                <button onclick="confirmEvolution(${spirit.id})" style="
                                    background: #ff6b6b;
                                    color: white;
                                    border: none;
                                    padding: 15px 30px;
                                    font-size: 1.1rem;
                                    font-weight: 700;
                                    border-radius: 8px;
                                    cursor: pointer;
                                    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
                                ">
                                    확인하기
                                </button>
                            </div>
                        </div>
                    `;
                }
                // 외형 묘사 가져오기
                const appearance = getAppearanceDescription(spirit);

                return `
                    <div class="spirit-card" style="position: relative;">
                        ${(() => {
                            const satisfaction = spirit.satisfaction || 'mid';
                            const satisfactionIcons = { high: '', mid: '', low: '' };
                            const satisfactionTexts = { high: '만족', mid: '보통', low: '불만' };
                            const satisfactionColors = { high: '#4caf50', mid: '#ff9800', low: '#f44336' };
                            return `
                                <div style="position: absolute; top: 12px; right: 12px; display: flex; align-items: center; gap: 4px; padding: 4px 8px; background: ${satisfactionColors[satisfaction]}22; border: 1px solid ${satisfactionColors[satisfaction]}; border-radius: 12px; font-size: 0.75rem;">
                                    <span style="font-size: 1rem;">${satisfactionIcons[satisfaction]}</span>
                                    <span style="font-weight: 600; color: ${satisfactionColors[satisfaction]};">${satisfactionTexts[satisfaction]}</span>
                                </div>
                            `;
                        })()}
                        <div class="spirit-header">
                            <div class="spirit-icon" onclick="showAppearance(${spirit.id})" style="cursor: pointer;">${icon}</div>
                            <div class="spirit-info">
                                <div class="spirit-name" onclick="changeName(${spirit.id})">${spirit.name}</div>
                                <div class="spirit-stage">${STAGE_NAMES[stage]}</div>
                            </div>
                        </div>
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: ${Math.min(progress, 100)}%"></div>
                        </div>
                        <div class="progress-text">성장 ${spirit.growth} / ${nextReq}</div>
                        <div class="parameters">
                            <div class="param"><span class="param-icon">🧠</span>지력 ${spirit.parameters.intelligence}</div>
                            <div class="param"><span class="param-icon">💪</span>체력 ${spirit.parameters.strength}</div>
                            <div class="param"><span class="param-icon">💖</span>매력 ${spirit.parameters.charm}</div>
                            <div class="param"><span class="param-icon">❤️</span>애정 ${spirit.parameters.affection}</div>
                        </div>
                        ${(() => {
                            const foodAttrs = spirit.hiddenAttributes || { fire: 0, water: 0, wind: 0, earth: 0, light: 0, dark: 0 };
                            const terrariumAttrs = terrarium || { fire: 0, water: 0, wind: 0, earth: 0, light: 0, dark: 0 };
                            // 최종 속성 = (먹이 × 0.7) + (테라리움 × 0.3)
                            const attrs = {};
                            for (let attr in foodAttrs) {
                                attrs[attr] = (foodAttrs[attr] * 0.7) + (terrariumAttrs[attr] * 0.3);
                            }
                            const attrIcons = { fire: '🔥', water: '💧', wind: '🌬️', earth: '🌱', light: '✨', dark: '🌙' };
                            const attrNames = { fire: '불', water: '물', wind: '바람', earth: '땅', light: '빛', dark: '어둠' };
                            const attrValues = Object.values(attrs);
                            const maxAttr = Math.max(...attrValues);
                            const minAttr = Math.min(...attrValues);
                            const isImbalanced = maxAttr >= 50 && minAttr <= 10;
                            
                            return `
                                <div style="margin: 8px 0; padding: 8px; background: var(--bg); border: 1px solid ${isImbalanced ? '#f44336' : 'var(--border)'}; border-radius: 8px;">
                                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                                        <span style="font-size: 0.8rem; font-weight: 600; color: var(--text-muted);">속성 (먹이+환경)</span>
                                        ${isImbalanced ? '<span style="font-size: 0.75rem; color: #f44336; font-weight: 600;">⚠️ 불균형</span>' : ''}
                                    </div>
                                    <div style="display: grid; grid-template-columns: repeat(6, 1fr); gap: 4px; text-align: center;">
                                        ${Object.entries(attrs).map(([key, val]) => {
                                            const isMax = val === maxAttr && maxAttr > 0;
                                            const isMin = val === minAttr && isImbalanced;
                                            const isPerfect = val >= 90;
                                            return `
                                                <div style="font-size: 0.75rem; ${isPerfect ? 'color: #ff6f00; font-weight: 700;' : isMax ? 'color: #4caf50; font-weight: 700;' : ''} ${isMin ? 'color: #f44336; font-weight: 700;' : ''}">
                                                    <div>${attrIcons[key]}</div>
                                                    <div>${Math.floor(val)}</div>
                                                </div>
                                            `;
                                        }).join('')}
                                    </div>
                                </div>
                            `;
                        })()}
                        ${(() => {
                            const keywords = getStatusKeywords(spirit);
                            if (keywords.length === 0) return '';
                            return `
                                <div style="margin: 12px 0; padding: 10px; background: var(--bg); border: 1px solid var(--border); display: flex; flex-wrap: wrap; gap: 6px;">
                                    ${keywords.map(kw => `
                                        <span style="
                                            display: inline-flex;
                                            align-items: center;
                                            padding: 4px 10px;
                                            background: #f5f5f5;
                                            border: 1px solid #ddd;
                                            font-size: 0.8rem;
                                            font-weight: 600;
                                            color: ${kw.color};
                                        ">
                                            ${kw.text}
                                        </span>
                                    `).join('')}
                                </div>
                            `;
                        })()}
                        <div class="spirit-status">${spirit.status}</div>
                        ${spirit.logs && spirit.logs.length > 0 ? `
                            <div style="margin-top: 6px; margin-bottom: 16px; border-top: 1px solid var(--border); padding-top: 6px;">
                                <div style="display: flex; justify-content: space-between; align-items: center; cursor: pointer; padding: 8px; background: var(--bg); border-radius: 6px;" onclick="toggleLogs(${spirit.id})">
                                    <span style="font-size: 0.9rem; font-weight: 600;">일지 (${spirit.logs.length}개)</span>
                                    <span id="logToggle${spirit.id}" style="font-size: 0.8rem;">▼</span>
                                </div>
                                <div id="logs${spirit.id}" style="display: none; margin-top: 8px; max-height: 200px; overflow-y: auto;">
                                    ${spirit.logs.map(log => `
                                        <div style="font-size: 0.85rem; color: #888; padding: 4px 0; border-bottom: 1px solid var(--border);">
                                            <span style="color: #666;">${log.time}</span> - ${log.message}
                                        </div>
                                    `).join('')}
                                </div>
                            </div>
                        ` : ''}
                        <div class="action-buttons">
                            ${spirit.isSick ? `
                                <button onclick="giveMedicine(${spirit.id})" style="background: var(--earth); color: white; font-weight: 700;">
                                    🌿 약초 사용
                                </button>
                            ` : ''}
                            <button onclick="openFeedModal(${spirit.id})" ${!canFeed ? 'disabled' : ''}>
                                ${spirit.isSick ? '🤒 ' : ''}먹이주기${!canFeed && spirit.lastFed ? ` (${Math.max(0, Math.ceil((10000 - (now - spirit.lastFed)) / 1000))}초)` : ''}
                            </button>
                            <button onclick="openMusicModal(${spirit.id})" ${!canMusic ? 'disabled' : ''}>
                                음악 듣기${!canMusic && spirit.lastMusic ? ` (${Math.max(0, Math.ceil((10000 - (now - spirit.lastMusic)) / 1000))}초)` : ''}
                            </button>
                            <button onclick="patSpirit(${spirit.id})" ${!canPat ? 'disabled' : ''}>
                                쓰다듬기${!canPat && spirit.lastPat ? ` (${Math.max(0, Math.ceil((10000 - (now - spirit.lastPat)) / 1000))}초)` : ''}
                            </button>
                            ${spirit.growth >= 100 && !spirit.isCompleted ? `
                                <button onclick="manualCompleteSpirit(${spirit.id})" style="background: #ffd700; color: #000; font-weight: 700;">
                                    진화하기
                                </button>
                            ` : ''}
                            <button onclick="confirmDeleteSpirit(${spirit.id})">
                                보내기
                            </button>
                        </div>
                    </div>
                `;
            }).join('');
            
            // 튜토리얼 진행 중이면 강조 표시 재적용
            if ((tutorialActive || tutorial2Active) && window.tutorialWaitingFor) {
                setTimeout(() => {
                    highlightTutorialTarget(window.tutorialWaitingFor);
                }, 100);
            }
        }

        function updateCoinDisplay() {
            const displays = document.querySelectorAll('#coinDisplay, #shopCoinDisplay');
            displays.forEach(el => {
                if (el) el.textContent = coins;
            });
        }

        function changeSellFilter() {
            const select = document.getElementById('sellFilterSelect');
            sellFilter = select.value;
            renderSellList();
        }

        function changeBuyFilter() {
            const select = document.getElementById('buyFilterSelect');
            buyFilter = select.value;
            renderBuyList();
        }

        // 상점 주인 대사 시스템
        function updateShopkeeperDialogue() {
            const dialogueEl = document.getElementById('shopkeeperDialogue');
            if (!dialogueEl) return;
            
            let dialogue = '';
            let gaveGift = false;
            
            // 우선순위 대사 체크
            if (!hasVisitedShop) {
                // 첫 방문
                dialogue = '처음 보는 얼굴이네요...';
                hasVisitedShop = true;
                saveGame();
            } else if (coins === 0) {
                // 0코인일 때 선물
                dialogue = '...이거라도 가져가요.';
                coins += 10;
                gaveGift = true;
                saveGame();
                updateCoinDisplay();
            } else if (coins <= 50) {
                // 50코인 이하
                dialogue = '주머니가 가벼워 보이네요.';
            } else {
                // 일반 랜덤 대사
                const randomDialogues = [
                    '어서오세요...',
                    '날씨가 좋네요. ...싫다.',
                    '날이 추워서 일하기 싫어요.',
                    '<계산대에 엎드려 자고있다.>',
                    '또 오셨네요...',
                    '천천히 둘러보세요...',
                    '...뭘 봐요.',
                    '오늘은 특별한 건 없어요.',
                    '...하품.',
                    '손님이 오면 일해야 하잖아요...'
                ];
                dialogue = randomDialogues[Math.floor(Math.random() * randomDialogues.length)];
            }
            
            dialogueEl.textContent = dialogue;
            
            // 선물 받았을 때 알림
            if (gaveGift) {
                setTimeout(() => {
                    showNotification('💰 상점 주인에게 10코인을 받았습니다!');
                }, 500);
            }
        }
        
        // 상점 주인 대사 직접 설정
        function setShopkeeperDialogue(text) {
            const dialogueEl = document.getElementById('shopkeeperDialogue');
            if (dialogueEl) {
                dialogueEl.textContent = text;
            }
        }
        
        function renderShop() {
            updateCoinDisplay();
            updateShopkeeperDialogue();
            renderSellList();
            renderBuyList();
        }

        function renderSellList() {
            const container = document.getElementById('sellList');
            if (!container) return;

            const items = [];

            if (currentShopCategory === 'all' || currentShopCategory === 'food') {
                // 먹이 판매 (순서 고정)
                if (inventory.food && inventory.food.length > 0) {
                    const foodCounts = {};
                    inventory.food.forEach(f => {
                        foodCounts[f] = (foodCounts[f] || 0) + 1;
                    });

                    const foodOrder = ['fire', 'water', 'wind', 'earth', 'light', 'dark'];
                    foodOrder.filter(type => foodCounts[type]).forEach(type => {
                        // 속성 필터 체크
                        if (sellFilter === 'all') {
                            // 전체 보기
                        } else if (['intelligence', 'strength', 'charm'].includes(sellFilter)) {
                            return; // 스탯 필터 시 먹이 숨김
                        } else if (type !== sellFilter) {
                            return; // 다른 속성이면 숨김
                        }
                        
                        const count = foodCounts[type];
                        const isRare = type === 'light' || type === 'dark';
                        const price = isRare ? SHOP_PRICES.sell.food_rare : SHOP_PRICES.sell.food_common;
                        const effectText = isRare ? `${ENV_ICONS[type]} 속성 +6, 성장 +3` : `${ENV_ICONS[type]} 속성 +3, 성장 +2`;
                        const rarityLabel = isRare ? ' <span style="font-size: 0.75rem; color: #9b59b6;">희귀</span>' : '';
                        items.push(`
                            <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px; background: var(--bg); border: 1px solid var(--border); margin-bottom: 10px;">
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <span style="font-size: 1.5rem;">${ENV_ICONS[type]}</span>
                                    <div>
                                        <div style="font-weight: 700;">${FOOD_NAMES[type]} ×${count}${rarityLabel}</div>
                                        <div style="font-size: 0.85rem; color: #666;">${effectText}</div>
                                        <div style="font-size: 0.85rem; color: #888;">판매가: ${price}💰</div>
                                    </div>
                                </div>
                                <button onclick="sellItem('food', '${type}')" style="padding: 8px 16px; background: var(--fire); color: white;">판매</button>
                            </div>
                        `);
                    });
                }
            }
            
            if (currentShopCategory === 'all' || currentShopCategory === 'decoration') {
                // 장식물 판매 (속성 → 품질 → 이름 순 정렬)
                if (inventory.decorations && inventory.decorations.length > 0) {
                    const decorCounts = {};
                    inventory.decorations.forEach(d => {
                        decorCounts[d] = (decorCounts[d] || 0) + 1;
                    });
                    
                    // 합성 전용 아이템 (상점에서 제외)
                    const synthOnlyItems = ['flame_lamp', 'aqua_fountain', 'wind_chime', 'earth_statue', 'light_orb', 'shadow_crystal'];

                    // 속성별, 품질별, 이름별로 정렬
                    const sortedDecoKeys = Object.keys(decorCounts).filter(key => !synthOnlyItems.includes(key)).sort((a, b) => {
                        const dataA = DECORATION_TYPES[a];
                        const dataB = DECORATION_TYPES[b];
                        if (!dataA || !dataB) return 0;
                        
                        // 1. 속성별 정렬
                        const attrOrder = { fire: 0, water: 1, wind: 2, earth: 3, light: 4, dark: 5 };
                        const attrDiff = (attrOrder[dataA.attr] || 0) - (attrOrder[dataB.attr] || 0);
                        if (attrDiff !== 0) return attrDiff;
                        
                        // 2. 품질별 정렬 (높은 순: legendary > epic > rare > common)
                        const qualityOrder = { legendary: 0, epic: 1, rare: 2, common: 3 };
                        const qualityDiff = (qualityOrder[dataA.quality] || 3) - (qualityOrder[dataB.quality] || 3);
                        if (qualityDiff !== 0) return qualityDiff;
                        
                        // 3. 이름별 정렬
                        return dataA.name.localeCompare(dataB.name);
                    });
                    
                    sortedDecoKeys.forEach(key => {
                        const decoData = DECORATION_TYPES[key];
                        if (!decoData) return; // 데이터 없으면 스킵
                        
                        // 속성 필터 체크
                        if (sellFilter === 'all') {
                            // 전체 보기
                        } else if (['intelligence', 'strength', 'charm'].includes(sellFilter)) {
                            return; // 스탯 필터 시 장식물 숨김
                        } else if (decoData.attr === 'dual') {
                            if (!decoData.dualAttr || !decoData.dualAttr.includes(sellFilter)) return;
                        } else if (decoData.attr === 'all') {
                            // all 속성 장식물은 모든 속성 필터에서 표시
                        } else if (decoData.attr !== sellFilter) {
                            return; // 다른 속성이면 숨김
                        }
                        
                        const count = decorCounts[key];
                        
                        const sellPrice = Math.floor(decoData.price * 0.5); // 판매가는 구매가의 50%
                        const qualityLabel = decoData.quality === 'legendary' ? '👑' : decoData.quality === 'epic' ? '⭐' : decoData.quality === 'rare' ? '💎' : '';
                        const qualityText = decoData.quality === 'legendary' ? '<span style="color: #ff6b35;">전설</span>' : decoData.quality === 'epic' ? '<span style="color: #9b59b6;">에픽</span>' : decoData.quality === 'rare' ? '<span style="color: #3498db;">레어</span>' : '<span style="color: #888;">일반</span>';
                        
                        // 속성 표시 (복합 속성 처리)
                        let attrDisplay = '';
                        if (decoData.attr === 'dual' && decoData.dualAttr) {
                            attrDisplay = decoData.dualAttr.map(a => ENV_ICONS[a]).join('') + ` +${decoData.power}`;
                        } else if (decoData.attr === 'all') {
                            attrDisplay = '🌈 전체 속성 +' + decoData.power;
                        } else {
                            const attrName = { fire: '불', water: '물', wind: '바람', earth: '땅', light: '빛', dark: '어둠' }[decoData.attr] || '';
                            attrDisplay = `${ENV_ICONS[decoData.attr]} ${attrName} 속성 +${decoData.power}`;
                        }
                        
                        items.push(`
                            <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px; background: var(--bg); border: 1px solid var(--border); margin-bottom: 10px;">
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <span style="font-size: 1.5rem;">${qualityLabel}${decoData.icon}</span>
                                    <div>
                                        <div style="font-weight: 700;">${decoData.name} ×${count}</div>
                                        <div style="font-size: 0.85rem; color: #666;">${attrDisplay} | ${qualityText}</div>
                                        <div style="font-size: 0.85rem; color: #888;">판매가: ${sellPrice}💰</div>
                                    </div>
                                </div>
                                <button onclick="sellItem('decoration', '${key}')" style="padding: 8px 16px; background: var(--fire); color: white;">판매</button>
                            </div>
                        `);
                    });
                }
            }

            

            if (currentShopCategory === 'all' || currentShopCategory === 'music') {
                // 음악 판매 (순서 고정)
                if (inventory.music && inventory.music.length > 0) {
                    const musicCounts = {};
                    inventory.music.forEach(m => {
                        musicCounts[m] = (musicCounts[m] || 0) + 1;
                    });

                    const musicOrder = ['classic', 'jazz', 'rock', 'pop', 'ballad'];
                    musicOrder.filter(type => musicCounts[type]).forEach(type => {
                        const musicData = MUSIC_TYPES[type];
                        
                        // 스탯 필터 체크 (음악 전용, 복합 스탯 음악도 해당 필터에 표시)
                        if (sellFilter === 'all') {
                            // 전체 보기일 때는 필터링 안 함
                        } else if (sellFilter === 'intelligence') {
                            if (!['classic', 'pop'].includes(type)) return;
                        } else if (sellFilter === 'strength') {
                            if (!['rock', 'ballad'].includes(type)) return;
                        } else if (sellFilter === 'charm') {
                            if (!['jazz', 'pop', 'ballad'].includes(type)) return;
                        } else if (['fire', 'water', 'wind', 'earth', 'light', 'dark'].includes(sellFilter)) {
                            return; // 속성 필터 시 음악 숨김
                        }
                        
                        const count = musicCounts[type];
                        items.push(`
                            <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px; background: var(--bg); border: 1px solid var(--border); margin-bottom: 10px;">
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <span style="font-size: 1.5rem;">🎵</span>
                                    <div>
                                        <div style="font-weight: 700;">${musicData.name} ×${count}</div>
                                        <div style="font-size: 0.85rem; color: #666;">${musicData.effect}</div>
                                        <div style="font-size: 0.85rem; color: #888;">판매가: ${SHOP_PRICES.sell.music}💰</div>
                                    </div>
                                </div>
                                <button onclick="sellItem('music', '${type}')" style="padding: 8px 16px; background: var(--fire); color: white;">판매</button>
                            </div>
                        `);
                    });
                }
            }

            if (items.length === 0) {
                container.innerHTML = '<p style="color: #888; text-align: center; padding: 20px;">판매할 물품이 없습니다</p>';
            } else {
                container.innerHTML = items.join('');
            }
        }

        function renderBuyList() {
            const container = document.getElementById('buyList');
            if (!container) return;

            const items = [];
            
            // 이벤트 아이템 섹션 (활성화된 이벤트가 있고, 기간 내일 때만)
            // 카테고리 필터에 맞는 이벤트 아이템만 표시
            if (activatedEvents && activatedEvents.length > 0) {
                let eventItems = [];
                
                activatedEvents.forEach(eventType => {
                    const event = EVENT_TYPES[eventType];
                    if (!event) return;
                    
                    // 이벤트 기간 체크
                    if (event.validUntil && new Date() > new Date(event.validUntil)) return;
                    
                    // 해당 이벤트의 아이템들
                    Object.keys(EVENT_ITEMS).forEach(itemKey => {
                        const item = EVENT_ITEMS[itemKey];
                        if (item.event !== eventType) return;
                        
                        // 카테고리 필터 적용
                        if (currentShopCategory !== 'all') {
                            if (currentShopCategory === 'food' && item.type !== 'food') return;
                            if (currentShopCategory === 'music' && item.type !== 'music') return;
                            if (currentShopCategory === 'decoration' && item.type !== 'decoration') return;
                        }
                        
                        // 세부 필터 적용
                        if (buyFilter !== 'all') {
                            // 속성 필터일 때 음악은 숨김
                            if (['fire', 'water', 'wind', 'earth', 'light', 'dark'].includes(buyFilter) && item.type === 'music') return;
                            // 스탯 필터일 때 먹이/장식물은 숨김
                            if (['intelligence', 'strength', 'charm'].includes(buyFilter) && item.type !== 'music') return;
                        }
                        
                        const price = item.type === 'food' ? 30 : item.type === 'music' ? 100 : 50;
                        
                        eventItems.push(`
                            <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px; background: var(--bg); border: 1px solid var(--border); margin-bottom: 10px;">
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <span style="font-size: 1.5rem;">${item.icon}</span>
                                    <div>
                                        <div style="font-weight: 700;">${item.name} <span style="font-size: 0.7rem; color: #c41e3a;">🎄한정</span></div>
                                        <div style="font-size: 0.85rem; color: #888;">가격: ${price}💰</div>
                                    </div>
                                </div>
                                <button onclick="buyEventItem('${itemKey}', ${price})" style="padding: 8px 16px;">구매</button>
                            </div>
                        `);
                    });
                });
                
                if (eventItems.length > 0) {
                    items.push(`<div style="margin-bottom: 10px;">
                        ${eventItems.join('')}
                    </div>`);
                }
            }
            
            // 약초 구매 (카테고리가 all 또는 food이고, 필터가 all이거나 속성 필터일 때만 표시)
            if ((currentShopCategory === 'all' || currentShopCategory === 'food') &&
                (buyFilter === 'all' || ['fire', 'water', 'wind', 'earth', 'light', 'dark'].includes(buyFilter))) {
                items.push(`
                    <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px; background: var(--bg); border: 1px solid var(--border); margin-bottom: 10px;">
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <span style="font-size: 1.5rem;">${MEDICINE.icon}</span>
                            <div>
                                <div style="font-weight: 700;">${MEDICINE.name}</div>
                                <div style="font-size: 0.85rem; color: #666;">${MEDICINE.description}</div>
                                <div style="font-size: 0.85rem; color: #888;">가격: ${MEDICINE.price}💰</div>
                            </div>
                        </div>
                        <button onclick="buyItem('food', 'medicine', ${MEDICINE.price})" style="padding: 8px 16px;">구매</button>
                    </div>
                `);
            }
            
            // 먹이 구매 (카테고리가 all 또는 food, 속성 필터만 적용)
            if ((currentShopCategory === 'all' || currentShopCategory === 'food') &&
                (buyFilter === 'all' || ['fire', 'water', 'wind', 'earth', 'light', 'dark'].includes(buyFilter))) {
                // 일반 먹이
                ['fire', 'water', 'wind', 'earth'].forEach(type => {
                    if (buyFilter !== 'all' && type !== buyFilter) return;
                    
                    items.push(`
                        <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px; background: var(--bg); border: 1px solid var(--border); margin-bottom: 10px;">
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <span style="font-size: 1.5rem;">${ENV_ICONS[type]}</span>
                                <div>
                                    <div style="font-weight: 700;">${FOOD_NAMES[type]}</div>
                                    <div style="font-size: 0.85rem; color: #666;">${ENV_ICONS[type]} 속성 +3, 성장 +2</div>
                                    <div style="font-size: 0.85rem; color: #888;">가격: ${SHOP_PRICES.buy.food_common}💰</div>
                                </div>
                            </div>
                            <button onclick="buyItem('food', '${type}', ${SHOP_PRICES.buy.food_common})" style="padding: 8px 16px;">구매</button>
                        </div>
                    `);
                });

                // 희귀 먹이
                ['light', 'dark'].forEach(type => {
                    if (buyFilter !== 'all' && type !== buyFilter) return;
                    
                    items.push(`
                        <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px; background: var(--bg); border: 1px solid var(--border); margin-bottom: 10px;">
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <span style="font-size: 1.5rem;">${ENV_ICONS[type]}</span>
                                <div>
                                    <div style="font-weight: 700;">${FOOD_NAMES[type]} <span style="font-size: 0.75rem; color: #9b59b6;">희귀</span></div>
                                    <div style="font-size: 0.85rem; color: #666;">${ENV_ICONS[type]} 속성 +6, 성장 +3</div>
                                    <div style="font-size: 0.85rem; color: #888;">가격: ${SHOP_PRICES.buy.food_rare}💰</div>
                                </div>
                            </div>
                            <button onclick="buyItem('food', '${type}', ${SHOP_PRICES.buy.food_rare})" style="padding: 8px 16px;">구매</button>
                        </div>
                    `);
                });
            }

            // 음악 구매 (카테고리가 all 또는 music, 스탯 필터 적용)
            if ((currentShopCategory === 'all' || currentShopCategory === 'music') &&
                (buyFilter === 'all' || ['intelligence', 'strength', 'charm'].includes(buyFilter))) {
                Object.keys(MUSIC_TYPES).forEach(type => {
                    // 스탯별 필터링 (복합 스탯 음악도 해당 필터에 표시)
                    if (buyFilter === 'intelligence' && !['classic', 'pop'].includes(type)) return;
                    if (buyFilter === 'strength' && !['rock', 'ballad'].includes(type)) return;
                    if (buyFilter === 'charm' && !['jazz', 'pop', 'ballad'].includes(type)) return;
                    
                    const musicData = MUSIC_TYPES[type];
                    items.push(`
                        <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px; background: var(--bg); border: 1px solid var(--border); margin-bottom: 10px;">
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <span style="font-size: 1.5rem;">🎵</span>
                                <div>
                                    <div style="font-weight: 700;">${musicData.name}</div>
                                    <div style="font-size: 0.85rem; color: #666;">${musicData.effect}</div>
                                    <div style="font-size: 0.85rem; color: #888;">가격: ${SHOP_PRICES.buy.music}💰</div>
                                </div>
                            </div>
                            <button onclick="buyItem('music', '${type}', ${SHOP_PRICES.buy.music})" style="padding: 8px 16px;">구매</button>
                        </div>
                    `);
                });
            }
            
            // 장식물 구매 (카테고리가 all 또는 decoration, 속성 필터 적용, legendary 제외 - 미니게임 전용)
            if ((currentShopCategory === 'all' || currentShopCategory === 'decoration') &&
                (buyFilter === 'all' || ['fire', 'water', 'wind', 'earth', 'light', 'dark'].includes(buyFilter))) {
                const decorationsByQuality = {
                    common: [],
                    rare: [],
                    epic: []
                };
                
                // 합성 전용 아이템 (상점에서 제외)
                const synthOnlyItems = ['flame_lamp', 'aqua_fountain', 'wind_chime', 'earth_statue', 'light_orb', 'shadow_crystal'];
                
                // 속성 표시용 헬퍼 함수
                function getDecoAttrDisplay(data) {
                    if (data.attr === 'dual' && data.dualAttr) {
                        return data.dualAttr.map(a => ENV_ICONS[a]).join('') + ` +${data.power}`;
                    } else if (data.attr === 'all') {
                        return '🌈 전체 속성 +' + data.power;
                    } else {
                        return `${ENV_ICONS[data.attr]} +${data.power}`;
                    }
                }
                
                Object.keys(DECORATION_TYPES).forEach(key => {
                    const decoData = DECORATION_TYPES[key];
                    
                    // legendary는 상점에서 판매 안함 (미니게임 전용)
                    if (decoData.quality === 'legendary') return;
                    
                    // 합성 전용 아이템 제외
                    if (synthOnlyItems.includes(key)) return;
                    if (decoData.quality === 'legendary') return;
                    
                    // 속성 필터 (복합 속성은 all 필터에서만 표시하거나, 해당 속성 포함 시 표시)
                    if (buyFilter !== 'all') {
                        if (decoData.attr === 'dual') {
                            if (!decoData.dualAttr || !decoData.dualAttr.includes(buyFilter)) return;
                        } else if (decoData.attr === 'all') {
                            // all 속성 장식물은 모든 속성 필터에서 표시
                        } else if (decoData.attr !== buyFilter) {
                            return;
                        }
                    }
                    
                    decorationsByQuality[decoData.quality].push({ key, data: decoData });
                });
                
                // 일반 장식물
                if (decorationsByQuality.common.length > 0) {
                    items.push(`<div style="margin: 20px 0 10px 0; padding: 10px; background: #f0f0f0; color: #333; font-weight: 700; border-radius: 6px;">🏠 일반 장식물</div>`);
                    decorationsByQuality.common.forEach(({ key, data }) => {
                        items.push(`
                            <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px; background: var(--bg); border: 1px solid var(--border); margin-bottom: 10px;">
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <span style="font-size: 1.5rem;">${data.icon}</span>
                                    <div>
                                        <div style="font-weight: 700;">${data.name}</div>
                                        <div style="font-size: 0.85rem; color: #888;">가격: ${data.price}💰 | ${getDecoAttrDisplay(data)}</div>
                                    </div>
                                </div>
                                <button onclick="buyItem('decoration', '${key}', ${data.price})" style="padding: 8px 16px;">구매</button>
                            </div>
                        `);
                    });
                }
                
                // 희귀 장식물
                if (decorationsByQuality.rare.length > 0) {
                    items.push(`<div style="margin: 20px 0 10px 0; padding: 10px; background: #e3f2fd; color: #1565c0; font-weight: 700; border-radius: 6px;">💎 희귀 장식물</div>`);
                    decorationsByQuality.rare.forEach(({ key, data }) => {
                        items.push(`
                            <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px; background: var(--bg); border: 1px solid var(--border); margin-bottom: 10px;">
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <span style="font-size: 1.5rem;">${data.icon}</span>
                                    <div>
                                        <div style="font-weight: 700;">${data.name}</div>
                                        <div style="font-size: 0.85rem; color: #888;">가격: ${data.price}💰 | ${getDecoAttrDisplay(data)}</div>
                                    </div>
                                </div>
                                <button onclick="buyItem('decoration', '${key}', ${data.price})" style="padding: 8px 16px;">구매</button>
                            </div>
                        `);
                    });
                }
                
                // 최상급 장식물
                if (decorationsByQuality.epic.length > 0) {
                    items.push(`<div style="margin: 20px 0 10px 0; padding: 10px; background: #fff3e0; color: #e65100; font-weight: 700; border-radius: 6px;">⭐ 최상급 장식물</div>`);
                    decorationsByQuality.epic.forEach(({ key, data }) => {
                        items.push(`
                            <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px; background: var(--bg); border: 1px solid var(--border); margin-bottom: 10px;">
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <span style="font-size: 1.5rem;">${data.icon}</span>
                                    <div>
                                        <div style="font-weight: 700;">${data.name}</div>
                                        <div style="font-size: 0.85rem; color: #888;">가격: ${data.price}💰 | ${getDecoAttrDisplay(data)}</div>
                                    </div>
                                </div>
                                <button onclick="buyItem('decoration', '${key}', ${data.price})" style="padding: 8px 16px;">구매</button>
                            </div>
                        `);
                    });
                }
            }

            container.innerHTML = items.length > 0 ? items.join('') : '<p style="color: #888; text-align: center; padding: 20px;">구매 가능한 물품이 없습니다</p>';
        }

        function sellItem(category, type) {
            // 이벤트 아이템 체크
            const eventItem = EVENT_ITEMS[type];
            if (eventItem) {
                let inventoryArray;
                if (eventItem.type === 'food') inventoryArray = inventory.food;
                else if (eventItem.type === 'music') inventoryArray = inventory.music;
                else if (eventItem.type === 'decoration') inventoryArray = inventory.decorations;
                
                const index = inventoryArray ? inventoryArray.indexOf(type) : -1;
                if (index === -1) return;
                
                inventoryArray.splice(index, 1);
                const sellPrice = eventItem.type === 'food' ? 15 : eventItem.type === 'music' ? 12 : 25;
                coins += sellPrice;
                showNotification(`🎄 ${eventItem.name}을(를) ${sellPrice}💰에 판매했습니다`);
                setShopkeeperDialogue(`${sellPrice}코인입니다.`);
                
                saveGame();
                renderSellList();
                renderBuyList();
                updateCoinDisplay();
                renderInventory();
                return;
            }
            
            let sellPrice = 0;
            if (category === 'food') {
                const index = inventory.food.indexOf(type);
                if (index === -1) return;
                inventory.food.splice(index, 1);
                const isRare = type === 'light' || type === 'dark';
                sellPrice = isRare ? SHOP_PRICES.sell.food_rare : SHOP_PRICES.sell.food_common;
                coins += sellPrice;
                showNotification(`${FOOD_NAMES[type]}을(를) ${sellPrice}💰에 판매했습니다`);
            } else if (category === 'decoration') {
                const index = inventory.decorations.indexOf(type);
                if (index === -1) return;
                inventory.decorations.splice(index, 1);
                
                const decoData = DECORATION_TYPES[type];
                sellPrice = Math.floor(decoData.price * 0.5);
                coins += sellPrice;
                showNotification(`${decoData.name}을(를) ${sellPrice}💰에 판매했습니다`);
            } else if (category === 'music') {
                const index = inventory.music.indexOf(type);
                if (index === -1) return;
                inventory.music.splice(index, 1);
                sellPrice = SHOP_PRICES.sell.music;
                coins += sellPrice;
                showNotification(`${MUSIC_TYPES[type].name}을(를) ${SHOP_PRICES.sell.music}💰에 판매했습니다`);
            }

            setShopkeeperDialogue(`${sellPrice}코인입니다.`);
            saveGame();
            renderSellList();
            renderBuyList();
            updateCoinDisplay();
            renderInventory();
        }

        function buyItem(category, type, price) {
            if (coins < price) {
                showNotification('코인이 부족합니다!');
                setShopkeeperDialogue('...돈이 부족해 보이네요.');
                return;
            }

            coins -= price;

            if (category === 'food') {
                if (!inventory.food) inventory.food = [];
                inventory.food.push(type);
                if (type === 'medicine') {
                    showNotification(`${MEDICINE.name}을(를) ${price}💰에 구매했습니다`);
                    // 질병 튜토리얼: 약초 구매 액션 체크
                    checkSickTutorialAction('buyMedicine');
                } else {
                    showNotification(`${FOOD_NAMES[type]}을(를) ${price}💰에 구매했습니다`);
                }
            } else if (category === 'music') {
                if (!inventory.music) inventory.music = [];
                inventory.music.push(type);
                showNotification(`${MUSIC_TYPES[type].name}을(를) ${price}💰에 구매했습니다`);
            } else if (category === 'decoration') {
                if (!inventory.decorations) inventory.decorations = [];
                inventory.decorations.push(type);
                showNotification(`${DECORATION_TYPES[type].name}을(를) ${price}💰에 구매했습니다`);
            }

            setShopkeeperDialogue('...감사합니다. 또 오세요.(오지마)');
            saveGame();
            renderSellList();
            renderBuyList();
            updateCoinDisplay();
            renderInventory();
        }
        
        // 이벤트 아이템 구매
        function buyEventItem(itemKey, price) {
            if (coins < price) {
                showNotification('코인이 부족합니다!');
                setShopkeeperDialogue('...돈이 부족해 보이네요.');
                return;
            }
            
            const item = EVENT_ITEMS[itemKey];
            if (!item) {
                showNotification('아이템을 찾을 수 없습니다');
                return;
            }
            
            // 이벤트 기간 체크
            const event = EVENT_TYPES[item.event];
            if (event && event.validUntil && new Date() > new Date(event.validUntil)) {
                showNotification('이벤트 기간이 종료되었습니다');
                return;
            }
            
            coins -= price;
            
            if (item.type === 'food') {
                if (!inventory.food) inventory.food = [];
                inventory.food.push(itemKey);
            } else if (item.type === 'music') {
                if (!inventory.music) inventory.music = [];
                inventory.music.push(itemKey);
            } else if (item.type === 'decoration') {
                if (!inventory.decorations) inventory.decorations = [];
                inventory.decorations.push(itemKey);
            }
            
            showNotification(`🎄 ${item.icon} ${item.name}을(를) ${price}💰에 구매했습니다`);
            setShopkeeperDialogue('...감사합니다. 또 오세요.(오지마)');
            
            saveGame();
            renderSellList();
            renderBuyList();
            updateCoinDisplay();
            renderInventory();
        }

        // 앨범 데이터로부터 도감 재구성
        function rebuildEncyclopediaFromAlbum() {
            console.log('앨범에서 도감 재구성 시작...');
            console.log('앨범 데이터:', collection);
            
            const newEncyclopedia = {};
            
            collection.forEach(spirit => {
                let encyclopediaKey;
                
                if (spirit.type === 'titania' || spirit.type === 'oberon') {
                    // 전설적 존재는 고유 키 사용
                    encyclopediaKey = spirit.type;
                } else if (spirit.type === 'nostat') {
                    // 수식어 없는 정령
                    encyclopediaKey = `nostat-${spirit.attributeType}`;
                } else if (spirit.type && spirit.type.startsWith('fusion-')) {
                    // 교배 정령은 타입 그대로 사용
                    encyclopediaKey = spirit.type;
                } else if (spirit.type && spirit.type.startsWith('event_')) {
                    // 이벤트 정령은 타입 그대로 사용
                    encyclopediaKey = spirit.type;
                } else {
                    // 일반 정령 (스탯-속성)
                    encyclopediaKey = `${spirit.type}-${spirit.attributeType}`;
                }
                
                if (!newEncyclopedia[encyclopediaKey]) {
                    newEncyclopedia[encyclopediaKey] = 0;
                }
                newEncyclopedia[encyclopediaKey]++;
            });
            
            console.log('재구성된 도감:', newEncyclopedia);
            encyclopedia = newEncyclopedia;
            saveGame();
            
            return Object.keys(newEncyclopedia).length;
        }

        async function manualRebuildEncyclopedia() {
            if (collection.length === 0) {
                showNotification('앨범에 데이터가 없어 복구할 수 없습니다');
                return;
            }
            
            const confirmed = await showConfirm(
                '도감 복구',
                `앨범에 있는 ${collection.length}마리의 정령 데이터로 도감을 다시 구성합니다.\n\n기존 도감 데이터는 덮어씌워집니다.\n계속하시겠습니까?`
            );
            
            if (!confirmed) {
                return;
            }
            
            const recoveredCount = rebuildEncyclopediaFromAlbum();
            renderEncyclopedia();
            showNotification(`✅ 도감을 복구했습니다! (${recoveredCount}종)`);
        }
        
        // 앨범 백업 복구 기능
        async function showAlbumBackupRestore() {
            const backups = JSON.parse(localStorage.getItem('spiritGarden_autoBackups') || '[]');
            
            if (backups.length === 0) {
                showNotification('저장된 백업이 없습니다. 정령을 완성하면 자동으로 백업됩니다.');
                return;
            }
            
            // 백업 목록 HTML 생성
            let backupListHtml = '';
            backups.forEach((backup, index) => {
                const date = new Date(backup.timestamp);
                const dateStr = date.toLocaleString('ko-KR', {
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit'
                });
                const albumCount = backup.collection ? backup.collection.length : 0;
                const encyclopediaCount = backup.encyclopedia ? Object.keys(backup.encyclopedia).length : 0;
                const eventCount = backup.collection ? backup.collection.filter(item => item.type && item.type.startsWith('event_')).length : 0;
                
                const eventText = eventCount > 0 ? ' · <span style="color: #c41e3a;">🎄 이벤트 ' + eventCount + '마리</span>' : '';
                
                backupListHtml += '<div style="padding: 16px; background: var(--bg); border-radius: 8px; border: 1px solid var(--border);">' +
                    '<div style="display: flex; justify-content: space-between; align-items: center;">' +
                        '<div>' +
                            '<div style="font-weight: 700; margin-bottom: 4px;">' + dateStr + '</div>' +
                            '<div style="font-size: 0.85rem; color: #888;">' +
                                '앨범: ' + albumCount + '마리 · 도감: ' + encyclopediaCount + '종' + eventText +
                            '</div>' +
                        '</div>' +
                        '<button onclick="restoreAlbumBackup(' + index + ')" style="padding: 8px 16px; background: #333; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">' +
                            '복구' +
                        '</button>' +
                    '</div>' +
                '</div>';
            });
            
            // 백업 목록 모달 표시
            const modal = document.createElement('div');
            modal.className = 'modal active';
            modal.id = 'backupRestoreModal';
            modal.innerHTML = 
                '<div class="modal-content" style="max-width: 600px; max-height: 80vh; overflow-y: auto;">' +
                    '<h3 style="margin-bottom: 16px;">📚 앨범 백업 복구</h3>' +
                    '<p style="margin-bottom: 8px; color: #888;">정령 완성 시 자동 저장된 백업 목록입니다 (최근 10개)</p>' +
                    '<p style="margin-bottom: 16px; color: #e67e22; font-size: 0.85rem;">⚠️ 복구 시 현재 앨범과 도감이 백업 시점으로 덮어씌워집니다.</p>' +
                    '<div style="display: flex; flex-direction: column; gap: 12px; margin-bottom: 20px;">' +
                        backupListHtml +
                    '</div>' +
                    '<div style="display: flex; gap: 12px;">' +
                        '<button onclick="exportAlbumBackup()" style="flex: 1; padding: 12px; background: var(--water); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600;">' +
                            '💾 앨범 백업 다운로드' +
                        '</button>' +
                        '<button onclick="importAlbumBackup()" style="flex: 1; padding: 12px; background: var(--wind); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600;">' +
                            '📂 앨범 백업 불러오기' +
                        '</button>' +
                    '</div>' +
                    '<button onclick="closeBackupModal()" style="width: 100%; margin-top: 16px; padding: 12px; background: #6c757d; color: white; border: none; border-radius: 8px; cursor: pointer;">' +
                        '닫기' +
                    '</button>' +
                '</div>';
            document.body.appendChild(modal);
        }
        
        function closeBackupModal() {
            const modal = document.getElementById('backupRestoreModal');
            if (modal) modal.remove();
        }
        
        async function restoreAlbumBackup(index) {
            const backups = JSON.parse(localStorage.getItem('spiritGarden_autoBackups') || '[]');
            const backup = backups[index];
            
            if (!backup) {
                showNotification('백업을 찾을 수 없습니다.');
                return;
            }
            
            const date = new Date(backup.timestamp).toLocaleString('ko-KR');
            const confirmed = await showConfirm(
                '앨범 복구',
                `${date} 시점의 백업으로 복구하시겠습니까?\n\n앨범: ${backup.collection.length}마리\n도감: ${Object.keys(backup.encyclopedia).length}종\n\n⚠️ 현재 앨범과 도감이 덮어씌워집니다.`
            );
            
            if (!confirmed) return;
            
            collection = backup.collection || [];
            encyclopedia = backup.encyclopedia || {};
            saveGame();
            
            closeBackupModal();
            renderCollection();
            renderEncyclopedia();
            showNotification(`✅ ${date} 시점으로 앨범을 복구했습니다!`);
        }
        
        function exportAlbumBackup() {
            const backupData = {
                exportDate: new Date().toISOString(),
                collection: collection,
                encyclopedia: encyclopedia
            };
            
            const blob = new Blob([JSON.stringify(backupData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `spirit-garden-album-backup-${new Date().toISOString().slice(0,10)}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showNotification('💾 앨범 백업 파일을 다운로드했습니다.');
        }
        
        function importAlbumBackup() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                try {
                    const text = await file.text();
                    const data = JSON.parse(text);
                    
                    if (!data.collection || !Array.isArray(data.collection)) {
                        showNotification('❌ 유효하지 않은 백업 파일입니다.');
                        return;
                    }
                    
                    const confirmed = await showConfirm(
                        '앨범 복구',
                        `백업 파일에서 복구하시겠습니까?\n\n앨범: ${data.collection.length}마리\n도감: ${data.encyclopedia ? Object.keys(data.encyclopedia).length : 0}종\n\n⚠️ 현재 앨범과 도감이 덮어씌워집니다.`
                    );
                    
                    if (!confirmed) return;
                    
                    collection = data.collection;
                    encyclopedia = data.encyclopedia || {};
                    
                    // 도감이 비어있으면 앨범에서 재구성
                    if (Object.keys(encyclopedia).length === 0 && collection.length > 0) {
                        rebuildEncyclopediaFromAlbum();
                    }
                    
                    saveGame();
                    closeBackupModal();
                    renderCollection();
                    renderEncyclopedia();
                    showNotification(`✅ 백업 파일에서 앨범을 복구했습니다!`);
                } catch (err) {
                    console.error('백업 복구 오류:', err);
                    showNotification('❌ 백업 파일을 읽는 중 오류가 발생했습니다.');
                }
            };
            input.click();
        }
        
        // 교배 정령 관리 기능
        async function repairBrokenSpirits() {
            // 교배로 태어난 정령 찾기
            const bredSpirits = spirits.filter(spirit => spirit.isBred || spirit.breedCode);
            
            if (bredSpirits.length === 0) {
                showNotification('교배로 태어난 정령이 없습니다.');
                return;
            }
            
            // 교배 정령 목록 표시
            const modal = document.createElement('div');
            modal.className = 'modal active';
            modal.id = 'repairModal';
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 500px; max-height: 80vh; overflow-y: auto;">
                    <h3 style="margin-bottom: 16px;">🔧 교배 정령 관리</h3>
                    <p style="margin-bottom: 16px; color: #888;">교배로 태어난 정령: ${bredSpirits.length}마리</p>
                    
                    <div style="display: flex; flex-direction: column; gap: 12px; margin-bottom: 20px;">
                        ${bredSpirits.map(spirit => {
                            const stage = getStage(spirit.growth);
                            return `
                            <div style="padding: 12px; background: var(--bg); border-radius: 8px; border: 1px solid var(--border);">
                                <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
                                    <span style="font-size: 1.5rem;">${STAGE_ICONS[stage] || '🥚'}</span>
                                    <div>
                                        <div style="font-weight: 700;">${spirit.name || '이름 없음'}</div>
                                        <div style="font-size: 0.8rem; color: #888;">${STAGE_NAMES[stage] || '알'} · 성장 ${spirit.growth || 0}</div>
                                    </div>
                                </div>
                                <div style="font-size: 0.85rem; color: #888; margin-bottom: 8px;">
                                    🔗 ${spirit.bredWith || '알 수 없음'}의 코드로 교배
                                </div>
                                <div style="display: flex; gap: 8px;">
                                    <button onclick="repairSpirit(${spirit.id})" style="flex: 1; padding: 8px; background: var(--water); color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.85rem;">
                                        🔧 복구
                                    </button>
                                    <button onclick="deleteBrokenSpirit(${spirit.id}, true)" style="flex: 1; padding: 8px; background: #e74c3c; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.85rem;">
                                        🗑️ 삭제 (코드반환)
                                    </button>
                                </div>
                            </div>
                        `}).join('')}
                    </div>
                    
                    <div style="display: flex; gap: 10px;">
                        <button onclick="repairAllSpirits()" style="flex: 1; padding: 12px; background: var(--water); color: white; border: none; border-radius: 8px; cursor: pointer;">
                            🔧 모두 복구
                        </button>
                        <button onclick="closeRepairModal()" style="flex: 1; padding: 12px; background: var(--card); border: 1px solid var(--border); border-radius: 8px; cursor: pointer;">
                            닫기
                        </button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }
        
        function closeRepairModal() {
            const modal = document.getElementById('repairModal');
            if (modal) modal.remove();
        }
        
        function repairSpirit(spiritId) {
            const spirit = spirits.find(s => String(s.id) === String(spiritId));
            if (!spirit) {
                showNotification('❌ 정령을 찾을 수 없습니다');
                return;
            }
            
            const timestamp = new Date().toLocaleString('ko-KR', {
                month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit'
            });
            
            // 필수 필드 복구
            if (!spirit.parameters) {
                spirit.parameters = { intelligence: 0, strength: 0, charm: 0, affection: 0 };
            }
            if (spirit.parameters.affection === undefined) spirit.parameters.affection = 0;
            
            if (!spirit.hiddenAttributes) {
                spirit.hiddenAttributes = { fire: 0, water: 0, wind: 0, earth: 0, light: 0, dark: 0 };
            }
            
            if (!spirit.satisfaction) spirit.satisfaction = 'mid';
            if (!spirit.status) spirit.status = '복구되었습니다';
            if (!spirit.birthTime) spirit.birthTime = Date.now();
            if (!spirit.lastInteraction) spirit.lastInteraction = Date.now();
            if (spirit.lightTime === undefined) spirit.lightTime = 0;
            if (spirit.darkTime === undefined) spirit.darkTime = 0;
            if (spirit.musicListened === undefined) spirit.musicListened = 0;
            if (spirit.feedCount === undefined) spirit.feedCount = 0;
            if (spirit.growth === undefined) spirit.growth = 0;
            
            // logs 형식 복구
            if (!spirit.logs) {
                spirit.logs = [];
            } else if (spirit.logs.length > 0 && typeof spirit.logs[0] === 'string') {
                // 문자열 배열을 객체 배열로 변환
                spirit.logs = spirit.logs.map(msg => ({
                    time: timestamp,
                    message: msg
                }));
            }
            
            // 복구 로그 추가
            spirit.logs.unshift({ time: timestamp, message: '🔧 데이터가 복구되었습니다.' });
            
            saveGame();
            renderSpirits();
            closeRepairModal();
            showNotification(`✅ ${spirit.name} 복구 완료!`);
        }
        
        function repairAllSpirits() {
            const bredSpirits = spirits.filter(spirit => spirit.isBred || spirit.breedCode);
            
            bredSpirits.forEach(spirit => {
                repairSpiritSilent(spirit);
            });
            
            saveGame();
            renderSpirits();
            closeRepairModal();
            showNotification(`✅ ${bredSpirits.length}마리 정령 복구 완료!`);
        }
        
        function repairSpiritSilent(spirit) {
            const timestamp = new Date().toLocaleString('ko-KR', {
                month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit'
            });
            
            if (!spirit.parameters) {
                spirit.parameters = { intelligence: 0, strength: 0, charm: 0, affection: 0 };
            }
            if (spirit.parameters.affection === undefined) spirit.parameters.affection = 0;
            
            if (!spirit.hiddenAttributes) {
                spirit.hiddenAttributes = { fire: 0, water: 0, wind: 0, earth: 0, light: 0, dark: 0 };
            }
            
            if (!spirit.satisfaction) spirit.satisfaction = 'mid';
            if (!spirit.status) spirit.status = '복구되었습니다';
            if (!spirit.birthTime) spirit.birthTime = Date.now();
            if (!spirit.lastInteraction) spirit.lastInteraction = Date.now();
            if (spirit.lightTime === undefined) spirit.lightTime = 0;
            if (spirit.darkTime === undefined) spirit.darkTime = 0;
            if (spirit.musicListened === undefined) spirit.musicListened = 0;
            if (spirit.feedCount === undefined) spirit.feedCount = 0;
            if (spirit.growth === undefined) spirit.growth = 0;
            
            if (!spirit.logs) {
                spirit.logs = [];
            } else if (spirit.logs.length > 0 && typeof spirit.logs[0] === 'string') {
                spirit.logs = spirit.logs.map(msg => ({ time: timestamp, message: msg }));
            }
            
            spirit.logs.unshift({ time: timestamp, message: '🔧 데이터가 복구되었습니다.' });
        }
        
        function deleteBrokenSpirit(spiritId, returnCode) {
            const spirit = spirits.find(s => String(s.id) === String(spiritId));
            if (!spirit) {
                console.log('Spirit not found:', spiritId);
                showNotification('❌ 정령을 찾을 수 없습니다');
                return;
            }
            
            if (returnCode && spirit.breedCode) {
                // 앨범에서도 해당 코드 사용 기록 제거
                if (collection) {
                    collection.forEach(s => {
                        if (s.breedCode === spirit.breedCode) {
                            delete s.breedCode;
                        }
                    });
                }
                showNotification('🔄 교배 코드가 반환되었습니다!');
            }
            
            spirits = spirits.filter(s => String(s.id) !== String(spiritId));
            saveGame();
            renderSpirits();
            closeRepairModal();
            showNotification(`🗑️ ${spirit.name} 삭제 완료`);
        }

        // ========== 합성 시스템 ==========
        
        function switchFusionMode(mode) {
            const localBtn = document.getElementById('fusionModeLocal');
            const shareBtn = document.getElementById('fusionModeShare');
            const localPanel = document.getElementById('localFusionPanel');
            const sharePanel = document.getElementById('shareFusionPanel');
            
            if (mode === 'local') {
                localBtn.style.background = 'var(--text)';
                localBtn.style.color = 'var(--bg)';
                shareBtn.style.background = 'var(--card)';
                shareBtn.style.color = 'var(--text)';
                localPanel.style.display = 'block';
                sharePanel.style.display = 'none';
            } else {
                localBtn.style.background = 'var(--card)';
                localBtn.style.color = 'var(--text)';
                shareBtn.style.background = 'var(--text)';
                shareBtn.style.color = 'var(--bg)';
                localPanel.style.display = 'none';
                sharePanel.style.display = 'block';
                updateShareSpiritList();
            }
        }
        
        function getCompletedSpirits() {
            // 현재 육성 중인 완성 정령
            const currentCompleted = spirits.filter(s => s.isCompleted && !s.isDead);
            
            // 앨범에 있는 완성 정령 (id가 없으면 생성)
            const albumSpirits = (collection || []).map((s, index) => ({
                ...s,
                id: s.id || `album-${index}`,
                isFromAlbum: true,
                isCompleted: true
            }));
            
            return [...currentCompleted, ...albumSpirits];
        }
        
        function getCompletedSpiritsForBreeding() {
            // 교배용: 현재 육성 중인 완성 정령 + 앨범 정령 (합성으로 떠난 정령 제외)
            const currentCompleted = spirits.filter(s => s.isCompleted && !s.isDead);
            
            const albumSpirits = (collection || [])
                .filter(s => !s.fusedAway) // 합성으로 떠난 정령 제외
                .map((s, index) => ({
                    ...s,
                    id: s.id || `album-${index}`,
                    isFromAlbum: true,
                    isCompleted: true
                }));
            
            return [...currentCompleted, ...albumSpirits];
        }
        
        function selectFusionSpirit(slot) {
            const completed = getCompletedSpirits();
            if (completed.length === 0) {
                showNotification('❌ 완성된 정령이 없습니다');
                return;
            }
            
            // 이미 다른 슬롯에 선택된 정령 제외
            const otherSlotSpirit = slot === 1 ? fusionSlot2Spirit : fusionSlot1Spirit;
            const available = completed.filter(s => !otherSlotSpirit || s.id !== otherSlotSpirit.id);
            
            if (available.length === 0) {
                showNotification('❌ 선택 가능한 정령이 없습니다');
                return;
            }
            
            // 선택 모달 표시
            const modalHtml = `
                <div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 10000; display: flex; justify-content: center; align-items: center;">
                    <div style="background: var(--card); padding: 24px; border-radius: 12px; max-width: 400px; width: 90%; max-height: 70vh; overflow-y: auto;">
                        <h3 style="margin-bottom: 16px;">정령 선택 (슬롯 ${slot})</h3>
                        <div style="display: flex; flex-direction: column; gap: 10px;">
                            ${available.map(s => {
                                const attrName = ATTRIBUTE_NAMES[s.attribute] || ATTRIBUTE_NAMES.normal;
                                return `
                                    <div onclick="confirmFusionSpirit(${slot}, '${s.id}')" style="display: flex; align-items: center; gap: 12px; padding: 12px; background: var(--bg); border-radius: 8px; cursor: pointer; transition: transform 0.2s;" onmouseover="this.style.transform='scale(1.02)'" onmouseout="this.style.transform='scale(1)'">
                                        <span style="font-size: 2rem;">${getSpiritEmoji(s)}</span>
                                        <div>
                                            <div style="font-weight: 700;">${s.name}</div>
                                            <div style="font-size: 0.85rem; color: #888;">${attrName.icon} ${attrName.name}</div>
                                            <div style="font-size: 0.8rem; color: #666;">💖 애정도: ${s.parameters?.affection || 0}</div>
                                        </div>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                        <button onclick="closeFusionModal()" style="margin-top: 16px; width: 100%; padding: 12px; background: var(--border); border: none; border-radius: 6px; cursor: pointer;">취소</button>
                    </div>
                </div>
            `;
            
            const modal = document.createElement('div');
            modal.id = 'fusionSelectModal';
            modal.innerHTML = modalHtml;
            document.body.appendChild(modal);
        }
        
        function closeFusionModal() {
            const modal = document.getElementById('fusionSelectModal');
            if (modal) modal.remove();
        }
        
        function confirmFusionSpirit(slot, spiritId) {
            const spirit = spirits.find(s => s.id === spiritId);
            if (!spirit) return;
            
            if (slot === 1) {
                fusionSlot1Spirit = spirit;
            } else {
                fusionSlot2Spirit = spirit;
            }
            
            closeFusionModal();
            updateFusionSlots();
        }
        
        function updateFusionSlots() {
            const slot1 = document.getElementById('fusionSlot1');
            const slot2 = document.getElementById('fusionSlot2');
            const result = document.getElementById('fusionResult');
            const info = document.getElementById('fusionInfo');
            const btn = document.getElementById('fusionBtn');
            
            // 슬롯 1 업데이트
            if (fusionSlot1Spirit) {
                const attr1 = ATTRIBUTE_NAMES[fusionSlot1Spirit.attribute] || ATTRIBUTE_NAMES.normal;
                slot1.innerHTML = `
                    <div style="font-size: 2.5rem;">${getSpiritEmoji(fusionSlot1Spirit)}</div>
                    <div style="font-weight: 700; font-size: 0.9rem;">${fusionSlot1Spirit.name}</div>
                    <div style="font-size: 0.8rem; color: #888;">${attr1.icon} ${attr1.name}</div>
                `;
                slot1.style.borderStyle = 'solid';
                slot1.style.background = 'linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1))';
            } else {
                slot1.innerHTML = `
                    <div style="font-size: 3rem; opacity: 0.3;">🥚</div>
                    <div style="color: #888; font-size: 0.9rem;">정령 선택</div>
                `;
                slot1.style.borderStyle = 'dashed';
                slot1.style.background = 'transparent';
            }
            
            // 슬롯 2 업데이트
            if (fusionSlot2Spirit) {
                const attr2 = ATTRIBUTE_NAMES[fusionSlot2Spirit.attribute] || ATTRIBUTE_NAMES.normal;
                slot2.innerHTML = `
                    <div style="font-size: 2.5rem;">${getSpiritEmoji(fusionSlot2Spirit)}</div>
                    <div style="font-weight: 700; font-size: 0.9rem;">${fusionSlot2Spirit.name}</div>
                    <div style="font-size: 0.8rem; color: #888;">${attr2.icon} ${attr2.name}</div>
                `;
                slot2.style.borderStyle = 'solid';
                slot2.style.background = 'linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1))';
            } else {
                slot2.innerHTML = `
                    <div style="font-size: 3rem; opacity: 0.3;">🥚</div>
                    <div style="color: #888; font-size: 0.9rem;">정령 선택</div>
                `;
                slot2.style.borderStyle = 'dashed';
                slot2.style.background = 'transparent';
            }
            
            // 결과 예측
            if (fusionSlot1Spirit && fusionSlot2Spirit) {
                const prediction = predictFusionResult(fusionSlot1Spirit, fusionSlot2Spirit);
                result.innerHTML = `
                    <div style="font-size: 2.5rem;">${prediction.icon}</div>
                    <div style="font-weight: 700; font-size: 0.9rem;">${prediction.name}</div>
                    <div style="font-size: 0.75rem; color: ${getRarityColor(prediction.rarity)};">${getRarityText(prediction.rarity)}</div>
                `;
                result.style.background = 'linear-gradient(135deg, rgba(255,215,0,0.2), rgba(255,255,255,0.1))';
                
                // 애정도 체크
                const affection1 = fusionSlot1Spirit.parameters?.affection || 0;
                const affection2 = fusionSlot2Spirit.parameters?.affection || 0;
                const minAffection = 50;
                
                if (affection1 < minAffection || affection2 < minAffection) {
                    info.innerHTML = `❌ 두 정령 모두 애정도 ${minAffection} 이상이어야 합니다.<br>(${fusionSlot1Spirit.name}: ${affection1}, ${fusionSlot2Spirit.name}: ${affection2})`;
                    info.style.color = '#e74c3c';
                    btn.disabled = true;
                    btn.style.opacity = '0.5';
                } else if (coins < FUSION_COST) {
                    info.innerHTML = `❌ 코인이 부족합니다. (필요: ${FUSION_COST}💰, 보유: ${coins}💰)`;
                    info.style.color = '#e74c3c';
                    btn.disabled = true;
                    btn.style.opacity = '0.5';
                } else {
                    info.innerHTML = `✅ 합성 준비 완료! 두 정령은 자연으로 돌아가고 새 알이 태어납니다.`;
                    info.style.color = '#27ae60';
                    btn.disabled = false;
                    btn.style.opacity = '1';
                }
            } else {
                result.innerHTML = `
                    <div style="font-size: 3rem; opacity: 0.3;">❓</div>
                    <div style="color: #888; font-size: 0.9rem;">결과</div>
                `;
                result.style.background = 'linear-gradient(135deg, rgba(255,215,0,0.1), rgba(255,255,255,0.1))';
                info.innerHTML = '두 정령을 선택해주세요.';
                info.style.color = '#888';
                btn.disabled = true;
                btn.style.opacity = '0.5';
            }
        }
        
        function getMainAttribute(spirit) {
            const attrs = spirit.attributes || {};
            let maxAttr = 'normal';
            let maxVal = 0;
            
            ['fire', 'water', 'wind', 'earth', 'light', 'dark'].forEach(attr => {
                if ((attrs[attr] || 0) > maxVal) {
                    maxVal = attrs[attr] || 0;
                    maxAttr = attr;
                }
            });
            
            return maxVal >= 50 ? maxAttr : 'normal';
        }
        
        function getStatType(spirit) {
            const params = spirit.parameters || {};
            const intel = params.intelligence || 0;
            const str = params.strength || 0;
            const charm = params.charm || 0;
            
            if (intel > str && intel > charm && intel >= 70) return 'intelligent';
            if (str > intel && str > charm && str >= 70) return 'strong';
            if (charm > intel && charm > str && charm >= 70) return 'beautiful';
            return null;
        }
        
        function predictFusionResult(spirit1, spirit2) {
            const attr1 = getMainAttribute(spirit1);
            const attr2 = getMainAttribute(spirit2);
            const stat1 = getStatType(spirit1);
            const stat2 = getStatType(spirit2);
            
            // 1. 스탯 기반 합성 체크
            if (stat1 && stat2 && stat1 === stat2) {
                const fusionKey = `fusion-${stat1 === 'intelligent' ? 'sage' : stat1 === 'strong' ? 'titan' : 'siren'}`;
                if (FUSION_TYPES[fusionKey]) {
                    return { ...FUSION_TYPES[fusionKey], key: fusionKey };
                }
            }
            
            // 2. 속성 기반 합성 체크
            // 정확한 레시피 매칭
            for (const [key, fusion] of Object.entries(FUSION_TYPES)) {
                const recipe = fusion.recipe;
                if ((recipe[0] === attr1 && recipe[1] === attr2) ||
                    (recipe[0] === attr2 && recipe[1] === attr1)) {
                    return { ...fusion, key };
                }
            }
            
            // 3. 기본 결과 - 부모 중 하나의 속성 랜덤 계승
            const inheritedAttr = Math.random() > 0.5 ? attr1 : attr2;
            const attrInfo = ATTRIBUTE_NAMES[inheritedAttr] || ATTRIBUTE_NAMES.normal;
            return {
                name: attrInfo.name,
                icon: attrInfo.icon,
                desc: attrInfo.desc,
                rarity: 'common',
                inheritedAttr
            };
        }
        
        function getRarityColor(rarity) {
            switch(rarity) {
                case 'mythic': return '#ff00ff';
                case 'legendary': return '#ff6b35';
                case 'epic': return '#9b59b6';
                case 'rare': return '#3498db';
                case 'event': return '#c41e3a';
                default: return '#888';
            }
        }
        
        function getRarityText(rarity) {
            switch(rarity) {
                case 'mythic': return '🌌 신화';
                case 'legendary': return '⭐ 전설';
                case 'epic': return '💜 에픽';
                case 'rare': return '💙 레어';
                case 'event': return '🎄 이벤트';
                default: return '일반';
            }
        }
        
        async function performFusion() {
            if (!fusionSlot1Spirit || !fusionSlot2Spirit) return;
            
            const affection1 = fusionSlot1Spirit.parameters?.affection || 0;
            const affection2 = fusionSlot2Spirit.parameters?.affection || 0;
            
            if (affection1 < 50 || affection2 < 50) {
                showNotification('❌ 애정도가 부족합니다');
                return;
            }
            
            if (coins < FUSION_COST) {
                showNotification('❌ 코인이 부족합니다');
                return;
            }
            
            const confirm = await showConfirm('정령 합성', 
                `${fusionSlot1Spirit.name}와(과) ${fusionSlot2Spirit.name}을(를) 합성하시겠습니까?\n\n두 정령은 자연으로 돌아가고 새 알이 태어납니다.\n비용: ${FUSION_COST}💰`);
            
            if (!confirm) return;
            
            // 결과 계산
            const result = predictFusionResult(fusionSlot1Spirit, fusionSlot2Spirit);
            
            // 스탯 계승 (부모 평균의 50~80%)
            const inheritRatio = 0.5 + Math.random() * 0.3;
            const newParams = {
                intelligence: Math.floor(((fusionSlot1Spirit.parameters?.intelligence || 0) + (fusionSlot2Spirit.parameters?.intelligence || 0)) / 2 * inheritRatio),
                strength: Math.floor(((fusionSlot1Spirit.parameters?.strength || 0) + (fusionSlot2Spirit.parameters?.strength || 0)) / 2 * inheritRatio),
                charm: Math.floor(((fusionSlot1Spirit.parameters?.charm || 0) + (fusionSlot2Spirit.parameters?.charm || 0)) / 2 * inheritRatio),
                affection: 0
            };
            
            // 부모 정령 제거 (앨범에 추가)
            [fusionSlot1Spirit, fusionSlot2Spirit].forEach(parent => {
                // 앨범에 추가
                collection.push({
                    id: `album-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`, // 고유 ID
                    name: parent.name,
                    type: parent.evolutionType || 'normal',
                    attribute: parent.attribute,
                    parameters: { ...parent.parameters },
                    attributes: { ...parent.attributes },
                    completedAt: new Date().toISOString(),
                    fusedAway: true // 합성으로 떠남 표시
                });
                
                // spirits에서 제거
                const idx = spirits.findIndex(s => s.id === parent.id);
                if (idx !== -1) spirits.splice(idx, 1);
            });
            
            // 새 알 생성
            const newAttribute = result.inheritedAttr || getMainAttribute(fusionSlot1Spirit);
            const isFusionType = result.key && FUSION_TYPES[result.key];
            
            const newSpirit = {
                id: Date.now().toString(),
                name: isFusionType ? result.name : generateSpiritName(),
                stage: 'egg',
                growth: 0,
                parameters: newParams,
                attributes: {},
                createdAt: new Date().toISOString(),
                logs: [`🧬 ${fusionSlot1Spirit.name}와(과) ${fusionSlot2Spirit.name}의 합성으로 태어났습니다.`],
                fusionType: result.key || null, // 합성 타입 저장
                fusionRarity: result.rarity || 'common'
            };
            
            // 초기 속성 설정 (합성 타입이면 특별 속성)
            if (isFusionType) {
                // 합성 전용 정령은 부모 속성 합
                const attrs1 = fusionSlot1Spirit.attributes || {};
                const attrs2 = fusionSlot2Spirit.attributes || {};
                ['fire', 'water', 'wind', 'earth', 'light', 'dark'].forEach(attr => {
                    newSpirit.attributes[attr] = Math.floor(((attrs1[attr] || 0) + (attrs2[attr] || 0)) / 2);
                });
            }
            
            spirits.push(newSpirit);
            coins -= FUSION_COST;
            
            // 합성 도감 등록
            if (isFusionType && result.key) {
                if (!encyclopedia[result.key]) {
                    encyclopedia[result.key] = { firstSeen: new Date().toISOString(), count: 1 };
                    showNotification(`🎉 새로운 합성 정령 "${result.name}" 도감 등록!`);
                } else {
                    encyclopedia[result.key].count++;
                }
            }
            
            // 초기화
            fusionSlot1Spirit = null;
            fusionSlot2Spirit = null;
            
            saveGame();
            updateFusionSlots();
            renderSpirits();
            renderFusionEncyclopedia();
            updateCoinDisplay();
            
            showNotification(`🧬 합성 성공! ${result.name}의 알이 태어났습니다!`);
        }
        
        function renderFusionEncyclopedia() {
            const container = document.getElementById('fusionEncyclopedia');
            if (!container) return;
            
            const entries = Object.entries(FUSION_TYPES).map(([key, data]) => {
                const discovered = encyclopedia[key];
                return `
                    <div style="padding: 12px; background: ${discovered ? 'var(--bg)' : 'rgba(0,0,0,0.3)'}; border: 1px solid ${discovered ? getRarityColor(data.rarity) : 'var(--border)'}; border-radius: 8px; text-align: center;">
                        <div style="font-size: 2rem; ${discovered ? '' : 'filter: grayscale(1); opacity: 0.3;'}">${data.icon}</div>
                        <div style="font-weight: 700; font-size: 0.85rem; margin-top: 4px; ${discovered ? '' : 'color: #666;'}">${discovered ? data.name : '???'}</div>
                        <div style="font-size: 0.75rem; color: ${getRarityColor(data.rarity)};">${getRarityText(data.rarity)}</div>
                        ${discovered ? `<div style="font-size: 0.7rem; color: #888; margin-top: 4px;">x${discovered.count}</div>` : ''}
                    </div>
                `;
            });
            
            container.innerHTML = entries.join('');
        }
        
        // ========== 교배 코드 공유 시스템 ==========
        
        function updateShareSpiritList() {
            const select1 = document.getElementById('shareSpritSelect');
            const select2 = document.getElementById('myBreedSpirit');
            const completed = getCompletedSpiritsForBreeding();
            
            const options = completed.map(s => {
                const attr = ATTRIBUTE_NAMES[s.attribute] || ATTRIBUTE_NAMES.normal;
                const affection = s.parameters?.affection || 0;
                const fromAlbum = s.isFromAlbum ? ' [앨범]' : '';
                const affectionMark = affection >= 50 ? '💕' : '💔';
                return `<option value="${s.id}">${s.name} (${attr.icon} ${affectionMark}${affection})${fromAlbum}</option>`;
            }).join('');
            
            if (select1) select1.innerHTML = '<option value="">완성된 정령 선택...</option>' + options;
            if (select2) select2.innerHTML = '<option value="">내 정령 선택...</option>' + options;
        }
        
        function encodeSpiritData(spirit) {
            const data = {
                id: spirit.id || null, // 고유 ID 추가
                n: spirit.name,
                o: spirit.originalName || spirit.name, // 본명 추가
                a: spirit.attribute,
                t: spirit.evolutionType || 'normal',
                i: spirit.parameters?.intelligence || 0,
                s: spirit.parameters?.strength || 0,
                c: spirit.parameters?.charm || 0,
                at: spirit.attributes || {},
                ts: Date.now(),
                // 이벤트 정령 정보
                ev: spirit.isEventSpirit ? spirit.eventType : null
            };
            
            try {
                const json = JSON.stringify(data);
                const base64 = btoa(unescape(encodeURIComponent(json)));
                return 'SG1-' + base64;
            } catch (e) {
                console.error('인코딩 오류:', e);
                return null;
            }
        }
        
        function decodeSpiritData(code) {
            try {
                if (!code.startsWith('SG1-')) return null;
                const base64 = code.substring(4);
                const json = decodeURIComponent(escape(atob(base64)));
                const data = JSON.parse(json);
                
                // 유효성 검사
                if (!data.n || !data.ts) return null;
                
                return {
                    id: data.id || null, // 고유 ID 추가
                    name: data.n,
                    originalName: data.o || data.n, // 본명 추가
                    attribute: data.a || 'normal',
                    evolutionType: data.t || 'normal',
                    parameters: {
                        intelligence: data.i || 0,
                        strength: data.s || 0,
                        charm: data.c || 0
                    },
                    attributes: data.at || {},
                    // 이벤트 정령 정보
                    isEventSpirit: !!data.ev,
                    eventType: data.ev || null
                };
            } catch (e) {
                console.error('디코딩 오류:', e);
                return null;
            }
        }
        
        function updateShareCode() {
            const select = document.getElementById('shareSpritSelect');
            const display = document.getElementById('shareCodeDisplay');
            const input = document.getElementById('shareCodeInput');
            
            if (!select.value) {
                display.style.display = 'none';
                return;
            }
            
            // 현재 정령 또는 앨범에서 찾기
            const allCompleted = getCompletedSpiritsForBreeding();
            const spirit = allCompleted.find(s => s.id === select.value);
            if (!spirit) return;
            
            const code = encodeSpiritData(spirit);
            if (code) {
                input.value = code;
                display.style.display = 'flex';
            }
        }
        
        function copyShareCode() {
            const input = document.getElementById('shareCodeInput');
            input.select();
            document.execCommand('copy');
            showNotification('📋 코드가 복사되었습니다!');
        }
        
        // 친구 코드 입력 시 미리보기
        document.addEventListener('DOMContentLoaded', () => {
            const friendInput = document.getElementById('friendCodeInput');
            if (friendInput) {
                friendInput.addEventListener('input', () => {
                    const preview = document.getElementById('friendCodePreview');
                    const code = friendInput.value.trim();
                    
                    if (!code) {
                        preview.style.display = 'none';
                        updateBreedPreview();
                        return;
                    }
                    
                    const data = decodeSpiritData(code);
                    if (!data) {
                        preview.innerHTML = '❌ 유효하지 않은 코드입니다.';
                        preview.style.display = 'block';
                        preview.style.color = '#e74c3c';
                        document.getElementById('breedPreview').style.display = 'none';
                    } else {
                        const attr = ATTRIBUTE_NAMES[data.attribute] || ATTRIBUTE_NAMES.normal;
                        
                        // 속성치 표시
                        const friendAttrs = data.attributes || {};
                        const attrDisplay = [];
                        ['fire', 'water', 'wind', 'earth', 'light', 'dark'].forEach(a => {
                            if (friendAttrs[a] && friendAttrs[a] > 0) {
                                attrDisplay.push(`${ENV_ICONS[a]}${friendAttrs[a]}`);
                            }
                        });
                        
                        // 본명이 현재 이름과 다르면 표시
                        const originalNameDisplay = (data.originalName && data.originalName !== data.name) 
                            ? `<div style="color: #aaa; font-size: 0.8rem; font-style: italic;">본명: ${data.originalName}</div>` 
                            : '';
                        
                        preview.innerHTML = `
                            <div style="display: flex; align-items: center; gap: 12px;">
                                <div style="font-size: 2.5rem;">${attr.icon}</div>
                                <div style="flex: 1;">
                                    <div style="font-weight: 700; font-size: 1.1rem;">✅ ${data.name}</div>
                                    ${originalNameDisplay}
                                    <div style="color: #888; font-size: 0.85rem;">${attr.name}</div>
                                    <div style="margin-top: 6px; font-size: 0.9rem;">
                                        🧠 ${data.parameters.intelligence} | 💪 ${data.parameters.strength} | 💖 ${data.parameters.charm}
                                    </div>
                                    ${attrDisplay.length > 0 ? `<div style="margin-top: 4px; font-size: 0.85rem;">${attrDisplay.join(' ')}</div>` : ''}
                                </div>
                            </div>
                        `;
                        preview.style.display = 'block';
                        preview.style.color = 'var(--text)';
                        updateBreedPreview();
                    }
                });
            }
        });
        
        async function breedWithCode() {
            const mySelect = document.getElementById('myBreedSpirit');
            const codeInput = document.getElementById('friendCodeInput');
            const breedCode = codeInput.value.trim();
            
            if (!mySelect.value) {
                showNotification('❌ 내 정령을 선택해주세요');
                return;
            }
            
            // 정령 슬롯 체크 (최대 6마리)
            if (spirits.length >= 6) {
                showNotification('❌ 정원이 가득 찼습니다! (최대 6마리) 정령을 자연으로 보내주세요.');
                return;
            }
            
            // 중복 코드 체크 (이미 사용된 코드인지)
            const allSpiritsAndAlbum = [...spirits, ...(collection || [])];
            const usedCode = allSpiritsAndAlbum.find(s => s.breedCode === breedCode);
            if (usedCode) {
                showNotification('❌ 이미 사용된 교배 코드입니다!');
                return;
            }
            
            // 현재 정령 또는 앨범에서 찾기
            const allCompleted = getCompletedSpiritsForBreeding();
            const mySpirit = allCompleted.find(s => s.id === mySelect.value);
            if (!mySpirit) {
                showNotification('❌ 정령을 찾을 수 없습니다');
                return;
            }
            
            const friendData = decodeSpiritData(breedCode);
            if (!friendData) {
                showNotification('❌ 유효하지 않은 코드입니다');
                return;
            }
            
            // 애정도 체크
            const myAffection = mySpirit.parameters?.affection || 0;
            if (myAffection < 50) {
                showNotification(`❌ 내 정령의 애정도가 부족합니다 (현재: ${myAffection}, 필요: 50)`);
                return;
            }
            
            if (coins < BREED_COST) {
                showNotification(`❌ 코인이 부족합니다 (필요: ${BREED_COST}💰)`);
                return;
            }
            
            // 결과 예측
            const prediction = predictBreedResult(mySpirit, friendData);
            
            const confirm = await showConfirm('교배 확인',
                `${mySpirit.name}와(과) ${friendData.name}(친구 정령)을(를) 교배하시겠습니까?\n\n예상 결과: ${prediction.name} (${getRarityText(prediction.rarity)})\n내 정령은 유지되고 새 알이 태어납니다.\n비용: ${BREED_COST}💰`);
            
            if (!confirm) return;
            
            // 교배 결과 계산 (부모 스탯 평균의 50% 계승)
            const newParams = {
                intelligence: Math.floor(((mySpirit.parameters?.intelligence || 0) + (friendData.parameters?.intelligence || 0)) / 2),
                strength: Math.floor(((mySpirit.parameters?.strength || 0) + (friendData.parameters?.strength || 0)) / 2),
                charm: Math.floor(((mySpirit.parameters?.charm || 0) + (friendData.parameters?.charm || 0)) / 2),
                affection: 0
            };
            
            // 부모 속성 평균 계승
            const myAttrs = mySpirit.attributes || {};
            const friendAttrs = friendData.attributes || {};
            const newAttrs = {};
            ['fire', 'water', 'wind', 'earth', 'light', 'dark'].forEach(attr => {
                const avg = Math.floor(((myAttrs[attr] || 0) + (friendAttrs[attr] || 0)) / 2);
                if (avg > 0) newAttrs[attr] = avg;
            });
            
            // 합성 타입 정령인지 확인
            const isFusionType = prediction.key && FUSION_TYPES[prediction.key];
            
            // 상속 정보 문자열 생성
            const inheritInfo = [];
            if (newParams.intelligence > 0) inheritInfo.push(`🧠${newParams.intelligence}`);
            if (newParams.strength > 0) inheritInfo.push(`💪${newParams.strength}`);
            if (newParams.charm > 0) inheritInfo.push(`💖${newParams.charm}`);
            const attrInfo = Object.entries(newAttrs).map(([k, v]) => `${ENV_ICONS[k]}${v}`).join(' ');
            
            // 로그 시간 포맷
            const timestamp = new Date().toLocaleString('ko-KR', {
                month: '2-digit',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit'
            });
            
            // 새 알 생성 (createNewSpirit과 동일한 구조)
            const newSpirit = {
                id: Date.now(),
                name: isFusionType ? prediction.name : generateSpiritName(),
                originalName: null,
                growth: 0,
                // 공개 스탯 (부모에게서 상속)
                parameters: newParams,
                // 숨겨진 속성 (부모에게서 상속)
                hiddenAttributes: {
                    fire: newAttrs.fire || 0,
                    water: newAttrs.water || 0,
                    wind: newAttrs.wind || 0,
                    earth: newAttrs.earth || 0,
                    light: newAttrs.light || 0,
                    dark: newAttrs.dark || 0
                },
                satisfaction: 'mid',
                lastFed: null,
                lastMusic: null,
                lastPat: null,
                lastDecorate: null,
                lastInteraction: Date.now(),
                status: '알이 따뜻합니다...',
                birthTime: Date.now(),
                logs: [
                    { time: timestamp, message: `🔗 ${mySpirit.name}와(과) ${friendData.name}의 교배로 태어났습니다.` },
                    { time: timestamp, message: `📊 부모에게서 물려받은 능력: ${inheritInfo.join(' ')} ${attrInfo}` }
                ],
                lightTime: 0,
                darkTime: 0,
                musicListened: 0,
                feedCount: 0,
                // 교배 관련 정보
                bredWith: friendData.name,
                breedCode: breedCode,
                fusionType: prediction.key || null,
                fusionRarity: prediction.rarity || 'common',
                isBred: true
            };
            
            spirits.push(newSpirit);
            coins -= BREED_COST;
            
            console.log('🥚 새 알 생성됨:', newSpirit);
            console.log('📋 현재 spirits:', spirits);
            
            // 합성 도감 등록
            if (isFusionType && prediction.key) {
                if (!encyclopedia[prediction.key]) {
                    encyclopedia[prediction.key] = { firstSeen: new Date().toISOString(), count: 1 };
                    showNotification(`🎉 새로운 교배 정령 "${prediction.name}" 도감 등록!`);
                } else {
                    encyclopedia[prediction.key].count++;
                }
            }
            
            saveGame();
            renderSpirits();
            updateCoinDisplay();
            renderFusionEncyclopedia();
            
            showNotification(`🎉 교배 성공! ${isFusionType ? prediction.name : newSpirit.name}이(가) 태어났습니다!`);
            
            // 입력 초기화
            codeInput.value = '';
            mySelect.value = '';
            document.getElementById('friendCodePreview').style.display = 'none';
            document.getElementById('breedPreview').style.display = 'none';
            
            // 정원 탭으로 이동해서 새 알 보여주기
            switchTab('garden');
        }
        
        function predictBreedResult(mySpirit, friendData) {
            // 티타니아 + 오베론 교배 체크 (오블리비온)
            const myType = mySpirit.type || mySpirit.evolutionType;
            const friendType = friendData.evolutionType || friendData.type;
            
            if ((myType === 'titania' && friendType === 'oberon') ||
                (myType === 'oberon' && friendType === 'titania')) {
                return { ...FUSION_TYPES['fusion-oblivion'], key: 'fusion-oblivion' };
            }
            
            // 이벤트 정령 교배 - 둘 중 하나라도 이벤트 정령이면 이벤트 정령으로
            const myEventType = mySpirit.isEventSpirit ? mySpirit.eventType : null;
            const friendEventType = friendData.isEventSpirit ? friendData.eventType : null;
            
            if (myEventType || friendEventType) {
                // 이벤트 정령 우선 (둘 다 이벤트면 내 정령 우선)
                const eventType = myEventType || friendEventType;
                const event = EVENT_TYPES[eventType];
                if (event) {
                    return {
                        name: event.name,
                        icon: event.stages.egg,
                        desc: event.desc,
                        rarity: 'event',
                        isEventResult: true,
                        eventType: eventType
                    };
                }
            }
            
            const myAttr = getMainAttribute(mySpirit);
            const friendAttr = friendData.attribute || 'normal';
            
            // 정확한 레시피 매칭
            for (const [key, fusion] of Object.entries(FUSION_TYPES)) {
                const recipe = fusion.recipe;
                if ((recipe[0] === myAttr && recipe[1] === friendAttr) ||
                    (recipe[0] === friendAttr && recipe[1] === myAttr)) {
                    return { ...fusion, key };
                }
            }
            
            // 스탯 기반 매칭
            const myStat = getStatType(mySpirit);
            const friendStat = getStatTypeFromData(friendData);
            
            if (myStat && friendStat && myStat === friendStat) {
                const fusionKey = `fusion-${myStat === 'intelligent' ? 'sage' : myStat === 'strong' ? 'titan' : 'siren'}`;
                if (FUSION_TYPES[fusionKey]) {
                    return { ...FUSION_TYPES[fusionKey], key: fusionKey };
                }
            }
            
            // 기본 결과
            const inheritedAttr = Math.random() > 0.5 ? myAttr : friendAttr;
            const attrInfo = ATTRIBUTE_NAMES[inheritedAttr] || ATTRIBUTE_NAMES.normal;
            return {
                name: attrInfo.name,
                icon: attrInfo.icon,
                desc: attrInfo.desc,
                rarity: 'common',
                inheritedAttr
            };
        }
        
        function getStatTypeFromData(data) {
            const params = data.parameters || {};
            const intel = params.intelligence || 0;
            const str = params.strength || 0;
            const charm = params.charm || 0;
            
            if (intel > str && intel > charm && intel >= 70) return 'intelligent';
            if (str > intel && str > charm && str >= 70) return 'strong';
            if (charm > intel && charm > str && charm >= 70) return 'beautiful';
            return null;
        }
        
        function updateBreedPreview() {
            const mySelect = document.getElementById('myBreedSpirit');
            const codeInput = document.getElementById('friendCodeInput');
            const preview = document.getElementById('breedPreview');
            
            if (!mySelect.value || !codeInput.value.trim()) {
                preview.style.display = 'none';
                return;
            }
            
            // 현재 정령 또는 앨범에서 찾기
            const allCompleted = getCompletedSpiritsForBreeding();
            const mySpirit = allCompleted.find(s => s.id === mySelect.value);
            const friendData = decodeSpiritData(codeInput.value.trim());
            
            if (!mySpirit || !friendData) {
                preview.style.display = 'none';
                return;
            }
            
            const prediction = predictBreedResult(mySpirit, friendData);
            
            // 예상 상속 스탯 계산
            const inheritParams = {
                intelligence: Math.floor(((mySpirit.parameters?.intelligence || 0) + (friendData.parameters?.intelligence || 0)) / 2),
                strength: Math.floor(((mySpirit.parameters?.strength || 0) + (friendData.parameters?.strength || 0)) / 2),
                charm: Math.floor(((mySpirit.parameters?.charm || 0) + (friendData.parameters?.charm || 0)) / 2)
            };
            
            // 예상 상속 속성 계산
            const myAttrs = mySpirit.attributes || {};
            const friendAttrs = friendData.attributes || {};
            const inheritAttrs = [];
            ['fire', 'water', 'wind', 'earth', 'light', 'dark'].forEach(attr => {
                const avg = Math.floor(((myAttrs[attr] || 0) + (friendAttrs[attr] || 0)) / 2);
                if (avg > 0) inheritAttrs.push(`${ENV_ICONS[attr]}${avg}`);
            });
            
            preview.innerHTML = `
                <div style="font-size: 0.85rem; color: #888; margin-bottom: 8px;">🥚 예상 결과</div>
                <div style="font-size: 2rem;">${prediction.icon}</div>
                <div style="font-weight: 700; margin: 4px 0;">${prediction.name}</div>
                <div style="font-size: 0.8rem; color: ${getRarityColor(prediction.rarity)}; margin-bottom: 8px;">${getRarityText(prediction.rarity)}</div>
                <div style="font-size: 0.8rem; color: #888; border-top: 1px solid var(--border); padding-top: 8px;">
                    <div style="margin-bottom: 4px;">📊 상속 스탯</div>
                    <div>🧠${inheritParams.intelligence} | 💪${inheritParams.strength} | 💖${inheritParams.charm}</div>
                    ${inheritAttrs.length > 0 ? `<div style="margin-top: 4px;">${inheritAttrs.join(' ')}</div>` : ''}
                </div>
            `;
            preview.style.display = 'block';
        }

        function renderEncyclopedia() {
            try {
                console.log('도감 렌더링 시작');
                console.log('현재 도감:', encyclopedia);
                console.log('현재 앨범:', collection);
                
                const grid = document.getElementById('encyclopediaGrid');
                if (!grid) {
                    console.error('encyclopediaGrid 엘리먼트를 찾을 수 없습니다');
                    return;
                }
                
                // encyclopedia가 null이거나 undefined인 경우 초기화
                if (!encyclopedia || typeof encyclopedia !== 'object') {
                    console.warn('⚠️ 도감 데이터가 유효하지 않음 - 초기화');
                    encyclopedia = {};
                }
                
                // 도감이 비어있는데 앨범에 데이터가 있으면 자동 복구
                if (Object.keys(encyclopedia).length === 0 && collection && collection.length > 0) {
                    console.log('⚠️ 도감이 비어있지만 앨범에 데이터 존재 - 자동 복구 시작');
                    try {
                        const recoveredCount = rebuildEncyclopediaFromAlbum();
                        showNotification(`도감을 복구했습니다! (${recoveredCount}종)`);
                    } catch (rebuildError) {
                        console.error('도감 복구 실패:', rebuildError);
                    }
                }
            
            const statTypes = [
                { key: 'nostat', name: '(수식어 없음)' },
                { key: 'intelligent', name: '지적인 계열' },
                { key: 'strong', name: '강한 계열' },
                { key: 'beautiful', name: '아름다운 계열' }
            ];
            
            // 속성별 그룹 정의
            const attributeGroups = [
                {
                    title: '⚪ 순수',
                    attrs: ['normal']
                },
                {
                    title: '🔥💧🌬️🌱✨🌙 기본 속성',
                    attrs: ['fire', 'water', 'wind', 'earth', 'light', 'dark']
                },
                {
                    title: '🔥 화염 조합',
                    attrs: ['fire-water', 'fire-wind', 'fire-earth', 'fire-light', 'fire-dark']
                },
                {
                    title: '💧 빙하 조합',
                    attrs: ['water-wind', 'water-earth', 'water-light', 'water-dark']
                },
                {
                    title: '🌬️ 질풍 조합',
                    attrs: ['earth-wind', 'light-wind', 'dark-wind']
                },
                {
                    title: '🌱 대지 조합',
                    attrs: ['earth-light', 'dark-earth']
                },
                {
                    title: '✨🌙 환혹',
                    attrs: ['dark-light']
                },
                {
                    title: '⚖️🌪️ 다속성',
                    attrs: ['balanced', 'multi']
                }
            ];
            
            let html = '';
            
            // 전설적 존재 (티타니아/오베론) - 맨 위에 특별 표시
            html += `<div style="grid-column: 1 / -1; margin-top: 10px; margin-bottom: 15px;">
                <h2 style="font-family: 'Nanum Myeongjo', serif; font-size: 1.5rem; color: var(--text); border-bottom: 3px solid gold; padding-bottom: 10px;">
                    전설적 존재
                </h2>
            </div>`;
            
            // 티타니아
            const titaniaCount = encyclopedia['titania'] || 0;
            const titaniaUnlocked = titaniaCount > 0;
            html += `
                <div class="${titaniaUnlocked ? 'encyclopedia-card unlocked' : 'encyclopedia-card locked'}" style="min-height: 120px; border: 2px solid gold;">
                    <div class="encyclopedia-icon" style="font-size: 3rem;">${titaniaUnlocked ? '🦋✨' : '?'}</div>
                    <div class="encyclopedia-name" style="font-size: 1rem; font-weight: 700;">${titaniaUnlocked ? '티타니아' : '???????'}</div>
                    <div class="encyclopedia-count" style="font-size: 0.8rem;">${titaniaUnlocked ? `${titaniaCount}회` : '미달성'}</div>
                    <div style="font-size: 0.7rem; color: ${titaniaUnlocked ? 'gold' : '#888'}; margin-top: 5px;">${titaniaUnlocked ? ENCYCLOPEDIA_HINTS['titania'] : '나비를 거느리는 정령들의 군주.'}</div>
                </div>
            `;
            
            // 오베론
            const oberonCount = encyclopedia['oberon'] || 0;
            const oberonUnlocked = oberonCount > 0;
            html += `
                <div class="${oberonUnlocked ? 'encyclopedia-card unlocked' : 'encyclopedia-card locked'}" style="min-height: 120px; border: 2px solid gold;">
                    <div class="encyclopedia-icon" style="font-size: 3rem;">${oberonUnlocked ? '🦋🌙' : '?'}</div>
                    <div class="encyclopedia-name" style="font-size: 1rem; font-weight: 700;">${oberonUnlocked ? '오베론' : '???????'}</div>
                    <div class="encyclopedia-count" style="font-size: 0.8rem;">${oberonUnlocked ? `${oberonCount}회` : '미달성'}</div>
                    <div style="font-size: 0.7rem; color: ${oberonUnlocked ? 'gold' : '#888'}; margin-top: 5px;">${oberonUnlocked ? ENCYCLOPEDIA_HINTS['oberon'] : '나방을 거느리는 정령들의 군주.'}</div>
                </div>
            `;
            
            // 오블리비온
            const oblivionCount = encyclopedia['fusion-oblivion'] || 0;
            const oblivionUnlocked = oblivionCount > 0;
            html += `
                <div class="${oblivionUnlocked ? 'encyclopedia-card unlocked' : 'encyclopedia-card locked'}" style="min-height: 120px; border: 2px solid #ff00ff;">
                    <div class="encyclopedia-icon" style="font-size: 3rem;">${oblivionUnlocked ? '🦋🌌' : '?'}</div>
                    <div class="encyclopedia-name" style="font-size: 1rem; font-weight: 700;">${oblivionUnlocked ? '오블리비온' : '???????'}</div>
                    <div class="encyclopedia-count" style="font-size: 0.8rem;">${oblivionUnlocked ? `${oblivionCount}회` : '미달성'}</div>
                    <div style="font-size: 0.7rem; color: ${oblivionUnlocked ? '#ff00ff' : '#888'}; margin-top: 5px;">${oblivionUnlocked ? '정령의 군주들 사이에서 태어난 망각의 정령.' : '군주들의 후예.'}</div>
                </div>
            `;
            
            attributeGroups.forEach(group => {
                // 그룹 헤더
                html += `<div style="grid-column: 1 / -1; margin-top: 30px; margin-bottom: 15px;">
                    <h2 style="font-family: 'Nanum Myeongjo', serif; font-size: 1.5rem; color: var(--text); border-bottom: 3px solid var(--fire); padding-bottom: 10px;">
                        ${group.title}
                    </h2>
                </div>`;
                
                group.attrs.forEach(attrType => {
                    const attributeData = ATTRIBUTE_NAMES[attrType];
                    if (!attributeData) return;
                    
                    // 속성 아이콘만 표시 (이름 숨김)
                    html += `<div style="grid-column: 1 / -1; margin-top: 20px; margin-bottom: 10px;">
                        <h3 style="font-family: 'Nanum Myeongjo', serif; font-size: 1.2rem; color: var(--text); display: flex; align-items: center; gap: 10px;">
                            <span style="font-size: 2rem;">${attributeData.icon}</span>
                        </h3>
                    </div>`;
                    
                    // 가로로 나열 (수식어 없음 + 3개 스탯 계열)
                    statTypes.forEach(statInfo => {
                        let count = 0;
                        let displayName = '???????';
                        let displayIcon = '?';
                        let isUnlocked = false;
                        let achievedLevel = 'mid'; // 기본값 설정 (모든 경로에서 사용 가능)
                        
                        if (statInfo.key === 'nostat') {
                            // 수식어 없는 정령
                            count = encyclopedia[`nostat-${attrType}`] || 0;
                            isUnlocked = count > 0;
                            displayName = isUnlocked ? '(수식어 없음)' : '???????';
                            displayIcon = isUnlocked ? attributeData.icon : '?';
                        } else {
                            // 스탯 계열 정령
                            const lowCount = encyclopedia[`${statInfo.key}-low-${attrType}`] || 0;
                            const midCount = encyclopedia[`${statInfo.key}-mid-${attrType}`] || 0;
                            const highCount = encyclopedia[`${statInfo.key}-high-${attrType}`] || 0;
                            count = lowCount + midCount + highCount;
                            isUnlocked = count > 0;
                            
                            // 달성된 레벨 찾기 (우선순위: high > mid > low)
                            if (highCount > 0) achievedLevel = 'high';
                            else if (midCount > 0) achievedLevel = 'mid';
                            else if (lowCount > 0) achievedLevel = 'low';
                            
                            if (isUnlocked) {
                                const statPrefix = EVOLUTION_TYPES[`${statInfo.key}-${achievedLevel}`].prefix;
                                const statIcon = EVOLUTION_TYPES[`${statInfo.key}-${achievedLevel}`].icon;
                                displayName = statPrefix;
                                displayIcon = `${statIcon}${attributeData.icon}`;
                            }
                        }
                        
                        const cardClass = isUnlocked ? 'encyclopedia-card unlocked' : 'encyclopedia-card locked';
                        const countText = isUnlocked ? `${count}회` : '미달성';
                        
                        // 정령 전체 이름 생성
                        let fullName = '???????';
                        let hintKey = '';
                        
                        if (isUnlocked) {
                            if (statInfo.key === 'nostat') {
                                fullName = attributeData.name;
                                hintKey = `nostat-${attrType}`;
                            } else {
                                const statPrefix = EVOLUTION_TYPES[`${statInfo.key}-${achievedLevel}`].prefix;
                                fullName = `${statPrefix} ${attributeData.name}`;
                                hintKey = `${statInfo.key}-${achievedLevel}-${attrType}`;
                            }
                        }
                        
                        // 잠금 상태에서도 힌트 표시
                        let hint = '';
                        if (isUnlocked) {
                            hint = ENCYCLOPEDIA_HINTS[hintKey] || '';
                        } else {
                            // 잠금 상태일 때도 힌트 표시
                            if (statInfo.key === 'nostat') {
                                hint = ENCYCLOPEDIA_HINTS[`nostat-${attrType}`] || '???';
                            } else {
                                // 임의의 레벨로 힌트 표시 (mid 우선)
                                hint = ENCYCLOPEDIA_HINTS[`${statInfo.key}-mid-${attrType}`] || 
                                       ENCYCLOPEDIA_HINTS[`${statInfo.key}-low-${attrType}`] || '???';
                            }
                        }
                        
                        html += `
                            <div class="${cardClass}" style="min-height: 120px;">
                                <div class="encyclopedia-icon" style="font-size: 2.5rem;">${displayIcon}</div>
                                <div class="encyclopedia-name" style="font-size: 0.85rem; font-weight: 600;">${fullName}</div>
                                <div class="encyclopedia-count" style="font-size: 0.75rem; margin-top: 4px;">${countText}</div>
                                ${hint ? `<div style="font-size: 0.7rem; color: #888; margin-top: 6px; line-height: 1.3; padding: 0 8px; text-align: center;">${hint}</div>` : ''}
                            </div>
                        `;
                    });
                });
            });
            
            // 이벤트 정령 섹션
            html += `<div style="grid-column: 1 / -1; margin-top: 30px; margin-bottom: 15px;">
                <h2 style="font-family: 'Nanum Myeongjo', serif; font-size: 1.5rem; color: #c41e3a; border-bottom: 3px solid #c41e3a; padding-bottom: 10px;">
                    🎄 이벤트 정령
                </h2>
            </div>`;
            
            Object.entries(EVENT_TYPES).forEach(([eventKey, event]) => {
                // 일반 이벤트 정령
                const eventEncKey = `event_${eventKey}`;
                const eventCount = encyclopedia[eventEncKey] || 0;
                const isUnlocked = eventCount > 0;
                
                html += `
                    <div class="${isUnlocked ? 'encyclopedia-card unlocked' : 'encyclopedia-card locked'}" style="min-height: 120px; border: 2px solid #c41e3a;">
                        <div class="encyclopedia-icon" style="font-size: 3rem;">${isUnlocked ? event.stages.adult : event.stages.egg}</div>
                        <div class="encyclopedia-name" style="font-size: 1rem; font-weight: 700; color: #c41e3a;">${isUnlocked ? event.name : '???'}</div>
                        <div class="encyclopedia-count" style="font-size: 0.8rem;">${isUnlocked ? `${eventCount}회` : '미달성'}</div>
                        <div style="font-size: 0.7rem; color: ${isUnlocked ? '#c41e3a' : '#888'}; margin-top: 5px;">${isUnlocked ? event.desc : '이벤트 코드로 획득할 수 있는 특별한 정령.'}</div>
                    </div>
                `;
                
                // 이로치 버전이 있으면 별도 표시
                if (event.shiny) {
                    const shinyEncKey = `event_${eventKey}_shiny`;
                    const shinyCount = encyclopedia[shinyEncKey] || 0;
                    const isShinyUnlocked = shinyCount > 0;
                    
                    html += `
                        <div class="${isShinyUnlocked ? 'encyclopedia-card unlocked' : 'encyclopedia-card locked'}" style="min-height: 120px; border: 2px solid #87CEEB; background: ${isShinyUnlocked ? 'linear-gradient(135deg, rgba(135,206,235,0.1), rgba(255,255,255,0.1))' : 'var(--card)'};">
                            <div class="encyclopedia-icon" style="font-size: 3rem;">${isShinyUnlocked ? event.shiny.stages.adult : event.shiny.stages.egg}</div>
                            <div class="encyclopedia-name" style="font-size: 1rem; font-weight: 700; color: #87CEEB;">${isShinyUnlocked ? event.shiny.name : '???'} ${isShinyUnlocked ? '✨' : ''}</div>
                            <div class="encyclopedia-count" style="font-size: 0.8rem;">${isShinyUnlocked ? `${shinyCount}회` : '미달성'}</div>
                            <div style="font-size: 0.7rem; color: ${isShinyUnlocked ? '#87CEEB' : '#888'}; margin-top: 5px;">${isShinyUnlocked ? event.shiny.desc : '크리스마스에 드물게 나타나는 차가운 눈꽃.'}</div>
                        </div>
                    `;
                }
            });
            
            // 교배 정령 섹션
            html += '<div style="grid-column: 1 / -1; margin-top: 30px; margin-bottom: 15px;">' +
                '<h2 style="font-family: \'Nanum Myeongjo\', serif; font-size: 1.5rem; color: #9b59b6; border-bottom: 3px solid #9b59b6; padding-bottom: 10px;">' +
                    '💜 교배 정령' +
                '</h2>' +
            '</div>';
            
            // 레어리티별 그룹화
            const fusionGroups = {
                'rare': { title: '💎 희귀', entries: [] },
                'epic': { title: '⭐ 에픽', entries: [] },
                'legendary': { title: '👑 전설', entries: [] }
            };
            
            Object.entries(FUSION_TYPES).forEach(([key, data]) => {
                if (fusionGroups[data.rarity]) {
                    fusionGroups[data.rarity].entries.push({ key, ...data });
                }
            });
            
            // 레어리티 순서대로 표시
            ['rare', 'epic', 'legendary'].forEach(rarity => {
                const group = fusionGroups[rarity];
                if (group.entries.length === 0) return;
                
                // 레어리티 소제목
                const rarityColors = { rare: '#3498db', epic: '#9b59b6', legendary: '#f1c40f' };
                html += '<div style="grid-column: 1 / -1; margin-top: 20px; margin-bottom: 10px;">' +
                    '<h3 style="font-family: \'Nanum Myeongjo\', serif; font-size: 1.1rem; color: ' + rarityColors[rarity] + ';">' + group.title + '</h3>' +
                '</div>';
                
                group.entries.forEach(fusion => {
                    const fusionCount = encyclopedia[fusion.key] || 0;
                    const isUnlocked = fusionCount > 0;
                    const borderColor = rarityColors[rarity];
                    
                    // 레시피 힌트 생성
                    let recipeHint = '';
                    if (fusion.recipe) {
                        const recipeNames = fusion.recipe.map(r => {
                            if (ATTRIBUTE_NAMES[r]) return ATTRIBUTE_NAMES[r].icon;
                            if (r === 'intelligent') return '🧠';
                            if (r === 'strong') return '💪';
                            if (r === 'beautiful') return '💖';
                            if (r === 'balanced') return '⚖️';
                            return r;
                        });
                        recipeHint = recipeNames.join(' + ');
                    }
                    
                    html += '<div class="' + (isUnlocked ? 'encyclopedia-card unlocked' : 'encyclopedia-card locked') + '" style="min-height: 120px; border: 2px solid ' + borderColor + ';">' +
                        '<div class="encyclopedia-icon" style="font-size: 2.5rem;">' + (isUnlocked ? fusion.icon : '?') + '</div>' +
                        '<div class="encyclopedia-name" style="font-size: 0.9rem; font-weight: 700; color: ' + borderColor + ';">' + (isUnlocked ? fusion.name : '???') + '</div>' +
                        '<div class="encyclopedia-count" style="font-size: 0.75rem;">' + (isUnlocked ? fusionCount + '회' : '미달성') + '</div>' +
                        '<div style="font-size: 0.7rem; color: #888; margin-top: 5px;">' + (isUnlocked ? fusion.desc : '교배: ' + recipeHint) + '</div>' +
                    '</div>';
                });
            });
            
            grid.innerHTML = html;
            } catch (error) {
                console.error('도감 렌더링 오류:', error);
                console.error('오류 스택:', error.stack);
                console.error('현재 도감 데이터:', encyclopedia);
                console.error('현재 앨범 데이터:', collection);
                
                const grid = document.getElementById('encyclopediaGrid');
                if (grid) {
                    grid.innerHTML = `
                        <div style="text-align: center; padding: 40px;">
                            <div style="color: #f44336; font-size: 1.2rem; margin-bottom: 20px;">⚠️ 도감 렌더링 오류</div>
                            <div style="color: #666; margin-bottom: 20px;">
                                오류: ${error.message}<br>
                                도감 항목: ${Object.keys(encyclopedia).length}개<br>
                                앨범 항목: ${collection.length}개
                            </div>
                            <button onclick="manualRebuildEncyclopedia()" style="padding: 12px 24px; background: var(--water); color: white; border: none; border-radius: 8px; font-weight: 700; cursor: pointer; margin-right: 10px;">
                                📚 앨범에서 도감 복구
                            </button>
                            <button onclick="renderEncyclopedia()" style="padding: 12px 24px; background: var(--fire); color: white; border: none; border-radius: 8px; font-weight: 700; cursor: pointer;">
                                🔄 다시 시도
                            </button>
                        </div>
                    `;
                }
            }
        }

        // 앨범 상세 이미지 저장 기능
        async function saveAlbumDetailImage() {
            showNotification('📷 이미지 생성 중...');
            
            try {
                const content = document.getElementById('albumDetailContent');
                
                // 스크롤 위치 저장 및 맨 위로 이동
                const originalScrollTop = content.scrollTop;
                content.scrollTop = 0;
                
                // 저장 버튼 임시 숨기기
                const saveBtn = content.querySelector('button[onclick="saveAlbumDetailImage()"]').parentElement;
                const originalSaveBtnDisplay = saveBtn.style.display;
                saveBtn.style.display = 'none';
                
                // X 버튼 임시 숨기기
                const closeBtn = content.querySelector('button[onclick="closeAlbumDetail()"]');
                const originalCloseBtnDisplay = closeBtn.style.display;
                closeBtn.style.display = 'none';
                
                // 교배 섹션 임시 숨기기
                const breedSection = document.getElementById('breedSection');
                const originalBreedDisplay = breedSection ? breedSection.style.display : '';
                if (breedSection) breedSection.style.display = 'none';
                
                // 스크롤바 임시 제거 및 전체 높이로 확장
                const originalOverflow = content.style.overflowY;
                const originalMaxHeight = content.style.maxHeight;
                content.style.overflowY = 'visible';
                content.style.maxHeight = 'none';
                
                const canvas = await html2canvas(content, {
                    backgroundColor: getComputedStyle(document.body).getPropertyValue('--card') || '#ffffff',
                    scale: 2,
                    useCORS: true,
                    logging: false,
                    windowHeight: content.scrollHeight,
                    height: content.scrollHeight
                });
                
                // 모든 요소 복원
                saveBtn.style.display = originalSaveBtnDisplay;
                closeBtn.style.display = originalCloseBtnDisplay;
                if (breedSection) breedSection.style.display = originalBreedDisplay;
                content.style.overflowY = 'auto';
                content.style.maxHeight = '80vh';
                content.scrollTop = originalScrollTop;
                
                // 정령 이름 가져오기
                const spiritName = document.getElementById('modalTitle').textContent || 'spirit';
                
                // 이미지 다운로드
                const link = document.createElement('a');
                link.download = `${spiritName}-${new Date().toISOString().slice(0,10)}.png`;
                link.href = canvas.toDataURL('image/png');
                link.click();
                
                showNotification('✅ 이미지가 저장되었습니다!');
            } catch (error) {
                console.error('이미지 생성 오류:', error);
                showNotification('❌ 이미지 생성에 실패했습니다');
            }
        }

        function renderCollection() {
            try {
                console.log('앨범 렌더링 시작');
                const grid = document.getElementById('collectionGrid');
                if (!grid) {
                    console.error('collectionGrid 엘리먼트를 찾을 수 없습니다');
                    return;
                }
            
            if (collection.length === 0) {
                grid.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-icon">📖</div>
                        <div>아직 등록된 정령이 없습니다<br>정령을 성충까지 키워보세요</div>
                    </div>
                `;
                return;
            }

            // 역순으로 표시 (최근 것이 맨 앞에)
            const reversedCollection = [...collection].reverse();
            
            grid.innerHTML = reversedCollection.map((item, reverseIndex) => {
                const index = collection.length - 1 - reverseIndex; // 원본 인덱스
                // desc는 도감 아이템에 저장되어 있음
                const desc = item.desc || '';
                const originalName = item.originalName || item.name || '이름 없음';
                
                // 날개 이모지 결정
                let wingEmoji = '';
                if (item.wingType === 'butterfly') {
                    wingEmoji = '🦋';
                } else if (item.wingType === 'moth') {
                    wingEmoji = '🦋'; // 나방도 나비 이모지 사용 (시각적으로 구분)
                } else if (item.wingType === 'both') {
                    wingEmoji = '🦋🦋';
                }
                
                return `
                    <div class="collection-card" onclick="showAlbumDetail(${index})" style="cursor: pointer; transition: transform 0.2s;" onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                        <div class="collection-icon">${item.icon}${wingEmoji}</div>
                        <div class="collection-name">${item.name}</div>
                        <div style="font-size: 0.85rem; color: #666; margin-top: 4px;">본명: ${originalName}</div>
                        ${item.wingType ? `<div style="font-size: 0.85rem; color: #888; margin-top: 4px;">${item.wingType === 'butterfly' ? '나비의 날개' : item.wingType === 'moth' ? '나방의 날개' : '나비와 나방의 날개'}</div>` : ''}
                        ${desc ? `<div style="font-size: 0.85rem; color: #888; margin-top: 8px; line-height: 1.4;">${desc}</div>` : ''}
                        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; margin-top: 12px;">
                            <div class="param">🧠 ${item.parameters.intelligence}</div>
                            <div class="param">💪 ${item.parameters.strength}</div>
                            <div class="param">${item.parameters.charm}</div>
                            <div class="param">${item.parameters.affection || 0}</div>
                        </div>
                        <div style="font-size: 0.75rem; color: #999; margin-top: 12px; text-align: center;">📊 클릭하여 상세 정보 보기</div>
                    </div>
                `;
            }).join('');
            } catch (error) {
                console.error('앨범 렌더링 오류:', error);
                console.error('오류 스택:', error.stack);
                const grid = document.getElementById('collectionGrid');
                if (grid) {
                    grid.innerHTML = `
                        <div style="text-align: center; padding: 40px;">
                            <div style="color: #f44336; font-size: 1.2rem; margin-bottom: 20px;">⚠️ 앨범 렌더링 오류</div>
                            <div style="color: #666;">오류: ${error.message}</div>
                        </div>
                    `;
                }
            }
        }

        function switchTab(tab) {
            try {
                console.log('탭 전환:', tab);
                currentTab = tab; // 현재 탭 저장
                
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
                
                if (tab === 'garden') {
                    document.querySelector('.tab:nth-child(1)').classList.add('active');
                    document.getElementById('gardenSection').classList.add('active');
                    // 질병 튜토리얼: 육성 탭 열기 액션 체크
                    checkSickTutorialAction('openGarden');
                } else if (tab === 'terrarium') {
                    document.querySelector('.tab:nth-child(2)').classList.add('active');
                    document.getElementById('terrariumSection').classList.add('active');
                    renderTerrariumManagement();
                } else if (tab === 'lab') {
                    document.querySelector('.tab:nth-child(3)').classList.add('active');
                    document.getElementById('labSection').classList.add('active');
                    renderRecipeList();
                    updateLabUI();
                } else if (tab === 'shop') {
                    document.querySelector('.tab:nth-child(4)').classList.add('active');
                    document.getElementById('shopSection').classList.add('active');
                    renderShop();
                    // 질병 튜토리얼: 상점 탭 열기 액션 체크
                    checkSickTutorialAction('openShop');
                } else if (tab === 'minigame') {
                    document.querySelector('.tab:nth-child(5)').classList.add('active');
                    document.getElementById('minigameSection').classList.add('active');
                    // 미니게임 탭 전환 시 게임 중이면 일시정지
                    if (minigameActive) {
                        pauseMinigame();
                    }
                } else if (tab === 'encyclopedia') {
                    document.querySelector('.tab:nth-child(6)').classList.add('active');
                    document.getElementById('encyclopediaSection').classList.add('active');
                    renderEncyclopedia();
                } else if (tab === 'album') {
                    document.querySelector('.tab:nth-child(7)').classList.add('active');
                    document.getElementById('albumSection').classList.add('active');
                    renderCollection();
                    // 튜토리얼2: 앨범 탭 열기 액션 체크
                    checkTutorialAction('openAlbum');
                } else if (tab === 'journal') {
                    document.querySelector('.tab:nth-child(8)').classList.add('active');
                    document.getElementById('journalSection').classList.add('active');
                } else if (tab === 'settings') {
                    // 설정은 탭 바에 없으므로 active 처리 안함
                    document.getElementById('settingsSection').classList.add('active');
                    updateSettingsInfo();
                }
            } catch (error) {
                console.error('탭 전환 오류:', error);
                console.error('오류 스택:', error.stack);
                showNotification('탭 전환 중 오류가 발생했습니다');
            }
        }

        // 설정 정보 업데이트
        function updateSettingsInfo() {
            // 다크모드 토글 상태 업데이트
            const toggle = document.getElementById('darkModeToggle');
            const slider = document.getElementById('darkModeSlider');
            if (toggle) {
                toggle.checked = darkModeLocked;
                if (darkModeLocked) {
                    slider.style.transform = 'translateX(28px)';
                    slider.parentElement.style.backgroundColor = '#4CAF50';
                } else {
                    slider.style.transform = 'translateX(0)';
                    slider.parentElement.style.backgroundColor = '#ccc';
                }
            }
        }
        
        // 이벤트 코드 사용
        async function redeemEventCode() {
            const input = document.getElementById('eventCodeInput');
            const code = input.value.trim();
            
            if (!code) {
                showNotification('❌ 이벤트 코드를 입력해주세요');
                return;
            }
            
            // 정령 슬롯 체크
            if (spirits.length >= 6) {
                showNotification('❌ 정원이 가득 찼습니다! (최대 6마리)');
                return;
            }
            
            const decoded = decodeEventCode(code);
            
            if (!decoded) {
                showNotification('❌ 유효하지 않은 이벤트 코드입니다');
                return;
            }
            
            if (decoded.expired) {
                showNotification('❌ 이벤트 기간이 종료되었습니다');
                return;
            }
            
            const event = decoded.event;
            
            const confirmed = await showConfirm('이벤트 코드 사용',
                `${event.icon} ${event.name} 알을 받으시겠습니까?\n\n${event.desc}\n\n🎁 이벤트 기간 동안 상점에서 특별 아이템을 구매할 수 있습니다!`);
            
            if (!confirmed) return;
            
            // 이벤트 정령 생성
            const newSpirit = createEventSpirit(decoded.eventType);
            if (!newSpirit) {
                showNotification('❌ 이벤트 정령 생성 실패');
                return;
            }
            
            spirits.push(newSpirit);
            
            // 이벤트 활성화 (상점에 아이템 추가)
            if (!activatedEvents) activatedEvents = [];
            if (!activatedEvents.includes(decoded.eventType)) {
                activatedEvents.push(decoded.eventType);
            }
            
            saveGame();
            renderSpirits();
            renderShop();
            
            input.value = '';
            showNotification(`🎄 ${event.name} 알이 태어났습니다! 상점에서 이벤트 아이템을 확인하세요!`);
            switchTab('garden');
        }
        
        // 다크 모드 고정 토글
        function toggleDarkModeLock() {
            darkModeLocked = !darkModeLocked;
            
            const slider = document.getElementById('darkModeSlider');
            if (darkModeLocked) {
                slider.style.transform = 'translateX(28px)';
                slider.parentElement.style.backgroundColor = '#4CAF50';
                showNotification('🌙 다크 모드가 고정되었습니다');
            } else {
                slider.style.transform = 'translateX(0)';
                slider.parentElement.style.backgroundColor = '#ccc';
                showNotification('🌓 조명에 따라 테마가 변경됩니다');
            }
            
            applyLightMode();
            saveGame();
        }
        
        // ===== 연구실 합성 시스템 함수 =====
        
        // 아이템 아이콘 가져오기
        function getItemIcon(type, category) {
            if (category === 'food') {
                // 합성 아이템인지 확인
                if (SYNTH_ITEMS[type]) {
                    return SYNTH_ITEMS[type].icon;
                }
                // 기본 먹이
                const icons = { fire: '🔥', water: '💧', wind: '🌬️', earth: '🌱', light: '✨', dark: '🌙' };
                return icons[type] || '❓';
            } else if (category === 'decoration') {
                // 합성 장식물인지 확인
                if (SYNTH_ITEMS[type]) {
                    return SYNTH_ITEMS[type].icon;
                }
                // 기본 장식물
                return DECORATION_TYPES[type]?.icon || '❓';
            }
            return '❓';
        }
        
        // 아이템 이름 가져오기
        function getItemName(type, category) {
            if (category === 'food') {
                if (SYNTH_ITEMS[type]) {
                    return SYNTH_ITEMS[type].name;
                }
                return FOOD_NAMES[type] || type;
            } else if (category === 'decoration') {
                if (SYNTH_ITEMS[type]) {
                    return SYNTH_ITEMS[type].name;
                }
                return DECORATION_TYPES[type]?.name || type;
            }
            return type;
        }
        
        // 인벤토리에서 아이템 개수 세기
        function countInventoryItem(type, category) {
            if (category === 'food') {
                return inventory.food.filter(f => f === type).length;
            } else if (category === 'decoration') {
                return inventory.decorations.filter(d => d === type).length;
            }
            return 0;
        }
        
        // 연구실 슬롯 모달 열기
        function openLabSlotModal(slotNum) {
            currentLabSlot = slotNum;
            
            // 먹이와 장식물 목록 생성
            const foodCounts = {};
            inventory.food.forEach(f => {
                foodCounts[f] = (foodCounts[f] || 0) + 1;
            });
            
            const decoCounts = {};
            inventory.decorations.forEach(d => {
                decoCounts[d] = (decoCounts[d] || 0) + 1;
            });
            
            let html = `
                <div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 10000; display: flex; justify-content: center; align-items: center;" onclick="if(event.target === this) closeLabModal()">
                    <div style="background: var(--card); border-radius: 12px; padding: 24px; max-width: 500px; width: 90%; max-height: 80vh; overflow-y: auto;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                            <h3 style="font-family: 'Nanum Myeongjo', serif; margin: 0;">재료 선택 (슬롯 ${slotNum})</h3>
                            <button onclick="closeLabModal()" style="background: none; border: none; font-size: 1.5rem; cursor: pointer;">✕</button>
                        </div>
                        
                        <div style="margin-bottom: 15px;">
                            <div style="font-weight: 600; margin-bottom: 10px;">🍎 먹이</div>
                            <div style="display: flex; flex-wrap: wrap; gap: 8px;">
            `;
            
            // 먹이 버튼들
            const foodOrder = ['fire', 'water', 'wind', 'earth', 'light', 'dark'];
            foodOrder.forEach(type => {
                const count = foodCounts[type] || 0;
                if (count > 0) {
                    html += `
                        <button onclick="selectLabItem('${type}', 'food')" style="padding: 10px 15px; border: 1px solid var(--border); border-radius: 8px; background: var(--bg); cursor: pointer; display: flex; align-items: center; gap: 5px;">
                            ${getItemIcon(type, 'food')} ${FOOD_NAMES[type]} ×${count}
                        </button>
                    `;
                }
            });
            
            // 합성 먹이도 표시
            Object.keys(SYNTH_ITEMS).forEach(type => {
                if (SYNTH_ITEMS[type].type === 'food') {
                    const count = foodCounts[type] || 0;
                    if (count > 0) {
                        html += `
                            <button onclick="selectLabItem('${type}', 'food')" style="padding: 10px 15px; border: 1px solid var(--border); border-radius: 8px; background: var(--bg); cursor: pointer; display: flex; align-items: center; gap: 5px;">
                                ${SYNTH_ITEMS[type].icon} ${SYNTH_ITEMS[type].name} ×${count}
                            </button>
                        `;
                    }
                }
            });
            
            if (Object.keys(foodCounts).length === 0) {
                html += `<div style="color: #888; font-size: 0.9rem;">먹이가 없습니다</div>`;
            }
            
            html += `
                            </div>
                        </div>
                        
                        <div>
                            <div style="font-weight: 600; margin-bottom: 10px;">🌳 장식물</div>
                            <div style="display: flex; flex-wrap: wrap; gap: 8px;">
            `;
            
            // 장식물 버튼들
            Object.keys(decoCounts).forEach(type => {
                const count = decoCounts[type];
                const deco = DECORATION_TYPES[type] || SYNTH_ITEMS[type];
                if (deco && count > 0) {
                    html += `
                        <button onclick="selectLabItem('${type}', 'decoration')" style="padding: 10px 15px; border: 1px solid var(--border); border-radius: 8px; background: var(--bg); cursor: pointer; display: flex; align-items: center; gap: 5px;">
                            ${deco.icon} ${deco.name} ×${count}
                        </button>
                    `;
                }
            });
            
            if (Object.keys(decoCounts).length === 0) {
                html += `<div style="color: #888; font-size: 0.9rem;">장식물이 없습니다</div>`;
            }
            
            html += `
                            </div>
                        </div>
                        
                        <div style="margin-top: 20px; text-align: center;">
                            <button onclick="clearLabSlot(${slotNum})" style="padding: 10px 20px; background: #e74c3c; color: white; border: none; border-radius: 8px; cursor: pointer;">슬롯 비우기</button>
                        </div>
                    </div>
                </div>
            `;
            
            // 모달 추가
            const modal = document.createElement('div');
            modal.id = 'labModal';
            modal.innerHTML = html;
            document.body.appendChild(modal);
        }
        
        // 연구실 모달 닫기
        function closeLabModal() {
            const modal = document.getElementById('labModal');
            if (modal) modal.remove();
        }
        
        // 연구실 슬롯에 아이템 선택
        function selectLabItem(type, category) {
            const count = countInventoryItem(type, category);
            if (count <= 0) {
                showNotification('해당 아이템이 없습니다');
                return;
            }
            
            // 개수 선택 (최대 보유량)
            const maxCount = Math.min(count, 10);
            let selectedCount = 1;
            
            // 간단히 1개로 설정 (나중에 개수 선택 UI 추가 가능)
            // 레시피에 맞게 필요 개수 자동 설정
            let neededCount = 1;
            
            // 레시피에서 필요한 개수 찾기
            Object.values(RECIPES).forEach(recipe => {
                recipe.ingredients.forEach(ing => {
                    if (ing.type === type && ing.category === category) {
                        neededCount = Math.max(neededCount, ing.count);
                    }
                });
            });
            
            selectedCount = Math.min(neededCount, count);
            
            if (currentLabSlot === 1) {
                labSlot1 = { type, category, count: selectedCount };
            } else {
                labSlot2 = { type, category, count: selectedCount };
            }
            
            closeLabModal();
            updateLabUI();
            checkRecipe();
        }
        
        // 슬롯 비우기
        function clearLabSlot(slotNum) {
            if (slotNum === 1) {
                labSlot1 = null;
            } else {
                labSlot2 = null;
            }
            closeLabModal();
            updateLabUI();
            checkRecipe();
        }
        
        // 연구실 UI 업데이트
        function updateLabUI() {
            const slot1El = document.getElementById('labSlot1');
            const slot2El = document.getElementById('labSlot2');
            
            if (slot1El) {
                if (labSlot1) {
                    slot1El.innerHTML = `
                        <div style="font-size: 2rem; margin-bottom: 5px;">${getItemIcon(labSlot1.type, labSlot1.category)}</div>
                        <div style="font-size: 0.8rem; color: var(--text);">${getItemName(labSlot1.type, labSlot1.category)}</div>
                        <div style="font-size: 0.75rem; color: #888;">×${labSlot1.count}</div>
                    `;
                    slot1El.style.borderStyle = 'solid';
                    slot1El.style.borderColor = '#9b59b6';
                } else {
                    slot1El.innerHTML = `
                        <div style="font-size: 2rem; margin-bottom: 5px;">➕</div>
                        <div style="font-size: 0.8rem; color: #888;">재료 선택</div>
                    `;
                    slot1El.style.borderStyle = 'dashed';
                    slot1El.style.borderColor = 'var(--border)';
                }
            }
            
            if (slot2El) {
                if (labSlot2) {
                    slot2El.innerHTML = `
                        <div style="font-size: 2rem; margin-bottom: 5px;">${getItemIcon(labSlot2.type, labSlot2.category)}</div>
                        <div style="font-size: 0.8rem; color: var(--text);">${getItemName(labSlot2.type, labSlot2.category)}</div>
                        <div style="font-size: 0.75rem; color: #888;">×${labSlot2.count}</div>
                    `;
                    slot2El.style.borderStyle = 'solid';
                    slot2El.style.borderColor = '#9b59b6';
                } else {
                    slot2El.innerHTML = `
                        <div style="font-size: 2rem; margin-bottom: 5px;">➕</div>
                        <div style="font-size: 0.8rem; color: #888;">재료 선택</div>
                    `;
                    slot2El.style.borderStyle = 'dashed';
                    slot2El.style.borderColor = 'var(--border)';
                }
            }
        }
        
        // 레시피 체크
        function checkRecipe() {
            const resultSlot = document.getElementById('labResultSlot');
            const synthesizeBtn = document.getElementById('synthesizeBtn');
            const labMessage = document.getElementById('labMessage');
            
            if (!labSlot1 || !labSlot2) {
                if (resultSlot) {
                    resultSlot.innerHTML = `
                        <div style="font-size: 2rem; margin-bottom: 5px;">❓</div>
                        <div style="font-size: 0.8rem; color: #888;">결과물</div>
                    `;
                }
                if (synthesizeBtn) {
                    synthesizeBtn.disabled = true;
                    synthesizeBtn.style.opacity = '0.5';
                }
                if (labMessage) labMessage.textContent = '재료를 선택해주세요';
                return null;
            }
            
            // 레시피 매칭
            for (const [recipeId, recipe] of Object.entries(RECIPES)) {
                const ing1 = recipe.ingredients[0];
                const ing2 = recipe.ingredients[1];
                
                // 슬롯1-재료1, 슬롯2-재료2 매칭 확인
                const match1 = (labSlot1.type === ing1.type && labSlot1.category === ing1.category && labSlot1.count >= ing1.count) &&
                              (labSlot2.type === ing2.type && labSlot2.category === ing2.category && labSlot2.count >= ing2.count);
                
                // 슬롯1-재료2, 슬롯2-재료1 매칭 확인 (순서 바꿔서)
                const match2 = (labSlot1.type === ing2.type && labSlot1.category === ing2.category && labSlot1.count >= ing2.count) &&
                              (labSlot2.type === ing1.type && labSlot2.category === ing1.category && labSlot2.count >= ing1.count);
                
                if (match1 || match2) {
                    // 레시피 발견!
                    const resultItem = SYNTH_ITEMS[recipe.result.type];
                    
                    if (resultSlot) {
                        resultSlot.innerHTML = `
                            <div style="font-size: 2rem; margin-bottom: 5px;">${resultItem.icon}</div>
                            <div style="font-size: 0.8rem; color: var(--text);">${resultItem.name}</div>
                            <div style="font-size: 0.75rem; color: #9b59b6;">×${recipe.result.count}</div>
                        `;
                        resultSlot.style.borderColor = '#9b59b6';
                    }
                    if (synthesizeBtn) {
                        synthesizeBtn.disabled = false;
                        synthesizeBtn.style.opacity = '1';
                    }
                    if (labMessage) {
                        labMessage.innerHTML = `<span style="color: #9b59b6;">✨ 합성 가능!</span>`;
                    }
                    return recipeId;
                }
            }
            
            // 매칭되는 레시피 없음
            if (resultSlot) {
                resultSlot.innerHTML = `
                    <div style="font-size: 2rem; margin-bottom: 5px;">💨</div>
                    <div style="font-size: 0.8rem; color: #888;">실패</div>
                `;
                resultSlot.style.borderColor = 'var(--border)';
            }
            if (synthesizeBtn) {
                synthesizeBtn.disabled = true;
                synthesizeBtn.style.opacity = '0.5';
            }
            if (labMessage) {
                labMessage.textContent = '이 조합으로는 만들 수 없습니다';
            }
            return null;
        }
        
        // 합성 실행
        function synthesize() {
            const recipeId = checkRecipe();
            if (!recipeId) {
                showNotification('합성할 수 없는 조합입니다');
                return;
            }
            
            const recipe = RECIPES[recipeId];
            const ing1 = recipe.ingredients[0];
            const ing2 = recipe.ingredients[1];
            
            // 재료 소모 (슬롯 순서에 맞게)
            let slot1Ing, slot2Ing;
            if (labSlot1.type === ing1.type && labSlot1.category === ing1.category) {
                slot1Ing = ing1;
                slot2Ing = ing2;
            } else {
                slot1Ing = ing2;
                slot2Ing = ing1;
            }
            
            // 인벤토리에서 재료 제거
            for (let i = 0; i < slot1Ing.count; i++) {
                const idx = slot1Ing.category === 'food' 
                    ? inventory.food.indexOf(slot1Ing.type)
                    : inventory.decorations.indexOf(slot1Ing.type);
                if (idx !== -1) {
                    if (slot1Ing.category === 'food') {
                        inventory.food.splice(idx, 1);
                    } else {
                        inventory.decorations.splice(idx, 1);
                    }
                }
            }
            
            for (let i = 0; i < slot2Ing.count; i++) {
                const idx = slot2Ing.category === 'food'
                    ? inventory.food.indexOf(slot2Ing.type)
                    : inventory.decorations.indexOf(slot2Ing.type);
                if (idx !== -1) {
                    if (slot2Ing.category === 'food') {
                        inventory.food.splice(idx, 1);
                    } else {
                        inventory.decorations.splice(idx, 1);
                    }
                }
            }
            
            // 결과물 추가
            const resultItem = SYNTH_ITEMS[recipe.result.type];
            for (let i = 0; i < recipe.result.count; i++) {
                if (resultItem.type === 'food') {
                    inventory.food.push(recipe.result.type);
                } else if (resultItem.type === 'decoration') {
                    inventory.decorations.push(recipe.result.type);
                }
            }
            
            // 레시피 발견 기록
            if (!discoveredRecipes.includes(recipeId)) {
                discoveredRecipes.push(recipeId);
            }
            
            // 슬롯 초기화
            labSlot1 = null;
            labSlot2 = null;
            
            // UI 업데이트
            updateLabUI();
            checkRecipe();
            renderInventory();
            renderRecipeList();
            saveGame();
            
            showNotification(`✨ ${resultItem.icon} ${resultItem.name} ×${recipe.result.count} 합성 성공!`);
        }
        
        // 레시피 목록 렌더링
        function renderRecipeList(filter = 'all') {
            const container = document.getElementById('recipeList');
            if (!container) return;
            
            let html = '';
            let discoveredCount = 0;
            
            Object.entries(RECIPES).forEach(([recipeId, recipe]) => {
                // 발견한 레시피만 표시
                if (!discoveredRecipes.includes(recipeId)) return;
                
                if (filter !== 'all' && recipe.category !== filter) return;
                
                discoveredCount++;
                const resultItem = SYNTH_ITEMS[recipe.result.type];
                const ing1 = recipe.ingredients[0];
                const ing2 = recipe.ingredients[1];
                
                const ing1Name = getItemName(ing1.type, ing1.category);
                const ing2Name = getItemName(ing2.type, ing2.category);
                const ing1Icon = getItemIcon(ing1.type, ing1.category);
                const ing2Icon = getItemIcon(ing2.type, ing2.category);
                
                // 효과 텍스트
                let effectText = '';
                if (resultItem.type === 'food') {
                    const effects = [];
                    if (resultItem.attrGain) {
                        if (resultItem.attr === 'all') {
                            effects.push(`전속성 +${resultItem.attrGain}`);
                        } else if (resultItem.attr === 'dual' && resultItem.dualAttr) {
                            effects.push(`${resultItem.dualAttr.join('+')} 각 +${resultItem.attrGain}`);
                        } else {
                            effects.push(`${resultItem.attr} +${resultItem.attrGain}`);
                        }
                    }
                    if (resultItem.affectionGain) effects.push(`애정도 +${resultItem.affectionGain}`);
                    if (resultItem.growthGain) effects.push(`성장 +${resultItem.growthGain}`);
                    effectText = effects.join(', ');
                } else if (resultItem.type === 'decoration') {
                    effectText = `${resultItem.attr} +${resultItem.power} (${resultItem.quality})`;
                }
                
                html += `
                    <div style="background: var(--bg); border: 1px solid var(--border); border-radius: 8px; padding: 12px;">
                        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                            <span style="font-size: 1.5rem;">${resultItem.icon}</span>
                            <span style="font-weight: 600;">${resultItem.name}</span>
                            <span style="color: #9b59b6; font-size: 0.85rem;">×${recipe.result.count}</span>
                        </div>
                        <div style="font-size: 0.85rem; color: #888; margin-bottom: 5px;">
                            ${ing1Icon} ${ing1Name} ×${ing1.count} + ${ing2Icon} ${ing2Name} ×${ing2.count}
                        </div>
                        <div style="font-size: 0.8rem; color: #9b59b6;">
                            효과: ${effectText}
                        </div>
                    </div>
                `;
            });
            
            const totalRecipes = Object.keys(RECIPES).length;
            const headerText = `<div style="margin-bottom: 15px; font-size: 0.9rem; color: #888;">발견한 레시피: ${discoveredRecipes.length} / ${totalRecipes}</div>`;
            
            container.innerHTML = headerText + (html || '<div style="color: #888; text-align: center; padding: 20px;">아직 발견한 레시피가 없습니다.<br>재료를 조합해 새로운 레시피를 발견해보세요!</div>');
        }
        
        // 레시피 필터
        function filterRecipes(filter) {
            renderRecipeList(filter);
        }
        
        // 게임 데이터 내보내기
        function exportGameData() {
            const gameData = {
                version: '2.1.0',
                exportDate: new Date().toISOString(),
                spirits: spirits,
                collection: collection,
                encyclopedia: encyclopedia,
                inventory: inventory,
                coins: coins,
                terrarium: terrarium,
                installedDecorations: installedDecorations,
                lightMode: lightMode,
                isPaused: isPaused,
                darkModeLocked: darkModeLocked,
                lowSatisfactionStartTime: lowSatisfactionStartTime
            };
            
            try {
                const json = JSON.stringify(gameData);
                const base64 = btoa(unescape(encodeURIComponent(json)));
                const code = 'SGDATA-' + base64;
                
                // 코드 표시 모달
                const modal = document.createElement('div');
                modal.id = 'exportCodeModal';
                const zIndex = getNextZIndex();
                modal.style.cssText = `position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: ${zIndex}; display: flex; justify-content: center; align-items: center;`;
                modal.innerHTML = `
                    <div style="background: var(--card); padding: 24px; border-radius: 12px; max-width: 500px; width: 90%; border: 1px solid var(--border);">
                        <h3 style="margin-bottom: 16px;">📤 게임 데이터 내보내기</h3>
                        <p style="font-size: 0.9rem; color: #888; margin-bottom: 12px;">아래 코드를 복사해서 안전한 곳에 저장하세요.</p>
                        <div style="margin-bottom: 12px;">
                            <textarea id="exportCodeText" readonly style="width: 100%; height: 120px; padding: 10px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg); color: var(--text); font-family: monospace; font-size: 0.75rem; resize: none; box-sizing: border-box;">${code}</textarea>
                        </div>
                        <div style="display: flex; gap: 8px; margin-bottom: 12px;">
                            <button onclick="copyExportCode()" style="flex: 1; padding: 12px; background: var(--water); color: white; border: none; border-radius: 6px; cursor: pointer;">
                                📋 코드 복사
                            </button>
                            <button onclick="downloadExportCode()" style="flex: 1; padding: 12px; background: var(--earth); color: white; border: none; border-radius: 6px; cursor: pointer;">
                                💾 파일로 저장
                            </button>
                        </div>
                        <p style="font-size: 0.8rem; color: #888; text-align: center; margin-bottom: 12px;">
                            📊 정령: ${spirits.length}마리 | 앨범: ${collection.length}마리 | 💰 ${coins}
                        </p>
                        <button onclick="closeExportCodeModal()" style="width: 100%; padding: 10px; background: var(--card); border: 1px solid var(--border); border-radius: 6px; cursor: pointer;">
                            닫기
                        </button>
                    </div>
                `;
                document.body.appendChild(modal);
            } catch (e) {
                console.error('데이터 내보내기 오류:', e);
                showNotification('❌ 데이터 내보내기 실패');
            }
        }
        
        function copyExportCode() {
            const textarea = document.getElementById('exportCodeText');
            textarea.select();
            document.execCommand('copy');
            showNotification('📋 코드가 복사되었습니다!');
        }
        
        function downloadExportCode() {
            const textarea = document.getElementById('exportCodeText');
            const code = textarea.value;
            const blob = new Blob([code], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `spirit-garden-backup-${new Date().toISOString().slice(0, 10)}.txt`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            showNotification('💾 파일로 저장되었습니다!');
        }
        
        function closeExportCodeModal() {
            const modal = document.getElementById('exportCodeModal');
            if (modal) modal.remove();
        }
        
        // 게임 데이터 불러오기
        function importGameData() {
            const modal = document.createElement('div');
            modal.id = 'importCodeModal';
            const zIndex = getNextZIndex();
            modal.style.cssText = `position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: ${zIndex}; display: flex; justify-content: center; align-items: center;`;
            modal.innerHTML = `
                <div style="background: var(--card); padding: 24px; border-radius: 12px; max-width: 500px; width: 90%; border: 1px solid var(--border);">
                    <h3 style="margin-bottom: 16px;">📥 게임 데이터 불러오기</h3>
                    <p style="font-size: 0.9rem; color: #888; margin-bottom: 12px;">백업 코드를 붙여넣거나 파일을 선택하세요.</p>
                    <div style="margin-bottom: 12px;">
                        <textarea id="importCodeText" placeholder="SGDATA-로 시작하는 코드를 붙여넣으세요..." style="width: 100%; height: 120px; padding: 10px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg); color: var(--text); font-family: monospace; font-size: 0.75rem; resize: none; box-sizing: border-box;"></textarea>
                    </div>
                    <div style="display: flex; gap: 8px; margin-bottom: 12px;">
                        <button onclick="executeImportCode()" style="flex: 1; padding: 12px; background: var(--water); color: white; border: none; border-radius: 6px; cursor: pointer;">
                            📥 코드로 불러오기
                        </button>
                        <button onclick="importFromFile()" style="flex: 1; padding: 12px; background: var(--earth); color: white; border: none; border-radius: 6px; cursor: pointer;">
                            📁 파일 선택
                        </button>
                    </div>
                    <p style="font-size: 0.8rem; color: #e74c3c; text-align: center; margin-bottom: 12px;">
                        ⚠️ 현재 데이터는 덮어씌워집니다!
                    </p>
                    <button onclick="closeImportCodeModal()" style="width: 100%; padding: 10px; background: var(--card); border: 1px solid var(--border); border-radius: 6px; cursor: pointer;">
                        닫기
                    </button>
                </div>
            `;
            document.body.appendChild(modal);
        }
        
        function closeImportCodeModal() {
            const modal = document.getElementById('importCodeModal');
            if (modal) modal.remove();
        }
        
        async function executeImportCode() {
            const textarea = document.getElementById('importCodeText');
            const code = textarea.value.trim();
            
            if (!code) {
                showNotification('❌ 코드를 입력해주세요');
                return;
            }
            
            try {
                let gameData;
                
                if (code.startsWith('SGDATA-')) {
                    // 코드 형식
                    const base64 = code.substring(7);
                    const json = decodeURIComponent(escape(atob(base64)));
                    gameData = JSON.parse(json);
                } else if (code.startsWith('{')) {
                    // JSON 형식 (하위 호환)
                    gameData = JSON.parse(code);
                } else {
                    throw new Error('올바른 형식이 아닙니다');
                }
                
                // 데이터 유효성 검사
                if (!gameData.spirits || !gameData.collection || !gameData.inventory) {
                    throw new Error('올바른 게임 데이터가 아닙니다');
                }
                
                const confirmed = await showConfirm(
                    '데이터 불러오기',
                    `백업 데이터를 불러오시겠습니까?\n\n백업 일시: ${new Date(gameData.exportDate).toLocaleString()}\n정령 수: ${gameData.spirits.length}\n앨범: ${gameData.collection.length}\n💰 ${gameData.coins}\n\n현재 데이터는 덮어씌워집니다.`
                );
                
                if (!confirmed) return;
                
                // 데이터 복원
                applyGameData(gameData);
                closeImportCodeModal();
                showNotification('✅ 게임 데이터를 불러왔습니다');
                switchTab('garden');
            } catch (error) {
                console.error('데이터 불러오기 오류:', error);
                showNotification('❌ 불러오기 실패: ' + error.message);
            }
        }
        
        function importFromFile() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json,.txt';
            
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                try {
                    const text = await file.text();
                    document.getElementById('importCodeText').value = text.trim();
                    showNotification('📁 파일을 불러왔습니다. "코드로 불러오기"를 클릭하세요.');
                } catch (error) {
                    showNotification('❌ 파일 읽기 실패');
                }
            };
            
            input.click();
        }
        
        function applyGameData(gameData) {
            spirits = gameData.spirits || [];
            collection = gameData.collection || [];
            encyclopedia = gameData.encyclopedia || {};
            inventory = gameData.inventory || { food: [], music: [], decorations: [], medicine: [] };
            coins = gameData.coins || 0;
            terrarium = gameData.terrarium || { fire: 0, water: 0, wind: 0, earth: 0, light: 0, dark: 0 };
            installedDecorations = gameData.installedDecorations || [];
            lightMode = gameData.lightMode !== undefined ? gameData.lightMode : true;
            isPaused = gameData.isPaused || false;
            darkModeLocked = gameData.darkModeLocked || false;
            lowSatisfactionStartTime = gameData.lowSatisfactionStartTime || {};
            
            saveGame();
            
            // UI 새로고침
            renderSpirits();
            renderInventory();
            updateCoinDisplay();
            applyLightMode();
            updateSettingsInfo();
        }

        function recalculateTerrariumEnvironment() {
            // 환경 초기화
            terrarium = {
                fire: 0,
                water: 0,
                wind: 0,
                earth: 0,
                light: 0,
                dark: 0
            };

            // 설치된 모든 장식물을 순회하며 환경 계산
            installedDecorations.forEach(deco => {
                // 문자열 또는 객체 모두 지원
                const decoKey = typeof deco === 'string' ? deco : deco.type;
                const decoData = DECORATION_TYPES[decoKey];
                const eventItem = EVENT_ITEMS[decoKey];
                
                // 일반 장식물 처리
                if (decoData) {
                    const attr = decoData.attr;
                    const power = decoData.power;
                    
                    // 복합 속성 장식물 처리
                    if (attr === 'dual' && decoData.dualAttr) {
                        // 두 속성 모두 증가 (대립 속성 감소 없음)
                        decoData.dualAttr.forEach(dualAttr => {
                            terrarium[dualAttr] = Math.min(50, terrarium[dualAttr] + power);
                        });
                    } else if (attr === 'all') {
                        // 모든 속성 증가 (대립 속성 감소 없음)
                        ['fire', 'water', 'wind', 'earth', 'light', 'dark'].forEach(allAttr => {
                            terrarium[allAttr] = Math.min(50, terrarium[allAttr] + power);
                        });
                    } else {
                        // 해당 속성 증가 (최대 50까지)
                        terrarium[attr] = Math.min(50, terrarium[attr] + power);

                        // 대립 속성 감소 (power만큼)
                        const opposites = {
                            fire: 'water',
                            water: 'fire',
                            wind: 'earth',
                            earth: 'wind',
                            light: 'dark',
                            dark: 'light'
                        };
                        const opposite = opposites[attr];
                        if (opposite) {
                            terrarium[opposite] = Math.max(0, terrarium[opposite] - power);
                        }
                    }
                }
                
                // 이벤트 장식물 처리 (effects 객체 사용, 대립 속성 감소 없음)
                if (eventItem && eventItem.type === 'decoration' && eventItem.effects) {
                    Object.entries(eventItem.effects).forEach(([attr, power]) => {
                        if (terrarium.hasOwnProperty(attr) && power > 0) {
                            terrarium[attr] = Math.min(50, terrarium[attr] + power);
                        }
                    });
                }
            });
        }

        function toggleLight() {
            const now = Date.now();
            
            // 현재 조명 변경 기록
            lightToggleHistory.push(now);
            
            // 1분(60초) 이전 기록 제거
            lightToggleHistory = lightToggleHistory.filter(time => (now - time) < 60000);
            
            // 1분 이내 5회 이상 변경 체크
            const isSpamming = lightToggleHistory.length >= 5;
            
            lightMode = !lightMode;
            
            // 정령들 반응
            spirits.forEach(spirit => {
                if (!spirit.isDead && !spirit.isCompleted) {
                    if (isSpamming) {
                        // 조명 남용 시 화내거나 춤추기
                        const spamMessages = [
                            `${spirit.name}이(가) 당신의 장난에 화를 냅니다.`,
                            `${spirit.name}이(가) 격한 춤을 춥니다.`,
                            `${spirit.name}이(가) 조명 장난에 짜증을 냅니다.`,
                            `${spirit.name}이(가) 어지러워합니다!`
                        ];
                        spirit.status = spamMessages[Math.floor(Math.random() * spamMessages.length)];
                        
                        // 일지 추가
                        addLog(spirit, spirit.status);
                        
                        // 애정도 -1
                        spirit.parameters.affection = Math.max(0, spirit.parameters.affection - 1);
                    } else {
                        // 정상적인 조명 전환 반응
                        if (lightMode) {
                            // 조명 켜짐
                            spirit.status = `${spirit.name}이(가) 갑자기 주변이 환해져 깜짝 놀랍니다.`;
                        } else {
                            // 조명 꺼짐
                            spirit.status = `${spirit.name}이(가) 갑자기 주변이 어두워져 깜짝 놀랍니다.`;
                        }
                        
                        // 일지 추가
                        addLog(spirit, spirit.status);
                    }
                }
            });
            
            applyLightMode();
            recalculateTerrariumEnvironment();
            saveGame();
            updateAllSpiritCards();
            if (document.getElementById('terrariumSection').classList.contains('active')) {
                renderTerrariumManagement();
            }
            
            if (isSpamming) {
                showNotification(lightMode ? '☀️ 조명을 켰습니다 (정령이 화를 냅니다!)' : '🌙 조명을 껐습니다 (정령이 화를 냅니다!)');
            } else {
                showNotification(lightMode ? '☀️ 조명을 켰습니다' : '🌙 조명을 껐습니다');
            }
            
            // 튜토리얼 액션 체크
            checkTutorialAction('toggleLight');
        }

        function applyLightMode() {
            const lightIcon = document.getElementById('lightIcon');
            
            // 다크 모드 고정이 활성화되어 있으면 조명 상태 무시
            if (darkModeLocked) {
                document.body.classList.add('dark-mode');
                if (lightIcon) lightIcon.textContent = '🌙';
                return;
            }
            
            if (lightMode) {
                document.body.classList.remove('dark-mode');
                if (lightIcon) lightIcon.textContent = '☀️';
            } else {
                document.body.classList.add('dark-mode');
                if (lightIcon) lightIcon.textContent = '🌙';
            }
        }
        
        // 일시정지 토글
        function togglePause() {
            isPaused = !isPaused;
            const pauseBtn = document.getElementById('pauseBtn');
            
            if (isPaused) {
                pausedAt = Date.now(); // 일시정지 시작 시간 기록
                if (pauseBtn) {
                    pauseBtn.textContent = '▶️';
                    pauseBtn.style.background = '#4CAF50';
                }
                showNotification('⏸️ 게임이 일시정지되었습니다');
            } else {
                if (pausedAt) {
                    // 일시정지했던 시간을 누적
                    totalPausedTime += (Date.now() - pausedAt);
                    pausedAt = null;
                }
                if (pauseBtn) {
                    pauseBtn.textContent = '⏸️';
                    pauseBtn.style.background = '#ff9800';
                }
                showNotification('▶️ 게임이 재개되었습니다');
            }
            
            // 버튼 상태 업데이트
            updateGatherButton();
            updateAllSpiritCards();
            
            saveGame();
        }
        
        // 게임 리셋
        async function resetGame() {
            const confirm1 = await showConfirm(
                '게임 초기화',
                '정말로 게임을 초기화하시겠습니까?\n\n모든 정령, 장식물, 먹이, 음악, 코인, 도감이 삭제됩니다.\n이 작업은 되돌릴 수 없습니다!'
            );
            
            if (!confirm1) {
                return;
            }
            
            const confirm2 = await showConfirm(
                '최종 확인',
                '다시 한 번 확인합니다.\n정말로 모든 데이터를 삭제하시겠습니까?'
            );
            
            if (!confirm2) {
                return;
            }
            
            // 모든 데이터 초기화
            spirits = [];
            collection = [];
            encyclopedia = {};
            inventory = {
                music: [],
                decorations: [],
                food: ['fire', 'fire', 'fire', 'water', 'water', 'water', 'wind', 'wind', 'wind', 'earth', 'earth', 'earth']
            };
            terrarium = {
                fire: 0,
                water: 0,
                wind: 0,
                earth: 0,
                light: 0,
                dark: 0
            };
            installedDecorations = [];
            lightMode = true;
            coins = 0;
            currentTitle = 'none';
            lastGatherTime = null;
            isPaused = false;
            pausedAt = null;
            totalPausedTime = 0;
            
            // localStorage 삭제
            localStorage.removeItem('spiritGardenV2');
            localStorage.removeItem('spiritGarden_openingSeen'); // 오프닝도 다시 보이게
            localStorage.removeItem('spiritGarden_tutorialSeen'); // 튜토리얼도 다시 보이게
            
            // UI 업데이트
            renderSpirits();
            renderInventory();
            renderShop();
            updateCoinDisplay();
            applyLightMode();
            renderEncyclopedia();
            renderCollection();
            
            const titleSelect = document.getElementById('titleSelect');
            if (titleSelect) {
                titleSelect.value = 'none';
            }
            
            const pauseBtn = document.getElementById('pauseBtn');
            if (pauseBtn) {
                pauseBtn.textContent = '⏸️';
                pauseBtn.classList.remove('paused');
            }
            
            showNotification('🔄 게임이 초기화되었습니다');
            
            // 육성 탭으로 이동 후 오프닝 표시 (약간의 딜레이)
            switchTab('garden');
            setTimeout(() => {
                console.log('오프닝 표시 시도...');
                showOpening();
            }, 500);
        }

        function renderTerrariumManagement() {
            // 환경 바 업데이트 (최대 50)
            Object.entries(terrarium).forEach(([attr, value]) => {
                const bar = document.getElementById(`terr${attr.charAt(0).toUpperCase() + attr.slice(1)}Bar`);
                const valueSpan = document.getElementById(`terr${attr.charAt(0).toUpperCase() + attr.slice(1)}Value`);
                if (bar) bar.style.width = `${(value / 50) * 100}%`;
                if (valueSpan) valueSpan.textContent = value;
            });
            
            // 전체 품질 업데이트
            const qualityEl = document.getElementById('terrariumQuality');
            if (qualityEl) {
                const avgQuality = calculateTerrariumQuality();
                qualityEl.textContent = avgQuality.toFixed(1);
                
                // 품질에 따른 색상 변경
                if (avgQuality > 4) {
                    qualityEl.style.color = '#4caf50'; // 초록 (높음)
                } else if (avgQuality > 3) {
                    qualityEl.style.color = '#ff9800'; // 주황 (보통)
                } else {
                    qualityEl.style.color = '#f44336'; // 빨강 (낮음)
                }
            }

            // 설치된 장식물 개수 업데이트
            const installedCountEl = document.getElementById('installedCount');
            if (installedCountEl) {
                installedCountEl.textContent = `${installedDecorations.length} / 20`;
            }

            // 설치된 장식물 목록
            const installedContainer = document.getElementById('installedDecorList');
            if (installedDecorations.length === 0) {
                installedContainer.innerHTML = '<p style="color: #888; text-align: center; padding: 20px;">설치된 장식물이 없습니다</p>';
            } else {
                const installedCounts = {};
                installedDecorations.forEach(d => {
                    // 문자열 또는 객체 모두 지원
                    const decoType = typeof d === 'string' ? d : d.type;
                    installedCounts[decoType] = (installedCounts[decoType] || 0) + 1;
                });

                // 속성별, 이름별로 정렬 (순서 고정)
                const sortedEntries = Object.entries(installedCounts).sort((a, b) => {
                    const dataA = DECORATION_TYPES[a[0]] || EVENT_ITEMS[a[0]];
                    const dataB = DECORATION_TYPES[b[0]] || EVENT_ITEMS[b[0]];
                    if (!dataA || !dataB) return 0;
                    
                    // 이벤트 아이템은 맨 위로
                    const isEventA = !!EVENT_ITEMS[a[0]];
                    const isEventB = !!EVENT_ITEMS[b[0]];
                    if (isEventA && !isEventB) return -1;
                    if (!isEventA && isEventB) return 1;
                    
                    if (!isEventA && !isEventB) {
                        // 1. 속성별 정렬
                        const attrOrder = { fire: 0, water: 1, wind: 2, earth: 3, light: 4, dark: 5 };
                        const attrDiff = (attrOrder[dataA.attr] || 0) - (attrOrder[dataB.attr] || 0);
                        if (attrDiff !== 0) return attrDiff;
                        
                        // 2. 품질별 정렬 (높은 순)
                        const qualityOrder = { epic: 0, rare: 1, common: 2 };
                        const qualityDiff = (qualityOrder[dataA.quality] || 2) - (qualityOrder[dataB.quality] || 2);
                        if (qualityDiff !== 0) return qualityDiff;
                        
                        // 3. 이름별 정렬
                        return dataA.name.localeCompare(dataB.name);
                    }
                    
                    return 0;
                });
                
                installedContainer.innerHTML = `
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                        ${sortedEntries.map(([key, count]) => {
                            // 일반 장식물 체크
                            const decoData = DECORATION_TYPES[key];
                            if (decoData) {
                                const qualityLabel = decoData.quality === 'epic' ? '⭐' : decoData.quality === 'rare' ? '💎' : '';
                                return `
                                    <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px; background: var(--bg); border: 1px solid var(--border); border-radius: 4px;">
                                        <div style="display: flex; align-items: center; gap: 8px;">
                                            <span style="font-size: 1.3rem;">${qualityLabel}${decoData.icon}</span>
                                            <div>
                                                <div style="font-weight: 700; font-size: 0.9rem;">${decoData.name} ×${count}</div>
                                                <div style="font-size: 0.75rem; color: #888;">${decoData.attr} +${decoData.power}</div>
                                            </div>
                                        </div>
                                        <button onclick="removeDecorationFromTerrarium('${key}')" style="padding: 6px 10px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.8rem;">
                                            회수
                                        </button>
                                    </div>
                                `;
                            }
                            
                            // 이벤트 장식물 체크
                            const eventItem = EVENT_ITEMS[key];
                            if (eventItem && eventItem.type === 'decoration') {
                                // 간소화된 효과 텍스트
                                let effectsText = '모든 속성 +5';
                                if (key === 'christmas_tree') {
                                    effectsText = '모든 속성 +5, 빛 +10';
                                } else if (key === 'christmas_gift') {
                                    effectsText = '모든 속성 +3, 빛/암 +5';
                                }
                                return `
                                    <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px; background: var(--bg); border: 1px solid var(--border); border-radius: 4px;">
                                        <div style="display: flex; align-items: center; gap: 8px;">
                                            <span style="font-size: 1.3rem;">🎄${eventItem.icon}</span>
                                            <div>
                                                <div style="font-weight: 700; font-size: 0.9rem;">${eventItem.name} ×${count}</div>
                                                <div style="font-size: 0.75rem; color: #c41e3a;">${effectsText}</div>
                                            </div>
                                        </div>
                                        <button onclick="removeDecorationFromTerrarium('${key}')" style="padding: 6px 10px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.8rem;">
                                            회수
                                        </button>
                                    </div>
                                `;
                            }
                            
                            return '';
                        }).join('')}
                    </div>
                `;
            }

            // 인벤토리 장식물 목록
            const listContainer = document.getElementById('terrariumDecorList');
            const filterArea = document.getElementById('terrariumFilterArea');
            if (!inventory.decorations) inventory.decorations = [];
            
            // 필터 UI를 오른쪽 상단에 렌더링
            if (filterArea) {
                filterArea.innerHTML = `
                    <select id="terrariumAttrFilter" onchange="setTerrariumFilter(this.value, 'attr')" style="padding: 6px 10px; border-radius: 4px; border: 1px solid var(--border); background: var(--bg); font-size: 0.85rem;">
                        <option value="all" ${terrariumInvFilter === 'all' ? 'selected' : ''}>속성</option>
                        <option value="event" ${terrariumInvFilter === 'event' ? 'selected' : ''}>🎄 이벤트</option>
                        <option value="fire" ${terrariumInvFilter === 'fire' ? 'selected' : ''}>🔥 불</option>
                        <option value="water" ${terrariumInvFilter === 'water' ? 'selected' : ''}>💧 물</option>
                        <option value="wind" ${terrariumInvFilter === 'wind' ? 'selected' : ''}>🌪️ 바람</option>
                        <option value="earth" ${terrariumInvFilter === 'earth' ? 'selected' : ''}>🌱 땅</option>
                        <option value="light" ${terrariumInvFilter === 'light' ? 'selected' : ''}>✨ 빛</option>
                        <option value="dark" ${terrariumInvFilter === 'dark' ? 'selected' : ''}>🌙 어둠</option>
                    </select>
                    <select id="terrariumQualityFilterSelect" onchange="setTerrariumFilter(this.value, 'quality')" style="padding: 6px 10px; border-radius: 4px; border: 1px solid var(--border); background: var(--bg); font-size: 0.85rem;">
                        <option value="all" ${terrariumQualityFilter === 'all' ? 'selected' : ''}>품질</option>
                        <option value="common" ${terrariumQualityFilter === 'common' ? 'selected' : ''}>일반</option>
                        <option value="rare" ${terrariumQualityFilter === 'rare' ? 'selected' : ''}>💎 희귀</option>
                        <option value="epic" ${terrariumQualityFilter === 'epic' ? 'selected' : ''}>⭐ 에픽</option>
                    </select>
                `;
            }
            
            if (inventory.decorations.length === 0) {
                listContainer.innerHTML = '<p style="color: #888; text-align: center; padding: 20px;">보유한 장식물이 없습니다</p>';
                return;
            }

            const decorCounts = {};
            inventory.decorations.forEach(d => {
                decorCounts[d] = (decorCounts[d] || 0) + 1;
            });

            const canInstall = installedDecorations.length < 20;

            // 속성별, 품질별, 이름별로 정렬 (순서 고정)
            let sortedDecorEntries = Object.entries(decorCounts).sort((a, b) => {
                const dataA = DECORATION_TYPES[a[0]] || EVENT_ITEMS[a[0]];
                const dataB = DECORATION_TYPES[b[0]] || EVENT_ITEMS[b[0]];
                if (!dataA || !dataB) return 0;
                
                // 이벤트 아이템은 맨 위로
                const isEventA = !!EVENT_ITEMS[a[0]];
                const isEventB = !!EVENT_ITEMS[b[0]];
                if (isEventA && !isEventB) return -1;
                if (!isEventA && isEventB) return 1;
                
                // 일반 장식물 정렬
                if (!isEventA && !isEventB) {
                    // 1. 속성별 정렬
                    const attrOrder = { fire: 0, water: 1, wind: 2, earth: 3, light: 4, dark: 5 };
                    const attrDiff = (attrOrder[dataA.attr] || 0) - (attrOrder[dataB.attr] || 0);
                    if (attrDiff !== 0) return attrDiff;
                    
                    // 2. 품질별 정렬 (높은 순)
                    const qualityOrder = { epic: 0, rare: 1, common: 2 };
                    const qualityDiff = (qualityOrder[dataA.quality] || 2) - (qualityOrder[dataB.quality] || 2);
                    if (qualityDiff !== 0) return qualityDiff;
                    
                    // 3. 이름별 정렬
                    return dataA.name.localeCompare(dataB.name);
                }
                
                return 0;
            });
            
            // 필터 적용
            sortedDecorEntries = sortedDecorEntries.filter(([key, count]) => {
                const decoData = DECORATION_TYPES[key];
                const eventItem = EVENT_ITEMS[key];
                const isEvent = !!eventItem;
                
                // 속성 필터
                if (terrariumInvFilter !== 'all') {
                    if (terrariumInvFilter === 'event') {
                        if (!isEvent) return false;
                    } else {
                        if (isEvent) return false; // 이벤트 아이템은 속성 필터에서 제외
                        if (decoData && decoData.attr !== terrariumInvFilter) return false;
                    }
                }
                
                // 품질 필터
                if (terrariumQualityFilter !== 'all') {
                    if (isEvent) return false; // 이벤트 아이템은 품질 필터에서 제외
                    if (decoData && decoData.quality !== terrariumQualityFilter) return false;
                }
                
                return true;
            });
            
            if (sortedDecorEntries.length === 0) {
                listContainer.innerHTML = '<p style="color: #888; text-align: center; padding: 20px;">조건에 맞는 장식물이 없습니다</p>';
                return;
            }

            listContainer.innerHTML = `
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                    ${sortedDecorEntries.map(([key, count]) => {
                        // 일반 장식물 체크
                        const decoData = DECORATION_TYPES[key];
                        if (decoData) {
                            const qualityLabel = decoData.quality === 'epic' ? '⭐' : decoData.quality === 'rare' ? '💎' : '';
                            return `
                                <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px; background: var(--bg); border: 1px solid var(--border); border-radius: 4px;">
                                    <div style="display: flex; align-items: center; gap: 8px;">
                                        <span style="font-size: 1.3rem;">${qualityLabel}${decoData.icon}</span>
                                        <div>
                                            <div style="font-weight: 700; font-size: 0.9rem;">${decoData.name} ×${count}</div>
                                            <div style="font-size: 0.75rem; color: #888;">${decoData.attr} +${decoData.power}</div>
                                        </div>
                                    </div>
                                    <button onclick="placeDecorationInTerrarium('${key}')" style="padding: 6px 10px; border: none; border-radius: 4px; cursor: pointer; font-size: 0.8rem;" ${!canInstall ? 'disabled' : ''}>
                                        ${canInstall ? '설치' : '가득'}
                                    </button>
                                </div>
                            `;
                        }
                        
                        // 이벤트 장식물 체크
                        const eventItem = EVENT_ITEMS[key];
                        if (eventItem && eventItem.type === 'decoration') {
                            // 간소화된 효과 텍스트
                            let effectsText = '모든 속성 +5';
                            if (key === 'christmas_tree') {
                                effectsText = '모든 속성 +5, 빛 +10';
                            } else if (key === 'christmas_gift') {
                                effectsText = '모든 속성 +3, 빛/암 +5';
                            }
                            return `
                                <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px; background: var(--bg); border: 1px solid var(--border); border-radius: 4px;">
                                    <div style="display: flex; align-items: center; gap: 8px;">
                                        <span style="font-size: 1.3rem;">🎄${eventItem.icon}</span>
                                        <div>
                                            <div style="font-weight: 700; font-size: 0.9rem;">${eventItem.name} ×${count}</div>
                                            <div style="font-size: 0.75rem; color: #c41e3a;">${effectsText}</div>
                                        </div>
                                    </div>
                                    <button onclick="placeDecorationInTerrarium('${key}')" style="padding: 6px 10px; border: none; border-radius: 4px; cursor: pointer; font-size: 0.8rem;" ${!canInstall ? 'disabled' : ''}>
                                        ${canInstall ? '설치' : '가득'}
                                    </button>
                                </div>
                            `;
                        }
                        
                        return '';
                    }).join('')}
                </div>
            `;
        }
        
        function setTerrariumFilter(value, type) {
            if (type === 'attr') {
                terrariumInvFilter = value;
            } else if (type === 'quality') {
                terrariumQualityFilter = value;
            }
            renderTerrariumManagement();
        }

        function placeDecorationInTerrarium(decorationType) {
            if (!inventory.decorations) inventory.decorations = [];
            
            // 최대 20개 체크
            if (installedDecorations.length >= 20) {
                showNotification('테라리움이 가득 찼습니다 (최대 20개)');
                return;
            }

            const invIndex = inventory.decorations.indexOf(decorationType);
            if (invIndex === -1) return;

            const decoData = DECORATION_TYPES[decorationType];
            const eventItem = EVENT_ITEMS[decorationType];
            
            if (!decoData && !eventItem) return;

            // 같은 타입의 장식물이 있는지 확인 (위치 고정을 위해)
            const existingIndices = installedDecorations
                .map((d, i) => ({ type: typeof d === 'string' ? d : d.type, index: i }))
                .filter(d => d.type === decorationType)
                .map(d => d.index);
            
            let targetIndex = installedDecorations.length; // 기본값: 맨 뒤
            
            if (existingIndices.length > 0) {
                // 같은 타입이 있으면 그 다음 위치에 배치
                targetIndex = Math.max(...existingIndices) + 1;
            }

            // 인벤토리에서 제거
            inventory.decorations.splice(invIndex, 1);
            
            // 설치 목록에 추가 (위치 정보 포함)
            installedDecorations.splice(targetIndex, 0, { type: decorationType, index: targetIndex });
            
            // 인덱스 재정렬
            installedDecorations.forEach((d, i) => {
                if (typeof d === 'object') {
                    d.index = i;
                }
            });

            // 환경 재계산
            recalculateTerrariumEnvironment();

            // 만족도 즉시 업데이트
            spirits.forEach(spirit => {
                if (!spirit.isDead && !spirit.isCompleted) {
                    spirit.satisfaction = calculateSatisfaction(spirit);
                }
            });
            
            const itemData = decoData || eventItem;
            saveGame();
            renderTerrariumManagement();
            renderInventory();
            renderSpirits();  // 만족도 변경 반영
            showNotification(`${itemData.icon} ${itemData.name} 설치 완료`);
        }

        function removeDecorationFromTerrarium(decorationType) {
            // 문자열 또는 객체 모두 지원
            const index = installedDecorations.findIndex(d => 
                (typeof d === 'string' ? d : d.type) === decorationType
            );
            if (index === -1) return;

            const decoData = DECORATION_TYPES[decorationType];
            const eventItem = EVENT_ITEMS[decorationType];
            const itemData = decoData || eventItem;
            
            if (!itemData) return;

            // 설치 목록에서 제거하고 인벤토리에 추가
            installedDecorations.splice(index, 1);
            
            // 인덱스 재정렬
            installedDecorations.forEach((d, i) => {
                if (typeof d === 'object') {
                    d.index = i;
                }
            });
            
            if (!inventory.decorations) inventory.decorations = [];
            inventory.decorations.push(decorationType);

            // 환경 재계산
            recalculateTerrariumEnvironment();
            
            // 정령들이 사라진 장식을 찾는 메시지 (3분 이내 랜덤)
            spirits.forEach(spirit => {
                if (!spirit.isDead && !spirit.isCompleted) {
                    const searchMessages = [
                        `${spirit.name}이(가) ${itemData.name}이(가) 어디갔는지 찾습니다.`,
                        `${spirit.name}이(가) ${itemData.name}을(를) 두리번거리며 찾습니다.`,
                        `${spirit.name}이(가) 사라진 ${itemData.name}을(를) 찾아 헤맵니다.`,
                        `${spirit.name}이(가) ${itemData.name}이(가) 없어져서 슬퍼합니다.`,
                        `${spirit.name}이(가) ${itemData.name}이(가) 그리워 보입니다.`
                    ];
                    const randomMessage = searchMessages[Math.floor(Math.random() * searchMessages.length)];
                    
                    // 0~180초(3분) 사이 랜덤 타이밍
                    const randomDelay = Math.random() * 180000; // 0 ~ 180000ms (0 ~ 3분)
                    
                    console.log(`${spirit.name}: ${randomDelay/1000}초 후에 "${randomMessage}" 표시 예정`);
                    
                    setTimeout(() => {
                        // 타임아웃 실행 시점에도 정령이 살아있고 완성되지 않았는지 재확인
                        const currentSpirit = spirits.find(s => s.id === spirit.id);
                        if (currentSpirit && !currentSpirit.isDead && !currentSpirit.isCompleted) {
                            console.log(`${currentSpirit.name}: 장식물 반응 표시 - "${randomMessage}"`);
                            currentSpirit.status = randomMessage;
                            
                            // 일지 추가
                            addLog(currentSpirit, randomMessage);
                            
                            updateSpiritCard(currentSpirit);
                        }
                    }, randomDelay);
                }
            });

            // 만족도 즉시 업데이트
            spirits.forEach(spirit => {
                if (!spirit.isDead && !spirit.isCompleted) {
                    spirit.satisfaction = calculateSatisfaction(spirit);
                }
            });
            
            saveGame();
            renderTerrariumManagement();
            renderInventory();
            renderSpirits();  // 만족도 변경 반영
            showNotification(`${itemData.icon} ${itemData.name} 회수 완료`);
        }

        // 랜덤 메시지 생성
        function getRandomMessage(spirit) {
            if (spirit.isDead || spirit.isCompleted) return spirit.status;
            
            const affection = spirit.parameters.affection || 0;
            const now = Date.now();
            const timeSinceLastFed = spirit.lastFed ? (now - spirit.lastFed) / 1000 : Infinity;
            const timeSinceLastMusic = spirit.lastMusic ? (now - spirit.lastMusic) / 1000 : Infinity;
            const stage = getStage(spirit.growth);
            
            // 알/번데기 상태인지 확인
            const isEgg = stage === 'egg';
            const isPupa = stage === 'pupa';
            
            let availableMessages = [];
            
            // 크리스마스 이벤트 정령 체크 (알/번데기가 아닐 때만)
            if (!isEgg && !isPupa) {
                const hasChristmasSpirit = spirits.some(s => s.isEventSpirit && s.eventType === 'christmas2025' && !s.isDead && !s.isCompleted);
                const isChristmasSpirit = spirit.isEventSpirit && spirit.eventType === 'christmas2025';
                
                // 크리스마스 장식 체크
                const hasChristmasTree = installedDecorations.some(d => {
                    const decoType = typeof d === 'string' ? d : d.type;
                    return decoType === 'christmas_tree';
                });
                const hasChristmasGift = installedDecorations.some(d => {
                    const decoType = typeof d === 'string' ? d : d.type;
                    return decoType === 'christmas_gift';
                });
                
                // 크리스마스 이벤트 대사 (25% 확률로 우선 출력)
                if ((hasChristmasSpirit || isChristmasSpirit) && Math.random() < 0.25) {
                    let christmasMessages = [];
                    
                    // 이벤트 정령 개인 대사
                    if (isChristmasSpirit) {
                        christmasMessages.push(
                            `${spirit.name}이(가) 캐롤을 흥얼거립니다 🎵`,
                            `${spirit.name} 주변으로 눈송이가 내립니다 ❄️`,
                            `${spirit.name}이(가) 빨간 모자를 고쳐 씁니다 🎅`
                        );
                        if (hasChristmasGift) {
                            christmasMessages.push(`${spirit.name}이(가) 선물 상자를 궁금해합니다 🎁`);
                        }
                        if (hasChristmasTree) {
                            christmasMessages.push(`${spirit.name}이(가) 트리 위 반짝이는 별을 바라봅니다 ⭐`);
                        }
                    }
                    
                    // 크리스마스 정령 없어도 장식이 있으면 개인 반응
                    if (!isChristmasSpirit && hasChristmasSpirit) {
                        if (hasChristmasTree) {
                            christmasMessages.push(`${spirit.name}이(가) 크리스마스 트리를 신기하게 바라봅니다 🎄`);
                        }
                        if (hasChristmasGift) {
                            christmasMessages.push(`${spirit.name}이(가) 선물 상자 주변을 맴돕니다 🎁`);
                        }
                    }
                    
                    if (christmasMessages.length > 0) {
                        return christmasMessages[Math.floor(Math.random() * christmasMessages.length)];
                    }
                }
            }
            
            // === 알 상태 대사 ===
            if (isEgg) {
                // 배고픔 (5분 이상 안 먹임) - 70% 확률
                if (timeSinceLastFed > 300 && Math.random() < 0.7) {
                    availableMessages = [...RANDOM_MESSAGES.egg_hungry];
                }
                // 최근에 음악 들음 (5분 이내, 30% 확률)
                else if (timeSinceLastMusic < 300 && spirit.lastMusicType && Math.random() < 0.3) {
                    const musicData = MUSIC_TYPES[spirit.lastMusicType];
                    const musicName = musicData ? musicData.name : '음악';
                    availableMessages = RANDOM_MESSAGES.egg_music.map(msg => 
                        msg.replace('{music}', musicName)
                    );
                }
                // 잠 (15% 확률)
                else if (Math.random() < 0.15) {
                    if (lightMode) {
                        availableMessages = [...RANDOM_MESSAGES.egg_napLight];
                    } else {
                        availableMessages = [...RANDOM_MESSAGES.egg_sleepDark];
                    }
                }
                // 애정도 낮음 (20% 확률)
                else if (affection < 30 && Math.random() < 0.2) {
                    availableMessages = [...RANDOM_MESSAGES.egg_affectionLow];
                }
                // 기본 대사
                if (availableMessages.length === 0) {
                    availableMessages = [...RANDOM_MESSAGES.egg_basic];
                }
                
                const randomMessage = availableMessages[Math.floor(Math.random() * availableMessages.length)];
                return randomMessage.replace('{name}', spirit.name);
            }
            
            // === 번데기 상태 대사 ===
            if (isPupa) {
                // 배고픔 (5분 이상 안 먹임) - 70% 확률
                if (timeSinceLastFed > 300 && Math.random() < 0.7) {
                    availableMessages = [...RANDOM_MESSAGES.pupa_hungry];
                }
                // 최근에 음악 들음 (5분 이내, 30% 확률)
                else if (timeSinceLastMusic < 300 && spirit.lastMusicType && Math.random() < 0.3) {
                    const musicData = MUSIC_TYPES[spirit.lastMusicType];
                    const musicName = musicData ? musicData.name : '음악';
                    availableMessages = RANDOM_MESSAGES.pupa_music.map(msg => 
                        msg.replace('{music}', musicName)
                    );
                }
                // 잠 (15% 확률)
                else if (Math.random() < 0.15) {
                    if (lightMode) {
                        availableMessages = [...RANDOM_MESSAGES.pupa_napLight];
                    } else {
                        availableMessages = [...RANDOM_MESSAGES.pupa_sleepDark];
                    }
                }
                // 애정도 낮음 (20% 확률)
                else if (affection < 30 && Math.random() < 0.2) {
                    availableMessages = [...RANDOM_MESSAGES.pupa_affectionLow];
                }
                // 기본 대사
                if (availableMessages.length === 0) {
                    availableMessages = [...RANDOM_MESSAGES.pupa_basic];
                }
                
                const randomMessage = availableMessages[Math.floor(Math.random() * availableMessages.length)];
                return randomMessage.replace('{name}', spirit.name);
            }
            
            // === 애벌레 상태 대사 (기존 로직) ===
            // 배고픔 (5분=300초 이상 안 먹임) - 70% 확률로 배고픔 메시지
            if (timeSinceLastFed > 300 && Math.random() < 0.7) {
                availableMessages = [...RANDOM_MESSAGES.hungry];
            }
            // 배고픔이 아니거나, 배고픔이지만 30% 확률로 다른 메시지
            else {
                // 최근에 음악 들음 (5분=300초 이내, 30% 확률)
                if (timeSinceLastMusic < 300 && spirit.lastMusicType && Math.random() < 0.3) {
                    const musicName = MUSIC_TYPES[spirit.lastMusicType].name;
                    availableMessages = RANDOM_MESSAGES.music.map(msg => 
                        msg.replace('{music}', musicName)
                    );
                }
                // 장식물 설치됨 (30% 확률)
                else if (installedDecorations.length > 0 && Math.random() < 0.3) {
                    const randomDeco = installedDecorations[Math.floor(Math.random() * installedDecorations.length)];
                    const decoType = typeof randomDeco === 'string' ? randomDeco : randomDeco.type;
                    if (RANDOM_MESSAGES.decorations[decoType]) {
                        availableMessages = [...RANDOM_MESSAGES.decorations[decoType]];
                    }
                }
                // 테라리움이 텅 비어있음 (30% 확률)
                else if (installedDecorations.length === 0 && Math.random() < 0.3) {
                    availableMessages = [
                        `${spirit.name}이(가) 텅 빈 테라리움 안을 빙글빙글 돌아다닙니다.`,
                        `${spirit.name}이(가) 심심해 보입니다.`,
                        `${spirit.name}이(가) 아무것도 없는 공간을 두리번거립니다.`,
                        `${spirit.name}이(가) 무료해 보입니다.`
                    ];
                }
                // 잠 (조명에 따라, 15% 확률)
                else if (Math.random() < 0.15) {
                    if (lightMode) {
                        availableMessages = [...RANDOM_MESSAGES.napLight];
                    } else {
                        availableMessages = [...RANDOM_MESSAGES.sleepDark];
                    }
                }
            }
            
            // 위 조건에 해당 안 되면 애정도별 메시지
            if (availableMessages.length === 0) {
                if (affection >= 100) {
                    availableMessages = [...RANDOM_MESSAGES.affectionVeryHigh, ...RANDOM_MESSAGES.basic];
                } else if (affection >= 50) {
                    availableMessages = [...RANDOM_MESSAGES.affectionHigh, ...RANDOM_MESSAGES.basic];
                } else if (affection >= 30) {
                    availableMessages = [...RANDOM_MESSAGES.affectionMedium, ...RANDOM_MESSAGES.basic];
                } else if (affection >= 10) {
                    availableMessages = [...RANDOM_MESSAGES.affectionLow, ...RANDOM_MESSAGES.basic];
                } else {
                    availableMessages = [...RANDOM_MESSAGES.affectionVeryLow, ...RANDOM_MESSAGES.basic];
                }
            }
            
            // 랜덤 선택
            const randomMessage = availableMessages[Math.floor(Math.random() * availableMessages.length)];
            return randomMessage.replace('{name}', spirit.name);
        }
        
        // 30초마다 랜덤 메시지 업데이트
        // 30초마다 랜덤 메시지 업데이트
        // 정령 간 상호작용
        function triggerSpiritInteraction() {
            
            if (isPaused) {
                return false;
            }
            
            // 살아있고 완성되지 않은 정령만
            const activeSpirits = spirits.filter(s => !s.isDead && !s.isCompleted);
            
            // 2마리 이상일 때만 상호작용
            if (activeSpirits.length < 2) {
                return false;
            }
            
            // 50% 확률로 상호작용 발생 (테스트용 높은 확률!)
            const randomValue = Math.random();
            if (randomValue > 0.5) {
                return false;
            }
            
            
            // 랜덤하게 2마리 선택
            const spirit1 = activeSpirits[Math.floor(Math.random() * activeSpirits.length)];
            let spirit2;
            do {
                spirit2 = activeSpirits[Math.floor(Math.random() * activeSpirits.length)];
            } while (spirit2.id === spirit1.id);
            
            // 상호작용 종류 결정
            const interactionTypes = ['decoration', 'sharing', 'fight', 'rest', 'song', 'play', 'talk'];
            const weights = [20, 10, 5, 15, 10, 25, 15]; // 가중치 (%)
            
            let random = Math.random() * 100;
            let selectedType = 'play'; // 기본값
            let cumulative = 0;
            
            for (let i = 0; i < interactionTypes.length; i++) {
                cumulative += weights[i];
                if (random < cumulative) {
                    selectedType = interactionTypes[i];
                    break;
                }
            }
            
            
            // 메시지 선택 및 적용
            const messages = RANDOM_MESSAGES.interaction[selectedType];
            
            let message = messages[Math.floor(Math.random() * messages.length)];
            
            message = message
                .replace('{name1}', spirit1.name)
                .replace('{name2}', spirit2.name);
            
            
            // 장식물 상호작용일 경우 장식물 이름 추가
            if (selectedType === 'decoration') {
                if (installedDecorations.length > 0) {
                    const randomDeco = installedDecorations[Math.floor(Math.random() * installedDecorations.length)];
                    const decoType = typeof randomDeco === 'string' ? randomDeco : randomDeco.type;
                    const decoData = DECORATION_TYPES[decoType];
                    if (decoData) {
                        message = message.replace('{deco}', decoData.name);
                        console.log('[상호작用] 장식물 이름 적용:', decoData.name);
                    } else {
                        return false; // 장식물 데이터 없으면 취소
                    }
                } else {
                    return false; // 장식물 없으면 취소
                }
            }
            
            // 효과 적용
            switch (selectedType) {
                case 'sharing': // 먹이 나눔 - 둘 다 성장 +1
                    spirit1.growth = Math.min(100, spirit1.growth + 1);
                    spirit2.growth = Math.min(100, spirit2.growth + 1);
                    break;
                    
                case 'song': // 노래 - 랜덤 스탯 +1
                    const statTypes = ['intelligence', 'strength', 'charm'];
                    const randomStat = statTypes[Math.floor(Math.random() * statTypes.length)];
                    spirit2.parameters[randomStat] += 1;
                    break;
                    
                case 'fight': // 싸움 - 약간의 스트레스, 애정도 -1
                    spirit1.parameters.affection = Math.max(0, spirit1.parameters.affection - 1);
                    spirit2.parameters.affection = Math.max(0, spirit2.parameters.affection - 1);
                    break;
                    
                case 'rest': // 휴식 - 만족도 회복
                    // 특별한 효과 없음, 메시지만
                    break;
            }
            
            // 두 정령 모두 같은 메시지 표시
            spirit1.status = message;
            spirit2.status = message;
            
            // 상호작용 시간 기록 (메시지 유지용)
            const now = Date.now();
            spirit1.lastSpiritInteraction = now;
            spirit2.lastSpiritInteraction = now;
            
            // 일지에 기록
            addLog(spirit1, message);
            
            // 성장도 체크 (100 이상이면 진화)
            if (spirit1.growth >= 100 && !spirit1.isCompleted) {
                completeSpirit(spirit1);
            }
            if (spirit2.growth >= 100 && !spirit2.isCompleted) {
                completeSpirit(spirit2);
            }
            
            saveGame();
            updateAllSpiritCards();
            
            return true; // 상호작용 발생!
        }

        function updateRandomMessages() {
            if (isPaused) return; // 일시정지 중이면 실행 안 함
            
            // 정령 간 상호작용 먼저 시도 (메시지 덮어쓰기 방지)
            const interactionOccurred = triggerSpiritInteraction();
            
            const now = Date.now();
            const activeSpirits = spirits.filter(s => !s.isDead && !s.isCompleted);
            
            // 전체 정령 메시지 먼저 결정 (크리스마스 정령이 있고 2마리 이상일 때)
            let globalMessage = null;
            const hasChristmasSpirit = spirits.some(s => s.isEventSpirit && s.eventType === 'christmas2025' && !s.isDead && !s.isCompleted);
            const hasChristmasTree = installedDecorations.some(d => {
                const decoType = typeof d === 'string' ? d : d.type;
                return decoType === 'christmas_tree';
            });
            
            if (hasChristmasSpirit && activeSpirits.length >= 2 && Math.random() < 0.15) {
                const globalMessages = [
                    `정령들이 다 같이 캐롤을 부릅니다 🎶`,
                    `정령들이 서로 선물을 교환하는 것 같습니다 🎁`,
                    `정령들이 함께 눈싸움을 합니다 ⛄`,
                    `정령들이 모두 모여 따뜻한 시간을 보냅니다 ☕`
                ];
                if (hasChristmasTree) {
                    globalMessages.push(`정령들이 다 같이 모여 크리스마스 트리를 구경합니다 🎄`);
                }
                globalMessage = globalMessages[Math.floor(Math.random() * globalMessages.length)];
            }
            
            // 전체 메시지가 선택되면 모든 정령에게 강제 적용
            if (globalMessage) {
                spirits.forEach(spirit => {
                    if (!spirit.isDead && !spirit.isCompleted) {
                        const oldStatus = spirit.status;
                        if (globalMessage !== oldStatus) {
                            addLog(spirit, globalMessage);
                        }
                        spirit.status = globalMessage;
                    }
                });
                updateAllSpiritCards();
                return;
            }
            
            // 전체 메시지가 없으면 개별 메시지 처리
            spirits.forEach(spirit => {
                if (!spirit.isDead && !spirit.isCompleted) {
                    // 정령 간 상호작용이 발생했으면 해당 정령 메시지 유지
                    if (interactionOccurred && spirit.lastSpiritInteraction && now - spirit.lastSpiritInteraction < 15000) {
                        return;
                    }
                    
                    // 최근 10초 이내에 플레이어 상호작용했으면 메시지 유지
                    const recentInteraction = (
                        (spirit.lastFeed && now - spirit.lastFeed < 10000) ||
                        (spirit.lastPat && now - spirit.lastPat < 10000) ||
                        (spirit.lastMusic && now - spirit.lastMusic < 10000)
                    );
                    
                    if (recentInteraction) {
                        return; // 메시지 유지
                    }
                    
                    const oldStatus = spirit.status;
                    const newStatus = getRandomMessage(spirit);
                    
                    // 메시지가 변경되었고, 특정 시스템 메시지가 아니면 일지에 기록
                    if (newStatus !== oldStatus && !newStatus.includes('듣고 있습니다')) {
                        addLog(spirit, newStatus);
                    }
                    
                    spirit.status = newStatus;
                }
            });
            
            updateAllSpiritCards();
        }
        
        // 5분 방치 체크 (애정도 감소)
        function checkNeglect() {
            if (isPaused) return; // 일시정지 중이면 실행 안 함
            
            const now = Date.now();
            spirits.forEach(spirit => {
                if (spirit.isDead || spirit.isCompleted) return;
                
                // 알, 애벌레, 번데기 상태에서는 방치 체크 안 함
                if (!spirit.stage || spirit.stage === 'egg' || spirit.stage === 'larva' || spirit.stage === 'pupa') {
                    return;
                }
                
                // lastInteraction이 없으면 현재 시간으로 초기화 (구버전 호환)
                if (!spirit.lastInteraction) {
                    spirit.lastInteraction = now;
                    return;
                }
                
                // 일시정지 시간 제외한 실제 경과 시간 계산
                const currentPausedTime = isPaused ? (now - pausedAt) : 0;
                const effectivePausedTime = totalPausedTime + currentPausedTime;
                
                const timeSinceLastInteraction = (now - spirit.lastInteraction - effectivePausedTime) / 1000; // 초
                const minutesSinceInteraction = timeSinceLastInteraction / 60;
                
                // 5분마다 애정도 -1 감소
                // lastAffectionDrop이 없거나 5분 이상 지났으면 감소
                if (!spirit.lastAffectionDrop) {
                    spirit.lastAffectionDrop = now;
                }
                
                const timeSinceAffectionDrop = (now - spirit.lastAffectionDrop - effectivePausedTime) / 1000; // 초
                if (timeSinceAffectionDrop >= 300) { // 5분 = 300초
                    if (spirit.parameters.affection > 0) {
                        spirit.parameters.affection -= 1;
                        spirit.lastAffectionDrop = now;
                        addLog(spirit, '방치되어 애정도가 감소했습니다 (-1)');
                        saveGame();
                    }
                }
                
                // 아픈 상태에서 30분 방치 시 도망감
                if (spirit.isSick && !spirit.sickWarned && minutesSinceInteraction >= 30) {
                    spirit.sickWarned = true;
                    spirit.status = `${spirit.name}이(가) 아파서 괴로워합니다... 🤒💔`;
                    addLog(spirit, '아픈 상태로 오래 방치되고 있습니다!');
                    showNotification(`${spirit.name}이(가) 매우 괴로워합니다! 곧 떠날 수 있습니다!`);
                    saveGame();
                }
                
                // 아픈 상태에서 1시간 방치 시 도망감
                if (spirit.isSick && minutesSinceInteraction >= 60) {
                    spirit.status = `${spirit.name}이(가) 테라리움을 떠났습니다... 😢`;
                    addLog(spirit, '아픈 상태로 방치되어 떠났습니다');
                    showNotification(`😢 ${spirit.name}이(가) 테라리움을 떠났습니다...`);
                    deleteSpirit(spirit.id);
                    return;
                }
                
                // 건강한 상태에서 1시간(3600초) 방치 시 도망감
                if (!spirit.isSick && timeSinceLastInteraction >= 3600) {
                    spirit.status = `${spirit.name}이(가) 외로워서 테라리움을 떠났습니다... 😢`;
                    addLog(spirit, '오래 방치되어 떠났습니다');
                    showNotification(`😢 ${spirit.name}이(가) 외로워서 떠났습니다...`);
                    deleteSpirit(spirit.id);
                    return;
                }
            });
            updateAllSpiritCards();
        }

        // 데이터 백업 시스템
        function createBackup() {
            const backupData = {
                version: GAME_VERSION,
                collection: collection,
                encyclopedia: encyclopedia,
                timestamp: Date.now()
            };
            
            const backupJson = JSON.stringify(backupData, null, 2);
            const blob = new Blob([backupJson], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `spirit-garden-backup-${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            showNotification('백업 파일이 다운로드되었습니다!');
        }
        
        function importBackup() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const backupData = JSON.parse(event.target.result);
                        
                        // 백업 데이터 병합 (기존 데이터 유지)
                        if (backupData.collection && Array.isArray(backupData.collection)) {
                            backupData.collection.forEach(item => {
                                // 중복 체크 (같은 정령이 이미 있는지)
                                const exists = collection.some(c => 
                                    c.name === item.name && 
                                    c.originalName === item.originalName &&
                                    c.completedAt === item.completedAt
                                );
                                if (!exists) {
                                    collection.push(item);
                                }
                            });
                        }
                        
                        if (backupData.encyclopedia && typeof backupData.encyclopedia === 'object') {
                            // 도감 데이터 병합 (카운트 누적)
                            for (let key in backupData.encyclopedia) {
                                if (!encyclopedia[key]) {
                                    encyclopedia[key] = 0;
                                }
                                encyclopedia[key] += backupData.encyclopedia[key];
                            }
                        }
                        
                        saveGame();
                        renderCollection();
                        renderEncyclopedia();
                        showNotification(`백업 복원 완료! (앨범 ${backupData.collection?.length || 0}개 복원)`);
                    } catch (err) {
                        showNotification('백업 파일을 읽을 수 없습니다: ' + err.message);
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }

        function removeAllDecorations() {
            if (installedDecorations.length === 0) {
                showNotification('설치된 장식물이 없습니다');
                return;
            }
            
            showConfirm(
                '장식물 전체 해제',
                `설치된 장식물 ${installedDecorations.length}개를 모두 해제하시겠습니까?`,
                () => {
                    // 모든 장식물을 인벤토리로 반환
                installedDecorations.forEach(deco => {
                    // 문자열 또는 객체 모두 지원
                    const decoType = typeof deco === 'string' ? deco : deco.type;
                    inventory.decorations.push(decoType);
                    
                    // 테라리움 속성 감소
                    const decoData = DECORATION_TYPES[decoType];
                    if (decoData && terrarium[decoData.attr] !== undefined) {
                        terrarium[decoData.attr] = Math.max(0, terrarium[decoData.attr] - decoData.power);
                    }
                });
                
                installedDecorations = [];
                
                // 테라리움 환경 재계산
                recalculateTerrariumEnvironment();
                
                // 만족도 즉시 업데이트
                spirits.forEach(spirit => {
                    if (!spirit.isDead && !spirit.isCompleted) {
                        spirit.satisfaction = calculateSatisfaction(spirit);
                    }
                });
                
                saveGame();
                    renderTerrariumManagement();
                    renderInventory();
                    renderSpirits();  // 만족도 변경 반영
                    showNotification('모든 장식물을 해제했습니다');
                }
            );
        }
        // ==================== 미니게임: 정령 지키기 ====================
        let minigameActive = false;
        let minigameScore = 0;
        let minigameLives = 3;
        let minigameWords = [];
        let minigameInterval = null;
        let minigameSpawnInterval = null;
        let minigameTimerInterval = null;
        let minigameTimeLeft = 60;
        let minigameDifficulty = 'normal';
        let minigameDefeated = 0;
        let minigamePaused = false;
        
        // 떨어지는 단어 목록 (해충, 독초, 잡초 등)
        const MINIGAME_ENEMIES = {
            easy: [
                // 해충
                { word: '애벌레', icon: '🐛' },
                { word: '해충', icon: '🪲' },
                { word: '바퀴', icon: '🪳' },
                { word: '진딧물', icon: '🐜' },
                { word: '달팽이', icon: '🐌' },
                { word: '지렁이', icon: '🪱' },
                { word: '딱정벌레', icon: '🪲' },
                { word: '메뚜기', icon: '🦗' },
                { word: '귀뚜라미', icon: '🦗' },
                { word: '하루살이', icon: '🪰' },
                { word: '나비유충', icon: '🐛' },
                // 독초/잡초
                { word: '독풀', icon: '🌿' },
                { word: '엉겅퀴', icon: '🌾' },
                { word: '쐐기풀', icon: '🌿' },
                { word: '덩굴', icon: '🌱' },
                { word: '가시덤불', icon: '🌵' },
                { word: '독버섯', icon: '🍄' },
                { word: '곰팡이', icon: '🦠' },
                { word: '이끼류', icon: '🪨' },
                // 기타
                { word: '거미줄', icon: '🕸️' },
                { word: '먼지', icon: '💨' }
            ],
            hard: [
                // 해충
                { word: '바퀴벌레', icon: '🪳' },
                { word: '집게벌레', icon: '🪲' },
                { word: '하늘소', icon: '🪲' },
                { word: '노린재', icon: '🪲' },
                { word: '총채벌레', icon: '🦟' },
                { word: '응애', icon: '🕷️' },
                { word: '진드기', icon: '🕷️' },
                { word: '독거미', icon: '🕷️' },
                { word: '지네', icon: '🐛' },
                { word: '그리마', icon: '🐛' },
                { word: '말벌', icon: '🐝' },
                { word: '땅벌', icon: '🐝' },
                { word: '쌀바구미', icon: '🪲' },
                { word: '흰개미', icon: '🐜' },
                { word: '기생충', icon: '🪱' },
                // 독초/잡초
                { word: '독미나리', icon: '🌿' },
                { word: '투구꽃', icon: '🌸' },
                { word: '미치광이풀', icon: '🌿' },
                { word: '협죽도', icon: '🌺' },
                { word: '천남성', icon: '🌱' },
                { word: '삿갓나물', icon: '🍀' },
                { word: '애기똥풀', icon: '🌼' },
                { word: '광대싸리', icon: '🌿' },
                { word: '독말풀', icon: '🌸' },
                { word: '곰팡이균', icon: '🦠' },
                // 기타
                { word: '해충떼', icon: '🪲' },
                { word: '독거미줄', icon: '🕸️' }
            ]
        };
        
        // 난이도별 설정
        const MINIGAME_SETTINGS = {
            easy: { spawnRate: 1700, fallSpeed: 2.2, maxWords: 5, coinMultiplier: 1 },
            hard: { spawnRate: 1200, fallSpeed: 2.8, maxWords: 8, coinMultiplier: 2 }
        };
        
        // 모바일 감지
        function isMobile() {
            return window.innerWidth <= 768;
        }
        
        // 모바일용 속도 조정 (화면이 작으니 더 느리게)
        function getMobileAdjustedSpeed(speed) {
            if (isMobile()) {
                return speed * 0.5; // 모바일에서 50% 속도
            }
            return speed;
        }
        
        function startMinigame() {
            minigameDifficulty = document.getElementById('minigameDifficulty').value;
            minigameActive = true;
            minigameScore = 0;
            minigameLives = 3;
            minigameWords = [];
            minigameDefeated = 0;
            minigamePaused = false;
            
            // 모바일 대응: body에 클래스 추가
            document.body.classList.add('minigame-active');
            
            // 화면 전환
            document.getElementById('minigameIntro').style.display = 'none';
            document.getElementById('minigamePlay').style.display = 'block';
            document.getElementById('minigameResult').style.display = 'none';
            
            // UI 초기화
            updateMinigameUI();
            
            // 입력 필드 포커스
            const input = document.getElementById('minigameInput');
            input.value = '';
            
            // 모바일: 약간 딜레이 후 포커스 (키보드 올라오게)
            setTimeout(() => {
                input.focus();
            }, 100);
            
            // 입력 이벤트 리스너 (한글 조합 완료 후 처리)
            let isComposing = false;
            
            input.addEventListener('compositionstart', () => {
                isComposing = true;
            });
            
            input.addEventListener('compositionend', (e) => {
                isComposing = false;
            });
            
            // 스페이스바나 엔터로 단어 확정
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    if (!isComposing) {
                        confirmMinigameInput();
                    }
                }
            });
            
            // 게임 시작
            const settings = MINIGAME_SETTINGS[minigameDifficulty];
            
            // 모바일에서는 최대 단어 수 줄이기
            const maxWords = isMobile() ? Math.min(settings.maxWords, 3) : settings.maxWords;
            
            // 단어 생성 인터벌 (모바일에서는 더 느리게)
            const spawnRate = isMobile() ? settings.spawnRate * 1.3 : settings.spawnRate;
            
            minigameSpawnInterval = setInterval(() => {
                if (!minigamePaused && minigameWords.length < maxWords) {
                    spawnMinigameWord();
                }
            }, spawnRate);
            
            // 게임 루프 (단어 이동)
            minigameInterval = setInterval(() => {
                if (!minigamePaused) {
                    updateMinigameWords();
                }
            }, 50);
            
            // 타이머 시작 (1분 제한)
            minigameTimeLeft = 60;
            document.getElementById('minigameTimer').textContent = minigameTimeLeft;
            minigameTimerInterval = setInterval(() => {
                if (!minigamePaused) {
                    minigameTimeLeft--;
                    document.getElementById('minigameTimer').textContent = minigameTimeLeft;
                    
                    // 10초 이하면 빨간색으로 표시
                    if (minigameTimeLeft <= 10) {
                        document.getElementById('minigameTimer').style.color = '#e74c3c';
                    }
                    
                    // 시간 종료
                    if (minigameTimeLeft <= 0) {
                        endMinigame();
                    }
                }
            }, 1000);
            
            // 첫 단어 바로 생성
            spawnMinigameWord();
        }
        
        function spawnMinigameWord() {
            const area = document.getElementById('minigameArea');
            const areaWidth = area.offsetWidth;
            const enemies = MINIGAME_ENEMIES[minigameDifficulty];
            const enemy = enemies[Math.floor(Math.random() * enemies.length)];
            
            // 단어 길이에 따른 예상 너비 계산 (글자당 약 18px + 패딩 + 아이콘)
            const estimatedWidth = (enemy.word.length * 18) + 60;
            // 최소 20px 여백, 최대 (화면너비 - 예상너비 - 20px)
            const maxX = Math.max(20, areaWidth - estimatedWidth - 20);
            
            // 모바일에서는 속도 감소
            const baseSpeed = MINIGAME_SETTINGS[minigameDifficulty].fallSpeed + (Math.random() * 0.5);
            const adjustedSpeed = getMobileAdjustedSpeed(baseSpeed);
            
            const wordObj = {
                id: Date.now() + Math.random(),
                word: enemy.word,
                icon: enemy.icon,
                x: Math.random() * maxX + 10,
                y: -50,
                speed: adjustedSpeed
            };
            
            // DOM 요소 생성
            const wordEl = document.createElement('div');
            wordEl.id = 'word-' + wordObj.id;
            wordEl.className = 'minigame-word';
            wordEl.style.cssText = `
                position: absolute;
                left: ${wordObj.x}px;
                top: ${wordObj.y}px;
                background: linear-gradient(135deg, #2c3e50, #34495e);
                color: white;
                padding: 8px 14px;
                border-radius: 20px;
                font-size: 1rem;
                font-weight: 600;
                white-space: nowrap;
                box-shadow: 0 4px 15px rgba(0,0,0,0.3);
                display: flex;
                align-items: center;
                gap: 6px;
                z-index: 10;
                transition: transform 0.1s;
            `;
            wordEl.innerHTML = `${enemy.word}`;
            
            area.appendChild(wordEl);
            minigameWords.push(wordObj);
        }
        
        function updateMinigameWords() {
            const area = document.getElementById('minigameArea');
            const areaHeight = area.offsetHeight;
            const settings = MINIGAME_SETTINGS[minigameDifficulty];
            
            minigameWords.forEach((wordObj, index) => {
                wordObj.y += wordObj.speed;
                
                const wordEl = document.getElementById('word-' + wordObj.id);
                if (wordEl) {
                    wordEl.style.top = wordObj.y + 'px';
                }
                
                // 바닥에 도달
                if (wordObj.y > areaHeight - 100) {
                    removeMinigameWord(wordObj.id, false);
                    minigameLives--;
                    
                    // 정령 피격 효과
                    const spirit = document.getElementById('minigameSpirit');
                    spirit.style.transform = 'translateX(-50%) scale(0.8)';
                    spirit.style.filter = 'drop-shadow(0 4px 8px rgba(0,0,0,0.3)) brightness(0.5)';
                    setTimeout(() => {
                        spirit.style.transform = 'translateX(-50%) scale(1)';
                        spirit.style.filter = 'drop-shadow(0 4px 8px rgba(0,0,0,0.3))';
                    }, 300);
                    
                    updateMinigameUI();
                    
                    if (minigameLives <= 0) {
                        endMinigame();
                    }
                }
            });
        }
        
        function confirmMinigameInput() {
            const input = document.getElementById('minigameInput');
            const typed = input.value.trim();
            
            if (!typed) return;
            
            // 정확히 일치하는 단어 찾기 (여러 개면 아래에 있는 것 우선)
            const exactMatches = minigameWords
                .filter(w => w.word === typed)
                .sort((a, b) => b.y - a.y);
            
            if (exactMatches.length > 0) {
                processMatchedWord(exactMatches[0], input);
            } else {
                // 일치하는 단어 없음 - 입력 초기화 (틀린 것)
                setTimeout(() => {
                    input.value = '';
                }, 0);
            }
        }
        
        function processMatchedWord(matched, input) {
            // 점수 계산 (단어 길이 + 빠른 처치 보너스)
            const lengthBonus = matched.word.length * 10;
            const speedBonus = Math.max(0, Math.floor((400 - matched.y) / 10));
            minigameScore += lengthBonus + speedBonus;
            minigameDefeated++;
            
            // 제거 효과
            removeMinigameWord(matched.id, true);
            
            // 보호막 효과
            const shield = document.getElementById('shieldEffect');
            shield.style.opacity = '1';
            setTimeout(() => {
                shield.style.opacity = '0';
            }, 200);
            
            // 입력 초기화 (setTimeout으로 조합 완료 후 클리어)
            setTimeout(() => {
                input.value = '';
            }, 0);
            
            updateMinigameUI();
        }
        
        function removeMinigameWord(id, success) {
            const wordEl = document.getElementById('word-' + id);
            if (wordEl) {
                if (success) {
                    // 성공 효과
                    wordEl.style.transform = 'scale(1.3)';
                    wordEl.style.opacity = '0';
                    wordEl.style.background = 'linear-gradient(135deg, #27ae60, #2ecc71)';
                    setTimeout(() => wordEl.remove(), 200);
                } else {
                    // 실패 효과 (빨간색)
                    wordEl.style.background = 'linear-gradient(135deg, #c0392b, #e74c3c)';
                    wordEl.style.transform = 'scale(0.5)';
                    wordEl.style.opacity = '0';
                    setTimeout(() => wordEl.remove(), 300);
                }
            }
            minigameWords = minigameWords.filter(w => w.id !== id);
        }
        
        function updateMinigameUI() {
            document.getElementById('minigameScore').textContent = minigameScore;
            
            let hearts = '';
            for (let i = 0; i < 3; i++) {
                hearts += i < minigameLives ? '❤️' : '🖤';
            }
            document.getElementById('minigameLives').textContent = hearts;
        }
        
        function pauseMinigame() {
            minigamePaused = true;
        }
        
        function resumeMinigame() {
            minigamePaused = false;
            document.getElementById('minigameInput').focus();
        }
        
        function endMinigame() {
            minigameActive = false;
            
            // 모바일 대응: body 클래스 제거
            document.body.classList.remove('minigame-active');
            
            // 인터벌 정리
            if (minigameInterval) {
                clearInterval(minigameInterval);
                minigameInterval = null;
            }
            if (minigameSpawnInterval) {
                clearInterval(minigameSpawnInterval);
                minigameSpawnInterval = null;
            }
            if (minigameTimerInterval) {
                clearInterval(minigameTimerInterval);
                minigameTimerInterval = null;
            }
            
            // 타이머 색상 초기화
            document.getElementById('minigameTimer').style.color = '';
            
            // 남은 단어 제거
            minigameWords.forEach(w => {
                const el = document.getElementById('word-' + w.id);
                if (el) el.remove();
            });
            minigameWords = [];
            
            // 결과 화면 표시
            document.getElementById('minigamePlay').style.display = 'none';
            document.getElementById('minigameResult').style.display = 'block';
            
            // 결과 업데이트
            document.getElementById('finalScore').textContent = minigameScore;
            document.getElementById('defeatedCount').textContent = minigameDefeated;
            
            // 결과 아이콘 & 메시지
            let icon, title;
            if (minigameScore >= 500) {
                icon = '🏆';
                title = '대단해요!';
            } else if (minigameScore >= 200) {
                icon = '🎉';
                title = '잘했어요!';
            } else if (minigameScore >= 100) {
                icon = '👍';
                title = '좋아요!';
            } else {
                icon = '💪';
                title = '다음엔 더 잘할 수 있어요!';
            }
            document.getElementById('resultIcon').textContent = icon;
            document.getElementById('resultTitle').textContent = title;
            
            // 보상 계산 (코인은 점수의 1/10 * 난이도 배수)
            const settings = MINIGAME_SETTINGS[minigameDifficulty];
            const coinReward = Math.floor(minigameScore / 10 * settings.coinMultiplier);
            document.getElementById('coinRewardAmount').textContent = '+' + coinReward;
        }
        
        function claimReward(type) {
            const settings = MINIGAME_SETTINGS[minigameDifficulty];
            
            if (type === 'coin') {
                const reward = Math.floor(minigameScore / 10 * settings.coinMultiplier);
                coins += reward;
                updateCoinDisplay();
                saveGame();
                showNotification(`💰 ${reward} 코인을 획득했습니다!`);
            } else if (type === 'item') {
                // 난이도와 점수에 따라 아이템 등급 결정
                let itemPool = [];
                
                if (minigameDifficulty === 'hard' && minigameScore >= 400) {
                    // 어려움 + 고득점: 전설급 아이템 (미니게임 전용)
                    itemPool = [
                        { type: 'decoration', item: 'fire_legendary', name: '태초의 불꽃' },
                        { type: 'decoration', item: 'water_legendary', name: '심해의 심장' },
                        { type: 'decoration', item: 'wind_legendary', name: '폭풍의 눈' },
                        { type: 'decoration', item: 'earth_legendary', name: '대지의 정수' },
                        { type: 'decoration', item: 'light_legendary', name: '천상의 광휘' },
                        { type: 'decoration', item: 'dark_legendary', name: '영원한 어둠' }
                    ];
                    showNotification('🌟 전설급 아이템 획득 기회!');
                } else if (minigameDifficulty === 'hard' && minigameScore >= 250) {
                    // 어려움 + 중간 점수: 에픽 아이템
                    itemPool = [
                        { type: 'decoration', item: 'fire_epic', name: '불사조 깃털' },
                        { type: 'decoration', item: 'water_epic', name: '인어의 눈물' },
                        { type: 'decoration', item: 'wind_epic', name: '하늘의 깃털' },
                        { type: 'decoration', item: 'earth_epic', name: '세계수 가지' },
                        { type: 'decoration', item: 'light_epic', name: '별의 파편' },
                        { type: 'decoration', item: 'dark_epic', name: '밤의 정수' },
                        { type: 'food', item: 'light', name: '빛나는 넥타' },
                        { type: 'food', item: 'dark', name: '검은 꽃가루' }
                    ];
                } else if (minigameScore >= 200) {
                    // 쉬움 고득점 또는 어려움 저득점: 레어 아이템
                    itemPool = [
                        { type: 'decoration', item: 'fire_rare1', name: '불꽃 조각상' },
                        { type: 'decoration', item: 'water_rare1', name: '산호 장식' },
                        { type: 'decoration', item: 'wind_rare1', name: '풍경' },
                        { type: 'decoration', item: 'earth_rare1', name: '나무 조각' },
                        { type: 'decoration', item: 'light_rare1', name: '빛나는 보석' },
                        { type: 'decoration', item: 'dark_rare1', name: '달빛석' },
                        { type: 'food', item: 'light', name: '빛나는 넥타' },
                        { type: 'food', item: 'dark', name: '검은 꽃가루' }
                    ];
                } else if (minigameScore >= 100) {
                    // 중간 점수: 일반 아이템
                    itemPool = [
                        { type: 'food', item: 'fire', name: '불꽃열매' },
                        { type: 'food', item: 'water', name: '맑은이슬' },
                        { type: 'food', item: 'wind', name: '바람꿀' },
                        { type: 'food', item: 'earth', name: '대지버섯' },
                        { type: 'decoration', item: 'fire_common1', name: '용암석' },
                        { type: 'decoration', item: 'water_common1', name: '분수' },
                        { type: 'decoration', item: 'wind_common1', name: '바람개비' },
                        { type: 'decoration', item: 'earth_common1', name: '화분' }
                    ];
                } else {
                    // 낮은 점수: 기본 먹이만
                    itemPool = [
                        { type: 'food', item: 'fire', name: '불꽃열매' },
                        { type: 'food', item: 'water', name: '맑은이슬' },
                        { type: 'food', item: 'wind', name: '바람꿀' },
                        { type: 'food', item: 'earth', name: '대지버섯' }
                    ];
                }
                
                const reward = itemPool[Math.floor(Math.random() * itemPool.length)];
                
                // 인벤토리에 추가
                if (reward.type === 'food') {
                    inventory.food.push(reward.item);
                } else if (reward.type === 'decoration') {
                    inventory.decorations.push(reward.item);
                } else if (reward.type === 'music') {
                    inventory.music.push(reward.item);
                }
                
                // 전설급 아이템이면 특별 알림
                const decoData = DECORATION_TYPES[reward.item];
                if (decoData && decoData.quality === 'legendary') {
                    showNotification(`🌟 전설급! ${decoData.icon} ${reward.name}을(를) 획득했습니다!`);
                } else {
                    showNotification(`🎁 ${reward.name}을(를) 획득했습니다!`);
                }
                
                saveGame();
                renderInventory();
            }
            
            // 보상 버튼 비활성화
            document.getElementById('rewardSection').innerHTML = `
                <div style="color: var(--wind); font-size: 1.2rem; font-weight: 700;">✓ 보상을 받았습니다!</div>
            `;
        }
        
        function backToMinigameIntro() {
            document.getElementById('minigameIntro').style.display = 'block';
            document.getElementById('minigamePlay').style.display = 'none';
            document.getElementById('minigameResult').style.display = 'none';
            
            // 보상 섹션 복구
            document.getElementById('rewardSection').innerHTML = `
                <h4 style="font-size: 1.2rem; margin-bottom: 20px; color: var(--text);">보상을 선택하세요</h4>
                <div style="display: flex; gap: 20px; justify-content: center; flex-wrap: wrap;">
                    <button onclick="claimReward('coin')" class="reward-btn" style="padding: 20px 30px; background: linear-gradient(135deg, #FFD700, #FFA500); color: #333; border: none; border-radius: 12px; cursor: pointer; min-width: 150px;">
                        <div style="font-size: 2rem; margin-bottom: 8px;">💰</div>
                        <div style="font-weight: 700;">코인 받기</div>
                        <div id="coinRewardAmount" style="font-size: 0.9rem; margin-top: 4px;">+0</div>
                    </button>
                    <button onclick="claimReward('item')" class="reward-btn" style="padding: 20px 30px; background: linear-gradient(135deg, #9B59B6, #8E44AD); color: white; border: none; border-radius: 12px; cursor: pointer; min-width: 150px;">
                        <div style="font-size: 2rem; margin-bottom: 8px;">🎁</div>
                        <div style="font-weight: 700;">아이템 받기</div>
                        <div style="font-size: 0.9rem; margin-top: 4px;">랜덤 보상</div>
                    </button>
                </div>
            `;
        }
        // ==================== 미니게임 끝 ====================

        function closeModal(modalId) {
            document.getElementById(modalId).classList.remove('active');
        }

        function showNotification(message) {
            // 기존 알림들의 개수를 세서 위치 조정
            const existingNotifs = document.querySelectorAll('.notification');
            const offset = existingNotifs.length * 70; // 각 알림마다 70px 간격
            
            const notif = document.createElement('div');
            notif.className = 'notification';
            notif.textContent = message;
            notif.style.top = `${80 + offset}px`;
            document.body.appendChild(notif);
            
            setTimeout(() => {
                notif.style.animation = 'slideOut 0.3s ease-out';
                setTimeout(() => notif.remove(), 300);
            }, 3000);
        }

        function updateTimeDisplay() {
            const now = new Date();
            const timeStr = now.toLocaleTimeString('ko-KR', { 
                hour: '2-digit', 
                minute: '2-digit',
                second: '2-digit'
            });
            document.getElementById('timeDisplay').textContent = timeStr;
        }

        // 게임 루프
        setInterval(() => {
            saveGame();
        }, 5000);

        // 1초마다 버튼 상태 및 정령 상태 체크
        setInterval(() => {
            checkSpiritStatus();
            // garden 탭이 활성화된 경우에만 카드 업데이트
            if (currentTab === 'garden') {
                updateCooldownDisplay();  // 쿨타임 텍스트만 업데이트 (성능 최적화)
                spirits.forEach(spirit => {
                    updateSpiritCard(spirit);
                });
            }
            updateGatherButton();
        }, 1000);

        // 1분마다 성장도 증가
        setInterval(() => {
            applyGrowth();
        }, 60000);  // 60000ms = 1분

        // 5분마다 테라리움 환경 효과 적용
        setInterval(() => {
            applyTerrariumGrowth();
        }, 300000);  // 300000ms = 5분

        // 만족도 업데이트 (1분마다)
        setInterval(() => {
            if (isPaused) return; // 일시정지 중이면 실행 안 함
            
            spirits.forEach(spirit => {
                if (spirit.isDead || spirit.isCompleted) return;
                
                // 성장도 체크 (100 이상이면 자동 진화)
                if (spirit.growth >= STAGE_REQUIREMENTS.adult && !spirit.isCompleted) {
                    completeSpirit(spirit);
                    return;
                }
                
                const oldSatisfaction = spirit.satisfaction || 'mid';
                const newSatisfaction = calculateSatisfaction(spirit);
                spirit.satisfaction = newSatisfaction;
                
                // 만족도에 따른 애정도 변화
                if (newSatisfaction === 'high') {
                    spirit.parameters.affection += 1;
                } else if (newSatisfaction === 'low') {
                    spirit.parameters.affection = Math.max(0, spirit.parameters.affection - 1);
                }
                
                // 만족도가 변경되었을 때 로그
                if (oldSatisfaction !== newSatisfaction) {
                    const satisfactionTexts = {
                        high: '매우 만족스러워 보입니다!',
                        mid: '평온해 보입니다.',
                        low: '불만족스러워 보입니다...'
                    };
                    addLog(spirit, satisfactionTexts[newSatisfaction]);
                }
            });
            saveGame();
            updateAllSpiritCards();
        }, 60000); // 60초마다

        setInterval(updateTimeDisplay, 1000);
        setInterval(updateRandomMessages, 15000); // 15초마다 랜덤 메시지 업데이트
        setInterval(checkNeglect, 60000); // 1분마다 방치 체크

        // 오프닝 스토리
        const OPENING_SCENES = [
            "멀지 않은 미래...",
            "지구에서 정령의 수가 급감하기 시작했다.",
            "정령이 사라진 자리,\n자연은 서서히 황폐해져 갔다.",
            "황폐해진 자연 속에서\n정령들은 더 이상 알을 낳지 않았다.",
            "뒤늦게 위기를 깨달은 인간들은\n남은 정령의 알을 수집하기 시작했다.",
            "그리고 작은 유리병 안에서\n정령을 키워 자연으로 돌려보내는\n이들이 나타났다.",
            "사람들은 그들을\n'정령지기'라 불렀다.",
            "이것은 작은 테라리움에서 시작되는\n당신의 이야기."
        ];
        
        let currentOpeningScene = 0;
        
        function showOpening() {
            console.log('showOpening 함수 실행됨');
            const modal = document.getElementById('openingModal');
            console.log('모달 요소:', modal);
            if (modal) {
                modal.style.display = 'flex';
                currentOpeningScene = 0;
                showOpeningText();
                console.log('오프닝 모달 표시됨');
            } else {
                console.error('오프닝 모달을 찾을 수 없음!');
            }
        }
        
        function showOpeningText() {
            const textEl = document.getElementById('openingText');
            const nextBtn = document.getElementById('openingNextBtn');
            
            textEl.style.opacity = '0';
            
            setTimeout(() => {
                textEl.innerHTML = OPENING_SCENES[currentOpeningScene].replace(/\n/g, '<br>');
                textEl.style.opacity = '1';
                
                setTimeout(() => {
                    nextBtn.style.display = 'inline-block';
                    if (currentOpeningScene === OPENING_SCENES.length - 1) {
                        nextBtn.textContent = '시작하기';
                    } else {
                        nextBtn.textContent = '다음';
                    }
                }, 500);
            }, 300);
        }
        
        function nextOpeningScene() {
            const nextBtn = document.getElementById('openingNextBtn');
            nextBtn.style.display = 'none';
            
            currentOpeningScene++;
            
            if (currentOpeningScene >= OPENING_SCENES.length) {
                closeOpening();
            } else {
                showOpeningText();
            }
        }
        
        function skipOpening() {
            closeOpening();
        }
        
        function closeOpening() {
            const modal = document.getElementById('openingModal');
            modal.style.opacity = '0';
            modal.style.transition = 'opacity 0.5s';
            
            setTimeout(() => {
                modal.style.display = 'none';
                modal.style.opacity = '1';
                // 오프닝 본 것으로 저장
                localStorage.setItem('spiritGarden_openingSeen', 'true');
                // 튜토리얼 시작
                startTutorial();
            }, 500);
        }
        
        // ========== 튜토리얼 시스템 ==========
        let tutorialStep = 0;
        let tutorialActive = false;
        
        const TUTORIAL_STEPS = [
            {
                type: 'dialog',
                text: '어, 새로 온 수습 정령지기구나? 환영해! 나는 이 테라리움을 관리하는 선배 정령지기야.'
            },
            {
                type: 'dialog',
                text: '여기가 처음이라면 기본적인 것들을 알려줄게. 잘 들어둬.'
            },
            {
                type: 'action',
                action: 'getEgg',
                text: '자, 먼저 정령 알을 받아보자. 아래로 내리면 "새로운 알 받기" 버튼이 있을거야.'
            },
            {
                type: 'dialog',
                text: '잘했어! 정령들의 알은 정령나무의 열매야. 이 알들은 기본적으로 무속성이지.'
            },
            {
                type: 'dialog',
                text: '먹이와 테라리움 관리로 속성이 있는 정령으로 자랄 수 있게 관리하는 게 우리 정령지기들의 임무야.'
            },
            {
                type: 'action',
                action: 'feed',
                text: '알이 배고파하는 것 같은데? "먹이주기" 버튼을 눌러서 먹이를 줘봐.'
            },
            {
                type: 'dialog',
                text: '좋아! 먹이마다 다른 속성이 있어서, 어떤 먹이를 주느냐에 따라 정령의 속성이 달라져.'
            },
            {
                type: 'action',
                action: 'music',
                text: '그리고 정령들의 언어가 노래라는 건 알고 있지? 정령들은 노래를 들으며 세상의 지식을 흡수해. "음악 듣기"를 눌러봐.'
            },
            {
                type: 'dialog',
                text: '음악도 종류마다 다른 능력치를 올려줘. 클래식은 지력, 팝은 매력 같은 식이지.'
            },
            {
                type: 'action',
                action: 'pat',
                text: '어차피 떠나보내야 한다고 먹이만 주는 녀석들도 있지만... 정령과 교감하는 것도 중요해. "쓰다듬기"를 눌러봐.'
            },
            {
                type: 'action',
                action: 'clickName',
                text: '그리고 정령에게 이름을 지어줄 수도 있어. 정령 카드에서 노란색으로 강조된 이름 부분을 눌러봐!'
            },
            {
                type: 'action',
                action: 'rename',
                text: '자, 입력창에 새 이름을 지어주고 확인을 눌러!'
            },
            {
                type: 'dialog',
                text: '잘했어. 꼭 이름을 지어줘야 하는 건 아니지만, 그래도 불러줄 이름이 있는 편이 훨씬 좋다고 생각하거든.'
            },
            {
                type: 'dialog',
                text: '이게 기본적인 정령 육성 방법이야. 테라리움 관리까지 생각하면 더 복잡하지만 그건 천천히 익히도록 해.'
            },
            {
                type: 'dialog',
                text: '아까 속성 이야기를 했지? 이미 알고 있겠지만 복습해보자.'
            },
            {
                type: 'dialog',
                text: '속성에는 불, 물, 땅, 바람 기본 4대원소와 희귀원소인 빛, 어둠이 있어.'
            },
            {
                type: 'dialog',
                text: '유충 상태의 정령은 이 여섯 가지 속성의 영향을 받아 자라게 돼. 불속성을 많이 접하면 불의 정령이 되고, 물속성을 많이 접하면 물의 정령이 되지.'
            },
            {
                type: 'dialog',
                text: '가끔 두 가지 속성이 섞여 다른 속성의 정령으로 진화하기도 하지만, 처음엔 한 가지 속성에 집중하는 게 좋아.'
            },
            {
                type: 'dialog',
                text: '그리고 다른 속성이 두 개 더 있는데... 그건 바로 태양과 달이야.'
            },
            {
                type: 'action',
                action: 'toggleLight',
                text: '탭 맨 오른쪽에 있는 태양 버튼을 눌러볼래?'
            },
            {
                type: 'dialog',
                text: '그 버튼으로 테라리움의 조도를 설정할 수 있어. 조도의 양에 따라 달의 정령이 되는지 태양의 정령이 되는지 달라지니까 이것도 신경쓰는 게 좋아.'
            },
            {
                type: 'dialog',
                text: '그리고 먹이나 레코드, 테라리움을 장식할 장식품들은 채집으로 얻을 수 있어.'
            },
            {
                type: 'dialog',
                text: '도저히 찾을 수 없는 게 있다면 상점에 가면 되고.'
            },
            {
                type: 'dialog',
                text: '너무 쪼들린다면 아르바이트도 해야 하니까 각오해. 유아기 정령들은 쉼없이 먹어대고 까다롭다고.'
            },
            {
                type: 'dialog',
                text: '자, 그럼 내가 선배로서 설명해줄 건 여기까지야. 나머지는 직접 부딪혀 가면서 배우도록 해. 그럼 이만!'
            }
        ];
        
        function startTutorial() {
            const tutorialSeen = localStorage.getItem('spiritGarden_tutorialSeen');
            if (tutorialSeen) return;
            
            // 다른 튜토리얼이 진행 중이면 시작하지 않음
            if (tutorial2Active || sickTutorialActive || imbalanceTutorialActive) return;
            
            // 튜토리얼용 기본 아이템 지급
            if (!inventory.food) inventory.food = [];
            if (!inventory.music) inventory.music = [];
            
            // 기본 먹이 3개 지급
            if (inventory.food.length === 0) {
                inventory.food.push('fire', 'water', 'earth');
            }
            // 클래식 레코드 1개 지급
            if (inventory.music.length === 0) {
                inventory.music.push('classic');
            }
            saveGame();
            renderInventory();
            
            tutorialStep = 0;
            tutorialActive = true;
            showTutorialStep();
        }
        
        function showTutorialStep() {
            if (tutorialStep >= TUTORIAL_STEPS.length) {
                endTutorial();
                return;
            }
            
            const step = TUTORIAL_STEPS[tutorialStep];
            
            if (step.type === 'dialog') {
                showTutorialDialog(step.text);
            } else if (step.type === 'action') {
                showTutorialAction(step.text, step.action);
            }
        }
        
        let tutorialCollapsed = false;
        
        function toggleTutorialCollapse() {
            tutorialCollapsed = !tutorialCollapsed;
            const content = document.getElementById('tutorialContent');
            const toggleBtn = document.getElementById('tutorialToggleBtn');
            
            if (tutorialCollapsed) {
                content.style.display = 'none';
                toggleBtn.textContent = '▼ 펼치기';
            } else {
                content.style.display = 'block';
                toggleBtn.textContent = '▲ 접기';
            }
        }
        
        function showTutorialDialog(text) {
            const modal = document.createElement('div');
            modal.id = 'tutorialModal';
            modal.style.cssText = `
                position: fixed;
                top: 10px;
                left: 50%;
                transform: translateX(-50%);
                width: 90%;
                max-width: 500px;
                background: var(--card);
                border: 2px solid #555;
                border-radius: 16px;
                padding: 15px;
                z-index: 100000;
                box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            `;
            
            modal.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: ${tutorialCollapsed ? '0' : '12px'};">
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <span style="font-size: 1.5rem;">🧙</span>
                        <span style="font-size: 0.9rem; color: #555; font-weight: 600;">선배 정령지기</span>
                    </div>
                    <div style="display: flex; gap: 8px;">
                        <button onclick="skipTutorial()" style="padding: 5px 12px; background: var(--bg); border: 1px solid var(--border); border-radius: 6px; cursor: pointer; font-size: 0.8rem; color: var(--text-muted);">건너뛰기</button>
                        <button id="tutorialToggleBtn" onclick="toggleTutorialCollapse()" style="padding: 5px 12px; background: var(--bg); border: 1px solid var(--border); border-radius: 6px; cursor: pointer; font-size: 0.8rem; color: var(--text-muted);">
                            ${tutorialCollapsed ? '▼ 펼치기' : '▲ 접기'}
                        </button>
                    </div>
                </div>
                <div id="tutorialContent" style="display: ${tutorialCollapsed ? 'none' : 'block'};">
                    <div style="font-size: 1rem; line-height: 1.6; color: var(--text); margin-bottom: 15px; padding: 10px; background: var(--bg); border-radius: 8px; word-break: keep-all;">${text}</div>
                    <div style="display: flex; justify-content: flex-end; align-items: center;">
                        <button onclick="nextTutorialStep()" style="padding: 10px 25px; background: #333; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600;">다음</button>
                    </div>
                </div>
            `;
            
            // 기존 튜토리얼 모달 제거
            const existing = document.getElementById('tutorialModal');
            if (existing) existing.remove();
            
            document.body.appendChild(modal);
        }
        
        function showTutorialAction(text, action) {
            const modal = document.createElement('div');
            modal.id = 'tutorialModal';
            modal.style.cssText = `
                position: fixed;
                top: 10px;
                left: 50%;
                transform: translateX(-50%);
                width: 90%;
                max-width: 500px;
                background: var(--card);
                border: 2px solid #f39c12;
                border-radius: 16px;
                padding: 15px;
                z-index: 100000;
                box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            `;
            
            modal.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: ${tutorialCollapsed ? '0' : '12px'};">
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <span style="font-size: 1.5rem;">🧙</span>
                        <span style="font-size: 0.9rem; color: #f39c12; font-weight: 600;">선배 정령지기</span>
                    </div>
                    <div style="display: flex; gap: 8px;">
                        <button onclick="skipTutorial()" style="padding: 5px 12px; background: var(--bg); border: 1px solid var(--border); border-radius: 6px; cursor: pointer; font-size: 0.8rem; color: var(--text-muted);">건너뛰기</button>
                        <button id="tutorialToggleBtn" onclick="toggleTutorialCollapse()" style="padding: 5px 12px; background: var(--bg); border: 1px solid var(--border); border-radius: 6px; cursor: pointer; font-size: 0.8rem; color: var(--text-muted);">
                            ${tutorialCollapsed ? '▼ 펼치기' : '▲ 접기'}
                        </button>
                    </div>
                </div>
                <div id="tutorialContent" style="display: ${tutorialCollapsed ? 'none' : 'block'};">
                    <div style="font-size: 1rem; line-height: 1.6; color: var(--text); margin-bottom: 10px; padding: 10px; background: var(--bg); border-radius: 8px; word-break: keep-all;">${text}</div>
                    <div style="padding: 8px 12px; background: #f39c1222; border-radius: 8px; font-size: 0.85rem; color: #f39c12;">
                        👇 아래 버튼을 눌러보세요!
                    </div>
                </div>
            `;
            
            // 기존 튜토리얼 모달 제거
            const existing = document.getElementById('tutorialModal');
            if (existing) existing.remove();
            
            document.body.appendChild(modal);
            
            // 해당 액션을 기다림
            window.tutorialWaitingFor = action;
            
            // 강조할 요소 찾아서 하이라이트
            highlightTutorialTarget(action);
        }
        
        // 튜토리얼 대상 요소 강조
        function highlightTutorialTarget(action) {
            // 기존 강조 제거
            clearTutorialHighlight();
            
            let targetSelector = null;
            
            switch(action) {
                case 'getEgg':
                    targetSelector = '.new-spirit-btn';
                    break;
                case 'clickName':
                    targetSelector = '.spirit-name';
                    break;
                case 'rename':
                    targetSelector = '#nameInput';
                    break;
                case 'feed':
                    targetSelector = 'button[onclick*="openFeedModal"]';
                    break;
                case 'music':
                    targetSelector = 'button[onclick*="openMusicModal"]';
                    break;
                case 'pat':
                    targetSelector = 'button[onclick*="patSpirit"]';
                    break;
                case 'toggleLight':
                    targetSelector = '#lightBtn';
                    break;
                case 'openAlbum':
                    targetSelector = '.tab:nth-child(7)';
                    break;
                case 'openAlbumDetail':
                    targetSelector = '.collection-card';
                    break;
            }
            
            if (targetSelector) {
                const target = document.querySelector(targetSelector);
                if (target) {
                    target.classList.add('tutorial-highlight');
                    // 해당 요소로 스크롤
                    target.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            }
        }
        
        // 튜토리얼 강조 제거
        function clearTutorialHighlight() {
            document.querySelectorAll('.tutorial-highlight').forEach(el => {
                el.classList.remove('tutorial-highlight');
            });
        }
        
        function checkTutorialAction(action) {
            if (!tutorialActive && !tutorial2Active) return;
            if (window.tutorialWaitingFor === action) {
                window.tutorialWaitingFor = null;
                clearTutorialHighlight();
                if (tutorial2Active) {
                    nextTutorial2Step();
                } else {
                    nextTutorialStep();
                }
            }
        }
        
        function nextTutorialStep() {
            tutorialStep++;
            showTutorialStep();
        }
        
        function skipTutorial() {
            endTutorial();
        }
        
        function endTutorial() {
            tutorialActive = false;
            window.tutorialWaitingFor = null;
            clearTutorialHighlight();
            
            const modal = document.getElementById('tutorialModal');
            if (modal) {
                modal.style.opacity = '0';
                modal.style.transition = 'opacity 0.3s';
                setTimeout(() => modal.remove(), 300);
            }
            
            localStorage.setItem('spiritGarden_tutorialSeen', 'true');
        }
        
        // ===== 두 번째 튜토리얼 (첫 정령 완성 후) =====
        let tutorial2Step = 0;
        let tutorial2Active = false;
        
        const TUTORIAL2_STEPS = [
            {
                type: 'dialog',
                text: '축하해! 네가 키워낸 첫 번째 정령이네.'
            },
            {
                type: 'dialog',
                text: '성장한 정령은 자연으로 돌아가지만, 아예 다시 볼 수 없는 건 아니야.'
            },
            {
                type: 'action',
                action: 'openAlbum',
                text: '앨범 탭을 눌러봐.'
            },
            {
                type: 'dialog',
                text: '여기에서 네가 키운 정령들을 다시 볼 수 있어. 네가 얼마나 잘 키워냈는지도 확인할 수 있고.'
            },
            {
                type: 'dialog',
                text: '그리고 정령 간의 교배도 가능하지.'
            },
            {
                type: 'action',
                action: 'openAlbumDetail',
                text: '성장한 정령의 앨범을 눌러봐.'
            },
            {
                type: 'dialog',
                text: '아래에 보면 코드 생성과 교배하기가 있지? 정령의 코드를 복사해 다른 정령과 교배가 가능해.'
            },
            {
                type: 'dialog',
                text: '무속성 알로는 보지 못하는 정령들도 있으니까 나중에 시도해보도록 해.'
            },
            {
                type: 'dialog',
                text: '자, 이제 정말 혼자서도 잘 할 수 있을 거야. 앞으로도 화이팅!'
            }
        ];
        
        function startTutorial2() {
            // 다른 튜토리얼이 진행 중이면 시작하지 않음
            if (tutorialActive || sickTutorialActive || imbalanceTutorialActive) return;
            
            tutorial2Step = 0;
            tutorial2Active = true;
            showTutorial2Step();
        }
        
        function showTutorial2Step() {
            if (tutorial2Step >= TUTORIAL2_STEPS.length) {
                endTutorial2();
                return;
            }
            
            const step = TUTORIAL2_STEPS[tutorial2Step];
            
            if (step.type === 'dialog') {
                showTutorial2Dialog(step.text);
            } else if (step.type === 'action') {
                showTutorial2Action(step.text, step.action);
            }
        }
        
        function showTutorial2Dialog(text) {
            const modal = document.createElement('div');
            modal.id = 'tutorialModal';
            modal.style.cssText = `
                position: fixed;
                top: 10px;
                left: 50%;
                transform: translateX(-50%);
                width: 90%;
                max-width: 500px;
                background: var(--card);
                border: 2px solid #555;
                border-radius: 16px;
                padding: 15px;
                z-index: 100000;
                box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            `;
            
            modal.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: ${tutorialCollapsed ? '0' : '12px'};">
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <span style="font-size: 1.5rem;">🧙</span>
                        <span style="font-size: 0.9rem; color: #555; font-weight: 600;">선배 정령지기</span>
                    </div>
                    <div style="display: flex; gap: 8px;">
                        <button onclick="skipTutorial2()" style="padding: 5px 12px; background: var(--bg); border: 1px solid var(--border); border-radius: 6px; cursor: pointer; font-size: 0.8rem; color: var(--text-muted);">건너뛰기</button>
                        <button id="tutorialToggleBtn" onclick="toggleTutorialCollapse()" style="padding: 5px 12px; background: var(--bg); border: 1px solid var(--border); border-radius: 6px; cursor: pointer; font-size: 0.8rem; color: var(--text-muted);">
                            ${tutorialCollapsed ? '▼ 펼치기' : '▲ 접기'}
                        </button>
                    </div>
                </div>
                <div id="tutorialContent" style="display: ${tutorialCollapsed ? 'none' : 'block'};">
                    <div style="font-size: 1rem; line-height: 1.6; color: var(--text); margin-bottom: 15px; padding: 10px; background: var(--bg); border-radius: 8px; word-break: keep-all;">${text}</div>
                    <div style="display: flex; justify-content: flex-end; align-items: center;">
                        <button onclick="nextTutorial2Step()" style="padding: 10px 25px; background: #333; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600;">다음</button>
                    </div>
                </div>
            `;
            
            const existing = document.getElementById('tutorialModal');
            if (existing) existing.remove();
            
            document.body.appendChild(modal);
        }
        
        function showTutorial2Action(text, action) {
            const modal = document.createElement('div');
            modal.id = 'tutorialModal';
            modal.style.cssText = `
                position: fixed;
                top: 10px;
                left: 50%;
                transform: translateX(-50%);
                width: 90%;
                max-width: 500px;
                background: var(--card);
                border: 2px solid #f39c12;
                border-radius: 16px;
                padding: 15px;
                z-index: 100000;
                box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            `;
            
            modal.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: ${tutorialCollapsed ? '0' : '12px'};">
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <span style="font-size: 1.5rem;">🧙</span>
                        <span style="font-size: 0.9rem; color: #f39c12; font-weight: 600;">선배 정령지기</span>
                    </div>
                    <div style="display: flex; gap: 8px;">
                        <button onclick="skipTutorial2()" style="padding: 5px 12px; background: var(--bg); border: 1px solid var(--border); border-radius: 6px; cursor: pointer; font-size: 0.8rem; color: var(--text-muted);">건너뛰기</button>
                        <button id="tutorialToggleBtn" onclick="toggleTutorialCollapse()" style="padding: 5px 12px; background: var(--bg); border: 1px solid var(--border); border-radius: 6px; cursor: pointer; font-size: 0.8rem; color: var(--text-muted);">
                            ${tutorialCollapsed ? '▼ 펼치기' : '▲ 접기'}
                        </button>
                    </div>
                </div>
                <div id="tutorialContent" style="display: ${tutorialCollapsed ? 'none' : 'block'};">
                    <div style="font-size: 1rem; line-height: 1.6; color: var(--text); margin-bottom: 10px; padding: 10px; background: var(--bg); border-radius: 8px; word-break: keep-all;">${text}</div>
                    <div style="padding: 8px 12px; background: #f39c1222; border-radius: 8px; font-size: 0.85rem; color: #f39c12;">
                        👇 해당 버튼을 눌러보세요!
                    </div>
                </div>
            `;
            
            const existing = document.getElementById('tutorialModal');
            if (existing) existing.remove();
            
            document.body.appendChild(modal);
            
            window.tutorialWaitingFor = action;
            
            // 강조할 요소 찾아서 하이라이트
            highlightTutorialTarget(action);
        }
        
        function nextTutorial2Step() {
            tutorial2Step++;
            showTutorial2Step();
        }
        
        function skipTutorial2() {
            endTutorial2();
        }
        
        function endTutorial2() {
            tutorial2Active = false;
            window.tutorialWaitingFor = null;
            clearTutorialHighlight();
            
            const modal = document.getElementById('tutorialModal');
            if (modal) {
                modal.style.opacity = '0';
                modal.style.transition = 'opacity 0.3s';
                setTimeout(() => modal.remove(), 300);
            }
            
            localStorage.setItem('spiritGarden_tutorial2Seen', 'true');
        }
        
        // ===== 질병 튜토리얼 (첫 질병 발생 시) =====
        let sickTutorialStep = 0;
        let sickTutorialActive = false;
        
        const SICK_TUTORIAL_STEPS = [
            {
                type: 'dialog',
                text: '정령이 질병에 걸렸구나. 유아기의 정령들은 약해서 종종 이런 일이 일어나곤 해.'
            },
            {
                type: 'dialog',
                text: '그래도 걱정하지마. 상점에서 약초를 사서 먹이면 되니까.'
            },
            {
                type: 'action',
                action: 'openShop',
                text: '상점 탭을 눌러볼래?'
            },
            {
                type: 'dialog',
                text: '안녕, 상점 주인. 오늘도 의욕이 없어보이네.'
            },
            {
                type: 'shopkeeper',
                text: '시비걸거면 가세요...'
            },
            {
                type: 'dialog',
                text: '저렇다니까. 아, 약초를 사러 왔었지. 구매하기에서 약초를 찾아 구매해봐.'
            },
            {
                type: 'action',
                action: 'buyMedicine',
                text: '약초를 구매해봐!'
            },
            {
                type: 'dialog',
                text: '약초를 샀으면 이제 육성탭으로 돌아가자.'
            },
            {
                type: 'action',
                action: 'openGarden',
                text: '육성 탭을 눌러봐.'
            },
            {
                type: 'action',
                action: 'useMedicine',
                text: '질병에 걸린 정령에게 약초 사용을 눌러봐.'
            },
            {
                type: 'dialog',
                text: '자, 금방 나았지? 앞으로도 당황하지말고 이렇게 하면 돼. 그럼 계속 힘내라고~'
            }
        ];
        
        function startSickTutorial() {
            // 이미 본 적 있으면 시작하지 않음
            if (localStorage.getItem('spiritGarden_sickTutorialSeen')) return;
            
            // 다른 튜토리얼이 진행 중이면 시작하지 않음
            if (tutorialActive || tutorial2Active || imbalanceTutorialActive) return;
            
            // 육성 탭으로 이동
            switchTab('garden');
            
            sickTutorialStep = 0;
            sickTutorialActive = true;
            showSickTutorialStep();
        }
        
        function showSickTutorialStep() {
            if (sickTutorialStep >= SICK_TUTORIAL_STEPS.length) {
                endSickTutorial();
                return;
            }
            
            const step = SICK_TUTORIAL_STEPS[sickTutorialStep];
            
            if (step.type === 'dialog') {
                showSickTutorialDialog(step.text);
            } else if (step.type === 'shopkeeper') {
                showSickTutorialShopkeeper(step.text);
            } else if (step.type === 'action') {
                showSickTutorialAction(step.text, step.action);
            }
        }
        
        function showSickTutorialDialog(text) {
            const modal = document.createElement('div');
            modal.id = 'tutorialModal';
            modal.style.cssText = `
                position: fixed;
                top: 10px;
                left: 50%;
                transform: translateX(-50%);
                width: 90%;
                max-width: 500px;
                background: var(--card);
                border: 2px solid #f39c12;
                border-radius: 16px;
                padding: 15px;
                z-index: 100000;
                box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            `;
            
            modal.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <span style="font-size: 1.5rem;">🧙</span>
                        <span style="font-size: 0.9rem; color: #f39c12; font-weight: 600;">선배 정령지기</span>
                    </div>
                    <button onclick="skipSickTutorial()" style="padding: 5px 12px; background: var(--bg); border: 1px solid var(--border); border-radius: 6px; cursor: pointer; font-size: 0.8rem; color: var(--text-muted);">건너뛰기</button>
                </div>
                <div style="font-size: 1rem; line-height: 1.6; color: var(--text); margin-bottom: 15px; padding: 10px; background: var(--bg); border-radius: 8px; word-break: keep-all;">${text}</div>
                <button onclick="nextSickTutorialStep()" style="width: 100%; padding: 12px; background: #f39c12; color: white; border: none; border-radius: 8px; font-size: 1rem; cursor: pointer;">다음</button>
            `;
            
            const existing = document.getElementById('tutorialModal');
            if (existing) existing.remove();
            
            document.body.appendChild(modal);
        }
        
        function showSickTutorialShopkeeper(text) {
            const modal = document.createElement('div');
            modal.id = 'tutorialModal';
            modal.style.cssText = `
                position: fixed;
                top: 10px;
                left: 50%;
                transform: translateX(-50%);
                width: 90%;
                max-width: 500px;
                background: var(--card);
                border: 2px solid #888;
                border-radius: 16px;
                padding: 15px;
                z-index: 100000;
                box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            `;
            
            modal.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <span style="font-size: 1.5rem;">👤</span>
                        <span style="font-size: 0.9rem; color: #888; font-weight: 600;">상점 주인</span>
                    </div>
                    <button onclick="skipSickTutorial()" style="padding: 5px 12px; background: var(--bg); border: 1px solid var(--border); border-radius: 6px; cursor: pointer; font-size: 0.8rem; color: var(--text-muted);">건너뛰기</button>
                </div>
                <div style="font-size: 1rem; line-height: 1.6; color: var(--text); margin-bottom: 15px; padding: 10px; background: var(--bg); border-radius: 8px; word-break: keep-all;">${text}</div>
                <button onclick="nextSickTutorialStep()" style="width: 100%; padding: 12px; background: #888; color: white; border: none; border-radius: 8px; font-size: 1rem; cursor: pointer;">다음</button>
            `;
            
            const existing = document.getElementById('tutorialModal');
            if (existing) existing.remove();
            
            document.body.appendChild(modal);
        }
        
        function showSickTutorialAction(text, action) {
            const modal = document.createElement('div');
            modal.id = 'tutorialModal';
            modal.style.cssText = `
                position: fixed;
                top: 10px;
                left: 50%;
                transform: translateX(-50%);
                width: 90%;
                max-width: 500px;
                background: var(--card);
                border: 2px solid #f39c12;
                border-radius: 16px;
                padding: 15px;
                z-index: 100000;
                box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            `;
            
            modal.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <span style="font-size: 1.5rem;">🧙</span>
                        <span style="font-size: 0.9rem; color: #f39c12; font-weight: 600;">선배 정령지기</span>
                    </div>
                    <button onclick="skipSickTutorial()" style="padding: 5px 12px; background: var(--bg); border: 1px solid var(--border); border-radius: 6px; cursor: pointer; font-size: 0.8rem; color: var(--text-muted);">건너뛰기</button>
                </div>
                <div style="font-size: 1rem; line-height: 1.6; color: var(--text); margin-bottom: 10px; padding: 10px; background: var(--bg); border-radius: 8px; word-break: keep-all;">${text}</div>
                <div style="padding: 8px 12px; background: #f39c1222; border-radius: 8px; font-size: 0.85rem; color: #f39c12;">
                    👇 해당 버튼을 눌러보세요!
                </div>
            `;
            
            const existing = document.getElementById('tutorialModal');
            if (existing) existing.remove();
            
            document.body.appendChild(modal);
            
            window.tutorialWaitingFor = action;
            
            // 강조할 요소 찾아서 하이라이트
            highlightSickTutorialTarget(action);
        }
        
        function highlightSickTutorialTarget(action) {
            clearTutorialHighlight();
            
            let targetSelector = '';
            
            if (action === 'openShop') {
                targetSelector = 'button.tab[onclick*="shop"]';
            } else if (action === 'buyMedicine') {
                targetSelector = 'button[onclick*="buyItem"][onclick*="medicine"]';
            } else if (action === 'openGarden') {
                targetSelector = 'button.tab[onclick*="garden"]';
            } else if (action === 'useMedicine') {
                targetSelector = 'button[onclick*="giveMedicine"]';
            }
            
            if (targetSelector) {
                const target = document.querySelector(targetSelector);
                if (target) {
                    target.classList.add('tutorial-highlight');
                    // 강조된 요소로 스크롤
                    setTimeout(() => {
                        target.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }, 100);
                }
            }
        }
        
        function nextSickTutorialStep() {
            sickTutorialStep++;
            showSickTutorialStep();
        }
        
        function skipSickTutorial() {
            endSickTutorial();
        }
        
        function endSickTutorial() {
            sickTutorialActive = false;
            window.tutorialWaitingFor = null;
            clearTutorialHighlight();
            
            const modal = document.getElementById('tutorialModal');
            if (modal) {
                modal.style.opacity = '0';
                modal.style.transition = 'opacity 0.3s';
                setTimeout(() => modal.remove(), 300);
            }
            
            localStorage.setItem('spiritGarden_sickTutorialSeen', 'true');
        }
        
        // 질병 튜토리얼용 액션 체크
        function checkSickTutorialAction(action) {
            if (!sickTutorialActive) return;
            if (window.tutorialWaitingFor !== action) return;
            
            clearTutorialHighlight();
            sickTutorialStep++;
            showSickTutorialStep();
        }
        
        // ===== 속성 불균형 튜토리얼 (첫 불균형 발생 시) =====
        let imbalanceTutorialStep = 0;
        let imbalanceTutorialActive = false;
        
        const IMBALANCE_TUTORIAL_STEPS = [
            {
                type: 'dialog',
                text: '처음엔 한 속성에만 신경쓰는게 좋다고 했더니 그 말을 아주 잘 들었구나, 후배...'
            },
            {
                type: 'dialog',
                text: '자, 봐. 속성 수치를 보면 높은 속성이 50이상, 낮은 속성은 10 이하지?'
            },
            {
                type: 'dialog',
                text: '이런 경우엔 정령에게 속성 불균형이 찾아와.'
            },
            {
                type: 'dialog',
                text: '자연에서는 모든 속성을 골고루 쌓을 수 있지만 인공 테라리움에선 그러기 쉽지 않거든.'
            },
            {
                type: 'dialog',
                text: '속성 불균형은 낮은 속성을 10 이상으로 올려주면 자연스럽게 풀릴거야.'
            },
            {
                type: 'dialog',
                text: '...그런거면 처음부터 말해달라고? 이 녀석이.'
            },
            {
                type: 'dialog',
                text: '일단 난 설명해줬으니 간다. 힘내라~'
            }
        ];
        
        function startImbalanceTutorial() {
            // 이미 본 적 있으면 시작하지 않음
            if (localStorage.getItem('spiritGarden_imbalanceTutorialSeen')) return;
            
            // 다른 튜토리얼이 진행 중이면 시작하지 않음
            if (tutorialActive || tutorial2Active || sickTutorialActive) return;
            
            // 육성 탭으로 이동
            switchTab('garden');
            
            imbalanceTutorialStep = 0;
            imbalanceTutorialActive = true;
            showImbalanceTutorialStep();
        }
        
        function showImbalanceTutorialStep() {
            if (imbalanceTutorialStep >= IMBALANCE_TUTORIAL_STEPS.length) {
                endImbalanceTutorial();
                return;
            }
            
            const step = IMBALANCE_TUTORIAL_STEPS[imbalanceTutorialStep];
            showImbalanceTutorialDialog(step.text);
        }
        
        function showImbalanceTutorialDialog(text) {
            const modal = document.createElement('div');
            modal.id = 'tutorialModal';
            modal.style.cssText = `
                position: fixed;
                top: 10px;
                left: 50%;
                transform: translateX(-50%);
                width: 90%;
                max-width: 500px;
                background: var(--card);
                border: 2px solid #f39c12;
                border-radius: 16px;
                padding: 15px;
                z-index: 100000;
                box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            `;
            
            modal.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <span style="font-size: 1.5rem;">🧙</span>
                        <span style="font-size: 0.9rem; color: #f39c12; font-weight: 600;">선배 정령지기</span>
                    </div>
                    <button onclick="skipImbalanceTutorial()" style="padding: 5px 12px; background: var(--bg); border: 1px solid var(--border); border-radius: 6px; cursor: pointer; font-size: 0.8rem; color: var(--text-muted);">건너뛰기</button>
                </div>
                <div style="font-size: 1rem; line-height: 1.6; color: var(--text); margin-bottom: 15px; padding: 10px; background: var(--bg); border-radius: 8px; word-break: keep-all;">${text}</div>
                <button onclick="nextImbalanceTutorialStep()" style="width: 100%; padding: 12px; background: #f39c12; color: white; border: none; border-radius: 8px; font-size: 1rem; cursor: pointer;">다음</button>
            `;
            
            const existing = document.getElementById('tutorialModal');
            if (existing) existing.remove();
            
            document.body.appendChild(modal);
        }
        
        function nextImbalanceTutorialStep() {
            imbalanceTutorialStep++;
            showImbalanceTutorialStep();
        }
        
        function skipImbalanceTutorial() {
            endImbalanceTutorial();
        }
        
        function endImbalanceTutorial() {
            imbalanceTutorialActive = false;
            
            const modal = document.getElementById('tutorialModal');
            if (modal) {
                modal.style.opacity = '0';
                modal.style.transition = 'opacity 0.3s';
                setTimeout(() => modal.remove(), 300);
            }
            
            localStorage.setItem('spiritGarden_imbalanceTutorialSeen', 'true');
        }
        
        // 속성 불균형 체크 함수
        function checkImbalanceAndTutorial(spirit) {
            if (!spirit || !spirit.hiddenAttributes) return;
            if (localStorage.getItem('spiritGarden_imbalanceTutorialSeen')) return;
            
            const attrs = spirit.hiddenAttributes;
            const attrValues = Object.values(attrs);
            const maxAttr = Math.max(...attrValues);
            const minAttr = Math.min(...attrValues);
            
            // 불균형 조건: 최고 50 이상 & 최저 10 이하
            if (maxAttr >= 50 && minAttr <= 10) {
                setTimeout(() => {
                    startImbalanceTutorial();
                }, 500);
            }
        }
        
        function checkAndShowOpening() {
            const seen = localStorage.getItem('spiritGarden_openingSeen');
            if (!seen) {
                showOpening();
            } else {
                // 오프닝은 봤지만 튜토리얼은 안 본 경우
                const tutorialSeen = localStorage.getItem('spiritGarden_tutorialSeen');
                if (!tutorialSeen) {
                    startTutorial();
                }
            }
        }

        // 모바일 디버깅 정보
        console.log('=== 모바일 디버깅 정보 ===');
        console.log('현재 시간:', new Date().toISOString());
        
        // 초기화
        try {
            console.log('게임 초기화 시작...');
            loadGame();
            renderSpirits();
            renderInventory();
            renderShop();
            updateTimeDisplay();
            applyLightMode();
            updateCoinDisplay();
            updateInventoryCollapseUI(); // 소지품 접힘 상태 적용
            startAutoGather(); // 자동 채집 시작
            checkAndShowOpening(); // 오프닝 체크
            
            console.log('🎉 게임 초기화 완료!');
        } catch (error) {
            console.error('❌ 초기화 오류:', error);
            console.error('오류 스택:', error.stack);
            alert('게임 초기화 중 오류가 발생했습니다: ' + error.message);
        }

        // 모달 배경 클릭 시 닫기
        document.querySelectorAll('.modal').forEach(modal => {
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.classList.remove('active');
                }
            });
        });
    </script>
    
    <!-- 플로팅 스크롤 버튼 -->
    <div class="scroll-buttons">
        <button class="scroll-btn" onclick="window.scrollTo({top: 0, behavior: 'smooth'})" title="맨 위로">⬆️</button>
        <button class="scroll-btn" onclick="window.scrollTo({top: document.body.scrollHeight, behavior: 'smooth'})" title="맨 아래로">⬇️</button>
    </div>
</body>
</html>

<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>나의 작은 테라리움 - Spirit Garden</title>
    <link href="https://fonts.googleapis.com/css2?family=Nanum+Myeongjo:wght@400;700;800&family=Gowun+Batang:wght@400;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg: #fafaf8;
            --text: #2a2a2a;
            --border: #e0e0dc;
            --card: #ffffff;
            --shadow: rgba(0, 0, 0, 0.06);
            
            --fire: #ff6b4a;
            --water: #4a9eff;
            --wind: #7bdb8f;
            --earth: #d4a574;
            --light: #ffd94a;
            --dark: #8e7cc3;
        }

        body {
            font-family: 'Gowun Batang', serif;
            background: var(--bg);
            color: var(--text);
            line-height: 1.6;
            padding: 20px;
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            font-family: 'Nanum Myeongjo', serif;
            font-size: 2.5rem;
            font-weight: 800;
            text-align: center;
            margin-bottom: 10px;
            letter-spacing: -1px;
        }

        .subtitle {
            text-align: center;
            font-size: 0.9rem;
            color: #888;
            margin-bottom: 40px;
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            border-bottom: 1px solid var(--border);
        }

        .tab {
            padding: 12px 24px;
            background: none;
            border: none;
            font-family: 'Gowun Batang', serif;
            font-size: 1rem;
            cursor: pointer;
            color: #888;
            transition: all 0.3s;
            border-bottom: 2px solid transparent;
        }

        .tab.active {
            color: var(--text);
            border-bottom-color: var(--text);
        }

        .tab:hover {
            color: var(--text);
        }

        .section {
            display: none;
        }

        .section.active {
            display: block;
        }

        .main-layout {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        .inventory-panel {
            background: var(--card);
            border: 1px solid var(--border);
            padding: 24px;
            height: fit-content;
            position: sticky;
            top: 20px;
        }

        .inventory-title {
            font-family: 'Nanum Myeongjo', serif;
            font-size: 1.2rem;
            font-weight: 700;
            margin-bottom: 16px;
        }

        .inventory-section {
            margin-bottom: 20px;
        }

        .inventory-label {
            font-size: 0.85rem;
            color: #888;
            margin-bottom: 8px;
        }

        .inventory-items {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .inventory-item {
            padding: 6px 12px;
            background: var(--bg);
            border: 1px solid var(--border);
            font-size: 0.85rem;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .spirits-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 20px;
        }

        .spirit-card {
            background: var(--card);
            border: 1px solid var(--border);
            padding: 24px;
            transition: all 0.3s;
        }

        .spirit-card:hover {
            box-shadow: 0 4px 20px var(--shadow);
            transform: translateY(-2px);
        }

        .spirit-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 16px;
        }

        .spirit-icon {
            font-size: 3rem;
            line-height: 1;
        }

        .spirit-info {
            flex: 1;
            margin-left: 16px;
        }

        .spirit-name {
            font-family: 'Nanum Myeongjo', serif;
            font-size: 1.2rem;
            font-weight: 700;
            margin-bottom: 4px;
            cursor: pointer;
        }

        .spirit-name:hover {
            color: var(--fire);
        }

        .spirit-stage {
            font-size: 0.85rem;
            color: #888;
        }

        .progress-bar {
            height: 6px;
            background: var(--border);
            margin-bottom: 8px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--light), var(--fire));
            transition: width 0.5s;
        }

        .progress-text {
            font-size: 0.8rem;
            color: #888;
            margin-bottom: 16px;
        }

        .parameters {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            margin-bottom: 16px;
            padding: 12px;
            background: var(--bg);
            border: 1px solid var(--border);
        }

        .param {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.85rem;
        }

        .param-icon {
            font-size: 1.1rem;
        }

        .environment {
            margin-bottom: 16px;
            padding: 12px;
            background: var(--bg);
            border: 1px solid var(--border);
        }

        .env-title {
            font-size: 0.85rem;
            font-weight: 700;
            margin-bottom: 8px;
        }

        .env-bars {
            display: grid;
            gap: 6px;
        }

        .env-bar {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.8rem;
        }

        .env-bar-bg {
            flex: 1;
            height: 8px;
            background: var(--border);
            position: relative;
            overflow: hidden;
        }

        .env-bar-fill {
            height: 100%;
            transition: width 0.5s;
        }

        .spirit-status {
            font-size: 0.85rem;
            color: #888;
            margin-bottom: 16px;
            min-height: 40px;
        }

        .action-buttons {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        button {
            padding: 10px 16px;
            border: 1px solid var(--border);
            background: var(--card);
            font-family: 'Gowun Batang', serif;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            user-select: none;
            -webkit-user-select: none;
        }

        button:hover {
            background: var(--bg);
            border-color: var(--text);
        }

        button:active {
            transform: scale(0.98);
        }

        button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        select {
            padding: 8px 12px;
            border: 1px solid var(--border);
            background: var(--card);
            color: var(--text);
            font-family: 'Gowun Batang', serif;
            font-size: 0.9rem;
            border-radius: 4px;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            -webkit-appearance: none;
            appearance: none;
        }
        
        select:focus {
            outline: 2px solid var(--fire);
            outline-offset: 2px;
        }


        .new-spirit-btn {
            width: 100%;
            padding: 16px;
            font-size: 1rem;
            font-weight: 700;
            margin-top: 20px;
        }

        .walk-btn {
            width: 100%;
            padding: 16px;
            font-size: 1rem;
            font-weight: 700;
            margin-bottom: 20px;
            background: var(--light);
            border-color: var(--light);
            color: #000 !important;
        }

        .walk-btn:hover {
            background: var(--fire);
            border-color: var(--fire);
            color: #000 !important;
        }

        .walk-btn:disabled {
            color: #666 !important;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.6);
            z-index: 1000;
            align-items: flex-start;
            justify-content: center;
            padding: 20px;
            padding-top: 100px;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: var(--card);
            padding: 32px;
            max-width: 500px;
            width: 100%;
            border: 1px solid var(--border);
            margin-bottom: 40px;
        }

        .modal-title {
            font-family: 'Nanum Myeongjo', serif;
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 20px;
        }

        .food-grid, .music-grid, .decor-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-bottom: 20px;
        }

        .option-btn {
            padding: 16px;
            text-align: left;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .option-icon {
            font-size: 1.5rem;
        }

        .option-info {
            flex: 1;
        }

        .option-name {
            font-weight: 700;
            margin-bottom: 2px;
        }

        .option-effect {
            font-size: 0.8rem;
            color: #888;
        }

        .close-btn {
            width: 100%;
            margin-top: 16px;
        }

        .collection-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 20px;
        }
        
        .encyclopedia-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .encyclopedia-card {
            background: var(--card);
            border: 2px solid var(--border);
            padding: 20px;
            text-align: center;
            position: relative;
            min-height: 120px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        .encyclopedia-card.unlocked {
            border-color: #4CAF50;
        }
        
        .encyclopedia-card.locked {
            background: repeating-linear-gradient(
                45deg,
                var(--card),
                var(--card) 10px,
                var(--border) 10px,
                var(--border) 11px
            );
            opacity: 0.6;
        }
        
        .encyclopedia-icon {
            font-size: 3rem;
            margin-bottom: 8px;
        }
        
        .encyclopedia-name {
            font-family: 'Nanum Myeongjo', serif;
            font-size: 1rem;
            font-weight: 700;
            color: var(--text);
        }
        
        .encyclopedia-count {
            font-size: 0.85rem;
            color: #888;
            margin-top: 4px;
        }

        .collection-card {
            background: var(--card);
            border: 1px solid var(--border);
            padding: 24px;
            text-align: center;
        }

        .collection-icon {
            font-size: 4rem;
            margin-bottom: 12px;
        }

        .collection-name {
            font-family: 'Nanum Myeongjo', serif;
            font-size: 1.2rem;
            font-weight: 700;
            margin-bottom: 8px;
        }

        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #888;
        }

        .empty-icon {
            font-size: 3rem;
            margin-bottom: 16px;
            opacity: 0.3;
        }

        .time-display {
            text-align: center;
            font-size: 0.9rem;
            color: #888;
            margin-bottom: 20px;
        }

        .notification {
            position: fixed;
            top: 80px;
            right: 20px;
            background: var(--card);
            border: 1px solid var(--border);
            padding: 16px 24px;
            box-shadow: 0 4px 20px var(--shadow);
            z-index: 999;
            animation: slideIn 0.3s ease-out;
            max-width: 300px;
            word-wrap: break-word;
        }

        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes slideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(400px);
                opacity: 0;
            }
        }

        .name-input {
            width: 100%;
            padding: 12px;
            font-family: 'Gowun Batang', serif;
            font-size: 1rem;
            border: 1px solid var(--border);
            margin-bottom: 16px;
        }

        .decor-btn:disabled::after {
            content: '재료 부족';
            position: absolute;
            top: 8px;
            right: 8px;
            font-size: 0.7rem;
            padding: 2px 6px;
            background: #f44;
            color: white;
            border-radius: 2px;
        }

        @media (max-width: 900px) {
            .main-layout {
                grid-template-columns: 1fr;
            }

            .inventory-panel {
                position: static;
            }
        }

        .light-toggle {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 60px;
            height: 32px;
            background: #4CAF50;
            border: none;
            border-radius: 16px;
            cursor: pointer;
            transition: background-color 0.3s ease;
            z-index: 1000;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            padding: 0;
        }
        
        /* 하단 버튼 컨테이너 */
        .bottom-buttons {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            z-index: 1000;
        }
        
        .bottom-btn {
            width: 50px;
            height: 50px;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
        }
        
        .bottom-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        
        .bottom-btn:active {
            transform: translateY(0);
        }
        
        .pause-btn {
            background: #ff9800;
            color: white;
        }
        
        .pause-btn.paused {
            background: #4CAF50;
        }
        
        .reset-btn {
            background: #f44336;
            color: white;
        }
        
        .light-btn {
            background: #2196F3;
            color: white;
        }
        
        /* 모바일에서 조명 버튼 크기 조정 */
        @media (max-width: 768px) {
            .bottom-buttons {
                bottom: 15px;
                right: 15px;
                gap: 8px;
            }
            
            .bottom-btn {
                width: 45px;
                height: 45px;
                font-size: 1.3rem;
            }
            .light-toggle {
                bottom: 15px;
                right: 15px;
                width: 50px;
                height: 28px;
            }
            
            .light-toggle::before {
                width: 22px !important;
                height: 22px !important;
            }
            
            body.dark-mode .light-toggle::before {
                transform: translateX(22px) !important;
            }
            
            /* 상점 레이아웃 1열로 변경 */
            .shop-grid {
                grid-template-columns: 1fr !important;
                gap: 15px !important;
            }
            
            /* 테라리움 장식물 목록 1열로 변경 */
            #installedDecorList > div,
            #terrariumDecorList > div {
                grid-template-columns: 1fr !important;
            }
            
            /* 상점 섹션 패딩 조정 */
            .shop-section {
                padding: 20px !important;
            }
            
            /* 제목 크기 조정 */
            h1 {
                font-size: 1.8rem !important;
            }
            
            h2 {
                font-size: 1.5rem !important;
            }
            
            /* 탭 버튼 크기 조정 */
            .tab {
                padding: 10px 15px !important;
                font-size: 0.9rem !important;
            }
            
            /* 상점 제목 크기 조정 */
            .shop-section h3 {
                font-size: 1.1rem !important;
            }
            
            /* 전체 여백 조정 */
            body {
                padding: 10px !important;
            }
        }

        .light-toggle::before {
            content: '';
            position: absolute;
            width: 26px;
            height: 26px;
            border-radius: 50%;
            background: white;
            top: 3px;
            left: 3px;
            transition: transform 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        body.dark-mode .light-toggle {
            background: #666;
        }

        body.dark-mode .light-toggle::before {
            transform: translateX(28px);
        }

        .light-toggle #lightIcon {
            display: none;
        }

        body.dark-mode {
            --bg: #1a1a1a;
            --card: #2d2d2d;
            --text: #e0e0e0;
            --border: #404040;
        }

        body.dark-mode .spirit-name,
        body.dark-mode .spirit-stage,
        body.dark-mode .progress-text,
        body.dark-mode .param,
        body.dark-mode .spirit-status,
        body.dark-mode .env-title,
        body.dark-mode .modal-title,
        body.dark-mode .option-name,
        body.dark-mode .option-effect,
        body.dark-mode .inventory-label,
        body.dark-mode .collection-name,
        body.dark-mode h1,
        body.dark-mode h2,
        body.dark-mode .subtitle,
        body.dark-mode .time-display {
            color: #e0e0e0;
        }

        body.dark-mode button {
            color: #e0e0e0;
        }

        body.dark-mode button:disabled {
            color: #888;
        }
    </style>
</head>
<body>
    <div class="bottom-buttons">
        <button class="bottom-btn reset-btn" onclick="resetGame()" title="게임 초기화">🔄</button>
        <button class="bottom-btn pause-btn" id="pauseBtn" onclick="togglePause()" title="일시정지">⏸️</button>
        <button class="bottom-btn light-btn" onclick="toggleLight()" title="조명 켜기/끄기">
            <span id="lightIcon">☀️</span>
        </button>
    </div>

    <h1>나의 작은 테라리움</h1>
    <div class="subtitle">Spirit Garden</div>

    <div class="time-display" id="timeDisplay"></div>

    <div class="tabs">
        <button class="tab active" onclick="switchTab('garden')">육성</button>
        <button class="tab" onclick="switchTab('terrarium')">테라리움</button>
        <button class="tab" onclick="switchTab('shop')">상점 💰<span id="coinDisplay">0</span></button>
        <button class="tab" onclick="switchTab('encyclopedia')">도감</button>
        <button class="tab" onclick="switchTab('album')">앨범</button>
        <button class="tab" onclick="switchTab('settings')">⚙️</button>
    </div>

    <div id="gardenSection" class="section active">
        <div class="main-layout">
            <div class="inventory-panel">
                <div style="margin-bottom: 16px;">
                    <label for="titleSelect" style="display: block; font-size: 0.9rem; margin-bottom: 6px; color: var(--text); font-weight: 600;">칭호 선택</label>
                    <select id="titleSelect" onchange="changeTitle()" style="width: 100%; padding: 10px; border: 2px solid var(--border); border-radius: 8px; background: var(--card); color: var(--text); font-size: 0.9rem; cursor: pointer;">
                        <option value="none">없음 (기본)</option>
                        <option value="hawk_eye">매의 눈 (모든 채집물 확률 1.5배)</option>
                        <option value="gatherer">채집꾼 (먹이 확률 2배)</option>
                        <option value="musician">음악가 (레코드 확률 2배)</option>
                        <option value="collector">수집가 (테라리움 물품 확률 2배)</option>
                    </select>
                </div>

                <div style="margin-bottom: 16px;">
                    <label for="gatherLocationSelect" style="display: block; font-size: 0.9rem; margin-bottom: 6px; color: var(--text); font-weight: 600;">채집 장소</label>
                    <select id="gatherLocationSelect" onchange="changeGatherLocation()" style="width: 100%; padding: 10px; border: 2px solid var(--border); border-radius: 8px; background: var(--card); color: var(--text); font-size: 0.9rem; cursor: pointer;">
                        <option value="garden">🌸 정원 (모든 속성)</option>
                        <option value="lake">🌊 호수 (물·바람)</option>
                        <option value="forest">🌲 숲 (땅·불)</option>
                    </select>
                </div>

                <button class="walk-btn" onclick="goGather()" style="margin-bottom: 20px;">채집하기</button>

                <div class="inventory-title">내 소지품</div>
                
                <div class="inventory-section">
                    <div class="inventory-label">🍎 먹이</div>
                    <div class="inventory-items" id="foodInventory">
                        <div class="inventory-item">없음</div>
                    </div>
                </div>

                <div class="inventory-section">
                    <div class="inventory-label">음악</div>
                    <div class="inventory-items" id="musicInventory">
                        <div class="inventory-item">없음</div>
                    </div>
                </div>

                <div class="inventory-section">
                    <div class="inventory-label">🌳 나무 & 장식물</div>
                    <div class="inventory-items" id="decorInventory">
                        <div class="inventory-item">없음</div>
                    </div>
                </div>
            </div>

            <div>
                <div class="spirits-grid" id="spiritsGrid"></div>
                <button class="new-spirit-btn" onclick="createNewSpirit()">+ 새로운 알 받기</button>
            </div>
        </div>
    </div>

    <div id="encyclopediaSection" class="section">
        <h2 style="text-align: center; font-family: 'Nanum Myeongjo', serif; font-size: 2rem; margin-bottom: 30px;">정령 도감</h2>
        <div class="encyclopedia-grid" id="encyclopediaGrid"></div>
    </div>

    <div id="albumSection" class="section">
        <h2 style="text-align: center; font-family: 'Nanum Myeongjo', serif; font-size: 2rem; margin-bottom: 30px;">💝 정령 앨범</h2>
        <div class="collection-grid" id="collectionGrid"></div>
    </div>


    <!-- 설정 섹션 -->
    <div id="settingsSection" class="section">
        <h2 style="text-align: center; font-family: 'Nanum Myeongjo', serif; font-size: 2rem; margin-bottom: 30px;">설정</h2>
        
        <div style="max-width: 600px; margin: 0 auto;">
            <!-- 데이터 관리 -->
            <div style="background: var(--card); padding: 24px; border: 1px solid var(--border); border-radius: 12px; margin-bottom: 20px;">
                <h3 style="font-family: 'Nanum Myeongjo', serif; font-size: 1.3rem; margin-bottom: 20px; color: var(--text);">데이터 관리</h3>
                
                <div style="display: flex; flex-direction: column; gap: 12px;">
                    <button onclick="exportGameData()" style="padding: 14px; background: var(--water); color: white; border: none; border-radius: 8px; font-size: 1rem; font-weight: 700; cursor: pointer;">
                        게임 데이터 내보내기
                    </button>
                    
                    <button onclick="importGameData()" style="padding: 14px; background: var(--wind); color: white; border: none; border-radius: 8px; font-size: 1rem; font-weight: 700; cursor: pointer;">
                        게임 데이터 불러오기
                    </button>
                    
                    <button onclick="manualRebuildEncyclopedia()" style="padding: 14px; background: var(--earth); color: white; border: none; border-radius: 8px; font-size: 1rem; font-weight: 700; cursor: pointer;">
                        앨범에서 도감 복구
                    </button>
                </div>
                
                <div style="margin-top: 16px; padding: 12px; background: var(--bg); border-radius: 8px; font-size: 0.85rem; color: #888;">
                    💡 데이터 내보내기를 통해 게임 진행상황을 백업할 수 있습니다.<br>
                    다른 기기나 브라우저에서 불러오기를 통해 복원할 수 있습니다.
                </div>
            </div>
            
            <!-- 화면 설정 -->
            <div style="background: var(--card); padding: 24px; border: 1px solid var(--border); border-radius: 12px; margin-bottom: 20px;">
                <h3 style="font-family: 'Nanum Myeongjo', serif; font-size: 1.3rem; margin-bottom: 20px; color: var(--text);">화면 설정</h3>
                
                <div style="display: flex; justify-content: space-between; align-items: center; padding: 12px; background: var(--bg); border-radius: 8px;">
                    <div>
                        <div style="font-weight: 700; margin-bottom: 4px;">다크 모드 고정</div>
                        <div style="font-size: 0.85rem; color: #888;">활성화 시 조명 상태와 무관하게 다크 모드 유지</div>
                    </div>
                    <label style="position: relative; display: inline-block; width: 60px; height: 32px;">
                        <input type="checkbox" id="darkModeToggle" onchange="toggleDarkModeLock()" style="opacity: 0; width: 0; height: 0;">
                        <span style="position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 32px;">
                            <span id="darkModeSlider" style="position: absolute; content: ''; height: 24px; width: 24px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%;"></span>
                        </span>
                    </label>
                </div>
            </div>
            
            <!-- 게임 정보 -->
            <div style="background: var(--card); padding: 24px; border: 1px solid var(--border); border-radius: 12px;">
                <h3 style="font-family: 'Nanum Myeongjo', serif; font-size: 1.3rem; margin-bottom: 20px; color: var(--text);">게임 정보</h3>
                
                <div style="display: flex; flex-direction: column; gap: 12px; font-size: 0.9rem; color: var(--text);">
                    <div style="display: flex; justify-content: space-between; padding: 8px 0;">
                        <span>버전</span>
                        <span style="font-weight: 700;">2.1.0</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- 앨범 상세 정보 모달 -->
    <div id="albumDetailModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 10000; justify-content: center; align-items: center;">
        <div style="background: var(--card); border: 2px solid var(--border); border-radius: 12px; padding: 30px; max-width: 500px; width: 90%; max-height: 80vh; overflow-y: auto;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <h2 id="modalTitle" style="font-family: 'Nanum Myeongjo', serif; font-size: 1.5rem; color: var(--text); margin: 0;"></h2>
                <button onclick="closeAlbumDetail()" style="background: none; border: none; font-size: 1.5rem; cursor: pointer; color: var(--text);">✕</button>
            </div>
            <div id="modalContent"></div>
        </div>
    </div>

    <div id="shopSection" class="section">
        <div style="max-width: 1000px; margin: 0 auto;">
            <div style="text-align: center; margin-bottom: 30px;">
                <h2 style="font-family: 'Nanum Myeongjo', serif; font-size: 2rem; margin-bottom: 10px;">🏪 정령 상점</h2>
                <div style="font-size: 1.5rem; font-weight: 700; color: var(--fire); margin-bottom: 20px;">보유 코인: <span id="shopCoinDisplay">0</span> 💰</div>
                
                <!-- 카테고리 선택 드롭다운 -->
                <select id="shopCategorySelect" onchange="changeShopCategory()" style="padding: 12px 20px; font-size: 1rem; border: 2px solid var(--border); border-radius: 8px; background: var(--card); color: var(--text); cursor: pointer; min-width: 200px;">
                    <option value="all">📦 전체</option>
                    <option value="food">🍎 먹이</option>
                    <option value="decoration">🌳 장식물</option>
                    <option value="music">레코드</option>
                </select>
            </div>

            <div class="shop-grid" style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 30px;">
                <!-- 판매 (소지품 → 코인) -->
                <div class="shop-section" style="background: var(--card); border: 1px solid var(--border); padding: 32px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                        <h3 style="font-family: 'Nanum Myeongjo', serif; font-size: 1.3rem; margin: 0; color: var(--fire);">💸 판매하기</h3>
                        <select id="sellFilterSelect" onchange="changeSellFilter()" style="padding: 8px 12px; font-size: 0.9rem; border: 1px solid var(--border); border-radius: 6px; background: var(--card); color: var(--text); cursor: pointer;">
                            <option value="all">전체</option>
                            <option value="fire">🔥 불</option>
                            <option value="water">💧 물</option>
                            <option value="wind">🌬️ 바람</option>
                            <option value="earth">🌱 땅</option>
                            <option value="light">✨ 빛</option>
                            <option value="dark">🌙 어둠</option>
                            <option value="intelligence">🧠 지력</option>
                            <option value="strength">💪 체력</option>
                            <option value="charm">💖 매력</option>
                        </select>
                    </div>
                    <div id="sellList"></div>
                </div>

                <!-- 구매 (코인 → 아이템) -->
                <div class="shop-section" style="background: var(--card); border: 1px solid var(--border); padding: 32px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                        <h3 style="font-family: 'Nanum Myeongjo', serif; font-size: 1.3rem; margin: 0; color: var(--water);">🛒 구매하기</h3>
                        <select id="buyFilterSelect" onchange="changeBuyFilter()" style="padding: 8px 12px; font-size: 0.9rem; border: 1px solid var(--border); border-radius: 6px; background: var(--card); color: var(--text); cursor: pointer;">
                            <option value="all">전체</option>
                            <option value="fire">🔥 불</option>
                            <option value="water">💧 물</option>
                            <option value="wind">🌬️ 바람</option>
                            <option value="earth">🌱 땅</option>
                            <option value="light">✨ 빛</option>
                            <option value="dark">🌙 어둠</option>
                            <option value="intelligence">🧠 지력</option>
                            <option value="strength">💪 체력</option>
                            <option value="charm">💖 매력</option>
                        </select>
                    </div>
                    <div id="buyList"></div>
                </div>
            </div>
        </div>
    </div>

    <div id="terrariumSection" class="section">
        <div style="max-width: 800px; margin: 0 auto;">
            <!-- 테라리움 환경 -->
            <div style="background: var(--card); border: 1px solid var(--border); padding: 32px; margin-bottom: 20px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <h2 style="font-family: 'Nanum Myeongjo', serif; font-size: 1.5rem; margin: 0;">테라리움 환경</h2>
                    <div style="display: flex; align-items: center; gap: 12px;">
                        <div style="display: flex; align-items: center; gap: 8px; padding: 8px 16px; background: #f0f0f0; border-radius: 8px;">
                            <span style="font-weight: 600; color: #666;">전체 품질:</span>
                            <span id="terrariumQuality" style="font-size: 1.2rem; font-weight: 700; color: #ff9800;">0.0</span>
                        </div>
                        <button onclick="removeAllDecorations()" style="padding: 8px 16px; background: var(--fire); color: white; border: none; border-radius: 8px; font-weight: 600; cursor: pointer;">
                            전체 해제
                        </button>
                    </div>
                </div>
                <div class="env-bars" style="display: grid; gap: 12px;">
                    <div class="env-bar" style="display: flex; align-items: center; gap: 12px;">
                        <span style="font-size: 1.5rem;">🔥</span>
                        <div class="env-bar-bg" style="flex: 1; height: 12px; background: var(--border);">
                            <div class="env-bar-fill" id="terrFireBar" style="height: 100%; background: var(--fire); width: 0%;"></div>
                        </div>
                        <span id="terrFireValue" style="min-width: 30px; text-align: right;">0</span>
                    </div>
                    <div class="env-bar" style="display: flex; align-items: center; gap: 12px;">
                        <span style="font-size: 1.5rem;">💧</span>
                        <div class="env-bar-bg" style="flex: 1; height: 12px; background: var(--border);">
                            <div class="env-bar-fill" id="terrWaterBar" style="height: 100%; background: var(--water); width: 0%;"></div>
                        </div>
                        <span id="terrWaterValue" style="min-width: 30px; text-align: right;">0</span>
                    </div>
                    <div class="env-bar" style="display: flex; align-items: center; gap: 12px;">
                        <span style="font-size: 1.5rem;">🌬️</span>
                        <div class="env-bar-bg" style="flex: 1; height: 12px; background: var(--border);">
                            <div class="env-bar-fill" id="terrWindBar" style="height: 100%; background: var(--wind); width: 0%;"></div>
                        </div>
                        <span id="terrWindValue" style="min-width: 30px; text-align: right;">0</span>
                    </div>
                    <div class="env-bar" style="display: flex; align-items: center; gap: 12px;">
                        <span style="font-size: 1.5rem;">🌱</span>
                        <div class="env-bar-bg" style="flex: 1; height: 12px; background: var(--border);">
                            <div class="env-bar-fill" id="terrEarthBar" style="height: 100%; background: var(--earth); width: 0%;"></div>
                        </div>
                        <span id="terrEarthValue" style="min-width: 30px; text-align: right;">0</span>
                    </div>
                    <div class="env-bar" style="display: flex; align-items: center; gap: 12px;">
                        <span style="font-size: 1.5rem;">✨</span>
                        <div class="env-bar-bg" style="flex: 1; height: 12px; background: var(--border);">
                            <div class="env-bar-fill" id="terrLightBar" style="height: 100%; background: var(--light); width: 0%;"></div>
                        </div>
                        <span id="terrLightValue" style="min-width: 30px; text-align: right;">0</span>
                    </div>
                    <div class="env-bar" style="display: flex; align-items: center; gap: 12px;">
                        <span style="font-size: 1.5rem;">🌙</span>
                        <div class="env-bar-bg" style="flex: 1; height: 12px; background: var(--border);">
                            <div class="env-bar-fill" id="terrDarkBar" style="height: 100%; background: var(--dark); width: 0%;"></div>
                        </div>
                        <span id="terrDarkValue" style="min-width: 30px; text-align: right;">0</span>
                    </div>
                </div>
            </div>

            <!-- 설치된 장식물 -->
            <div style="background: var(--card); border: 1px solid var(--border); padding: 32px; margin-bottom: 20px;">
                <h2 style="font-family: 'Nanum Myeongjo', serif; font-size: 1.5rem; margin-bottom: 10px;">설치된 장식물</h2>
                <div style="font-size: 0.9rem; color: #888; margin-bottom: 20px;" id="installedCount">0 / 20</div>
                <div id="installedDecorList"></div>
            </div>

            <!-- 인벤토리 장식물 -->
            <div style="background: var(--card); border: 1px solid var(--border); padding: 32px;">
                <h2 style="font-family: 'Nanum Myeongjo', serif; font-size: 1.5rem; margin-bottom: 20px;">인벤토리 장식물</h2>
                <div id="terrariumDecorList"></div>
            </div>
        </div>
    </div>

    <!-- Name Modal -->
    <div class="modal" id="nameModal">
        <div class="modal-content">
            <div class="modal-title">정령의 이름을 지어주세요</div>
            <input type="text" class="name-input" id="nameInput" placeholder="이름을 입력하세요" maxlength="10">
            <button onclick="confirmName()" style="width: 100%;">확인</button>
        </div>
    </div>

    <!-- Feed Modal -->
    <div class="modal" id="feedModal">
        <div class="modal-content">
            <div class="modal-title">무엇을 먹일까요?</div>
            <div class="food-grid">
                <!-- 초기 더미 버튼 (renderFeedOptions()로 동적 생성됨) -->
            </div>
            <button class="close-btn" onclick="closeModal('feedModal')">닫기</button>
        </div>
    </div>

    <!-- Music Modal -->
    <div class="modal" id="musicModal">
        <div class="modal-content">
            <div class="modal-title">어떤 음악을 들려줄까요?</div>
            <div id="musicOptions"></div>
            <button class="close-btn" onclick="closeModal('musicModal')">닫기</button>
        </div>
    </div>

    <!-- Decorate Modal -->
    <div class="modal" id="decorateModal">
        <div class="modal-content">
            <div class="modal-title">테라리움 꾸미기</div>
            <div id="decorOptions"></div>
            <button class="close-btn" onclick="closeModal('decorateModal')">닫기</button>
        </div>
    </div>



    <!-- 커스텀 확인 모달 -->
    <div id="confirmModal" class="modal">
        <div class="modal-content" style="max-width: 400px;">
            <h3 id="confirmTitle" style="font-family: 'Nanum Myeongjo', serif; font-size: 1.3rem; margin-bottom: 15px; color: var(--text);"></h3>
            <p id="confirmMessage" style="margin-bottom: 25px; line-height: 1.6; color: var(--text); white-space: pre-line;"></p>
            <div style="display: flex; gap: 10px; justify-content: flex-end;">
                <button id="confirmCancelBtn" style="background: #888; color: white;">취소</button>
                <button id="confirmOkBtn" style="background: var(--fire); color: white;">확인</button>
            </div>
        </div>
    </div>

    <script>      let spirits = [];
        let collection = [];
        let encyclopedia = {}; // 도감: { evolutionKey: count }
        let darkModeLocked = false; // 다크 모드 고정 여부
        let inventory = {
            music: [],
            decorations: [],
            food: ['fire', 'fire', 'fire', 'water', 'water', 'water', 'wind', 'wind', 'wind', 'earth', 'earth', 'earth'],
            medicine: [] // 약초
        };
        let terrarium = {
            fire: 0,
            water: 0,
            wind: 0,
            earth: 0,
            light: 0,
            dark: 0
        };
        let installedDecorations = []; // 설치된 장식물 목록 (객체 배열: { type, index })
        let lightMode = true; // 조명 모드 (true: 빛, false: 어둠)
        let coins = 0; // 화폐
        let currentSpiritId = null;
        let pendingSpirit = null;
        let lastGatherTime = null;
        let currentTab = 'garden'; // 현재 활성 탭
        let currentTitle = 'none'; // 현재 칭호 (none, hawk_eye, gatherer, musician, collector)
        let currentShopCategory = 'all'; // 현재 상점 카테고리 (all, food, decoration, music)
        let sellFilter = 'all'; // 판매 필터 (all, fire, water, wind, earth, light, dark, intelligence, strength, charm)
        let buyFilter = 'all'; // 구매 필터 (all, fire, water, wind, earth, light, dark, intelligence, strength, charm)
        let currentGatherLocation = 'garden'; // 현재 채집 장소 (garden, lake, forest)
        let lightToggleHistory = []; // 조명 변경 기록 (타임스탬프 배열)
        let isPaused = false; // 게임 일시정지 상태
        let pausedAt = null; // 일시정지 시작 시간
        let totalPausedTime = 0; // 총 일시정지 시간

        // 랜덤 문구 시스템
        const RANDOM_MESSAGES = {
            // 기본 행동 (조건 없음)
            basic: [
                '{name}이(가) 꿈틀거립니다.',
                '{name}이(가) 몸을 부르르 떱니다.',
                '{name}이(가) 주변을 두리번거립니다.',
                '{name}이(가) 작게 울음소리를 냅니다.',
                '{name}이(가) 가만히 웅크리고 있습니다.',
                '{name}이(가) 천천히 움직입니다.',
                '{name}이(가) 테라리움 유리에 몸을 문지릅니다.',
                '{name}이(가) 날개를 살짝 떨고 있습니다.',
                '{name}이(가) 자신의 몸을 정리합니다.',
                '{name}이(가) 무언가를 찾는 듯합니다.',
                '{name}이(가) 외로워합니다.',
                '{name}이(가) 심심해 보입니다.',
                '{name}이(가) 한숨을 쉽니다.'
            ],
            // 배고픔
            hungry: [
                '{name}이(가) 배고파 보입니다.',
                '{name}이(가) 먹이를 찾고 있습니다.',
                '{name}이(가) 허기진 눈빛으로 당신을 봅니다.',
                '{name}이(가) 입맛을 다십니다.',
                '{name}이(가) 배를 움켜쥐고 있습니다.'
            ],
            // 낮잠 (조명 켜짐)
            napLight: [
                '{name}이(가) 낮잠을 자고 있습니다.',
                '{name}이(가) 햇살 아래에서 졸고 있습니다.',
                '{name}이(가) 편안하게 눈을 감고 있습니다.',
                '{name}이(가) 스르륵 잠이 들었습니다.',
                '{name}이(가) 나뭇잎 위에서 낮잠을 즐깁니다.'
            ],
            // 밤잠 (조명 꺼짐)
            sleepDark: [
                '{name}이(가) 잠을 자고 있습니다.',
                '{name}이(가) 깊은 잠에 빠졌습니다.',
                '{name}이(가) 고요히 잠들어 있습니다.',
                '{name}이(가) 어둠 속에서 편히 쉬고 있습니다.',
                '{name}이(가) 조용히 꿈나라로 떠났습니다.'
            ],
            // 애정도 낮음 (0-10)
            affectionVeryLow: [
                '{name}이(가) 당신을 피해 테라리움 구석에 숨습니다.',
                '{name}이(가) 당신을 경계하며 멀리 떨어집니다.',
                '{name}이(가) 고개를 돌려 당신을 외면합니다.',
                '{name}이(가) 불안한 듯 몸을 떨고 있습니다.',
                '{name}이(가) 당신 앞에서 움츠러듭니다.'
            ],
            // 애정도 낮음 (10-30)
            affectionLow: [
                '{name}이(가) 당신을 빤히 바라봅니다.',
                '{name}이(가) 조심스럽게 당신을 관찰합니다.',
                '{name}이(가) 살짝 당신에게 다가옵니다.',
                '{name}이(가) 당신에게 관심을 보이기 시작합니다.',
                '{name}이(가) 호기심 어린 눈으로 당신을 봅니다.'
            ],
            // 애정도 중간 (30-50)
            affectionMedium: [
                '{name}이(가) 당신의 손에 뺨을 부빕니다.',
                '{name}이(가) 당신 주변을 빙글빙글 돕니다.',
                '{name}이(가) 당신의 손가락을 살짝 건드립니다.',
                '{name}이(가) 당신에게 애교를 부립니다.',
                '{name}이(가) 당신 곁에 가까이 다가옵니다.'
            ],
            // 애정도 높음 (50-100)
            affectionHigh: [
                '{name}이(가) 당신을 보며 행복해합니다.',
                '{name}이(가) 당신의 손바닥에서 뒹굽니다.',
                '{name}이(가) 당신에게 애정 어린 눈빛을 보냅니다.',
                '{name}이(가) 당신의 손을 꼭 붙잡습니다.',
                '{name}이(가) 당신과 함께 있어 즐거워 보입니다.'
            ],
            // 애정도 매우 높음 (100+)
            affectionVeryHigh: [
                '{name}이(가) 당신을 깊이 신뢰하고 있습니다.',
                '{name}이(가) 당신의 품에 파고듭니다.',
                '{name}이(가) 당신을 향한 사랑을 표현합니다.',
                '{name}이(가) 당신의 손에 입맞춤합니다.',
                '{name}이(가) 당신 없이는 못 산다는 듯 쳐다봅니다.'
            ],
            // 음악 관련 (최근에 음악 들음)
            music: [
                '{name}이(가) {music}을(를) 흥얼거립니다.',
                '{name}이(가) {music}에 맞춰 춤을 춥니다.',
                '{name}이(가) {music}의 선율을 떠올립니다.',
                '{name}이(가) 음악에 취해 있습니다.',
                '{name}이(가) {music}의 여운에 젖어 있습니다.'
            ],
            // 장식물 관련 (30개 전체)
            decorations: {
                // 불 속성
                fire_common1: [
                    '{name}이(가) 용암석에서 흐르는 열기를 바라봅니다.',
                    '{name}이(가) 용암석의 불을 신기하게 쳐다봅니다.',
                    '{name}이(가) 뜨거운 용암석 근처에서 따뜻함을 느낍니다.'
                ],
                fire_common2: [
                    '{name}이(가) 화산재를 톡톡 건드립니다.',
                    '{name}이(가) 화산재의 향을 맡고 있습니다.',
                    '{name}이(가) 화산재 더미 옆에서 놀고 있습니다.'
                ],
                fire_rare1: [
                    '{name}이(가) 불꽃 조각상을 경외하며 바라봅니다.',
                    '{name}이(가) 불꽃 조각상의 아름다움에 매료되어 있습니다.',
                    '{name}이(가) 불꽃 조각상 주변을 빙글빙글 돕니다.'
                ],
                fire_rare2: [
                    '{name}이(가) 타오르는 램프의 불빛을 구경합니다.',
                    '{name}이(가) 램프 불빛에 그림자를 드리웁니다.',
                    '{name}이(가) 램프의 따뜻한 빛을 즐깁니다.'
                ],
                fire_epic: [
                    '{name}이(가) 불사조 깃털의 신비로운 기운을 느낍니다.',
                    '{name}이(가) 불사조 깃털이 내뿜는 불꽃에 감탄합니다.',
                    '{name}이(가) 불사조 깃털 앞에서 경건해집니다.'
                ],
                
                // 물 속성
                water_common1: [
                    '{name}이(가) 분수의 물줄기를 구경합니다.',
                    '{name}이(가) 분수 물소리에 귀를 기울입니다.',
                    '{name}이(가) 분수에서 튀는 물방울과 놀고 있습니다.'
                ],
                water_common2: [
                    '{name}이(가) 조약돌을 톡톡 두드립니다.',
                    '{name}이(가) 매끈한 조약돌을 굴리고 있습니다.',
                    '{name}이(가) 조약돌 위에서 쉬고 있습니다.'
                ],
                water_rare1: [
                    '{name}이(가) 산호 장식의 색깔에 감탄합니다.',
                    '{name}이(가) 산호 사이를 헤엄치듯 움직입니다.',
                    '{name}이(가) 산호의 신비로운 모습을 관찰합니다.'
                ],
                water_rare2: [
                    '{name}이(가) 물방울 구슬에 자신의 모습을 비춰봅니다.',
                    '{name}이(가) 구슬 속 물방울을 신기하게 쳐다봅니다.',
                    '{name}이(가) 물방울 구슬을 굴리며 놀고 있습니다.'
                ],
                water_epic: [
                    '{name}이(가) 인어의 눈물이 빛나는 모습에 넋을 잃습니다.',
                    '{name}이(가) 인어의 눈물에서 나오는 물의 기운을 느낍니다.',
                    '{name}이(가) 인어의 눈물 앞에서 경건해집니다.'
                ],
                
                // 바람 속성
                wind_common1: [
                    '{name}이(가) 바람개비를 신기하게 바라봅니다.',
                    '{name}이(가) 바람개비가 도는 모습에 감탄합니다.',
                    '{name}이(가) 바람개비와 함께 빙글빙글 돕니다.'
                ],
                wind_common2: [
                    '{name}이(가) 부드러운 깃털을 살짝 만집니다.',
                    '{name}이(가) 깃털이 흔들리는 모습을 구경합니다.',
                    '{name}이(가) 깃털 위에서 가볍게 뛰어놉니다.'
                ],
                wind_rare1: [
                    '{name}이(가) 풍경 소리에 귀를 기울입니다.',
                    '{name}이(가) 풍경이 울리는 소리를 즐깁니다.',
                    '{name}이(가) 풍경과 함께 리듬을 타고 있습니다.'
                ],
                wind_rare2: [
                    '{name}이(가) 나비 표본을 부러운 듯 바라봅니다.',
                    '{name}이(가) 나비 표본의 아름다운 날개를 감상합니다.',
                    '{name}이(가) 나비 표본 앞에서 날개를 펄럭입니다.'
                ],
                wind_epic: [
                    '{name}이(가) 하늘의 깃털에서 나오는 바람을 느낍니다.',
                    '{name}이(가) 하늘의 깃털이 빛나는 모습에 감탄합니다.',
                    '{name}이(가) 하늘의 깃털 앞에서 경건해집니다.'
                ],
                
                // 땅 속성
                earth_common1: [
                    '{name}이(가) 화분의 흙냄새를 맡고 있습니다.',
                    '{name}이(가) 화분 속 식물을 살펴봅니다.',
                    '{name}이(가) 화분 주변을 기어다닙니다.'
                ],
                earth_common2: [
                    '{name}이(가) 이끼돌의 촉촉한 표면을 만집니다.',
                    '{name}이(가) 이끼 사이를 탐험하고 있습니다.',
                    '{name}이(가) 이끼돌에서 자연의 기운을 느낍니다.'
                ],
                earth_rare1: [
                    '{name}이(가) 나무 조각의 나이테를 세어봅니다.',
                    '{name}이(가) 나무 조각의 질감을 즐깁니다.',
                    '{name}이(가) 나무 조각 위를 오르내리고 있습니다.'
                ],
                earth_rare2: [
                    '{name}이(가) 버섯 군락을 신기하게 쳐다봅니다.',
                    '{name}이(가) 버섯 사이를 헤집고 다닙니다.',
                    '{name}이(가) 버섯의 포자 향을 맡고 있습니다.'
                ],
                earth_epic: [
                    '{name}이(가) 세계수 가지의 생명력을 느낍니다.',
                    '{name}이(가) 세계수 가지에서 나오는 고대의 기운에 압도됩니다.',
                    '{name}이(가) 세계수 가지 앞에서 경건해집니다.'
                ],
                
                // 빛 속성
                light_common1: [
                    '{name}이(가) 수정에 자신의 얼굴을 비춰봅니다.',
                    '{name}이(가) 빛나는 수정을 구경합니다.',
                    '{name}이(가) 수정이 반사하는 무지개를 쫓아갑니다.'
                ],
                light_common2: [
                    '{name}이(가) 반짝이 가루를 톡톡 건드립니다.',
                    '{name}이(가) 반짝이는 가루에 뒹굽니다.',
                    '{name}이(가) 반짝이 가루가 빛나는 모습을 즐깁니다.'
                ],
                light_rare1: [
                    '{name}이(가) 빛나는 보석의 광채에 넋을 잃습니다.',
                    '{name}이(가) 보석이 만들어내는 빛의 향연을 감상합니다.',
                    '{name}이(가) 보석 옆에서 함께 빛나고 있습니다.'
                ],
                light_rare2: [
                    '{name}이(가) 태양석의 따뜻한 빛을 쬡니다.',
                    '{name}이(가) 태양석 앞에서 날개를 펼칩니다.',
                    '{name}이(가) 태양석의 광채를 온몸으로 받고 있습니다.'
                ],
                light_epic: [
                    '{name}이(가) 별의 파편이 빛나는 모습에 경외합니다.',
                    '{name}이(가) 별의 파편에서 나오는 우주의 기운을 느낍니다.',
                    '{name}이(가) 별의 파편 앞에서 경건해집니다.'
                ],
                
                // 어둠 속성
                dark_common1: [
                    '{name}이(가) 흑요석의 깊은 어둠에 빠져듭니다.',
                    '{name}이(가) 흑요석의 매끈한 표면을 쓰다듬습니다.',
                    '{name}이(가) 흑요석 옆에서 조용히 명상합니다.'
                ],
                dark_common2: [
                    '{name}이(가) 검은 모래를 파헤치고 있습니다.',
                    '{name}이(가) 검은 모래 위에 그림을 그립니다.',
                    '{name}이(가) 검은 모래의 감촉을 즐깁니다.'
                ],
                dark_rare1: [
                    '{name}이(가) 달빛석을 조용히 바라봅니다.',
                    '{name}이(가) 달빛석의 은은한 빛에 잠깁니다.',
                    '{name}이(가) 달빛석과 함께 밤의 기운을 느낍니다.'
                ],
                dark_rare2: [
                    '{name}이(가) 그림자 수정 속을 들여다봅니다.',
                    '{name}이(가) 그림자 수정의 신비로운 모습에 매료됩니다.',
                    '{name}이(가) 그림자 수정이 만들어내는 어둠을 즐깁니다.'
                ],
                dark_epic: [
                    '{name}이(가) 밤의 정수에서 나오는 어둠의 힘을 느낍니다.',
                    '{name}이(가) 밤의 정수가 품은 신비에 압도됩니다.',
                    '{name}이(가) 밤의 정수 앞에서 경건해집니다.'
                ]
            },
            // 정령 간 상호작용
            interaction: {
                decoration: [
                    '{name1}과(와) {name2}이(가) 함께 {deco}을(를) 구경합니다.',
                    '{name1}이(가) {name2}에게 {deco}을(를) 보여줍니다.',
                    '{name1}과(와) {name2}이(가) {deco} 주위를 빙글빙글 돕니다.',
                    '{name1}과(와) {name2}이(가) {deco} 옆에서 함께 쉬고 있습니다.',
                    '{name1}이(가) {name2}와(과) {deco}을(를) 함께 즐기고 있습니다.'
                ],
                sharing: [
                    '{name1}이(가) {name2}에게 먹이를 나눠줍니다.',
                    '{name1}이(가) {name2}와(과) 먹이를 함께 먹습니다.',
                    '{name1}과(와) {name2}이(가) 서로의 먹이를 나누고 있습니다.'
                ],
                fight: [
                    '{name1}과(와) {name2}이(가) 서로를 깨뭅니다.',
                    '{name1}이(가) {name2}와(과) 장난스럽게 싸웁니다.',
                    '{name1}과(와) {name2}이(가) 으르렁거리며 대치합니다.',
                    '{name1}이(가) {name2}를(을) 쫓아다닙니다.'
                ],
                rest: [
                    '{name1}과(와) {name2}이(가) 서로에게 기대어 잠이 듭니다.',
                    '{name1}이(가) {name2} 옆에서 편안히 쉬고 있습니다.',
                    '{name1}과(와) {name2}이(가) 나란히 낮잠을 자고 있습니다.',
                    '{name1}이(가) {name2}를(을) 베개 삼아 잠들었습니다.',
                    '{name1}과(와) {name2}이(가) 함께 꿈나라로 떠났습니다.'
                ],
                song: [
                    '{name1}이(가) {name2}에게 자신이 좋아하는 노래를 불러줍니다.',
                    '{name1}과(와) {name2}이(가) 함께 노래를 부릅니다.',
                    '{name1}이(가) {name2}를(을) 위해 음악을 연주합니다.',
                    '{name1}이(가) {name2}와(과) 함께 춤을 춥니다.'
                ],
                play: [
                    '{name1}과(와) {name2}이(가) 숨바꼭질을 하고 있습니다.',
                    '{name1}이(가) {name2}와(과) 술래잡기를 즐깁니다.',
                    '{name1}과(와) {name2}이(가) 재미있게 놀고 있습니다.',
                    '{name1}이(가) {name2}를(을) 간지럽힙니다.',
                    '{name1}과(와) {name2}이(가) 함께 웃고 떠들고 있습니다.'
                ],
                talk: [
                    '{name1}과(와) {name2}이(가) 수다를 떨고 있습니다.',
                    '{name1}이(가) {name2}에게 무언가 이야기하고 있습니다.',
                    '{name1}과(와) {name2}이(가) 즐겁게 대화를 나눕니다.',
                    '{name1}이(가) {name2}의 이야기를 경청하고 있습니다.'
                ]
            }
        };

        const STAGE_REQUIREMENTS = {
            egg: 0,
            larva1: 10,
            larva2: 25,
            larva3: 45,
            pupa: 70,
            adult: 100
        };

        const STAGE_ICONS = {
            egg: '🥚',
            larva1: '🐛',
            larva2: '🐛',
            larva3: '🐛',
            pupa: '🦋',
            adult: '🦋'
        };

        const STAGE_NAMES = {
            egg: '알',
            larva1: '애벌레 I',
            larva2: '애벌레 II',
            larva3: '애벌레 III',
            pupa: '번데기',
            adult: '성충'
        };
        
        // 성장 단계별 속성 외형 묘사
        const APPEARANCE_DESCRIPTIONS = {
            egg: {
                fire: '껍질이 따뜻하고 미세한 열기가 느껴집니다.',
                water: '촉촉하고 투명한 광택이 흐릅니다.',
                wind: '껍질이 부드럽고 가볍습니다.',
                earth: '단단하고 거친 질감이 있습니다.',
                light: '은은한 빛이 내부에서 비칩니다.',
                dark: '짙은 색으로 깊이를 알 수 없습니다.',
                normal: '평범한 흰색 알입니다.'
            },
            larva1: {
                fire: '몸이 붉게 물들고 따뜻한 기운이 느껴집니다.',
                water: '촉촉한 피부에서 물방울이 맺힙니다.',
                wind: '몸이 가볍고 바람에 흔들립니다.',
                earth: '단단한 갈색 피부로 덮여있습니다.',
                light: '온몸에서 은은한 빛이 납니다.',
                dark: '어두운 보라빛 몸을 하고 있습니다.',
                normal: '투명한 초록빛 몸을 하고 있습니다.'
            },
            larva2: {
                fire: '외견이 붉고, 만졌을 때 따뜻하며 머리카락이 불꽃처럼 일렁입니다.',
                water: '푸른빛이 도는 몸에서 시원한 기운이 나며, 몸 표면에 물결 무늬가 있습니다.',
                wind: '연한 하늘색 몸에 깃털 같은 솜털이 돋아있고, 공중에 둥둥 떠오릅니다.',
                earth: '갈색빛 몸에 작은 이끼가 자라고, 만지면 흙 냄새가 납니다.',
                light: '금빛으로 빛나는 몸에서 따뜻한 빛이 발산되며, 주변을 밝힙니다.',
                dark: '깊은 남색 몸에 별빛 같은 반점이 있고, 주변의 빛을 흡수합니다.',
                normal: '투명한 몸에 무지개빛이 은은하게 감돕니다.'
            },
            larva3: {
                fire: '온몸이 주황빛 불꽃으로 감싸여 있고, 숨을 쉴 때마다 작은 불똥이 튑니다.',
                water: '깊은 청록색 몸에서 작은 물줄기가 흘러내리고, 주변 공기가 축축합니다.',
                wind: '은빛 날개 비늘이 돋아나고, 움직일 때마다 바람이 일어납니다.',
                earth: '단단한 나무껍질 같은 외피에 작은 꽃봉오리가 피어있습니다.',
                light: '눈부신 황금빛으로 빛나며, 주변에 무지개 후광이 보입니다.',
                dark: '칠흑 같은 몸에 은하수 같은 빛의 띠가 흐르고, 그림자가 춤춥니다.',
                normal: '맑고 투명한 몸에 모든 색이 은은하게 어우러집니다.'
            },
            pupa: {
                fire: '붉은 수정 같은 번데기에서 열기가 피어오르고, 내부에 불꽃이 춤춥니다.',
                water: '푸른 얼음 같은 번데기 속에서 물결이 일렁이며 변화가 일어납니다.',
                wind: '하얀 구름 같은 번데기가 공중에 떠있고, 바람에 맞춰 회전합니다.',
                earth: '나무 옹이 같은 번데기에서 새순이 돋아나고 있습니다.',
                light: '빛나는 크리스탈 번데기에서 무지개빛이 퍼져나옵니다.',
                dark: '검은 보석 같은 번데기에서 신비로운 별빛이 깜빡입니다.',
                normal: '순백의 번데기가 조용히 변화를 준비하고 있습니다.'
            }
        };

        const PARAM_ICONS = {
            intelligence: '🧠',
            strength: '💪',
            charm: '💖',
            affection: '❤️'
        };

        const ENV_ICONS = {
            fire: '🔥',
            water: '💧',
            wind: '🌬️',
            earth: '🌱',
            light: '✨',
            dark: '🌙'
        };

        const MUSIC_TYPES = {
            classic: { name: '클래식 🎻', icon: '🎻', effect: '지력 +10' },
            jazz: { name: '재즈 🎷', icon: '🎷', effect: '매력 +10' },
            rock: { name: '록 🎸', icon: '🎸', effect: '체력 +10' },
            pop: { name: '팝 🎤', icon: '🎤', effect: '지력 +5, 매력 +5' },
            ballad: { name: '발라드 🎹', icon: '🎹', effect: '체력 +5, 매력 +5' }
        };

        const DECORATION_TYPES = {
            // 불 속성 (5개)
            fire_common1: { name: '용암석', icon: '🔥', attr: 'fire', power: 1, quality: 'common', price: 30 },
            fire_common2: { name: '화산재', icon: '🌋', attr: 'fire', power: 1, quality: 'common', price: 30 },
            fire_rare1: { name: '불꽃 조각상', icon: '🔆', attr: 'fire', power: 2, quality: 'rare', price: 60 },
            fire_rare2: { name: '타오르는 램프', icon: '🏮', attr: 'fire', power: 2, quality: 'rare', price: 60 },
            fire_epic: { name: '불사조 깃털', icon: '🦅', attr: 'fire', power: 3, quality: 'epic', price: 100 },
            
            // 물 속성 (5개)
            water_common1: { name: '분수', icon: '💧', attr: 'water', power: 1, quality: 'common', price: 30 },
            water_common2: { name: '조약돌', icon: '🪨', attr: 'water', power: 1, quality: 'common', price: 30 },
            water_rare1: { name: '산호 장식', icon: '🪸', attr: 'water', power: 2, quality: 'rare', price: 60 },
            water_rare2: { name: '물방울 구슬', icon: '💎', attr: 'water', power: 2, quality: 'rare', price: 60 },
            water_epic: { name: '인어의 눈물', icon: '🧜', attr: 'water', power: 3, quality: 'epic', price: 100 },
            
            // 바람 속성 (5개)
            wind_common1: { name: '바람개비', icon: '🌬️', attr: 'wind', power: 1, quality: 'common', price: 30 },
            wind_common2: { name: '부드러운 깃털', icon: '🪶', attr: 'wind', power: 1, quality: 'common', price: 30 },
            wind_rare1: { name: '풍경', icon: '🎐', attr: 'wind', power: 2, quality: 'rare', price: 60 },
            wind_rare2: { name: '나비 표본', icon: '🦋', attr: 'wind', power: 2, quality: 'rare', price: 60 },
            wind_epic: { name: '하늘의 깃털', icon: '☁️', attr: 'wind', power: 3, quality: 'epic', price: 100 },
            
            // 땅 속성 (5개)
            earth_common1: { name: '화분', icon: '🌱', attr: 'earth', power: 1, quality: 'common', price: 30 },
            earth_common2: { name: '이끼돌', icon: '🪵', attr: 'earth', power: 1, quality: 'common', price: 30 },
            earth_rare1: { name: '나무 조각', icon: '🌳', attr: 'earth', power: 2, quality: 'rare', price: 60 },
            earth_rare2: { name: '버섯 군락', icon: '🍄', attr: 'earth', power: 2, quality: 'rare', price: 60 },
            earth_epic: { name: '세계수 가지', icon: '🌲', attr: 'earth', power: 3, quality: 'epic', price: 100 },
            
            // 빛 속성 (5개)
            light_common1: { name: '수정', icon: '✨', attr: 'light', power: 1, quality: 'common', price: 30 },
            light_common2: { name: '반짝이 가루', icon: '⭐', attr: 'light', power: 1, quality: 'common', price: 30 },
            light_rare1: { name: '빛나는 보석', icon: '💠', attr: 'light', power: 2, quality: 'rare', price: 60 },
            light_rare2: { name: '태양석', icon: '☀️', attr: 'light', power: 2, quality: 'rare', price: 60 },
            light_epic: { name: '별의 파편', icon: '🌟', attr: 'light', power: 3, quality: 'epic', price: 100 },
            
            // 어둠 속성 (5개)
            dark_common1: { name: '흑요석', icon: '🌙', attr: 'dark', power: 1, quality: 'common', price: 30 },
            dark_common2: { name: '검은 모래', icon: '🖤', attr: 'dark', power: 1, quality: 'common', price: 30 },
            dark_rare1: { name: '달빛석', icon: '🌑', attr: 'dark', power: 2, quality: 'rare', price: 60 },
            dark_rare2: { name: '그림자 수정', icon: '🔮', attr: 'dark', power: 2, quality: 'rare', price: 60 },
            dark_epic: { name: '밤의 정수', icon: '🌌', attr: 'dark', power: 3, quality: 'epic', price: 100 }
        };

        const FOOD_NAMES = {
            fire: '불꽃열매',
            water: '맑은이슬',
            wind: '바람꿀',
            earth: '대지버섯',
            light: '빛나는 넥타',
            dark: '검은 꽃가루'
        };
        
        // 약초 아이템
        const MEDICINE = {
            name: '만병통치 약초',
            icon: '🌿',
            price: 50,
            description: '정령의 질병을 치료합니다'
        };



        // 도감 힌트 데이터
        const ENCYCLOPEDIA_HINTS = {
            // 전설
            'titania': '나비를 거느리는 정령들의 군주.',
            'oberon': '나방을 거느리는 정령들의 군주.',
            
            // 백의 정령
            'nostat-normal': '순수한 백색. 아무 속성도 깃들지 않은 정령.',
            'intelligent-low-normal': '지혜롭지만 순수한 정령.',
            'intelligent-mid-normal': '지적이며 순수한 정령.',
            'intelligent-high-normal': '세상의 지혜를 담은 순수한 정령.',
            'strong-low-normal': '튼튼하지만 순수한 정령.',
            'strong-mid-normal': '강하며 순수한 정령.',
            'strong-high-normal': '세상의 힘을 담은 순수한 정령.',
            'beautiful-low-normal': '귀엽고 순수한 정령.',
            'beautiful-mid-normal': '아름답고 순수한 정령.',
            'beautiful-high-normal': '세상의 아름다움을 담은 순수한 정령.',
            
            // 불 속성
            'nostat-fire': '불의 기운이 느껴지는 정령.',
            'intelligent-low-fire': '똑똑한 불의 정령.',
            'intelligent-mid-fire': '지적인 불의 정령.',
            'intelligent-high-fire': '세상의 불을 다스리는 지혜로운 정령.',
            'strong-low-fire': '튼튼한 불의 정령.',
            'strong-mid-fire': '강한 불의 정령.',
            'strong-high-fire': '세상의 불을 다스리는 강인한 정령.',
            'beautiful-low-fire': '귀여운 불의 정령.',
            'beautiful-mid-fire': '아름다운 불의 정령.',
            'beautiful-high-fire': '세상의 불을 다스리는 매혹적인 정령.',
            
            // 물 속성
            'nostat-water': '물의 기운이 느껴지는 정령.',
            'intelligent-low-water': '똑똑한 물의 정령.',
            'intelligent-mid-water': '지적인 물의 정령.',
            'intelligent-high-water': '세상의 물을 다스리는 지혜로운 정령.',
            'strong-low-water': '튼튼한 물의 정령.',
            'strong-mid-water': '강한 물의 정령.',
            'strong-high-water': '세상의 물을 다스리는 강인한 정령.',
            'beautiful-low-water': '귀여운 물의 정령.',
            'beautiful-mid-water': '아름다운 물의 정령.',
            'beautiful-high-water': '세상의 물을 다스리는 매혹적인 정령.',
            
            // 바람 속성
            'nostat-wind': '바람의 기운이 느껴지는 정령.',
            'intelligent-low-wind': '똑똑한 바람의 정령.',
            'intelligent-mid-wind': '지적인 바람의 정령.',
            'intelligent-high-wind': '세상의 바람을 다스리는 지혜로운 정령.',
            'strong-low-wind': '튼튼한 바람의 정령.',
            'strong-mid-wind': '강한 바람의 정령.',
            'strong-high-wind': '세상의 바람을 다스리는 강인한 정령.',
            'beautiful-low-wind': '귀여운 바람의 정령.',
            'beautiful-mid-wind': '아름다운 바람의 정령.',
            'beautiful-high-wind': '세상의 바람을 다스리는 매혹적인 정령.',
            
            // 땅 속성
            'nostat-earth': '땅의 기운이 느껴지는 정령.',
            'intelligent-low-earth': '똑똑한 땅의 정령.',
            'intelligent-mid-earth': '지적인 땅의 정령.',
            'intelligent-high-earth': '세상의 땅을 다스리는 지혜로운 정령.',
            'strong-low-earth': '튼튼한 땅의 정령.',
            'strong-mid-earth': '강한 땅의 정령.',
            'strong-high-earth': '세상의 땅을 다스리는 강인한 정령.',
            'beautiful-low-earth': '귀여운 땅의 정령.',
            'beautiful-mid-earth': '아름다운 땅의 정령.',
            'beautiful-high-earth': '세상의 땅을 다스리는 매혹적인 정령.',
            
            // 빛 속성
            'nostat-light': '빛의 기운이 강하게 느껴지는 정령.',
            'intelligent-low-light': '똑똑한 빛의 정령.',
            'intelligent-mid-light': '지적인 빛의 정령.',
            'intelligent-high-light': '세상의 빛을 다스리는 지혜로운 정령.',
            'strong-low-light': '튼튼한 빛의 정령.',
            'strong-mid-light': '강한 빛의 정령.',
            'strong-high-light': '세상의 빛을 다스리는 강인한 정령.',
            'beautiful-low-light': '귀여운 빛의 정령.',
            'beautiful-mid-light': '아름다운 빛의 정령.',
            'beautiful-high-light': '세상의 빛을 다스리는 매혹적인 정령.',
            
            // 어둠 속성
            'nostat-dark': '어둠의 기운이 강하게 느껴지는 정령.',
            'intelligent-low-dark': '똑똑한 어둠의 정령.',
            'intelligent-mid-dark': '지적인 어둠의 정령.',
            'intelligent-high-dark': '세상의 어둠을 다스리는 지혜로운 정령.',
            'strong-low-dark': '튼튼한 어둠의 정령.',
            'strong-mid-dark': '강한 어둠의 정령.',
            'strong-high-dark': '세상의 어둠을 다스리는 강인한 정령.',
            'beautiful-low-dark': '귀여운 어둠의 정령.',
            'beautiful-mid-dark': '아름다운 어둠의 정령.',
            'beautiful-high-dark': '세상의 어둠을 다스리는 매혹적인 정령.',
            
            // 복합 속성 (간략하게)
            'nostat-fire-water': '불과 물의 기운이 느껴지는 정령.',
            'nostat-fire-wind': '불과 바람의 기운이 느껴지는 정령.',
            'nostat-fire-earth': '불과 땅의 기운이 느껴지는 정령.',
            'nostat-fire-light': '불과 빛의 기운이 느껴지는 정령.',
            'nostat-fire-dark': '불과 어둠의 기운이 느껴지는 정령.',
            'nostat-water-wind': '물과 바람의 기운이 느껴지는 정령.',
            'nostat-water-earth': '물과 땅의 기운이 느껴지는 정령.',
            'nostat-water-light': '물과 빛의 기운이 느껴지는 정령.',
            'nostat-water-dark': '물과 어둠의 기운이 느껴지는 정령.',
            'nostat-wind-earth': '바람과 땅의 기운이 느껴지는 정령.',
            'nostat-wind-light': '바람과 빛의 기운이 느껴지는 정령.',
            'nostat-wind-dark': '바람과 어둠의 기운이 느껴지는 정령.',
            'nostat-earth-light': '땅과 빛의 기운이 느껴지는 정령.',
            'nostat-earth-dark': '땅과 어둠의 기운이 느껴지는 정령.',
            'nostat-light-dark': '빛과 어둠이 공존하는 신비로운 정령.',
            'nostat-balanced': '모든 속성이 조화롭게 균형잡힌 정령.',
            'nostat-multi': '여러 속성이 뒤섞인 혼돈의 정령.'
        };

        // 상태 키워드 시스템
        function getStatusKeywords(spirit) {
            const keywords = [];
            const keywordColor = '#2a2a2a';  // 검정색 통일
            
            // 애정도 기반
            if (spirit.parameters.affection >= 100) {
                keywords.push({ text: '사랑이 가득한', color: keywordColor });
            } else if (spirit.parameters.affection >= 70) {
                keywords.push({ text: '애정 어린', color: keywordColor });
            } else if (spirit.parameters.affection <= 10) {
                keywords.push({ text: '경계하는', color: keywordColor });
            }
            
            // 질병 상태
            if (spirit.isSick) {
                keywords.push({ text: '질병에 걸린', color: keywordColor });
            }
            
            // 음악 청취 횟수 (musicListened 카운트)
            if (spirit.musicListened >= 10) {
                keywords.push({ text: '음악을 사랑하는', color: keywordColor });
            }
            
            // 스탯 기반
            if (spirit.parameters.intelligence >= 80) {
                keywords.push({ text: '현명한', color: keywordColor });
            }
            if (spirit.parameters.strength >= 80) {
                keywords.push({ text: '강인한', color: keywordColor });
            }
            if (spirit.parameters.charm >= 80) {
                keywords.push({ text: '매혹적인', color: keywordColor });
            }
            
            // 성장 단계 기반
            const stage = getStage(spirit.growth);
            if (stage === 'adult' && !spirit.isCompleted) {
                keywords.push({ text: '번데기가 된', color: keywordColor });
            }
            
            // 만족도 기반
            if (spirit.satisfaction === 'high') {
                keywords.push({ text: '행복한', color: keywordColor });
            } else if (spirit.satisfaction === 'low') {
                keywords.push({ text: '불만족스러운', color: keywordColor });
            }
            
            // 방치 시간 기반 (30분 이상)
            const timeSinceInteraction = Date.now() - (spirit.lastInteraction || Date.now());
            if (timeSinceInteraction > 30 * 60 * 1000) {
                keywords.push({ text: '외로운', color: keywordColor });
            }
            
            // 테라리움 환경과 속성 일치도
            const dominantAttr = getDominantAttribute(spirit);
            const terrariumEnv = Object.keys(terrarium).reduce((a, b) => 
                terrarium[a] > terrarium[b] ? a : b
            );
            if (dominantAttr === terrariumEnv && terrarium[terrariumEnv] >= 30) {
                keywords.push({ text: '환경에 적응한', color: keywordColor });
            }
            
            // 빛/어둠 시간 기반
            if (spirit.lightTime >= 10) {
                keywords.push({ text: '태양을 동경하는', color: keywordColor });
            }
            if (spirit.darkTime >= 10) {
                keywords.push({ text: '어둠을 좋아하는', color: keywordColor });
            }
            
            // 먹이 횟수 (feedCount 카운트)
            if (spirit.feedCount >= 20) {
                keywords.push({ text: '미식가', color: keywordColor });
            }
            
            return keywords;
        }

                // 상점 가격표
        const SHOP_PRICES = {
            // 판매 가격 (인벤토리 → 코인)
            sell: {
                food_common: 8,    // 일반 먹이 판매
                food_rare: 15,     // 희귀 먹이 판매
                decoration: 15,    // 장식물 1개 = 15코인
                music: 25          // 음악 1개 = 25코인
            },
            // 구매 가격 (코인 → 인벤토리)
            buy: {
                food_common: 20,   // 일반 먹이 (화수풍지)
                food_rare: 40,     // 희귀 먹이 (빛암)
                music: 80,         // 음악 레코드
                decoration: 50     // 장식물
            }
        };

        const EVOLUTION_TYPES = {
            // 노멀 (모든 스탭이 10 미만)
            normal: { name: '백의 정령', icon: '🤍', desc: '순수한 빛을 간직한 정령. 모든 정령의 시작이자 근원.' },
            
            // 지적인 계열 (intelligence 최고)
            'intelligent-low': { prefix: '똑똑한', icon: '✨' },
            'intelligent-mid': { prefix: '지적인', icon: '💎' },
            'intelligent-high': { prefix: '세상의 비밀을 아는', icon: '🔮' },
            
            // 강한 계열 (strength 최고)
            'strong-low': { prefix: '튼튼한', icon: '✨' },
            'strong-mid': { prefix: '강한', icon: '💪' },
            'strong-high': { prefix: '세상을 받치는', icon: '⚡' },
            
            // 아름다운 계열 (charm 최고)
            'beautiful-low': { prefix: '귀여운', icon: '✨' },
            'beautiful-mid': { prefix: '아름다운', icon: '🌸' },
            'beautiful-high': { prefix: '세상을 매혹하는', icon: '🌺' }
        };
        
        // 속성별 정령 이름
        const ATTRIBUTE_NAMES = {
            normal: { name: '백의 정령', icon: '⚪', desc: '순수한 백색의 빛을 지닌 정령.' },
            fire: { name: '화염의 정령', icon: '🔥', desc: '타오르는 열정을 간직한 화염의 정령.' },
            water: { name: '빙하의 정령', icon: '💧', desc: '차가운 지혜를 품은 물의 정령.' },
            wind: { name: '질풍의 정령', icon: '🌬️', desc: '자유로운 바람을 담은 질풍의 정령.' },
            earth: { name: '대지의 정령', icon: '🌱', desc: '견고한 대지의 힘을 지닌 정령.' },
            light: { name: '광명의 정령', icon: '✨', desc: '찬란한 빛으로 가득한 광명의 정령.' },
            dark: { name: '암흑의 정령', icon: '🌙', desc: '신비로운 어둠을 담은 암흑의 정령.' },
            
            // 2속성 조합
            'fire-water': { name: '증기의 정령', icon: '💨', desc: '불과 물이 만나 탄생한 증기의 정령.' },
            'fire-wind': { name: '폭풍의 정령', icon: '🌪️', desc: '불과 바람이 만든 뜨거운 폭풍의 정령.' },
            'fire-earth': { name: '용암의 정령', icon: '🌋', desc: '불과 대지가 빚어낸 용암의 정령.' },
            'fire-light': { name: '태양의 정령', icon: '☀️', desc: '불과 빛이 합쳐진 태양의 정령.' },
            'fire-dark': { name: '연기의 정령', icon: '💨', desc: '불과 어둠이 만든 연기의 정령.' },
            'water-wind': { name: '구름의 정령', icon: '☁️', desc: '물과 바람이 만든 구름의 정령.' },
            'water-earth': { name: '진흙의 정령', icon: '🪨', desc: '물과 대지가 섞인 진흙의 정령.' },
            'water-light': { name: '무지개의 정령', icon: '🌈', desc: '물과 빛이 만든 무지개의 정령.' },
            'water-dark': { name: '안개의 정령', icon: '🌫️', desc: '물과 어둠이 만든 안개의 정령.' },
            'wind-earth': { name: '모래의 정령', icon: '🏜️', desc: '바람과 대지가 만든 모래의 정령.' },
            'wind-light': { name: '오로라의 정령', icon: '🌌', desc: '바람과 빛이 만든 오로라의 정령.' },
            'wind-dark': { name: '회오리의 정령', icon: '🌀', desc: '바람과 어둠이 만든 회오리의 정령.' },
            'earth-light': { name: '수정의 정령', icon: '💎', desc: '대지와 빛이 만든 수정의 정령.' },
            'earth-dark': { name: '동굴의 정령', icon: '⛰️', desc: '대지와 어둠이 만든 동굴의 정령.' },
            'light-dark': { name: '환혹의 정령', icon: '✨🌙', desc: '빛과 어둠이 공존하는 환혹의 정령.' },
            
            // 3속성 이상 (복합)
            balanced: { name: '조화의 정령', icon: '⚖️', desc: '모든 속성이 조화롭게 균형 잡힌 정령.' },
            multi: { name: '혼돈의 정령', icon: '🌪️', desc: '여러 속성이 뒤섞인 혼돈의 정령.' }
        };

        function loadGame() {
            const saved = localStorage.getItem('spiritGardenV2');
            if (saved) {
                const data = JSON.parse(saved);
                spirits = data.spirits || [];
                collection = data.collection || [];
                encyclopedia = data.encyclopedia || {};
                
                // 기존 도감 데이터 호환성 처리 - 존재하지 않는 진화 타입 제거
                collection = collection.filter(item => {
                    return EVOLUTION_TYPES[item.type] !== undefined;
                });
                
                inventory = data.inventory || { 
                    music: [], 
                    decorations: [],
                    food: ['fire', 'fire', 'fire', 'water', 'water', 'water', 'wind', 'wind', 'wind', 'earth', 'earth', 'earth']
                };
                
                // 잘못된 음악 키 제거 (quest, lullaby 등 → classic, jazz 등)
                if (inventory.music) {
                    const validMusicKeys = ['classic', 'jazz', 'rock', 'pop', 'ballad'];
                    inventory.music = inventory.music.filter(m => validMusicKeys.includes(m));
                }
                
                // 기존 장식물 키를 새 형식으로 변환 (fire → fire_common1 등)
                const oldToNewDecoMapping = {
                    fire: 'fire_common1',
                    water: 'water_common1',
                    wind: 'wind_common1',
                    earth: 'earth_common1',
                    light: 'light_common1',
                    dark: 'dark_common1'
                };
                
                if (inventory.decorations) {
                    inventory.decorations = inventory.decorations.map(d => {
                        // 이미 새 형식이면 그대로, 아니면 변환
                        return oldToNewDecoMapping[d] || d;
                    });
                }
                
                if (installedDecorations) {
                    installedDecorations = installedDecorations.map(d => {
                        return oldToNewDecoMapping[d] || d;
                    });
                }
                
                terrarium = data.terrarium || {
                    fire: 0, water: 0, wind: 0, earth: 0, light: 0, dark: 0
                };
                installedDecorations = data.installedDecorations || [];
                
                // 기존 문자열 배열을 객체 배열로 변환 (하위 호환성)
                installedDecorations = installedDecorations.map((d, index) => {
                    if (typeof d === 'string') {
                        return { type: d, index: index };
                    }
                    return d;
                });
                
                lightMode = data.lightMode !== undefined ? data.lightMode : true;
                coins = data.coins || 0;
                lastGatherTime = data.lastGatherTime || null;
                currentTitle = data.currentTitle || 'none';
                isPaused = data.isPaused || false;
                darkModeLocked = data.darkModeLocked || false;

                // 칭호 UI 반영
                const titleSelect = document.getElementById('titleSelect');
                if (titleSelect) {
                    titleSelect.value = currentTitle;
                }
                
                // 일시정지 버튼 UI 반영
                const pauseBtn = document.getElementById('pauseBtn');
                if (pauseBtn && isPaused) {
                    pauseBtn.textContent = '▶️';
                    pauseBtn.classList.add('paused');
                    pauseBtn.title = '재개';
                }

                // 설치된 장식물로 환경 재계산
                if (installedDecorations.length > 0) {
                    recalculateTerrariumEnvironment();
                }
                
                // 기존 정령들의 만족도 초기화 (하위 호환성)
                spirits.forEach(spirit => {
                    if (!spirit.satisfaction) {
                        spirit.satisfaction = 'mid';
                    }
                });

                // 조명 상태 적용
                applyLightMode();
            }
        }

        function saveGame() {
            localStorage.setItem('spiritGardenV2', JSON.stringify({
                spirits,
                collection,
                encyclopedia,
                inventory,
                terrarium,
                installedDecorations,
                lightMode,
                coins,
                lastGatherTime,
                currentTitle,
                currentGatherLocation,
                isPaused,
                darkModeLocked
            }));
        }

        const EGG_NAMES = [
            '반짝이는 알', '매끈매끈한 알', '얼룩무늬 알', '보라색 알',
            '투명한 알', '황금빛 알', '은빛 알', '검은색 알',
            '하얀색 알', '무지개 알', '작은 알', '큰 알',
            '따뜻한 알', '차가운 알', '부드러운 알', '단단한 알'
        ];

        function addLog(spirit, message) {
            if (!spirit.logs) spirit.logs = [];
            const timestamp = new Date().toLocaleString('ko-KR', {
                month: '2-digit',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit'
            });
            spirit.logs.unshift({ time: timestamp, message }); // 최신이 위로
            if (spirit.logs.length > 50) spirit.logs.pop(); // 최대 50개 유지
            
            // 일지 추가 시에만 전체 렌더링
            renderSpirits();
        }

        function createNewSpirit() {
            if (spirits.length >= 6) {
                showNotification('정원이 가득 찼습니다 (최대 6마리)');
                return;
            }

            const randomName = EGG_NAMES[Math.floor(Math.random() * EGG_NAMES.length)];

            const spirit = {
                id: Date.now(),
                name: randomName,
                growth: 0,
                // 공개 스탯
                parameters: {
                    intelligence: 0,  // 지력
                    strength: 0,      // 체력
                    charm: 0,         // 매력
                    affection: 0      // 애정
                },
                // 숨겨진 속성 (진화 결정)
                hiddenAttributes: {
                    fire: 0,
                    water: 0,
                    wind: 0,
                    earth: 0,
                    light: 0,
                    dark: 0
                },
                satisfaction: 'mid',  // 만족도: 'high', 'mid', 'low'
                lastFed: null,
                lastMusic: null,
                lastPat: null,
                lastDecorate: null,
                lastInteraction: Date.now(),  // 마지막 상호작용 시간
                status: '배고파 보입니다...',
                birthTime: Date.now(),
                logs: [],  // 일지
                lightTime: 0,  // 빛 모드 누적 시간 (초)
                darkTime: 0,   // 어둠 모드 누적 시간 (초)
                musicListened: 0,  // 음악 청취 횟수
                feedCount: 0       // 먹이 횟수
            };

            spirits.push(spirit);
            saveGame();
            renderSpirits();
            showNotification(`${randomName}이(가) 태어났습니다! 🥚`);
        }


        function showAppearance(spiritId) {
            const spirit = spirits.find(s => s.id === spiritId);
            if (!spirit) return;
            
            const appearance = getAppearanceDescription(spirit);
            if (appearance) {
                showNotification(`${spirit.name}의 모습: ${appearance}`);
            } else {
                showNotification(`${spirit.name}의 모습을 자세히 볼 수 없습니다.`);
            }
        }

        function changeName(spiritId) {
            currentSpiritId = spiritId;
            const spirit = spirits.find(s => s.id === spiritId);
            document.getElementById('nameInput').value = spirit.name;
            document.getElementById('nameModal').classList.add('active');
            
            // 이름 변경 모드로 전환
            const confirmBtn = document.querySelector('#nameModal button');
            const originalHandler = confirmBtn.onclick;
            confirmBtn.onclick = function() {
                const newName = document.getElementById('nameInput').value.trim();
                if (!newName) {
                    showNotification('이름을 입력해주세요');
                    return;
                }
                spirit.name = newName;
                closeModal('nameModal');
                saveGame();
                updateSpiritCard(spirit);
                showNotification('이름을 변경했습니다');
                
                // 원래 함수로 복구
                confirmBtn.onclick = originalHandler;
            };
        }

        // 정령의 주요 속성 찾기
        function getDominantAttribute(spirit) {
            if (!spirit.hiddenAttributes) {
                return 'normal';
            }
            
            let maxAttr = 'normal';
            let maxValue = 0;
            
            for (let attr in spirit.hiddenAttributes) {
                if (spirit.hiddenAttributes[attr] > maxValue) {
                    maxValue = spirit.hiddenAttributes[attr];
                    maxAttr = attr;
                }
            }
            
            // 속성값이 60 미만이면 normal (100에서 60으로 낮춤)
            if (maxValue < 60) {
                return 'normal';
            }
            
            return maxAttr;
        }

                function getStage(growth) {
            if (growth >= STAGE_REQUIREMENTS.adult) return 'adult';
            if (growth >= STAGE_REQUIREMENTS.pupa) return 'pupa';
            if (growth >= STAGE_REQUIREMENTS.larva3) return 'larva3';
            if (growth >= STAGE_REQUIREMENTS.larva2) return 'larva2';
            if (growth >= STAGE_REQUIREMENTS.larva1) return 'larva1';
            return 'egg';
        }
        
        // 현재 속성에 따른 외형 묘사 가져오기
        function getAppearanceDescription(spirit) {
            const stage = getStage(spirit.growth);
            
            // 성충이면 외형 묘사 없음
            if (stage === 'adult') return null;
            
            // 알 ~ 번데기만 외형 묘사 있음
            if (!APPEARANCE_DESCRIPTIONS[stage]) return null;
            
            // 현재 속성 계산 (먹이 + 테라리움)
            const foodAttrs = spirit.hiddenAttributes || { fire: 0, water: 0, wind: 0, earth: 0, light: 0, dark: 0 };
            const finalAttrs = {};
            for (let attr in foodAttrs) {
                finalAttrs[attr] = (foodAttrs[attr] * 0.5) + (terrarium[attr] * 0.5);
            }
            
            // 가장 높은 속성 찾기
            let maxAttr = 'normal';
            let maxValue = 0;
            for (let attr in finalAttrs) {
                if (finalAttrs[attr] > maxValue) {
                    maxValue = finalAttrs[attr];
                    maxAttr = attr;
                }
            }
            
            // 속성이 10 미만이면 normal
            if (maxValue < 10) {
                maxAttr = 'normal';
            }
            
            return APPEARANCE_DESCRIPTIONS[stage][maxAttr] || '평범한 모습입니다.';
        }
        
        // 품질 등급을 점수로 변환
        function getQualityScore(quality) {
            const qualityScores = {
                'common': 1,   // 낮음
                'rare': 3,     // 보통
                'epic': 5      // 높음
            };
            return qualityScores[quality] || 1;
        }
        
        // 테라리움 전체 품질 계산
        function calculateTerrariumQuality() {
            if (installedDecorations.length === 0) return 0;
            
            let totalQuality = 0;
            installedDecorations.forEach(deco => {
                // 문자열 또는 객체 모두 지원
                const key = typeof deco === 'string' ? deco : deco.type;
                const decoData = DECORATION_TYPES[key];
                if (decoData) {
                    totalQuality += getQualityScore(decoData.quality);
                }
            });
            
            // 평균 품질 반환 (소수점 1자리)
            return Math.round((totalQuality / installedDecorations.length) * 10) / 10;
        }
        
        // 만족도 계산 함수
        function calculateSatisfaction(spirit) {
            const stage = getStage(spirit.growth);
            
            // 죽었거나 완성된 정령은 만족도 계산 안 함
            if (spirit.isDead || spirit.isCompleted) return spirit.satisfaction || 'mid';
            
            // 장식물이 없으면 낮음
            if (installedDecorations.length === 0) return 'low';
            
            // 테라리움 전체 품질
            const avgQuality = calculateTerrariumQuality();
            
            // 알 ~ 애벌레1: 품질만 확인
            if (stage === 'egg' || stage === 'larva1') {
                // 품질 평균이 3(보통)을 초과하면 만족
                if (avgQuality > 3) return 'high';
                else if (avgQuality >= 2) return 'mid';
                else return 'low';
            }
            // 애벌레2, 애벌레3, 번데기: 품질 + 속성 유사도 (난이도 완화)
            else {
                // 정령의 현재 속성 계산
                const foodAttrs = spirit.hiddenAttributes || { fire: 0, water: 0, wind: 0, earth: 0, light: 0, dark: 0 };
                const spiritAttrs = {};
                for (let attr in foodAttrs) {
                    spiritAttrs[attr] = (foodAttrs[attr] * 0.5) + (terrarium[attr] * 0.5);
                }
                
                // 정령의 주 속성 찾기 (가장 높은 속성)
                let maxAttr = null;
                let maxValue = 0;
                for (let attr in spiritAttrs) {
                    if (spiritAttrs[attr] > maxValue) {
                        maxValue = spiritAttrs[attr];
                        maxAttr = attr;
                    }
                }
                
                // 속성이 10 미만이면 속성이 명확하지 않음
                if (maxValue < 10) {
                    // 품질만으로 판단 (완화)
                    if (avgQuality > 3.5) return 'high';
                    else if (avgQuality >= 2) return 'mid';
                    else return 'low';
                }
                
                // 테라리움의 주 속성과 정령의 주 속성 비교
                const terrariumMaxAttr = Object.entries(terrarium)
                    .sort((a, b) => b[1] - a[1])[0][0];
                
                // 속성 일치 확인 (완화: 정령 속성이 테라리움 상위 2개 안에 있으면 OK)
                const topTerrariumAttrs = Object.entries(terrarium)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 2)
                    .map(([attr]) => attr);
                
                if (topTerrariumAttrs.includes(maxAttr)) {
                    // 속성 일치 + 품질 적정 = 만족
                    return avgQuality >= 2.5 ? 'high' : 'mid';
                } else {
                    // 속성 불일치
                    if (avgQuality > 4) return 'mid';
                    else return 'low';
                }
            }
        }

        function getNextStageRequirement(growth) {
            const stage = getStage(growth);
            const stages = Object.keys(STAGE_REQUIREMENTS);
            const currentIndex = stages.indexOf(stage);
            if (currentIndex < stages.length - 1) {
                return STAGE_REQUIREMENTS[stages[currentIndex + 1]];
            }
            return STAGE_REQUIREMENTS.adult;
        }

        function canDoAction(spirit, action) {
            const now = Date.now();
            const cooldown = 10000; // 10초

            if (action === 'feed') {
                return !spirit.lastFeed || (now - spirit.lastFeed > cooldown);
            }
            if (action === 'music') {
                return !spirit.lastMusic || (now - spirit.lastMusic > cooldown);
            }
            if (action === 'pat') {
                return !spirit.lastPat || (now - spirit.lastPat > cooldown);
            }
            if (action === 'decorate') {
                return !spirit.lastDecorate || (now - spirit.lastDecorate > cooldown);
            }
            return false;
        }


        // 커스텀 확인 창 표시
        function showConfirm(title, message, onConfirm) {
            return new Promise((resolve) => {
                const modal = document.getElementById('confirmModal');
                const titleEl = document.getElementById('confirmTitle');
                const messageEl = document.getElementById('confirmMessage');
                const okBtn = document.getElementById('confirmOkBtn');
                const cancelBtn = document.getElementById('confirmCancelBtn');
                
                titleEl.textContent = title;
                messageEl.textContent = message;
                modal.classList.add('active');
                
                // 이전 이벤트 리스너 제거
                const newOkBtn = okBtn.cloneNode(true);
                const newCancelBtn = cancelBtn.cloneNode(true);
                okBtn.parentNode.replaceChild(newOkBtn, okBtn);
                cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);
                
                // 확인 버튼
                document.getElementById('confirmOkBtn').onclick = () => {
                    modal.classList.remove('active');
                    if (onConfirm) onConfirm();
                    resolve(true);
                };
                
                // 취소 버튼
                document.getElementById('confirmCancelBtn').onclick = () => {
                    modal.classList.remove('active');
                    resolve(false);
                };
            });
        }

        function openFeedModal(spiritId) {
            const spirit = spirits.find(s => s.id === spiritId);
            if (!canDoAction(spirit, 'feed')) {
                showNotification('아직 배가 부릅니다');
                return;
            }
            if (!inventory.food) inventory.food = [];
            if (inventory.food.length === 0) {
                showNotification('먹이가 없습니다. 채집을 해보세요!');
                return;
            }
            currentSpiritId = spiritId;
            renderFeedOptions();
            document.getElementById('feedModal').classList.add('active');
        }

        function renderFeedOptions() {
            if (!inventory.food) inventory.food = [];
            
            const modal = document.getElementById('feedModal');
            const spirit = spirits.find(s => s.id === currentSpiritId);
            
            const foodCounts = {};
            inventory.food.forEach(f => {
                foodCounts[f] = (foodCounts[f] || 0) + 1;
            });
            
            // medicine을 foodCounts에서 분리
            const medicineCount = foodCounts['medicine'] || 0;
            delete foodCounts['medicine'];
            
            let medicineSection = '';
            if (spirit && spirit.isSick && medicineCount > 0) {
                medicineSection = `
                    <button class="option-btn" onclick="giveMedicineFromModal(${currentSpiritId})">
                        <span class="option-icon">🌿</span>
                        <div class="option-info">
                            <div class="option-name">${MEDICINE.name} ×${medicineCount}</div>
                            <div class="option-effect">병을 완전히 치료합니다</div>
                        </div>
                    </button>
                `;
            } else if (spirit && spirit.isSick) {
                medicineSection = `
                    <div style="margin-bottom: 10px; padding: 10px; background: var(--card); border: 1px solid var(--border);">
                        <div style="font-size: 0.9rem; color: #666;">정령이 아픕니다! 약초가 필요합니다.</div>
                    </div>
                `;
            }

            const content = `
                <div class="modal-title">무엇을 먹일까요?</div>
                <div style="font-weight: 600; margin-bottom: 10px; color: var(--text);">🍎 먹이</div>
                <div class="food-grid">
                    ${medicineSection}
                    ${Object.entries(foodCounts).map(([type, count]) => {
                        const isRare = type === 'light' || type === 'dark';
                        const gain = isRare ? 2 : 1;
                        const growth = isRare ? 3 : 2;
                        return `
                            <button class="option-btn" onclick="feedSpiritFromInventory(${currentSpiritId}, '${type}')">
                                <span class="option-icon">${ENV_ICONS[type]}</span>
                                <div class="option-info">
                                    <div class="option-name">${FOOD_NAMES[type]} ×${count}</div>
                                    <div class="option-effect">${ENV_ICONS[type]}+${gain} 성장+${growth}</div>
                                </div>
                            </button>
                        `;
                    }).join('')}
                </div>
                <button class="close-btn" onclick="closeModal('feedModal')">닫기</button>
            `;
            modal.querySelector('.modal-content').innerHTML = content;
        }
        
        function giveMedicineFromModal(spiritId) {
            giveMedicine(spiritId);
            closeModal('feedModal');
        }

        function feedSpiritFromInventory(spiritId, foodType) {
            if (isPaused) {
                showNotification('게임이 일시정지 상태입니다');
                return;
            }
            
            const spirit = spirits.find(s => s.id === spiritId);
            if (!spirit) return;

            if (!inventory.food) inventory.food = [];
            const foodIndex = inventory.food.indexOf(foodType);
            if (foodIndex === -1) {
                showNotification('먹이가 없습니다');
                return;
            }

            // 먹이 소모
            inventory.food.splice(foodIndex, 1);

            const isRare = foodType === 'light' || foodType === 'dark';
            const attrGain = isRare ? 6 : 3;  // 희귀 +6, 일반 +3
            const growthGain = isRare ? 3 : 2;

            // 정령의 숨겨진 속성 증가
            if (!spirit.hiddenAttributes) {
                spirit.hiddenAttributes = {
                    fire: 0, water: 0, wind: 0, earth: 0, light: 0, dark: 0
                };
            }
            spirit.hiddenAttributes[foodType] += attrGain;

            spirit.growth += growthGain;
            spirit.lastFeed = Date.now();
            spirit.lastFed = Date.now();  // 배고픔 체크용
            spirit.lastInteraction = Date.now();  // 상호작용 시간 업데이트
            spirit.status = '맛있게 먹었습니다!';
            spirit.parameters.affection += 1;
            
            // 먹이 횟수 증가
            if (!spirit.feedCount) spirit.feedCount = 0;
            spirit.feedCount += 1;

            // 일지 추가
            addLog(spirit, `${FOOD_NAMES[foodType]}를 먹었습니다`);
            addLog(spirit, '맛있게 먹었습니다!');

            // 성충 체크 (100 이상이면 무조건 완료)
            if (spirit.growth >= STAGE_REQUIREMENTS.adult && !spirit.isCompleted) {
                completeSpirit(spirit);
            }

            closeModal('feedModal');
            saveGame();
            renderSpirits();  // 전체 렌더링으로 쿨타임 표시 업데이트
            renderInventory();
            showNotification(`${ENV_ICONS[foodType]} ${FOOD_NAMES[foodType]}를 주었습니다`);
        }

        function openMusicModal(spiritId) {
            const spirit = spirits.find(s => s.id === spiritId);
            if (!canDoAction(spirit, 'music')) {
                showNotification('아직 음악을 듣고 있습니다');
                return;
            }
            if (inventory.music.length === 0) {
                showNotification('보유한 음악이 없습니다. 채집을 해보세요!');
                return;
            }
            currentSpiritId = spiritId;
            renderMusicOptions();
            document.getElementById('musicModal').classList.add('active');
        }

        function renderMusicOptions() {
            const container = document.getElementById('musicOptions');
            
            // 음악 개수 세기
            const musicCounts = {};
            inventory.music.forEach(m => {
                musicCounts[m] = (musicCounts[m] || 0) + 1;
            });
            
            // 순서대로 표시 (classic, jazz, rock, pop, ballad)
            const musicOrder = ['classic', 'jazz', 'rock', 'pop', 'ballad'];
            const musicHTML = musicOrder
                .filter(type => musicCounts[type])
                .map(type => {
                    const musicData = MUSIC_TYPES[type];
                    const count = musicCounts[type];
                    return `
                        <button class="option-btn" onclick="playMusicByType('${type}')">
                            <span class="option-icon">${musicData.icon}</span>
                            <div class="option-info">
                                <div class="option-name">${musicData.name} ×${count}</div>
                                <div class="option-effect">${musicData.effect}</div>
                            </div>
                        </button>
                    `;
                }).join('');
            
            container.innerHTML = '<div class="music-grid">' + musicHTML + '</div>';
        }

        function playMusicByType(musicType) {
            const spiritId = currentSpiritId;
            
            // 해당 타입의 음악 찾기
            const musicIndex = inventory.music.indexOf(musicType);
            if (musicIndex === -1) {
                showNotification('해당 음악이 없습니다');
                return;
            }
            
            // 기존 playMusic 함수 호출
            playMusic(spiritId, musicType, musicIndex);
        }

        function playMusic(spiritId, musicType, inventoryIndex) {
            if (isPaused) {
                showNotification('게임이 일시정지 상태입니다');
                return;
            }
            
            const spirit = spirits.find(s => s.id === spiritId);
            if (!spirit) return;

            const musicData = MUSIC_TYPES[musicType];
            
            // 만족도 즉시 계산
            spirit.satisfaction = calculateSatisfaction(spirit);
            const singleStatBonus = spirit.satisfaction === 'high' ? 2 : 0; // 단일 스탯 +2
            const dualStatBonus = spirit.satisfaction === 'high' ? 1 : 0;   // 복수 스탯 각 +1
            
            // 효과 적용 (만족도 높으면 보너스)
            if (musicType === 'classic') {
                spirit.parameters.intelligence = Math.min(100, spirit.parameters.intelligence + 10 + singleStatBonus);
            } else if (musicType === 'jazz') {
                spirit.parameters.charm = Math.min(100, spirit.parameters.charm + 10 + singleStatBonus);
            } else if (musicType === 'rock') {
                spirit.parameters.strength = Math.min(100, spirit.parameters.strength + 10 + singleStatBonus);
            } else if (musicType === 'pop') {
                spirit.parameters.intelligence = Math.min(100, spirit.parameters.intelligence + 5 + dualStatBonus);
                spirit.parameters.charm = Math.min(100, spirit.parameters.charm + 5 + dualStatBonus);
            } else if (musicType === 'ballad') {
                spirit.parameters.strength = Math.min(100, spirit.parameters.strength + 5 + dualStatBonus);
                spirit.parameters.charm = Math.min(100, spirit.parameters.charm + 5 + dualStatBonus);
            }

            // 애정도 증가 (만족도 높으면 +1 보너스)
            const affectionBonus = spirit.satisfaction === 'high' ? 3 : 2;
            spirit.parameters.affection += affectionBonus;

            spirit.lastMusic = Date.now();
            spirit.lastInteraction = Date.now();  // 상호작용 시간 업데이트
            spirit.lastMusicType = musicType; // 마지막으로 들은 음악 저장
            
            // 음악 청취 횟수 증가
            if (!spirit.musicListened) spirit.musicListened = 0;
            spirit.musicListened += 1;
            
            // 음악 관련 랜덤 메시지
            const musicMessages = [
                `${spirit.name}이(가) ${musicData.name}을(를) 흥얼거립니다.`,
                `${spirit.name}이(가) ${musicData.name}에 맞춰 춤을 춥니다.`,
                `${spirit.name}이(가) ${musicData.name}의 선율을 떠올립니다.`,
                `${spirit.name}이(가) 음악에 취해 있습니다.`,
                `${spirit.name}이(가) ${musicData.name}의 여운에 젖어 있습니다.`
            ];
            spirit.status = musicMessages[Math.floor(Math.random() * musicMessages.length)];

            // 일지 추가
            addLog(spirit, `${musicData.name}을(를) 들었습니다`);

            // 음악 소모
            inventory.music.splice(inventoryIndex, 1);

            closeModal('musicModal');
            saveGame();
            renderSpirits();  // 전체 렌더링으로 쿨타임 표시 업데이트
            renderInventory();
            const bonusText = spirit.satisfaction === 'high' ? ' (만족 보너스!)' : '';
            showNotification(`${musicData.name}을(를) 들려주었습니다${bonusText}`);
        }

        function patSpirit(spiritId) {
            if (isPaused) {
                showNotification('게임이 일시정지 상태입니다');
                return;
            }
            
            const spirit = spirits.find(s => s.id === spiritId);
            if (!spirit) return;

            if (!canDoAction(spirit, 'pat')) {
                showNotification('아직 쓰다듬을 수 없습니다');
                return;
            }

            // 만족도 즉시 계산
            spirit.satisfaction = calculateSatisfaction(spirit);
            
            const currentAffection = spirit.parameters.affection || 0;
            const affectionBonus = spirit.satisfaction === 'high' ? 2 : 1;
            spirit.parameters.affection += affectionBonus;
            spirit.lastPat = Date.now();
            spirit.lastInteraction = Date.now();  // 상호작용 시간 업데이트
            
            // 애정도에 따른 반응 메시지
            let messages = [];
            let notificationEmoji = '';
            
            if (currentAffection < 10) {
                // 낯설어함, 경계함
                messages = [
                    `${spirit.name}이(가) 당신을 낯설어합니다...`,
                    `${spirit.name}이(가) 경계하며 물러섭니다`,
                    `${spirit.name}이(가) 조심스럽게 바라봅니다`,
                    `${spirit.name}이(가) 당신의 손길을 두려워합니다`,
                    `${spirit.name}이(가) 불안해하며 몸을 움츠립니다`,
                    `${spirit.name}이(가) 당신이 누구인지 궁금해합니다`,
                    `${spirit.name}이(가) 천천히 다가옵니다...`
                ];
                notificationEmoji = '😟';
            } else if (currentAffection < 50) {
                // 익숙해짐
                messages = [
                    `${spirit.name}이(가) 당신에게 익숙해졌습니다`,
                    `${spirit.name}이(가) 편안해 보입니다`,
                    `${spirit.name}이(가) 당신의 손길을 받아들입니다`,
                    `${spirit.name}이(가) 조금씩 마음을 엽니다`,
                    `${spirit.name}이(가) 당신을 신뢰하기 시작합니다`,
                    `${spirit.name}이(가) 기분이 좋아 보입니다`,
                    `${spirit.name}이(가) 당신 곁에 머뭅니다`
                ];
                notificationEmoji = '😊';
            } else {
                // 친해짐, 잘 따름
                messages = [
                    `${spirit.name}이(가) 당신을 무척 좋아합니다!`,
                    `${spirit.name}이(가) 당신을 따라다닙니다`,
                    `${spirit.name}이(가) 행복하게 당신을 바라봅니다`,
                    `${spirit.name}이(가) 당신에게 애교를 부립니다`,
                    `${spirit.name}이(가) 당신의 손을 비빕니다`,
                    `${spirit.name}이(가) 기뻐하며 날아오릅니다!`,
                    `${spirit.name}이(가) 당신 곁을 떠나지 않으려 합니다`,
                    `${spirit.name}이(가) 당신의 사랑을 온몸으로 느낍니다`
                ];
                notificationEmoji = '🥰';
            }
            
            spirit.status = messages[Math.floor(Math.random() * messages.length)];

            // 일지 추가
            addLog(spirit, '쓰다듬었습니다');
            addLog(spirit, spirit.status);

            saveGame();
            renderSpirits();  // 전체 렌더링으로 쿨타임 표시 업데이트
            const bonusText = spirit.satisfaction === 'high' ? ' (만족 보너스!)' : '';
            showNotification(`쓰다듬었습니다 (애정 +${affectionBonus}${bonusText})`);
        }
        
        // 약 먹이기 함수
        function giveMedicine(spiritId) {
            if (isPaused) {
                showNotification('게임이 일시정지 상태입니다');
                return;
            }
            
            const spirit = spirits.find(s => s.id === spiritId);
            if (!spirit) return;
            
            if (!spirit.isSick) {
                showNotification('이 정령은 건강합니다');
                return;
            }
            
            if (!inventory.food) inventory.food = [];
            const medicineIndex = inventory.food.indexOf('medicine');
            if (medicineIndex === -1) {
                showNotification('약초가 없습니다. 상점에서 구매하세요!');
                return;
            }
            
            // 약초 소모
            inventory.food.splice(medicineIndex, 1);
            
            // 병 치료
            spirit.isSick = false;
            spirit.sickWarned = false;
            delete spirit.sickTime;
            spirit.lastInteraction = Date.now(); // 상호작용 시간 업데이트
            
            const healMessages = [
                `${spirit.name}이(가) 약초를 먹고 건강해졌습니다! 💚`,
                `${spirit.name}의 병이 완전히 나았습니다!`,
                `${spirit.name}이(가) 활기를 되찾았습니다! 🌟`,
                `${spirit.name}이(가) 당신의 보살핌에 감사합니다`
            ];
            
            spirit.status = healMessages[Math.floor(Math.random() * healMessages.length)];
            
            // 일지 추가
            addLog(spirit, '약초를 먹고 건강해졌습니다');
            addLog(spirit, spirit.status);
            
            saveGame();
            updateSpiritCard(spirit);
            renderInventory();
            showNotification(`${spirit.name}의 병이 나았습니다!`);
        }

        function changeTitle() {
            const select = document.getElementById('titleSelect');
            currentTitle = select.value;
            
            const titleNames = {
                'none': '없음',
                'hawk_eye': '🦅 매의 눈',
                'gatherer': '🍎 채집꾼',
                'musician': '음악가',
                'collector': '💎 수집가'
            };
            
            showNotification(`칭호를 ${titleNames[currentTitle]}(으)로 변경했습니다`);
            saveGame();
        }
        
        function changeShopCategory() {
            const select = document.getElementById('shopCategorySelect');
            currentShopCategory = select.value;
            renderShop();
        }


        function changeGatherLocation() {
            const select = document.getElementById('gatherLocationSelect');
            currentGatherLocation = select.value;
            saveGame();
            
            const locationNames = {
                garden: '🌸 정원',
                lake: '🌊 호수',
                forest: '🌲 숲'
            };
            showNotification(`채집 장소를 ${locationNames[currentGatherLocation]}(으)로 변경했습니다`);
        }

        function goGather() {
            if (isPaused) {
                showNotification('게임이 일시정지 상태입니다');
                return;
            }
            
            const now = Date.now();
            const gatherCooldown = 15000; // 15초

            // 쿨다운 체크
            if (lastGatherTime && (now - lastGatherTime < gatherCooldown)) {
                const remainingTime = Math.ceil((gatherCooldown - (now - lastGatherTime)) / 1000);
                showNotification(`${remainingTime}초 후에 다시 채집할 수 있습니다`);
                return;
            }
            
            // 선택된 장소에서 바로 채집
            gatherAtLocation(currentGatherLocation);
        }
        
        function gatherAtLocation(location) {
            const now = Date.now();

            if (!inventory.food) inventory.food = [];
            if (!inventory.music) inventory.music = [];
            if (!inventory.decorations) inventory.decorations = [];

            const discoveries = [];
            
            // 칭호별 확률 보너스
            const titleBonus = {
                hawk_eye: 1.5,    // 매의 눈: 모든 확률 1.5배
                gatherer: 1.0,    // 채집꾼: 먹이만 2배 (아래서 따로 처리)
                musician: 1.0,    // 음악가: 레코드만 2배 (아래서 따로 처리)
                collector: 1.0    // 수집가: 테라리움만 2배 (아래서 따로 처리)
            };
            
            const baseBonus = currentTitle !== 'none' && titleBonus[currentTitle] ? titleBonus[currentTitle] : 1.0;
            const foodBonus = currentTitle === 'gatherer' ? 2.0 : baseBonus;
            
            // 장소별 먹이 타입
            let locationFoodTypes = [];
            let locationDecoTypes = [];
            
            if (location === 'garden') {
                locationFoodTypes = ['fire', 'water', 'wind', 'earth'];  // 정원: 모든 기본 속성
                locationDecoTypes = ['fire', 'water', 'wind', 'earth'];
            } else if (location === 'lake') {
                locationFoodTypes = ['water', 'wind'];  // 호수: 물, 바람
                locationDecoTypes = ['water', 'wind'];
            } else if (location === 'forest') {
                locationFoodTypes = ['earth', 'fire'];  // 숲: 땅, 불
                locationDecoTypes = ['earth', 'fire'];
            }
            
            // 80% 확률로 일반 먹이 발견 (장소 고정)
            if (Math.random() < (0.8 * foodBonus)) {
                const randomFood = locationFoodTypes[Math.floor(Math.random() * locationFoodTypes.length)];
                inventory.food.push(randomFood);
                discoveries.push(`🍎 ${FOOD_NAMES[randomFood]}`);
            }

            // 40% 확률로 희귀 먹이 발견 (빛암)
            if (Math.random() < (0.4 * foodBonus)) {
                const rareFoodTypes = ['light', 'dark'];
                const randomRareFood = rareFoodTypes[Math.floor(Math.random() * rareFoodTypes.length)];
                inventory.food.push(randomRareFood);
                discoveries.push(`${FOOD_NAMES[randomRareFood]}`);
            }

            // 장식물 채집 (장소별 + 등급별 확률)
            const decoBonus = currentTitle === 'collector' ? 2.0 : baseBonus;
            
            // 50% 확률로 일반(common) 장식물 (장소 고정)
            if (Math.random() < (0.5 * decoBonus)) {
                const commonDecos = Object.keys(DECORATION_TYPES).filter(key => {
                    const deco = DECORATION_TYPES[key];
                    return deco.quality === 'common' && locationDecoTypes.includes(deco.attr);
                });
                if (commonDecos.length > 0) {
                    const randomDeco = commonDecos[Math.floor(Math.random() * commonDecos.length)];
                    inventory.decorations.push(randomDeco);
                    discoveries.push(`${DECORATION_TYPES[randomDeco].icon} ${DECORATION_TYPES[randomDeco].name}`);
                }
            }
            
            // 20% 확률로 희귀(rare) 장식물 (장소 고정)
            if (Math.random() < (0.2 * decoBonus)) {
                const rareDecos = Object.keys(DECORATION_TYPES).filter(key => {
                    const deco = DECORATION_TYPES[key];
                    return deco.quality === 'rare' && locationDecoTypes.includes(deco.attr);
                });
                if (rareDecos.length > 0) {
                    const randomDeco = rareDecos[Math.floor(Math.random() * rareDecos.length)];
                    inventory.decorations.push(randomDeco);
                    discoveries.push(`${DECORATION_TYPES[randomDeco].icon} ${DECORATION_TYPES[randomDeco].name}`);
                }
            }
            
            // 8% 확률로 최상급(epic) 장식물 (장소 고정)
            if (Math.random() < (0.08 * decoBonus)) {
                const epicDecos = Object.keys(DECORATION_TYPES).filter(key => {
                    const deco = DECORATION_TYPES[key];
                    return deco.quality === 'epic' && locationDecoTypes.includes(deco.attr);
                });
                if (epicDecos.length > 0) {
                    const randomDeco = epicDecos[Math.floor(Math.random() * epicDecos.length)];
                    inventory.decorations.push(randomDeco);
                    discoveries.push(`${DECORATION_TYPES[randomDeco].icon} ${DECORATION_TYPES[randomDeco].name} (최상급!)`);
                }
            }

            // 15% 확률로 음악 레코드 발견
            const musicBonus = currentTitle === 'musician' ? 2.0 : baseBonus;
            if (Math.random() < (0.15 * musicBonus)) {
                const musicKeys = Object.keys(MUSIC_TYPES);
                const randomMusic = musicKeys[Math.floor(Math.random() * musicKeys.length)];
                inventory.music.push(randomMusic);
                discoveries.push(`${MUSIC_TYPES[randomMusic].name}`);
            }

            if (discoveries.length === 0) {
                showNotification('아무것도 발견하지 못했습니다...');
            } else {
                const locationNames = { garden: '🌸 정원', lake: '🌊 호수', forest: '🌲 숲' };
                showNotification(`${locationNames[location]} 채집: ${discoveries.join(', ')}`);
            }

            lastGatherTime = now;
            saveGame();
            renderInventory();
            updateGatherButton();
        }

        function updateGatherButton() {
            const gatherBtn = document.querySelector('.walk-btn');
            if (!gatherBtn) return;

            const now = Date.now();
            const gatherCooldown = 15000; // 15초
            
            // 일시정지 중이면 버튼 비활성화
            if (isPaused) {
                gatherBtn.disabled = true;
                gatherBtn.textContent = '채집하기 (일시정지)';
                return;
            }

            if (lastGatherTime && (now - lastGatherTime < gatherCooldown)) {
                gatherBtn.disabled = true;
                const remainingTime = Math.ceil((gatherCooldown - (now - lastGatherTime)) / 1000);
                gatherBtn.textContent = `채집하기 (${remainingTime}초)`;
            } else {
                gatherBtn.disabled = false;
                gatherBtn.textContent = '채집하기';
            }
        }

        function confirmDeleteSpirit(spiritId) {
            const spirit = spirits.find(s => s.id === spiritId);
            if (!spirit) return;

            showConfirm(
                '정령 보내기',
                `정말로 ${spirit.name}을(를) 보내시겠습니까?\n\n이 작업은 되돌릴 수 없습니다.`,
                () => deleteSpirit(spiritId)
            );
        }

        function deleteSpirit(spiritId) {
            spirits = spirits.filter(s => s.id !== spiritId);
            saveGame();
            renderSpirits();
            showNotification('정령을 떠나보냈습니다');
        }

        function renderInventory() {
            // 먹이가 없으면 초기화
            if (!inventory.food) {
                inventory.food = [];
            }

            // 먹이 인벤토리 (순서 고정: fire, water, wind, earth, light, dark)
            const foodContainer = document.getElementById('foodInventory');
            if (inventory.food.length === 0) {
                foodContainer.innerHTML = '<div class="inventory-item">없음</div>';
            } else {
                const foodCounts = {};
                inventory.food.forEach(f => {
                    foodCounts[f] = (foodCounts[f] || 0) + 1;
                });
                const foodOrder = ['fire', 'water', 'wind', 'earth', 'light', 'dark'];
                foodContainer.innerHTML = foodOrder
                    .filter(type => foodCounts[type])
                    .map(type => `
                        <div class="inventory-item">
                            ${ENV_ICONS[type]} ×${foodCounts[type]}
                        </div>
                    `).join('');
            }

            // 음악 인벤토리 (순서 고정: classic, jazz, rock, pop, ballad)
            const musicContainer = document.getElementById('musicInventory');
            if (!inventory.music) inventory.music = [];
            console.log('=== Music Inventory Debug ===');
            console.log('Music array:', inventory.music);
            console.log('Music array length:', inventory.music.length);
            
            if (inventory.music.length === 0) {
                console.log('No music, showing empty state');
                musicContainer.innerHTML = '<div class="inventory-item">없음</div>';
            } else {
                const musicCounts = {};
                inventory.music.forEach(m => {
                    console.log('Processing music:', m);
                    musicCounts[m] = (musicCounts[m] || 0) + 1;
                });
                console.log('Music counts:', musicCounts);
                const musicOrder = ['classic', 'jazz', 'rock', 'pop', 'ballad'];
                const filteredMusic = musicOrder.filter(type => musicCounts[type]);
                console.log('Filtered music types:', filteredMusic);
                
                const musicHTML = filteredMusic.map(type => {
                    const html = `
                        <div class="inventory-item">
                            ${MUSIC_TYPES[type].icon} ×${musicCounts[type]}
                        </div>
                    `;
                    console.log('Generated HTML for', type, ':', html);
                    return html;
                }).join('');
                
                console.log('Final music HTML length:', musicHTML.length);
                console.log('Final music HTML:', musicHTML);
                musicContainer.innerHTML = musicHTML || '<div class="inventory-item">없음</div>';
            }

            // 장식물 인벤토리 (등급별 표시)
            const decorContainer = document.getElementById('decorInventory');
            if (!inventory.decorations) inventory.decorations = [];
            if (inventory.decorations.length === 0) {
                decorContainer.innerHTML = '<div class="inventory-item">없음</div>';
            } else {
                const decorCounts = {};
                inventory.decorations.forEach(d => {
                    decorCounts[d] = (decorCounts[d] || 0) + 1;
                });
                
                const decorHTML = Object.keys(decorCounts).map(key => {
                    const decoData = DECORATION_TYPES[key];
                    if (!decoData) return '';
                    
                    const qualityLabel = decoData.quality === 'epic' ? '⭐' : decoData.quality === 'rare' ? '💎' : '';
                    return `
                        <div class="inventory-item" title="${decoData.name} (${decoData.attr} +${decoData.power})">
                            ${qualityLabel}${decoData.icon} ×${decorCounts[key]}
                        </div>
                    `;
                }).join('');
                
                decorContainer.innerHTML = decorHTML || '<div class="inventory-item">없음</div>';
            }
        }


        function manualCompleteSpirit(spiritId) {
            if (isPaused) {
                showNotification('게임이 일시정지 상태입니다');
                return;
            }
            
            const spirit = spirits.find(s => s.id === spiritId);
            if (!spirit) {
                showNotification('정령을 찾을 수 없습니다.');
                return;
            }
            
            if (spirit.growth >= 100 && !spirit.isCompleted) {
                try {
                    completeSpirit(spirit);
                    saveGame();
                    renderSpirits();
                    showNotification('✨ 정령이 진화합니다!');
                } catch (error) {
                    console.error('진화 오류:', error);
                    showNotification('진화 중 오류가 발생했습니다: ' + error.message);
                }
            } else {
                showNotification(`아직 진화할 수 없습니다. (성장도: ${Math.floor(spirit.growth)}/100)`);
            }
        }

        function completeSpirit(spirit) {
            // 스탯으로 진화 결정
            const params = spirit.parameters;
            const maxStat = Math.max(params.intelligence, params.strength, params.charm);
            
            // 노멀 진화 체크 (모든 스탯이 20 미만)
            // 하지만 속성이 있으면 속성 진화 가능
            const hasLowStats = maxStat < 20;
            
            // 스탯 계열 결정 (20 이상인 경우만)
            let statType = '';
            let evolutionKey = '';
            
            if (!hasLowStats) {
                // 최고 스탯 결정
                if (params.intelligence >= params.strength && params.intelligence >= params.charm) {
                    statType = 'intelligent';
                } else if (params.strength >= params.intelligence && params.strength >= params.charm) {
                    statType = 'strong';
                } else {
                    statType = 'beautiful';
                }

                // 진화 단계 결정 (스탯 수치 기준)
                if (maxStat >= 80) {
                    evolutionKey = `${statType}-high`;  // 80+ : 세상의~
                } else if (maxStat >= 50) {
                    evolutionKey = `${statType}-mid`;  // 50-79 : 지적인/강한/아름다운
                } else {
                    evolutionKey = `${statType}-low`;  // 20-49 : 똑똑한/튼튼한/귀여운
                }
            }

            // 속성 분석 (먹이 50% + 테라리움 50%)
            const foodAttrs = spirit.hiddenAttributes || { fire: 0, water: 0, wind: 0, earth: 0, light: 0, dark: 0 };
            const terrariumAttrs = terrarium || { fire: 0, water: 0, wind: 0, earth: 0, light: 0, dark: 0 };
            
            // 최종 속성 = (먹이 속성 × 0.5) + (테라리움 속성 × 0.5)
            const finalAttrs = {};
            for (let attr in foodAttrs) {
                finalAttrs[attr] = (foodAttrs[attr] * 0.5) + (terrariumAttrs[attr] * 0.5);
            }
            
            const sortedAttrs = Object.entries(finalAttrs)
                .sort((a, b) => b[1] - a[1]); // 내림차순 정렬
            
            // 최고 속성값
            const maxAttrValue = sortedAttrs[0][1];
            
            let attributeKey = '';
            let attributeData = null;
            
            if (maxAttrValue < 50) {
                // 모든 속성이 50 미만 - 백의 정령
                attributeKey = 'normal';
                attributeData = { name: '백의 정령', icon: '🤍', desc: '속성이 깃들지 않은 순수한 정령.' };
            } else {
                // 50 이상인 속성들만 필터링
                const significantAttrs = sortedAttrs.filter(([_, value]) => value >= 50);
                
                if (significantAttrs.length === 1) {
                    // 단일 속성 (하나만 60 이상)
                    attributeKey = significantAttrs[0][0];
                    attributeData = ATTRIBUTE_NAMES[attributeKey];
                    if (!attributeData) {
                        console.error('Missing ATTRIBUTE_NAMES for:', attributeKey);
                        // 가장 높은 단일 속성으로 폴백
                        attributeKey = sortedAttrs[0][0];
                        attributeData = ATTRIBUTE_NAMES[attributeKey] || ATTRIBUTE_NAMES['fire'];
                    }
                } else if (significantAttrs.length === 2) {
                    // 2속성: 1위와 2위 차이가 40% 이하면 조합, 초과면 단일
                    const first = significantAttrs[0][1];
                    const second = significantAttrs[1][1];
                    const diffPercent = ((first - second) / first) * 100;
                    
                    if (diffPercent <= 40) {
                        // 2속성 조합
                        const attr1 = significantAttrs[0][0];
                        const attr2 = significantAttrs[1][0];
                        const comboKey = [attr1, attr2].sort().join('-');
                        attributeData = ATTRIBUTE_NAMES[comboKey];
                        attributeKey = comboKey;
                        if (!attributeData) {
                            console.error('Missing ATTRIBUTE_NAMES for combo:', comboKey);
                            // 조합이 없으면 1순위 단일 속성으로 폴백
                            attributeKey = attr1;
                            attributeData = ATTRIBUTE_NAMES[attr1] || ATTRIBUTE_NAMES['fire'];
                        }
                    } else {
                        // 단일 속성 (차이가 너무 큼)
                        attributeKey = significantAttrs[0][0];
                        attributeData = ATTRIBUTE_NAMES[attributeKey];
                        if (!attributeData) {
                            console.error('Missing ATTRIBUTE_NAMES for:', attributeKey);
                            // 가장 높은 속성으로 폴백
                            attributeKey = sortedAttrs[0][0];
                            attributeData = ATTRIBUTE_NAMES[attributeKey] || ATTRIBUTE_NAMES['fire'];
                        }
                    }
                } else if (significantAttrs.length >= 3) {
                    // 3속성 이상
                    const topValues = significantAttrs.slice(0, 3).map(a => a[1]);
                    const maxVal = Math.max(...topValues);
                    const minVal = Math.min(...topValues);
                    const diffPercent = ((maxVal - minVal) / maxVal) * 100;
                    
                    if (diffPercent <= 25) {
                        // 조화 (차이 25% 이하)
                        attributeKey = 'balanced';
                        attributeData = ATTRIBUTE_NAMES['balanced'];
                    } else {
                        // 혼돈 (차이 25% 초과)
                        attributeKey = 'multi';
                        attributeData = ATTRIBUTE_NAMES['multi'];
                    }
                    if (!attributeData) {
                        console.error('Missing ATTRIBUTE_NAMES for:', attributeKey);
                        // 가장 높은 단일 속성으로 폴백
                        attributeKey = significantAttrs[0][0];
                        attributeData = ATTRIBUTE_NAMES[attributeKey] || ATTRIBUTE_NAMES['fire'];
                    }
                }
            }
            
            // 최종 이름과 아이콘 조합
            let finalName = '';
            let finalIcon = '';
            let finalDesc = '';
            
            // 날개 타입 먼저 결정 (티타니아/오베론 판정에 필요)
            if (!spirit.lightTime) spirit.lightTime = 0;
            if (!spirit.darkTime) spirit.darkTime = 0;
            
            let wingType = null;
            if (spirit.lightTime > spirit.darkTime) {
                wingType = 'butterfly';
            } else if (spirit.darkTime > spirit.lightTime) {
                wingType = 'moth';
            } else {
                wingType = 'butterfly'; // 동점이면 나비
            }
            
            // 티타니아/오베론 조건 체크
            // 모든 스탯 70 이상 + 모든 속성 100 근접 (90 이상)
            const isPerfectStats = params.intelligence >= 70 && params.strength >= 70 && params.charm >= 70;
            const isPerfectAttributes = Object.values(finalAttrs).every(val => val >= 90);
            
            if (isPerfectStats && isPerfectAttributes) {
                // 완벽한 정령 - 티타니아/오베론
                if (wingType === 'butterfly') {
                    finalName = '티타니아';
                    finalIcon = '🦋✨';
                    finalDesc = '모든 힘을 완벽히 갖춘 나비의 여왕. 빛과 생명을 관장하는 전설적 존재.';
                } else {
                    finalName = '오베론';
                    finalIcon = '🦋🌙';
                    finalDesc = '모든 힘을 완벽히 갖춘 나방의 군주. 어둠과 신비를 지배하는 전설적 존재.';
                }
            } else if (attributeKey === 'normal') {
                // 속성 없음
                if (hasLowStats) {
                    // 스탯도 낮음 - 순수한 백의 정령
                    if (attributeData) {
                        finalName = attributeData.name;
                        finalIcon = attributeData.icon;
                        finalDesc = attributeData.desc;
                    } else {
                        finalName = '백의 정령';
                        finalIcon = '🤍';
                        finalDesc = '속성이 깃들지 않은 순수한 정령.';
                    }
                } else {
                    // 스탯은 높음 - "스탯 계열 + 백의 정령"
                    const evolution = EVOLUTION_TYPES[evolutionKey];
                    if (evolution && attributeData) {
                        finalName = `${evolution.prefix} ${attributeData.name}`;
                        finalIcon = `${evolution.icon}${attributeData.icon}`;
                        finalDesc = attributeData.desc;
                    } else if (evolution) {
                        // evolution은 있는데 attributeData가 없으면 백의 정령 사용
                        finalName = `${evolution.prefix} 백의 정령`;
                        finalIcon = `${evolution.icon}🤍`;
                        finalDesc = '속성이 깃들지 않은 순수한 정령.';
                    } else {
                        finalName = '백의 정령';
                        finalIcon = '🤍';
                        finalDesc = '속성이 깃들지 않은 순수한 정령.';
                    }
                }
            } else if (hasLowStats) {
                // 스탯 부족하지만 속성 있음 - 속성 이름만
                if (attributeData) {
                    finalName = attributeData.name;
                    finalIcon = attributeData.icon;
                    finalDesc = attributeData.desc;
                } else {
                    console.error('attributeData is undefined for key:', attributeKey);
                    // 가장 높은 단일 속성으로 폴백
                    const fallbackKey = sortedAttrs[0][0];
                    const fallbackData = ATTRIBUTE_NAMES[fallbackKey] || ATTRIBUTE_NAMES['fire'];
                    finalName = fallbackData.name;
                    finalIcon = fallbackData.icon;
                    finalDesc = fallbackData.desc;
                    attributeKey = fallbackKey;
                }
            } else {
                // 스탯도 있고 속성도 있음 - "스탯 계열 + 속성 이름" 형태
                const evolution = EVOLUTION_TYPES[evolutionKey];
                if (evolution && attributeData) {
                    finalName = `${evolution.prefix} ${attributeData.name}`;
                    finalIcon = `${evolution.icon}${attributeData.icon}`;
                    finalDesc = attributeData.desc;
                } else {
                    console.error('Evolution data missing:', { evolutionKey, attributeKey, evolution, attributeData });
                    // 폴백: 가장 높은 속성으로 진화
                    const fallbackKey = sortedAttrs[0][0];
                    const fallbackData = ATTRIBUTE_NAMES[fallbackKey] || ATTRIBUTE_NAMES['fire'];
                    const fallbackEvolution = EVOLUTION_TYPES[evolutionKey] || EVOLUTION_TYPES['intelligent-mid'];
                    if (fallbackEvolution && fallbackData) {
                        finalName = `${fallbackEvolution.prefix} ${fallbackData.name}`;
                        finalIcon = `${fallbackEvolution.icon}${fallbackData.icon}`;
                        finalDesc = fallbackData.desc;
                    } else {
                        finalName = fallbackData.name;
                        finalIcon = fallbackData.icon;
                        finalDesc = fallbackData.desc;
                    }
                    attributeKey = fallbackKey;
                }
            }
            
            // evolutionKey 설정 (도감 등록용)
            let finalEvolutionType = evolutionKey;
            if (isPerfectStats && isPerfectAttributes) {
                // 티타니아/오베론
                finalEvolutionType = wingType === 'butterfly' ? 'titania' : 'oberon';
            } else if (hasLowStats) {
                // 스탯 부족한 경우
                if (attributeKey === 'normal') {
                    finalEvolutionType = 'nostat';  // 스탯 낮고 속성도 없음 -> nostat-normal
                } else {
                    finalEvolutionType = 'nostat';  // 스탯 낮고 속성 있음 -> nostat-fire 등
                }
            } else if (attributeKey === 'normal') {
                // 스탯은 높은데 속성 없음 -> intelligent-high-normal 같은 형태 유지
                finalEvolutionType = evolutionKey;
            }
            
            // 정령을 완성 상태로 표시 (아직 제거하지 않음)
            spirit.isCompleted = true;
            spirit.evolutionData = {
                type: finalEvolutionType,
                attributeType: attributeKey,
                name: finalName,
                icon: finalIcon,
                desc: finalDesc,
                wingType: wingType
            };
            
            saveGame();
            renderSpirits();
            showNotification('🎉 정령이 성장을 완료했습니다! 육성 탭에서 확인해주세요.');
        }
        
        function confirmEvolution(spiritId) {
            const spirit = spirits.find(s => s.id === spiritId);
            if (!spirit || !spirit.isCompleted) {
                console.log('confirmEvolution failed:', { spirit, spiritId, isCompleted: spirit?.isCompleted });
                return;
            }
            
            const evolutionData = spirit.evolutionData;
            console.log('Evolution data:', evolutionData);
            
            const affection = spirit.parameters.affection || 0;
            
            // 애정도별 엔딩 메시지
            let endingMessage = '';
            
            if (affection >= 150) {
                endingMessage = `${spirit.name}은(는) 당신에게 "ㅁㅁㅁㅁ"라는 말을 남기고 떠납니다.\n\n정령어 사전을 찾아보면 그 말은 "사랑해요"라는 의미입니다.`;
            } else if (affection >= 100) {
                endingMessage = `${spirit.name}은(는) 당신의 뺨에 입맞춤을 남기고 떠납니다.`;
            } else if (affection >= 50) {
                endingMessage = `${spirit.name}은(는) 당신에게 감사의 인사를 남기고 떠납니다.`;
            } else {
                endingMessage = `${spirit.name}이(가) 떠나갑니다.`;
            }
            
            showConfirm(
                '정령 완성',
                endingMessage,
                () => {
                    // 앨범에 추가
                collection.push({
                    type: evolutionData.type,
                    attributeType: evolutionData.attributeType,
                    name: evolutionData.name,
                    icon: evolutionData.icon,
                    desc: evolutionData.desc,
                    parameters: { ...spirit.parameters },
                    hiddenAttributes: { ...spirit.hiddenAttributes },
                    originalName: spirit.name,
                    wingType: evolutionData.wingType,
                    lightTime: spirit.lightTime,
                    darkTime: spirit.darkTime,
                    completedAt: Date.now()
                });
                
                // 도감에 등록 (진화 타입별 카운트)
                let encyclopediaKey;
                if (evolutionData.type === 'titania' || evolutionData.type === 'oberon') {
                    // 전설적 존재는 고유 키 사용
                    encyclopediaKey = evolutionData.type;
                } else if (evolutionData.type === 'nostat') {
                    // 수식어 없는 정령
                    encyclopediaKey = `nostat-${evolutionData.attributeType}`;
                } else {
                    // 일반 정령 (스탯-레벨-속성)
                    encyclopediaKey = `${evolutionData.type}-${evolutionData.attributeType}`;
                }
                
                if (!encyclopedia[encyclopediaKey]) {
                    encyclopedia[encyclopediaKey] = 0;
                }
                encyclopedia[encyclopediaKey]++;
                
                console.log('도감 등록:', encyclopediaKey, '카운트:', encyclopedia[encyclopediaKey]);
                
                // 정령 제거
                spirits = spirits.filter(s => s.id !== spiritId);
                saveGame();
                
                // 자동 로컬 백업 (최근 10개 유지)
                try {
                    const backups = JSON.parse(localStorage.getItem('spiritGarden_autoBackups') || '[]');
                    backups.unshift({
                        timestamp: Date.now(),
                        collection: [...collection],
                        encyclopedia: {...encyclopedia}
                    });
                    // 최근 10개만 유지
                    if (backups.length > 10) backups.length = 10;
                    localStorage.setItem('spiritGarden_autoBackups', JSON.stringify(backups));
                } catch (e) {
                    console.warn('자동 백업 실패:', e);
                }
                
                    renderSpirits();
                    showNotification(`${evolutionData.icon} ${spirit.name}이(가) ${evolutionData.name}(으)로 앨범에 등록되었습니다`);
                }
            );
        }

        function showAlbumDetail(index) {
            const item = collection[index];
            if (!item) return;
            
            const modal = document.getElementById('albumDetailModal');
            const modalTitle = document.getElementById('modalTitle');
            const modalContent = document.getElementById('modalContent');
            
            modalTitle.textContent = item.name;
            
            // 날개 정보
            let wingInfo = '';
            if (item.wingType === 'butterfly') {
                wingInfo = '🦋 나비의 날개';
            } else if (item.wingType === 'moth') {
                wingInfo = '🦋 나방의 날개';
            }
            
            // 조명 시간 계산
            const lightMinutes = Math.floor((item.lightTime || 0) / 60);
            const darkMinutes = Math.floor((item.darkTime || 0) / 60);
            
            // 숨겨진 속성 정보
            const hiddenAttrs = item.hiddenAttributes || { fire: 0, water: 0, wind: 0, earth: 0, light: 0, dark: 0 };
            
            modalContent.innerHTML = `
                <div style="text-align: center; margin-bottom: 20px;">
                    <div style="font-size: 4rem; margin-bottom: 10px;">${item.icon}${wingInfo ? '🦋' : ''}</div>
                    <div style="font-size: 0.9rem; color: #888;">본명: ${item.originalName || '이름 없음'}</div>
                    ${wingInfo ? `<div style="font-size: 0.9rem; color: #888; margin-top: 4px;">${wingInfo}</div>` : ''}
                    ${item.desc ? `<div style="font-size: 0.9rem; color: #888; margin-top: 8px; line-height: 1.4; font-style: italic;">"${item.desc}"</div>` : ''}
                </div>
                
                <div style="background: var(--bg); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                    <h3 style="font-size: 1rem; margin-bottom: 10px; color: var(--text);">📊 기본 스탯</h3>
                    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px;">
                        <div class="param">🧠 지력: ${item.parameters.intelligence}</div>
                        <div class="param">💪 체력: ${item.parameters.strength}</div>
                        <div class="param">매력: ${item.parameters.charm}</div>
                        <div class="param">애정도: ${item.parameters.affection || 0}</div>
                    </div>
                </div>
                
                <div style="background: var(--bg); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                    <h3 style="font-size: 1rem; margin-bottom: 10px; color: var(--text);">🌈 숨겨진 속성</h3>
                    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px;">
                        <div style="font-size: 0.85rem; padding: 8px; background: var(--card); border-radius: 4px;">🔥 화: ${hiddenAttrs.fire}</div>
                        <div style="font-size: 0.85rem; padding: 8px; background: var(--card); border-radius: 4px;">💧 수: ${hiddenAttrs.water}</div>
                        <div style="font-size: 0.85rem; padding: 8px; background: var(--card); border-radius: 4px;">🌬️ 풍: ${hiddenAttrs.wind}</div>
                        <div style="font-size: 0.85rem; padding: 8px; background: var(--card); border-radius: 4px;">🌱 지: ${hiddenAttrs.earth}</div>
                        <div style="font-size: 0.85rem; padding: 8px; background: var(--card); border-radius: 4px;">빛: ${hiddenAttrs.light}</div>
                        <div style="font-size: 0.85rem; padding: 8px; background: var(--card); border-radius: 4px;">🌙 암: ${hiddenAttrs.dark}</div>
                    </div>
                </div>
                
                <div style="background: var(--bg); padding: 15px; border-radius: 8px;">
                    <h3 style="font-size: 1rem; margin-bottom: 10px; color: var(--text);">⏱️ 육성 정보</h3>
                    <div style="font-size: 0.85rem; line-height: 1.6;">
                        <div>☀️ 빛 시간: ${lightMinutes}분</div>
                        <div>🌙 어둠 시간: ${darkMinutes}분</div>
                        <div style="margin-top: 8px; color: #888;">등록 날짜: ${new Date(item.completedAt).toLocaleString('ko-KR')}</div>
                    </div>
                </div>
            `;
            
            modal.style.display = 'flex';
        }
        
        function closeAlbumDetail() {
            const modal = document.getElementById('albumDetailModal');
            modal.style.display = 'none';
        }

        function applyGrowth() {
            if (isPaused) return; // 일시정지 중이면 성장 안 함
            
            spirits.forEach(spirit => {
                if (spirit.isDead || spirit.isCompleted) return;

                // 성장도 +1
                const previousGrowth = spirit.growth;
                spirit.growth += 1;

                console.log(`Spirit ${spirit.name}: growth ${previousGrowth} → ${spirit.growth}`);

                // 성충 체크 (100 이상이면 무조건 완료)
                if (spirit.growth >= STAGE_REQUIREMENTS.adult) {
                    console.log(`Completing spirit ${spirit.name} with growth ${spirit.growth}`);
                    completeSpirit(spirit);
                }
            });

            saveGame();
            updateAllSpiritCards();
        }

        function applyTerrariumGrowth() {
            if (isPaused) return; // 일시정지 중이면 실행 안 함
            
            spirits.forEach(spirit => {
                if (spirit.isDead || spirit.isCompleted) return;  // 죽었거나 완성된 정령 제외

                // 조명 누적 시간 추가 (300초 = 5분)
                if (!spirit.lightTime) spirit.lightTime = 0;
                if (!spirit.darkTime) spirit.darkTime = 0;
                
                if (lightMode) {
                    spirit.lightTime += 300;
                } else {
                    spirit.darkTime += 300;
                }

                // 정령의 숨겨진 속성에 테라리움 환경값 추가
                if (!spirit.hiddenAttributes) {
                    spirit.hiddenAttributes = {
                        fire: 0, water: 0, wind: 0, earth: 0, light: 0, dark: 0
                    };
                }

                // 테라리움의 각 속성값만큼 정령의 속성 증가 (최대 100까지만)
                Object.keys(terrarium).forEach(attr => {
                    if (terrarium[attr] > 0) {
                        spirit.hiddenAttributes[attr] = Math.min(
                            spirit.hiddenAttributes[attr] + terrarium[attr],
                            100  // 속성 최대치
                        );
                    }
                });
                
                // 질병 체크 (5분마다, 이미 아프지 않은 경우)
                if (!spirit.isSick) {
                    checkForDisease(spirit);
                }
            });

            saveGame();
            updateAllSpiritCards();
        }
        
        // 질병 체크 함수
        function checkForDisease(spirit) {
            // 정령의 주 속성 찾기
            const attrs = spirit.hiddenAttributes || { fire: 0, water: 0, wind: 0, earth: 0, light: 0, dark: 0 };
            let maxAttr = null;
            let maxValue = 0;
            
            for (let attr in attrs) {
                if (attrs[attr] > maxValue) {
                    maxValue = attrs[attr];
                    maxAttr = attr;
                }
            }
            
            // 속성이 너무 낮으면 체크 안 함
            if (maxValue < 20) return;
            
            // 대립 속성 정의
            const opposites = {
                fire: 'water',
                water: 'fire',
                wind: 'earth',
                earth: 'wind',
                light: 'dark',
                dark: 'light'
            };
            
            const oppositeAttr = opposites[maxAttr];
            if (!oppositeAttr) return;
            
            // 테라리움의 대립 속성이 정령의 주 속성보다 높으면 질병 위험
            if (terrarium[oppositeAttr] > terrarium[maxAttr] && terrarium[oppositeAttr] >= 10) {
                // 20% 확률로 질병 발생
                if (Math.random() < 0.2) {
                    spirit.isSick = true;
                    spirit.sickTime = Date.now();
                    spirit.status = `${spirit.name}이(가) 아파 보입니다... 🤒`;
                    addLog(spirit, '환경이 맞지 않아 병에 걸렸습니다');
                    showNotification(`${spirit.name}이(가) 병에 걸렸습니다!`);
                }
            }
        }

        function checkSpiritStatus() {
            const now = Date.now();
            spirits.forEach(spirit => {
                if (!spirit.lastFed) {
                    spirit.lastFed = spirit.birthTime;
                }

                const timeSinceLastFed = now - spirit.lastFed;
                const hours = timeSinceLastFed / 1000 / 60 / 60;

                // 24시간 경과 - 사망만 체크 (배고픔 메시지는 getRandomMessage에서 처리)
                if (hours >= 24) {
                    if (getStage(spirit.growth) === 'egg') {
                        spirit.status = '❌ 알이 깨져서 미동이 없습니다...';
                        spirit.isDead = true;
                    } else {
                        spirit.status = '❌ 테라리움 밖으로 나가 사라졌습니다...';
                        spirit.isDead = true;
                    }
                }
            });
        }

        function updateAllSpiritCards() {
            spirits.forEach(spirit => {
                updateSpiritCard(spirit);
            });
        }


        // 쿨타임 텍스트만 업데이트 (성능 최적화)
        function updateCooldownDisplay() {
            if (currentTab !== 'garden' || isPaused) return;
            
            const now = Date.now();
            spirits.forEach((spirit, index) => {
                const cards = document.querySelectorAll('.spirit-card');
                const card = cards[index];
                if (!card) return;
                
                // 버튼들 찾기
                const buttons = card.querySelectorAll('button');
                buttons.forEach(button => {
                    const text = button.textContent;
                    
                    // 먹이주기 버튼
                    if (text.includes('먹이주기')) {
                        const canFeed = !isPaused && canDoAction(spirit, 'feed') && !spirit.isDead;
                        if (!canFeed && spirit.lastFeed) {
                            const remaining = Math.max(0, Math.ceil((10000 - (now - spirit.lastFeed)) / 1000));
                            button.textContent = `${spirit.isSick ? '🤢 ' : ''}먹이주기 (${remaining}초)`;
                        } else if (canFeed) {
                            button.textContent = `${spirit.isSick ? '🤢 ' : ''}먹이주기`;
                        }
                    }
                    
                    // 음악 듣기 버튼
                    if (text.includes('음악 듣기')) {
                        const canMusic = !isPaused && canDoAction(spirit, 'music') && !spirit.isDead;
                        if (!canMusic && spirit.lastMusic) {
                            const remaining = Math.max(0, Math.ceil((10000 - (now - spirit.lastMusic)) / 1000));
                            button.textContent = `음악 듣기 (${remaining}초)`;
                        } else if (canMusic) {
                            button.textContent = `음악 듣기`;
                        }
                    }
                    
                    // 쓰다듬기 버튼
                    if (text.includes('쓰다듬기')) {
                        const canPat = !isPaused && canDoAction(spirit, 'pat') && !spirit.isDead;
                        if (!canPat && spirit.lastPat) {
                            const remaining = Math.max(0, Math.ceil((10000 - (now - spirit.lastPat)) / 1000));
                            button.textContent = `쓰다듬기 (${remaining}초)`;
                        } else if (canPat) {
                            button.textContent = `쓰다듬기`;
                        }
                    }
                });
            });
        }

        function updateSpiritCard(spirit) {
            const cards = document.querySelectorAll('.spirit-card');
            const index = spirits.findIndex(s => s.id === spirit.id);
            if (index === -1 || !cards[index]) return;

            const card = cards[index];
            const stage = getStage(spirit.growth);
            const nextReq = getNextStageRequirement(spirit.growth);
            const progress = (spirit.growth / nextReq) * 100;
            
            const canFeed = canDoAction(spirit, 'feed') && !spirit.isDead;
            const canMusic = canDoAction(spirit, 'music') && !spirit.isDead;
            const canPat = canDoAction(spirit, 'pat') && !spirit.isDead;

            let icon = STAGE_ICONS[stage];
            if (stage === 'adult' && spirit.evolutionType) {
                const evolutionData = EVOLUTION_TYPES[spirit.evolutionType];
                if (evolutionData) {
                    icon = evolutionData.icon;
                }
            }
            if (spirit.isDead) {
                icon = stage === 'egg' ? '💔' : '👻';
            }

            // 아이콘 업데이트
            const iconElement = card.querySelector('.spirit-icon');
            if (iconElement && iconElement.textContent !== icon) {
                iconElement.textContent = icon;
            }

            // 스테이지 업데이트
            const stageElement = card.querySelector('.spirit-stage');
            if (stageElement) {
                stageElement.textContent = STAGE_NAMES[stage];
            }

            // 진행도 업데이트
            const progressFill = card.querySelector('.progress-fill');
            if (progressFill) {
                progressFill.style.width = `${Math.min(progress, 100)}%`;
            }

            const progressText = card.querySelector('.progress-text');
            if (progressText) {
                progressText.textContent = `성장 ${spirit.growth} / ${nextReq}`;
            }

            // 파라미터 업데이트
            const params = card.querySelectorAll('.param');
            if (params.length >= 4) {
                params[0].innerHTML = `<span class="param-icon">🧠</span>지력 ${spirit.parameters.intelligence}`;
                params[1].innerHTML = `<span class="param-icon">💪</span>체력 ${spirit.parameters.strength}`;
                params[2].innerHTML = `<span class="param-icon">💖</span>매력 ${spirit.parameters.charm}`;
                params[3].innerHTML = `<span class="param-icon">❤️</span>애정 ${spirit.parameters.affection}`;
            }

            // 상태 메시지 업데이트
            const statusElement = card.querySelector('.spirit-status');
            if (statusElement) {
                statusElement.textContent = spirit.status;
            }

            // 버튼 상태 업데이트
            const actionButtons = card.querySelector('.action-buttons');
            if (actionButtons) {
                const buttons = actionButtons.querySelectorAll('button');
                if (buttons.length >= 4) {
                    buttons[0].disabled = !canFeed;
                    buttons[1].disabled = !canMusic;
                    buttons[2].disabled = !canPat;
                    // buttons[3]는 보내기 버튼이므로 항상 활성화
                }
            }
        }

        function toggleLogs(spiritId) {
            const logsDiv = document.getElementById(`logs${spiritId}`);
            const toggleIcon = document.getElementById(`logToggle${spiritId}`);
            
            if (logsDiv.style.display === 'none') {
                logsDiv.style.display = 'block';
                toggleIcon.textContent = '▲';
            } else {
                logsDiv.style.display = 'none';
                toggleIcon.textContent = '▼';
            }
        }

        function renderSpirits() {
            const grid = document.getElementById('spiritsGrid');
            const now = Date.now(); // 쿨타임 계산용
            
            if (spirits.length === 0) {
                grid.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-icon">🥚</div>
                        <div>아직 정령이 없습니다<br>새로운 알을 받아보세요</div>
                    </div>
                `;
                return;
            }

            grid.innerHTML = spirits.map(spirit => {
                const stage = getStage(spirit.growth);
                const nextReq = getNextStageRequirement(spirit.growth);
                const progress = (spirit.growth / nextReq) * 100;
                
                const canFeed = !isPaused && canDoAction(spirit, 'feed') && !spirit.isDead;
                const canMusic = !isPaused && canDoAction(spirit, 'music') && !spirit.isDead;
                const canPat = !isPaused && canDoAction(spirit, 'pat') && !spirit.isDead;

                let icon = STAGE_ICONS[stage];
                if (stage === 'adult' && spirit.evolutionType) {
                    const evolutionData = EVOLUTION_TYPES[spirit.evolutionType];
                    if (evolutionData) {
                        icon = evolutionData.icon;
                    }
                }
                if (spirit.isDead) {
                    icon = stage === 'egg' ? '💔' : '👻';
                }

                // 하위 호환성을 위한 파라미터 체크
                if (!spirit.parameters.affection && spirit.parameters.mystery !== undefined) {
                    spirit.parameters.affection = spirit.parameters.mystery;
                    delete spirit.parameters.mystery;
                }
                if (!spirit.hiddenAttributes) {
                    spirit.hiddenAttributes = {
                        fire: 0, water: 0, wind: 0, earth: 0, light: 0, dark: 0
                    };
                }
                if (!spirit.logs) {
                    spirit.logs = [];
                }
                if (!spirit.lightTime) {
                    spirit.lightTime = 0;
                }
                if (!spirit.darkTime) {
                    spirit.darkTime = 0;
                }
                if (!spirit.musicListened) {
                    spirit.musicListened = 0;
                }
                if (!spirit.feedCount) {
                    spirit.feedCount = 0;
                }
                
                // 완성된 정령인 경우 특별한 카드 표시
                if (spirit.isCompleted && spirit.evolutionData) {
                    return `
                        <div class="spirit-card" style="background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%); border: 3px solid #ffa500;">
                            <div style="text-align: center; padding: 20px;">
                                <div style="font-size: 4rem; margin-bottom: 15px;">${spirit.evolutionData.icon}</div>
                                <div style="font-size: 1.3rem; font-weight: 700; color: #333; margin-bottom: 10px;">
                                    🎉 번데기에서 정령이 부화했습니다! 🎉
                                </div>
                                <div style="font-size: 1rem; color: #555; margin-bottom: 8px;">
                                    ${spirit.name} → ${spirit.evolutionData.name}
                                </div>
                                <div style="font-size: 0.9rem; color: #666; margin-bottom: 20px;">
                                    애정도: ${spirit.parameters.affection || 0}
                                </div>
                                <button onclick="confirmEvolution(${spirit.id})" style="
                                    background: #ff6b6b;
                                    color: white;
                                    border: none;
                                    padding: 15px 30px;
                                    font-size: 1.1rem;
                                    font-weight: 700;
                                    border-radius: 8px;
                                    cursor: pointer;
                                    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
                                ">
                                    확인하기
                                </button>
                            </div>
                        </div>
                    `;
                }
                // 외형 묘사 가져오기
                const appearance = getAppearanceDescription(spirit);

                return `
                    <div class="spirit-card" style="position: relative;">
                        ${(() => {
                            const satisfaction = spirit.satisfaction || 'mid';
                            const satisfactionIcons = { high: '', mid: '', low: '' };
                            const satisfactionTexts = { high: '만족', mid: '보통', low: '불만' };
                            const satisfactionColors = { high: '#4caf50', mid: '#ff9800', low: '#f44336' };
                            return `
                                <div style="position: absolute; top: 12px; right: 12px; display: flex; align-items: center; gap: 4px; padding: 4px 8px; background: ${satisfactionColors[satisfaction]}22; border: 1px solid ${satisfactionColors[satisfaction]}; border-radius: 12px; font-size: 0.75rem;">
                                    <span style="font-size: 1rem;">${satisfactionIcons[satisfaction]}</span>
                                    <span style="font-weight: 600; color: ${satisfactionColors[satisfaction]};">${satisfactionTexts[satisfaction]}</span>
                                </div>
                            `;
                        })()}
                        <div class="spirit-header">
                            <div class="spirit-icon" onclick="showAppearance(${spirit.id})" style="cursor: pointer;">${icon}</div>
                            <div class="spirit-info">
                                <div class="spirit-name" onclick="changeName(${spirit.id})">${spirit.name}</div>
                                <div class="spirit-stage">${STAGE_NAMES[stage]}</div>
                            </div>
                        </div>
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: ${Math.min(progress, 100)}%"></div>
                        </div>
                        <div class="progress-text">성장 ${spirit.growth} / ${nextReq}</div>
                        <div class="parameters">
                            <div class="param"><span class="param-icon">🧠</span>지력 ${spirit.parameters.intelligence}</div>
                            <div class="param"><span class="param-icon">💪</span>체력 ${spirit.parameters.strength}</div>
                            <div class="param"><span class="param-icon">💖</span>매력 ${spirit.parameters.charm}</div>
                            <div class="param"><span class="param-icon">❤️</span>애정 ${spirit.parameters.affection}</div>
                        </div>
                        ${(() => {
                            const keywords = getStatusKeywords(spirit);
                            if (keywords.length === 0) return '';
                            return `
                                <div style="margin: 12px 0; padding: 10px; background: var(--bg); border: 1px solid var(--border); display: flex; flex-wrap: wrap; gap: 6px;">
                                    ${keywords.map(kw => `
                                        <span style="
                                            display: inline-flex;
                                            align-items: center;
                                            padding: 4px 10px;
                                            background: #f5f5f5;
                                            border: 1px solid #ddd;
                                            font-size: 0.8rem;
                                            font-weight: 600;
                                            color: ${kw.color};
                                        ">
                                            ${kw.text}
                                        </span>
                                    `).join('')}
                                </div>
                            `;
                        })()}
                        <div class="spirit-status">${spirit.status}</div>
                        ${spirit.logs && spirit.logs.length > 0 ? `
                            <div style="margin-top: 12px; border-top: 1px solid var(--border); padding-top: 12px;">
                                <div style="display: flex; justify-content: space-between; align-items: center; cursor: pointer;" onclick="toggleLogs(${spirit.id})">
                                    <span style="font-size: 0.9rem; font-weight: 600;">일지 (${spirit.logs.length}개)</span>
                                    <span id="logToggle${spirit.id}" style="font-size: 0.8rem;">▼</span>
                                </div>
                                <div id="logs${spirit.id}" style="display: none; margin-top: 8px; max-height: 200px; overflow-y: auto;">
                                    ${spirit.logs.map(log => `
                                        <div style="font-size: 0.85rem; color: #888; padding: 4px 0; border-bottom: 1px solid var(--border);">
                                            <span style="color: #666;">${log.time}</span> - ${log.message}
                                        </div>
                                    `).join('')}
                                </div>
                            </div>
                        ` : ''}
                        <div class="action-buttons">
                            ${spirit.isSick ? `
                                <button onclick="giveMedicine(${spirit.id})" style="background: var(--earth); color: white; font-weight: 700;">
                                    🌿 약초 사용
                                </button>
                            ` : ''}
                            <button onclick="openFeedModal(${spirit.id})" ${!canFeed ? 'disabled' : ''}>
                                ${spirit.isSick ? '🤒 ' : ''}먹이주기${!canFeed && spirit.lastFeed ? ` (${Math.ceil((10000 - (now - spirit.lastFeed)) / 1000)}초)` : ''}
                            </button>
                            <button onclick="openMusicModal(${spirit.id})" ${!canMusic ? 'disabled' : ''}>
                                음악 듣기${!canMusic && spirit.lastMusic ? ` (${Math.max(0, Math.ceil((10000 - (now - spirit.lastMusic)) / 1000))}초)` : ''}
                            </button>
                            <button onclick="patSpirit(${spirit.id})" ${!canPat ? 'disabled' : ''}>
                                쓰다듬기${!canPat && spirit.lastPat ? ` (${Math.max(0, Math.ceil((10000 - (now - spirit.lastPat)) / 1000))}초)` : ''}
                            </button>
                            ${spirit.growth >= 100 && !spirit.isCompleted ? `
                                <button onclick="manualCompleteSpirit(${spirit.id})" style="background: #ffd700; color: #000; font-weight: 700;">
                                    진화하기
                                </button>
                            ` : ''}
                            <button onclick="confirmDeleteSpirit(${spirit.id})">
                                보내기
                            </button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function updateCoinDisplay() {
            const displays = document.querySelectorAll('#coinDisplay, #shopCoinDisplay');
            displays.forEach(el => {
                if (el) el.textContent = coins;
            });
        }


        function changeSellFilter() {
            const select = document.getElementById('sellFilterSelect');
            sellFilter = select.value;
            renderSellList();
        }

        function changeBuyFilter() {
            const select = document.getElementById('buyFilterSelect');
            buyFilter = select.value;
            renderBuyList();
        }

        function renderShop() {
            updateCoinDisplay();
            renderSellList();
            renderBuyList();
        }

        function renderSellList() {
            const container = document.getElementById('sellList');
            if (!container) return;

            const items = [];

            if (currentShopCategory === 'all' || currentShopCategory === 'food') {
                // 먹이 판매 (순서 고정)
                if (inventory.food && inventory.food.length > 0) {
                    const foodCounts = {};
                    inventory.food.forEach(f => {
                        foodCounts[f] = (foodCounts[f] || 0) + 1;
                    });

                    const foodOrder = ['fire', 'water', 'wind', 'earth', 'light', 'dark'];
                    foodOrder.filter(type => foodCounts[type]).forEach(type => {
                        // 속성 필터 체크
                        if (sellFilter === 'all') {
                            // 전체 보기
                        } else if (['intelligence', 'strength', 'charm'].includes(sellFilter)) {
                            return; // 스탯 필터 시 먹이 숨김
                        } else if (type !== sellFilter) {
                            return; // 다른 속성이면 숨김
                        }
                        
                        const count = foodCounts[type];
                        const isRare = type === 'light' || type === 'dark';
                        const price = isRare ? SHOP_PRICES.sell.food_rare : SHOP_PRICES.sell.food_common;
                        items.push(`
                            <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px; background: var(--bg); border: 1px solid var(--border); margin-bottom: 10px;">
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <span style="font-size: 1.5rem;">${ENV_ICONS[type]}</span>
                                    <div>
                                        <div style="font-weight: 700;">${FOOD_NAMES[type]} ×${count}</div>
                                        <div style="font-size: 0.85rem; color: #888;">판매가: ${price}💰</div>
                                    </div>
                                </div>
                                <button onclick="sellItem('food', '${type}')" style="padding: 8px 16px; background: var(--fire); color: white;">판매</button>
                            </div>
                        `);
                    });
                }
            }
            
            if (currentShopCategory === 'all' || currentShopCategory === 'decoration') {
                // 장식물 판매 (속성 → 품질 → 이름 순 정렬)
                if (inventory.decorations && inventory.decorations.length > 0) {
                    const decorCounts = {};
                    inventory.decorations.forEach(d => {
                        decorCounts[d] = (decorCounts[d] || 0) + 1;
                    });

                    // 속성별, 품질별, 이름별로 정렬
                    const sortedDecoKeys = Object.keys(decorCounts).sort((a, b) => {
                        const dataA = DECORATION_TYPES[a];
                        const dataB = DECORATION_TYPES[b];
                        if (!dataA || !dataB) return 0;
                        
                        // 1. 속성별 정렬
                        const attrOrder = { fire: 0, water: 1, wind: 2, earth: 3, light: 4, dark: 5 };
                        const attrDiff = (attrOrder[dataA.attr] || 0) - (attrOrder[dataB.attr] || 0);
                        if (attrDiff !== 0) return attrDiff;
                        
                        // 2. 품질별 정렬 (높은 순)
                        const qualityOrder = { epic: 0, rare: 1, common: 2 };
                        const qualityDiff = (qualityOrder[dataA.quality] || 2) - (qualityOrder[dataB.quality] || 2);
                        if (qualityDiff !== 0) return qualityDiff;
                        
                        // 3. 이름별 정렬
                        return dataA.name.localeCompare(dataB.name);
                    });
                    
                    sortedDecoKeys.forEach(key => {
                        const decoData = DECORATION_TYPES[key];
                        if (!decoData) return; // 데이터 없으면 스킵
                        
                        // 속성 필터 체크
                        if (sellFilter === 'all') {
                            // 전체 보기
                        } else if (['intelligence', 'strength', 'charm'].includes(sellFilter)) {
                            return; // 스탯 필터 시 장식물 숨김
                        } else if (decoData.attr !== sellFilter) {
                            return; // 다른 속성이면 숨김
                        }
                        
                        const count = decorCounts[key];
                        
                        const sellPrice = Math.floor(decoData.price * 0.5); // 판매가는 구매가의 50%
                        const qualityLabel = decoData.quality === 'epic' ? '⭐' : decoData.quality === 'rare' ? '💎' : '';
                        
                        items.push(`
                            <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px; background: var(--bg); border: 1px solid var(--border); margin-bottom: 10px;">
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <span style="font-size: 1.5rem;">${qualityLabel}${decoData.icon}</span>
                                    <div>
                                        <div style="font-weight: 700;">${decoData.name} ×${count}</div>
                                        <div style="font-size: 0.85rem; color: #888;">판매가: ${sellPrice}💰</div>
                                    </div>
                                </div>
                                <button onclick="sellItem('decoration', '${key}')" style="padding: 8px 16px; background: var(--fire); color: white;">판매</button>
                            </div>
                        `);
                    });
                }
            }

            

            if (currentShopCategory === 'all' || currentShopCategory === 'music') {
                // 음악 판매 (순서 고정)
                if (inventory.music && inventory.music.length > 0) {
                    const musicCounts = {};
                    inventory.music.forEach(m => {
                        musicCounts[m] = (musicCounts[m] || 0) + 1;
                    });

                    const musicOrder = ['classic', 'jazz', 'rock', 'pop', 'ballad'];
                    musicOrder.filter(type => musicCounts[type]).forEach(type => {
                        const musicData = MUSIC_TYPES[type];
                        
                        // 스탯 필터 체크 (음악 전용)
                        if (sellFilter === 'all') {
                            // 전체 보기일 때는 필터링 안 함
                        } else if (sellFilter === 'intelligence') {
                            if (type !== 'classic') return;
                        } else if (sellFilter === 'strength') {
                            if (type !== 'rock') return;
                        } else if (sellFilter === 'charm') {
                            if (!['jazz', 'pop', 'ballad'].includes(type)) return;
                        } else if (['fire', 'water', 'wind', 'earth', 'light', 'dark'].includes(sellFilter)) {
                            return; // 속성 필터 시 음악 숨김
                        }
                        
                        const count = musicCounts[type];
                        items.push(`
                            <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px; background: var(--bg); border: 1px solid var(--border); margin-bottom: 10px;">
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <span style="font-size: 1.5rem;">🎵</span>
                                    <div>
                                        <div style="font-weight: 700;">${musicData.name} ×${count}</div>
                                        <div style="font-size: 0.85rem; color: #888;">판매가: ${SHOP_PRICES.sell.music}💰</div>
                                    </div>
                                </div>
                                <button onclick="sellItem('music', '${type}')" style="padding: 8px 16px; background: var(--fire); color: white;">판매</button>
                            </div>
                        `);
                    });
                }
            }

            if (items.length === 0) {
                container.innerHTML = '<p style="color: #888; text-align: center; padding: 20px;">판매할 물품이 없습니다</p>';
            } else {
                container.innerHTML = items.join('');
            }
        }

        function renderBuyList() {
            const container = document.getElementById('buyList');
            if (!container) return;

            const items = [];
            
            if (currentShopCategory === 'all' || currentShopCategory === 'food') {
                // 약초 구매 (제일 위에 표시)
                items.push(`
                    <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px; background: var(--bg); border: 1px solid var(--border); margin-bottom: 10px;">
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <span style="font-size: 1.5rem;">${MEDICINE.icon}</span>
                            <div>
                                <div style="font-weight: 700;">${MEDICINE.name}</div>
                                <div style="font-size: 0.85rem; color: #666;">${MEDICINE.description}</div>
                                <div style="font-size: 0.85rem; color: #888;">가격: ${MEDICINE.price}💰</div>
                            </div>
                        </div>
                        <button onclick="buyItem('medicine', 'medicine', ${MEDICINE.price})" style="padding: 8px 16px;">구매</button>
                    </div>
                `);
                
                // 일반 먹이 구매
                ['fire', 'water', 'wind', 'earth'].forEach(type => {
                    // 속성 필터 체크
                    if (buyFilter === 'all') {
                        // 전체 보기
                    } else if (['intelligence', 'strength', 'charm'].includes(buyFilter)) {
                        return; // 스탯 필터 시 먹이 숨김
                    } else if (type !== buyFilter) {
                        return; // 다른 속성이면 숨김
                    }
                    
                    items.push(`
                        <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px; background: var(--bg); border: 1px solid var(--border); margin-bottom: 10px;">
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <span style="font-size: 1.5rem;">${ENV_ICONS[type]}</span>
                                <div>
                                    <div style="font-weight: 700;">${FOOD_NAMES[type]}</div>
                                    <div style="font-size: 0.85rem; color: #888;">가격: ${SHOP_PRICES.buy.food_common}💰</div>
                                </div>
                            </div>
                            <button onclick="buyItem('food', '${type}', ${SHOP_PRICES.buy.food_common})" style="padding: 8px 16px;">구매</button>
                        </div>
                    `);
                });

                // 희귀 먹이 구매
                ['light', 'dark'].forEach(type => {
                    // 속성 필터 체크
                    if (buyFilter === 'all') {
                        // 전체 보기
                    } else if (['intelligence', 'strength', 'charm'].includes(buyFilter)) {
                        return; // 스탯 필터 시 먹이 숨김
                    } else if (type !== buyFilter) {
                        return; // 다른 속성이면 숨김
                    }
                    
                    items.push(`
                        <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px; background: var(--bg); border: 1px solid var(--border); margin-bottom: 10px;">
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <span style="font-size: 1.5rem;">${ENV_ICONS[type]}</span>
                                <div>
                                    <div style="font-weight: 700;">${FOOD_NAMES[type]}</div>
                                    <div style="font-size: 0.85rem; color: #888;">가격: ${SHOP_PRICES.buy.food_rare}💰</div>
                                </div>
                            </div>
                            <button onclick="buyItem('food', '${type}', ${SHOP_PRICES.buy.food_rare})" style="padding: 8px 16px;">구매</button>
                        </div>
                    `);
                });
            }

            

            if (currentShopCategory === 'all' || currentShopCategory === 'music') {
                // 음악 구매
                Object.keys(MUSIC_TYPES).forEach(type => {
                    // 스탯 필터 체크 (음악 전용)
                    if (buyFilter === 'all') {
                        // 전체 보기일 때는 필터링 안 함
                    } else if (buyFilter === 'intelligence') {
                        if (type !== 'classic') return;
                    } else if (buyFilter === 'strength') {
                        if (type !== 'rock') return;
                    } else if (buyFilter === 'charm') {
                        if (!['jazz', 'pop', 'ballad'].includes(type)) return;
                    } else if (['fire', 'water', 'wind', 'earth', 'light', 'dark'].includes(buyFilter)) {
                        return; // 속성 필터 시 음악 숨김
                    }
                    
                    const musicData = MUSIC_TYPES[type];
                    items.push(`
                        <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px; background: var(--bg); border: 1px solid var(--border); margin-bottom: 10px;">
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <span style="font-size: 1.5rem;">🎵</span>
                                <div>
                                    <div style="font-weight: 700;">${musicData.name}</div>
                                    <div style="font-size: 0.85rem; color: #888;">가격: ${SHOP_PRICES.buy.music}💰</div>
                                </div>
                            </div>
                            <button onclick="buyItem('music', '${type}', ${SHOP_PRICES.buy.music})" style="padding: 8px 16px;">구매</button>
                        </div>
                    `);
                });
            }
            
            if (currentShopCategory === 'all' || currentShopCategory === 'decoration') {
                // 장식물 구매 (등급별 그룹화)
                const decorationsByQuality = {
                    common: [],
                    rare: [],
                    epic: []
                };
                
                Object.keys(DECORATION_TYPES).forEach(key => {
                    const decoData = DECORATION_TYPES[key];
                    
                    // 속성 필터 체크
                    if (buyFilter === 'all') {
                        // 전체 보기
                    } else if (['intelligence', 'strength', 'charm'].includes(buyFilter)) {
                        return; // 스탯 필터 시 장식물 숨김
                    } else if (decoData.attr !== buyFilter) {
                        return; // 다른 속성이면 숨김
                    }
                    
                    decorationsByQuality[decoData.quality].push({ key, data: decoData });
                });
                
                // 일반 장식물
                items.push(`<div style="margin: 20px 0; padding: 10px; background: #f0f0f0; color: #333; font-weight: 700;">🏠 일반 장식물</div>`);
                decorationsByQuality.common.forEach(({ key, data }) => {
                    items.push(`
                        <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px; background: var(--bg); border: 1px solid var(--border); margin-bottom: 10px;">
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <span style="font-size: 1.5rem;">${data.icon}</span>
                                <div>
                                    <div style="font-weight: 700;">${data.name}</div>
                                    <div style="font-size: 0.85rem; color: #888;">가격: ${data.price}💰 | ${data.attr} +${data.power}</div>
                                </div>
                            </div>
                            <button onclick="buyItem('decoration', '${key}', ${data.price})" style="padding: 8px 16px;">구매</button>
                        </div>
                    `);
                });
                
                // 희귀 장식물
                items.push(`<div style="margin: 20px 0; padding: 10px; background: #e3f2fd; color: #1565c0; font-weight: 700;">💎 희귀 장식물</div>`);
                decorationsByQuality.rare.forEach(({ key, data }) => {
                    items.push(`
                        <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px; background: var(--bg); border: 1px solid var(--border); margin-bottom: 10px;">
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <span style="font-size: 1.5rem;">💎${data.icon}</span>
                                <div>
                                    <div style="font-weight: 700;">${data.name}</div>
                                    <div style="font-size: 0.85rem; color: #888;">가격: ${data.price}💰 | ${data.attr} +${data.power}</div>
                                </div>
                            </div>
                            <button onclick="buyItem('decoration', '${key}', ${data.price})" style="padding: 8px 16px;">구매</button>
                        </div>
                    `);
                });
                
                // 최상급 장식물
                items.push(`<div style="margin: 20px 0; padding: 10px; background: #fff3e0; color: #e65100; font-weight: 700;">⭐ 최상급 장식물</div>`);
                decorationsByQuality.epic.forEach(({ key, data }) => {
                    items.push(`
                        <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px; background: var(--bg); border: 1px solid var(--border); margin-bottom: 10px;">
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <span style="font-size: 1.5rem;">⭐${data.icon}</span>
                                <div>
                                    <div style="font-weight: 700;">${data.name}</div>
                                    <div style="font-size: 0.85rem; color: #888;">가격: ${data.price}💰 | ${data.attr} +${data.power}</div>
                                </div>
                            </div>
                            <button onclick="buyItem('decoration', '${key}', ${data.price})" style="padding: 8px 16px;">구매</button>
                        </div>
                    `);
                });
            }

            container.innerHTML = items.length > 0 ? items.join('') : '<p style="color: #888; text-align: center; padding: 20px;">구매 가능한 물품이 없습니다</p>';
        }

        function sellItem(category, type) {
            if (category === 'food') {
                const index = inventory.food.indexOf(type);
                if (index === -1) return;
                inventory.food.splice(index, 1);
                const isRare = type === 'light' || type === 'dark';
                const price = isRare ? SHOP_PRICES.sell.food_rare : SHOP_PRICES.sell.food_common;
                coins += price;
                showNotification(`${FOOD_NAMES[type]}을(를) ${price}💰에 판매했습니다`);
            } else if (category === 'decoration') {
                const index = inventory.decorations.indexOf(type);
                if (index === -1) return;
                inventory.decorations.splice(index, 1);
                
                const decoData = DECORATION_TYPES[type];
                const sellPrice = Math.floor(decoData.price * 0.5);
                coins += sellPrice;
                showNotification(`${decoData.name}을(를) ${sellPrice}💰에 판매했습니다`);
            } else if (category === 'music') {
                const index = inventory.music.indexOf(type);
                if (index === -1) return;
                inventory.music.splice(index, 1);
                coins += SHOP_PRICES.sell.music;
                showNotification(`${MUSIC_TYPES[type].name}을(를) ${SHOP_PRICES.sell.music}💰에 판매했습니다`);
            }

            saveGame();
            renderShop();
            renderInventory();
        }

        function buyItem(category, type, price) {
            if (coins < price) {
                showNotification('코인이 부족합니다!');
                return;
            }

            coins -= price;

            if (category === 'food') {
                if (!inventory.food) inventory.food = [];
                inventory.food.push(type);
                if (type === 'medicine') {
                    showNotification(`${MEDICINE.name}을(를) ${price}💰에 구매했습니다`);
                } else {
                    showNotification(`${FOOD_NAMES[type]}을(를) ${price}💰에 구매했습니다`);
                }
            } else if (category === 'music') {
                if (!inventory.music) inventory.music = [];
                inventory.music.push(type);
                showNotification(`${MUSIC_TYPES[type].name}을(를) ${price}💰에 구매했습니다`);
            } else if (category === 'decoration') {
                if (!inventory.decorations) inventory.decorations = [];
                inventory.decorations.push(type);
                showNotification(`${DECORATION_TYPES[type].name}을(를) ${price}💰에 구매했습니다`);
            }

            saveGame();
            renderShop();
            renderInventory();
        }


        // 앨범 데이터로부터 도감 재구성
        function rebuildEncyclopediaFromAlbum() {
            console.log('앨범에서 도감 재구성 시작...');
            console.log('앨범 데이터:', collection);
            
            const newEncyclopedia = {};
            
            collection.forEach(spirit => {
                let encyclopediaKey;
                
                if (spirit.type === 'titania' || spirit.type === 'oberon') {
                    // 전설적 존재는 고유 키 사용
                    encyclopediaKey = spirit.type;
                } else if (spirit.type === 'nostat') {
                    // 수식어 없는 정령
                    encyclopediaKey = `nostat-${spirit.attributeType}`;
                } else {
                    // 일반 정령 (스탯-속성)
                    encyclopediaKey = `${spirit.type}-${spirit.attributeType}`;
                }
                
                if (!newEncyclopedia[encyclopediaKey]) {
                    newEncyclopedia[encyclopediaKey] = 0;
                }
                newEncyclopedia[encyclopediaKey]++;
            });
            
            console.log('재구성된 도감:', newEncyclopedia);
            encyclopedia = newEncyclopedia;
            saveGame();
            
            return Object.keys(newEncyclopedia).length;
        }


        async function manualRebuildEncyclopedia() {
            if (collection.length === 0) {
                showNotification('앨범에 데이터가 없어 복구할 수 없습니다');
                return;
            }
            
            const confirmed = await showConfirm(
                '도감 복구',
                `앨범에 있는 ${collection.length}마리의 정령 데이터로 도감을 다시 구성합니다.\n\n기존 도감 데이터는 덮어씌워집니다.\n계속하시겠습니까?`
            );
            
            if (!confirmed) {
                return;
            }
            
            const recoveredCount = rebuildEncyclopediaFromAlbum();
            renderEncyclopedia();
            showNotification(`✅ 도감을 복구했습니다! (${recoveredCount}종)`);
        }

        function renderEncyclopedia() {
            try {
                console.log('도감 렌더링 시작');
                console.log('현재 도감:', encyclopedia);
                console.log('현재 앨범:', collection);
                
                const grid = document.getElementById('encyclopediaGrid');
                if (!grid) {
                    console.error('encyclopediaGrid 엘리먼트를 찾을 수 없습니다');
                    return;
                }
                
                // encyclopedia가 null이거나 undefined인 경우 초기화
                if (!encyclopedia || typeof encyclopedia !== 'object') {
                    console.warn('⚠️ 도감 데이터가 유효하지 않음 - 초기화');
                    encyclopedia = {};
                }
                
                // 도감이 비어있는데 앨범에 데이터가 있으면 자동 복구
                if (Object.keys(encyclopedia).length === 0 && collection && collection.length > 0) {
                    console.log('⚠️ 도감이 비어있지만 앨범에 데이터 존재 - 자동 복구 시작');
                    try {
                        const recoveredCount = rebuildEncyclopediaFromAlbum();
                        showNotification(`도감을 복구했습니다! (${recoveredCount}종)`);
                    } catch (rebuildError) {
                        console.error('도감 복구 실패:', rebuildError);
                    }
                }
            
            const statTypes = [
                { key: 'nostat', name: '(수식어 없음)' },
                { key: 'intelligent', name: '지적인 계열' },
                { key: 'strong', name: '강한 계열' },
                { key: 'beautiful', name: '아름다운 계열' }
            ];
            
            // 속성별 그룹 정의
            const attributeGroups = [
                {
                    title: '⚪ 순수',
                    attrs: ['normal']
                },
                {
                    title: '🔥💧🌬️🌱✨🌙 기본 속성',
                    attrs: ['fire', 'water', 'wind', 'earth', 'light', 'dark']
                },
                {
                    title: '🔥 화염 조합',
                    attrs: ['fire-water', 'fire-wind', 'fire-earth', 'fire-light', 'fire-dark']
                },
                {
                    title: '💧 빙하 조합',
                    attrs: ['water-wind', 'water-earth', 'water-light', 'water-dark']
                },
                {
                    title: '🌬️ 질풍 조합',
                    attrs: ['wind-earth', 'wind-light', 'wind-dark']
                },
                {
                    title: '🌱 대지 조합',
                    attrs: ['earth-light', 'earth-dark']
                },
                {
                    title: '✨🌙 환혹',
                    attrs: ['light-dark']
                },
                {
                    title: '⚖️🌪️ 다속성',
                    attrs: ['balanced', 'multi']
                }
            ];
            
            let html = '';
            
            // 전설적 존재 (티타니아/오베론) - 맨 위에 특별 표시
            html += `<div style="grid-column: 1 / -1; margin-top: 10px; margin-bottom: 15px;">
                <h2 style="font-family: 'Nanum Myeongjo', serif; font-size: 1.5rem; color: var(--text); border-bottom: 3px solid gold; padding-bottom: 10px;">
                    전설적 존재
                </h2>
            </div>`;
            
            // 티타니아
            const titaniaCount = encyclopedia['titania'] || 0;
            const titaniaUnlocked = titaniaCount > 0;
            html += `
                <div class="${titaniaUnlocked ? 'encyclopedia-card unlocked' : 'encyclopedia-card locked'}" style="min-height: 120px; border: 2px solid gold;">
                    <div class="encyclopedia-icon" style="font-size: 3rem;">${titaniaUnlocked ? '🦋✨' : '?'}</div>
                    <div class="encyclopedia-name" style="font-size: 1rem; font-weight: 700;">${titaniaUnlocked ? '티타니아' : '???????'}</div>
                    <div class="encyclopedia-count" style="font-size: 0.8rem;">${titaniaUnlocked ? `${titaniaCount}회` : '미달성'}</div>
                    <div style="font-size: 0.7rem; color: ${titaniaUnlocked ? 'gold' : '#888'}; margin-top: 5px;">${titaniaUnlocked ? ENCYCLOPEDIA_HINTS['titania'] : '나비를 거느리는 정령들의 군주.'}</div>
                </div>
            `;
            
            // 오베론
            const oberonCount = encyclopedia['oberon'] || 0;
            const oberonUnlocked = oberonCount > 0;
            html += `
                <div class="${oberonUnlocked ? 'encyclopedia-card unlocked' : 'encyclopedia-card locked'}" style="min-height: 120px; border: 2px solid gold;">
                    <div class="encyclopedia-icon" style="font-size: 3rem;">${oberonUnlocked ? '🦋🌙' : '?'}</div>
                    <div class="encyclopedia-name" style="font-size: 1rem; font-weight: 700;">${oberonUnlocked ? '오베론' : '???????'}</div>
                    <div class="encyclopedia-count" style="font-size: 0.8rem;">${oberonUnlocked ? `${oberonCount}회` : '미달성'}</div>
                    <div style="font-size: 0.7rem; color: ${oberonUnlocked ? 'gold' : '#888'}; margin-top: 5px;">${oberonUnlocked ? ENCYCLOPEDIA_HINTS['oberon'] : '나방을 거느리는 정령들의 군주.'}</div>
                </div>
            `;
            
            attributeGroups.forEach(group => {
                // 그룹 헤더
                html += `<div style="grid-column: 1 / -1; margin-top: 30px; margin-bottom: 15px;">
                    <h2 style="font-family: 'Nanum Myeongjo', serif; font-size: 1.5rem; color: var(--text); border-bottom: 3px solid var(--fire); padding-bottom: 10px;">
                        ${group.title}
                    </h2>
                </div>`;
                
                group.attrs.forEach(attrType => {
                    const attributeData = ATTRIBUTE_NAMES[attrType];
                    if (!attributeData) return;
                    
                    // 속성 아이콘만 표시 (이름 숨김)
                    html += `<div style="grid-column: 1 / -1; margin-top: 20px; margin-bottom: 10px;">
                        <h3 style="font-family: 'Nanum Myeongjo', serif; font-size: 1.2rem; color: var(--text); display: flex; align-items: center; gap: 10px;">
                            <span style="font-size: 2rem;">${attributeData.icon}</span>
                        </h3>
                    </div>`;
                    
                    // 가로로 나열 (수식어 없음 + 3개 스탯 계열)
                    statTypes.forEach(statInfo => {
                        let count = 0;
                        let displayName = '???????';
                        let displayIcon = '?';
                        let isUnlocked = false;
                        let achievedLevel = 'mid'; // 기본값 설정 (모든 경로에서 사용 가능)
                        
                        if (statInfo.key === 'nostat') {
                            // 수식어 없는 정령
                            count = encyclopedia[`nostat-${attrType}`] || 0;
                            isUnlocked = count > 0;
                            displayName = isUnlocked ? '(수식어 없음)' : '???????';
                            displayIcon = isUnlocked ? attributeData.icon : '?';
                        } else {
                            // 스탯 계열 정령
                            const lowCount = encyclopedia[`${statInfo.key}-low-${attrType}`] || 0;
                            const midCount = encyclopedia[`${statInfo.key}-mid-${attrType}`] || 0;
                            const highCount = encyclopedia[`${statInfo.key}-high-${attrType}`] || 0;
                            count = lowCount + midCount + highCount;
                            isUnlocked = count > 0;
                            
                            // 달성된 레벨 찾기 (우선순위: high > mid > low)
                            if (highCount > 0) achievedLevel = 'high';
                            else if (midCount > 0) achievedLevel = 'mid';
                            else if (lowCount > 0) achievedLevel = 'low';
                            
                            if (isUnlocked) {
                                const statPrefix = EVOLUTION_TYPES[`${statInfo.key}-${achievedLevel}`].prefix;
                                const statIcon = EVOLUTION_TYPES[`${statInfo.key}-${achievedLevel}`].icon;
                                displayName = statPrefix;
                                displayIcon = `${statIcon}${attributeData.icon}`;
                            }
                        }
                        
                        const cardClass = isUnlocked ? 'encyclopedia-card unlocked' : 'encyclopedia-card locked';
                        const countText = isUnlocked ? `${count}회` : '미달성';
                        
                        // 정령 전체 이름 생성
                        let fullName = '???????';
                        let hintKey = '';
                        
                        if (isUnlocked) {
                            if (statInfo.key === 'nostat') {
                                fullName = attributeData.name;
                                hintKey = `nostat-${attrType}`;
                            } else {
                                const statPrefix = EVOLUTION_TYPES[`${statInfo.key}-${achievedLevel}`].prefix;
                                fullName = `${statPrefix} ${attributeData.name}`;
                                hintKey = `${statInfo.key}-${achievedLevel}-${attrType}`;
                            }
                        }
                        
                        // 잠금 상태에서도 힌트 표시
                        let hint = '';
                        if (isUnlocked) {
                            hint = ENCYCLOPEDIA_HINTS[hintKey] || '';
                        } else {
                            // 잠금 상태일 때도 힌트 표시
                            if (statInfo.key === 'nostat') {
                                hint = ENCYCLOPEDIA_HINTS[`nostat-${attrType}`] || '???';
                            } else {
                                // 임의의 레벨로 힌트 표시 (mid 우선)
                                hint = ENCYCLOPEDIA_HINTS[`${statInfo.key}-mid-${attrType}`] || 
                                       ENCYCLOPEDIA_HINTS[`${statInfo.key}-low-${attrType}`] || '???';
                            }
                        }
                        
                        html += `
                            <div class="${cardClass}" style="min-height: 120px;">
                                <div class="encyclopedia-icon" style="font-size: 2.5rem;">${displayIcon}</div>
                                <div class="encyclopedia-name" style="font-size: 0.85rem; font-weight: 600;">${fullName}</div>
                                <div class="encyclopedia-count" style="font-size: 0.75rem; margin-top: 4px;">${countText}</div>
                                ${hint ? `<div style="font-size: 0.7rem; color: #888; margin-top: 6px; line-height: 1.3; padding: 0 8px; text-align: center;">${hint}</div>` : ''}
                            </div>
                        `;
                    });
                });
            });
            
            grid.innerHTML = html;
            } catch (error) {
                console.error('도감 렌더링 오류:', error);
                console.error('오류 스택:', error.stack);
                console.error('현재 도감 데이터:', encyclopedia);
                console.error('현재 앨범 데이터:', collection);
                
                const grid = document.getElementById('encyclopediaGrid');
                if (grid) {
                    grid.innerHTML = `
                        <div style="text-align: center; padding: 40px;">
                            <div style="color: #f44336; font-size: 1.2rem; margin-bottom: 20px;">⚠️ 도감 렌더링 오류</div>
                            <div style="color: #666; margin-bottom: 20px;">
                                오류: ${error.message}<br>
                                도감 항목: ${Object.keys(encyclopedia).length}개<br>
                                앨범 항목: ${collection.length}개
                            </div>
                            <button onclick="manualRebuildEncyclopedia()" style="padding: 12px 24px; background: var(--water); color: white; border: none; border-radius: 8px; font-weight: 700; cursor: pointer; margin-right: 10px;">
                                📚 앨범에서 도감 복구
                            </button>
                            <button onclick="renderEncyclopedia()" style="padding: 12px 24px; background: var(--fire); color: white; border: none; border-radius: 8px; font-weight: 700; cursor: pointer;">
                                🔄 다시 시도
                            </button>
                        </div>
                    `;
                }
            }
        }

        function renderCollection() {
            try {
                console.log('앨범 렌더링 시작');
                const grid = document.getElementById('collectionGrid');
                if (!grid) {
                    console.error('collectionGrid 엘리먼트를 찾을 수 없습니다');
                    return;
                }
            
            if (collection.length === 0) {
                grid.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-icon">📖</div>
                        <div>아직 등록된 정령이 없습니다<br>정령을 성충까지 키워보세요</div>
                    </div>
                `;
                return;
            }

            // 역순으로 표시 (최근 것이 맨 앞에)
            const reversedCollection = [...collection].reverse();
            
            grid.innerHTML = reversedCollection.map((item, reverseIndex) => {
                const index = collection.length - 1 - reverseIndex; // 원본 인덱스
                // desc는 도감 아이템에 저장되어 있음
                const desc = item.desc || '';
                const originalName = item.originalName || item.name || '이름 없음';
                
                // 날개 이모지 결정
                let wingEmoji = '';
                if (item.wingType === 'butterfly') {
                    wingEmoji = '🦋';
                } else if (item.wingType === 'moth') {
                    wingEmoji = '🦋'; // 나방도 나비 이모지 사용 (시각적으로 구분)
                } else if (item.wingType === 'both') {
                    wingEmoji = '🦋🦋';
                }
                
                return `
                    <div class="collection-card" onclick="showAlbumDetail(${index})" style="cursor: pointer; transition: transform 0.2s;" onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                        <div class="collection-icon">${item.icon}${wingEmoji}</div>
                        <div class="collection-name">${item.name}</div>
                        <div style="font-size: 0.85rem; color: #666; margin-top: 4px;">본명: ${originalName}</div>
                        ${item.wingType ? `<div style="font-size: 0.85rem; color: #888; margin-top: 4px;">${item.wingType === 'butterfly' ? '나비의 날개' : item.wingType === 'moth' ? '나방의 날개' : '나비와 나방의 날개'}</div>` : ''}
                        ${desc ? `<div style="font-size: 0.85rem; color: #888; margin-top: 8px; line-height: 1.4;">${desc}</div>` : ''}
                        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; margin-top: 12px;">
                            <div class="param">🧠 ${item.parameters.intelligence}</div>
                            <div class="param">💪 ${item.parameters.strength}</div>
                            <div class="param">${item.parameters.charm}</div>
                            <div class="param">${item.parameters.affection || 0}</div>
                        </div>
                        <div style="font-size: 0.75rem; color: #999; margin-top: 12px; text-align: center;">📊 클릭하여 상세 정보 보기</div>
                    </div>
                `;
            }).join('');
            } catch (error) {
                console.error('앨범 렌더링 오류:', error);
                console.error('오류 스택:', error.stack);
                const grid = document.getElementById('collectionGrid');
                if (grid) {
                    grid.innerHTML = `
                        <div style="text-align: center; padding: 40px;">
                            <div style="color: #f44336; font-size: 1.2rem; margin-bottom: 20px;">⚠️ 앨범 렌더링 오류</div>
                            <div style="color: #666;">오류: ${error.message}</div>
                        </div>
                    `;
                }
            }
        }

        function switchTab(tab) {
            try {
                console.log('탭 전환:', tab);
                currentTab = tab; // 현재 탭 저장
                
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
                
                if (tab === 'garden') {
                    document.querySelector('.tab:nth-child(1)').classList.add('active');
                    document.getElementById('gardenSection').classList.add('active');
                } else if (tab === 'terrarium') {
                    document.querySelector('.tab:nth-child(2)').classList.add('active');
                    document.getElementById('terrariumSection').classList.add('active');
                    renderTerrariumManagement();
                } else if (tab === 'shop') {
                    document.querySelector('.tab:nth-child(3)').classList.add('active');
                    document.getElementById('shopSection').classList.add('active');
                    renderShop();
                } else if (tab === 'encyclopedia') {
                    document.querySelector('.tab:nth-child(4)').classList.add('active');
                    document.getElementById('encyclopediaSection').classList.add('active');
                    renderEncyclopedia();
                } else if (tab === 'album') {
                    document.querySelector('.tab:nth-child(5)').classList.add('active');
                    document.getElementById('albumSection').classList.add('active');
                    renderCollection();
                } else if (tab === 'settings') {
                    document.querySelector('.tab:nth-child(6)').classList.add('active');
                    document.getElementById('settingsSection').classList.add('active');
                    updateSettingsInfo();
                }
            } catch (error) {
                console.error('탭 전환 오류:', error);
                console.error('오류 스택:', error.stack);
                showNotification('탭 전환 중 오류가 발생했습니다');
            }
        }


        // 설정 정보 업데이트
        function updateSettingsInfo() {
            // 다크모드 토글 상태 업데이트
            const toggle = document.getElementById('darkModeToggle');
            const slider = document.getElementById('darkModeSlider');
            if (toggle) {
                toggle.checked = darkModeLocked;
                if (darkModeLocked) {
                    slider.style.transform = 'translateX(28px)';
                    slider.parentElement.style.backgroundColor = '#4CAF50';
                } else {
                    slider.style.transform = 'translateX(0)';
                    slider.parentElement.style.backgroundColor = '#ccc';
                }
            }
        }
        
        // 다크 모드 고정 토글
        function toggleDarkModeLock() {
            darkModeLocked = !darkModeLocked;
            
            const slider = document.getElementById('darkModeSlider');
            if (darkModeLocked) {
                slider.style.transform = 'translateX(28px)';
                slider.parentElement.style.backgroundColor = '#4CAF50';
                showNotification('🌙 다크 모드가 고정되었습니다');
            } else {
                slider.style.transform = 'translateX(0)';
                slider.parentElement.style.backgroundColor = '#ccc';
                showNotification('🌓 조명에 따라 테마가 변경됩니다');
            }
            
            applyLightMode();
            saveGame();
        }
        
        // 게임 데이터 내보내기
        function exportGameData() {
            const gameData = {
                version: '2.1.0',
                exportDate: new Date().toISOString(),
                spirits: spirits,
                collection: collection,
                encyclopedia: encyclopedia,
                inventory: inventory,
                coins: coins,
                terrarium: terrarium,
                installedDecorations: installedDecorations,
                lightMode: lightMode,
                isPaused: isPaused,
                darkModeLocked: darkModeLocked
            };
            
            const dataStr = JSON.stringify(gameData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = `spirit-garden-backup-${new Date().toISOString().slice(0, 10)}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            
            showNotification('✅ 게임 데이터를 내보냈습니다');
        }
        
        // 게임 데이터 불러오기
        function importGameData() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                try {
                    const text = await file.text();
                    const gameData = JSON.parse(text);
                    
                    // 데이터 유효성 검사
                    if (!gameData.spirits || !gameData.collection || !gameData.inventory) {
                        throw new Error('올바른 게임 데이터 파일이 아닙니다');
                    }
                    
                    const confirmed = await showConfirm(
                        '데이터 불러오기',
                        `백업 파일을 불러오시겠습니까?\n\n백업 일시: ${new Date(gameData.exportDate).toLocaleString()}\n정령 수: ${gameData.spirits.length}\n앨범: ${gameData.collection.length}\n\n현재 데이터는 덮어씌워집니다.`
                    );
                    
                    if (!confirmed) return;
                    
                    // 데이터 복원
                    spirits = gameData.spirits || [];
                    collection = gameData.collection || [];
                    encyclopedia = gameData.encyclopedia || {};
                    inventory = gameData.inventory || { food: [], music: [], decorations: [], medicine: [] };
                    coins = gameData.coins || 0;
                    terrarium = gameData.terrarium || { fire: 0, water: 0, wind: 0, earth: 0, light: 0, dark: 0 };
                    installedDecorations = gameData.installedDecorations || [];
                    lightMode = gameData.lightMode !== undefined ? gameData.lightMode : true;
                    isPaused = gameData.isPaused || false;
                    darkModeLocked = gameData.darkModeLocked || false;
                    
                    saveGame();
                    
                    // UI 새로고침
                    renderSpirits();
                    renderInventory();
                    updateCoinDisplay();
                    applyLightMode();
                    updateSettingsInfo();
                    
                    showNotification('✅ 게임 데이터를 불러왔습니다');
                    switchTab('garden');
                } catch (error) {
                    console.error('데이터 불러오기 오류:', error);
                    showNotification('❌ 데이터 불러오기 실패: ' + error.message);
                }
            };
            
            input.click();
        }

        function recalculateTerrariumEnvironment() {
            // 환경 초기화
            terrarium = {
                fire: 0,
                water: 0,
                wind: 0,
                earth: 0,
                light: 0,
                dark: 0
            };

            // 설치된 모든 장식물을 순회하며 환경 계산
            installedDecorations.forEach(deco => {
                // 문자열 또는 객체 모두 지원
                const decoKey = typeof deco === 'string' ? deco : deco.type;
                const decoData = DECORATION_TYPES[decoKey];
                if (!decoData) return;
                
                const attr = decoData.attr;
                const power = decoData.power;
                
                // 해당 속성 증가 (최대 50까지)
                terrarium[attr] = Math.min(50, terrarium[attr] + power);

                // 대립 속성 감소 (power만큼)
                const opposites = {
                    fire: 'water',
                    water: 'fire',
                    wind: 'earth',
                    earth: 'wind',
                    light: 'dark',
                    dark: 'light'
                };
                const opposite = opposites[attr];
                if (opposite) {
                    terrarium[opposite] = Math.max(0, terrarium[opposite] - power);
                }
            });

            // 조명 효과 적용
            if (lightMode) {
                terrarium.light = Math.min(50, terrarium.light + 3);
                terrarium.dark = Math.max(0, terrarium.dark - 2);
            } else {
                terrarium.dark = Math.min(50, terrarium.dark + 3);
                terrarium.light = Math.max(0, terrarium.light - 2);
            }
        }

        function toggleLight() {
            const now = Date.now();
            
            // 현재 조명 변경 기록
            lightToggleHistory.push(now);
            
            // 1분(60초) 이전 기록 제거
            lightToggleHistory = lightToggleHistory.filter(time => (now - time) < 60000);
            
            // 1분 이내 5회 이상 변경 체크
            const isSpamming = lightToggleHistory.length >= 5;
            
            lightMode = !lightMode;
            
            // 정령들 반응
            spirits.forEach(spirit => {
                if (!spirit.isDead && !spirit.isCompleted) {
                    if (isSpamming) {
                        // 조명 남용 시 화내거나 춤추기
                        const spamMessages = [
                            `${spirit.name}이(가) 당신의 장난에 화를 냅니다.`,
                            `${spirit.name}이(가) 격한 춤을 춥니다.`,
                            `${spirit.name}이(가) 조명 장난에 짜증을 냅니다.`,
                            `${spirit.name}이(가) 어지러워합니다!`
                        ];
                        spirit.status = spamMessages[Math.floor(Math.random() * spamMessages.length)];
                        
                        // 일지 추가
                        addLog(spirit, spirit.status);
                        
                        // 애정도 -1
                        spirit.parameters.affection = Math.max(0, spirit.parameters.affection - 1);
                    } else {
                        // 정상적인 조명 전환 반응
                        if (lightMode) {
                            // 조명 켜짐
                            spirit.status = `${spirit.name}이(가) 갑자기 주변이 환해져 깜짝 놀랍니다.`;
                        } else {
                            // 조명 꺼짐
                            spirit.status = `${spirit.name}이(가) 갑자기 주변이 어두워져 깜짝 놀랍니다.`;
                        }
                        
                        // 일지 추가
                        addLog(spirit, spirit.status);
                    }
                }
            });
            
            applyLightMode();
            recalculateTerrariumEnvironment();
            saveGame();
            updateAllSpiritCards();
            if (document.getElementById('terrariumSection').classList.contains('active')) {
                renderTerrariumManagement();
            }
            
            if (isSpamming) {
                showNotification(lightMode ? '☀️ 조명을 켰습니다 (정령이 화를 냅니다!)' : '🌙 조명을 껐습니다 (정령이 화를 냅니다!)');
            } else {
                showNotification(lightMode ? '☀️ 조명을 켰습니다' : '🌙 조명을 껐습니다');
            }
        }

        function applyLightMode() {
            const icon = document.getElementById('lightIcon');
            
            // 다크 모드 고정이 활성화되어 있으면 조명 상태 무시
            if (darkModeLocked) {
                document.body.classList.add('dark-mode');
                if (icon) icon.textContent = '🌙';
                return;
            }
            
            if (lightMode) {
                document.body.classList.remove('dark-mode');
                if (icon) icon.textContent = '☀️';
            } else {
                document.body.classList.add('dark-mode');
                if (icon) icon.textContent = '🌙';
            }
        }
        
        // 일시정지 토글
        function togglePause() {
            isPaused = !isPaused;
            const pauseBtn = document.getElementById('pauseBtn');
            
            if (isPaused) {
                pausedAt = Date.now(); // 일시정지 시작 시간 기록
                pauseBtn.textContent = '▶️';
                pauseBtn.classList.add('paused');
                pauseBtn.title = '재개';
                showNotification('⏸️ 게임이 일시정지되었습니다');
            } else {
                if (pausedAt) {
                    // 일시정지했던 시간을 누적
                    totalPausedTime += (Date.now() - pausedAt);
                    pausedAt = null;
                }
                pauseBtn.textContent = '⏸️';
                pauseBtn.classList.remove('paused');
                pauseBtn.title = '일시정지';
                showNotification('▶️ 게임이 재개되었습니다');
            }
            
            // 버튼 상태 업데이트
            updateGatherButton();
            updateAllSpiritCards();
            
            saveGame();
        }
        
        // 게임 리셋
        async function resetGame() {
            const confirm1 = await showConfirm(
                '게임 초기화',
                '정말로 게임을 초기화하시겠습니까?\n\n모든 정령, 장식물, 먹이, 음악, 코인, 도감이 삭제됩니다.\n이 작업은 되돌릴 수 없습니다!'
            );
            
            if (!confirm1) {
                return;
            }
            
            const confirm2 = await showConfirm(
                '최종 확인',
                '다시 한 번 확인합니다.\n정말로 모든 데이터를 삭제하시겠습니까?'
            );
            
            if (!confirm2) {
                return;
            }
            
            // 모든 데이터 초기화
            spirits = [];
            collection = [];
            encyclopedia = {};
            inventory = {
                music: [],
                decorations: [],
                food: ['fire', 'fire', 'fire', 'water', 'water', 'water', 'wind', 'wind', 'wind', 'earth', 'earth', 'earth']
            };
            terrarium = {
                fire: 0,
                water: 0,
                wind: 0,
                earth: 0,
                light: 0,
                dark: 0
            };
            installedDecorations = [];
            lightMode = true;
            coins = 0;
            currentTitle = 'none';
            lastGatherTime = null;
            isPaused = false;
            pausedAt = null;
            totalPausedTime = 0;
            
            // localStorage 삭제
            localStorage.removeItem('spiritGardenV2');
            
            // UI 업데이트
            renderSpirits();
            renderInventory();
            updateCoinDisplay();
            applyLightMode();
            renderEncyclopedia();
            renderAlbum();
            
            const titleSelect = document.getElementById('titleSelect');
            if (titleSelect) {
                titleSelect.value = 'none';
            }
            
            const pauseBtn = document.getElementById('pauseBtn');
            if (pauseBtn) {
                pauseBtn.textContent = '⏸️';
                pauseBtn.classList.remove('paused');
            }
            
            showNotification('🔄 게임이 초기화되었습니다');
        }

        function renderTerrariumManagement() {
            // 환경 바 업데이트 (최대 50)
            Object.entries(terrarium).forEach(([attr, value]) => {
                const bar = document.getElementById(`terr${attr.charAt(0).toUpperCase() + attr.slice(1)}Bar`);
                const valueSpan = document.getElementById(`terr${attr.charAt(0).toUpperCase() + attr.slice(1)}Value`);
                if (bar) bar.style.width = `${(value / 50) * 100}%`;
                if (valueSpan) valueSpan.textContent = value;
            });
            
            // 전체 품질 업데이트
            const qualityEl = document.getElementById('terrariumQuality');
            if (qualityEl) {
                const avgQuality = calculateTerrariumQuality();
                qualityEl.textContent = avgQuality.toFixed(1);
                
                // 품질에 따른 색상 변경
                if (avgQuality > 4) {
                    qualityEl.style.color = '#4caf50'; // 초록 (높음)
                } else if (avgQuality > 3) {
                    qualityEl.style.color = '#ff9800'; // 주황 (보통)
                } else {
                    qualityEl.style.color = '#f44336'; // 빨강 (낮음)
                }
            }

            // 설치된 장식물 개수 업데이트
            const installedCountEl = document.getElementById('installedCount');
            if (installedCountEl) {
                installedCountEl.textContent = `${installedDecorations.length} / 20`;
            }

            // 설치된 장식물 목록
            const installedContainer = document.getElementById('installedDecorList');
            if (installedDecorations.length === 0) {
                installedContainer.innerHTML = '<p style="color: #888; text-align: center; padding: 20px;">설치된 장식물이 없습니다</p>';
            } else {
                const installedCounts = {};
                installedDecorations.forEach(d => {
                    // 문자열 또는 객체 모두 지원
                    const decoType = typeof d === 'string' ? d : d.type;
                    installedCounts[decoType] = (installedCounts[decoType] || 0) + 1;
                });

                // 속성별, 이름별로 정렬 (순서 고정)
                const sortedEntries = Object.entries(installedCounts).sort((a, b) => {
                    const dataA = DECORATION_TYPES[a[0]];
                    const dataB = DECORATION_TYPES[b[0]];
                    if (!dataA || !dataB) return 0;
                    
                    // 1. 속성별 정렬
                    const attrOrder = { fire: 0, water: 1, wind: 2, earth: 3, light: 4, dark: 5 };
                    const attrDiff = (attrOrder[dataA.attr] || 0) - (attrOrder[dataB.attr] || 0);
                    if (attrDiff !== 0) return attrDiff;
                    
                    // 2. 품질별 정렬 (높은 순)
                    const qualityOrder = { epic: 0, rare: 1, common: 2 };
                    const qualityDiff = (qualityOrder[dataA.quality] || 2) - (qualityOrder[dataB.quality] || 2);
                    if (qualityDiff !== 0) return qualityDiff;
                    
                    // 3. 이름별 정렬
                    return dataA.name.localeCompare(dataB.name);
                });
                
                installedContainer.innerHTML = `
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                        ${sortedEntries.map(([key, count]) => {
                            const decoData = DECORATION_TYPES[key];
                            if (!decoData) return '';
                            
                            const qualityLabel = decoData.quality === 'epic' ? '⭐' : decoData.quality === 'rare' ? '💎' : '';
                            return `
                                <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px; background: var(--bg); border: 1px solid var(--border); border-radius: 4px;">
                                    <div style="display: flex; align-items: center; gap: 8px;">
                                        <span style="font-size: 1.3rem;">${qualityLabel}${decoData.icon}</span>
                                        <div>
                                            <div style="font-weight: 700; font-size: 0.9rem;">${decoData.name} ×${count}</div>
                                            <div style="font-size: 0.75rem; color: #888;">${decoData.attr} +${decoData.power}</div>
                                        </div>
                                    </div>
                                    <button onclick="removeDecorationFromTerrarium('${key}')" style="padding: 6px 10px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.8rem;">
                                        회수
                                    </button>
                                </div>
                            `;
                        }).join('')}
                    </div>
                `;
            }

            // 인벤토리 장식물 목록
            const listContainer = document.getElementById('terrariumDecorList');
            if (!inventory.decorations) inventory.decorations = [];
            
            if (inventory.decorations.length === 0) {
                listContainer.innerHTML = '<p style="color: #888; text-align: center; padding: 20px;">보유한 장식물이 없습니다</p>';
                return;
            }

            const decorCounts = {};
            inventory.decorations.forEach(d => {
                decorCounts[d] = (decorCounts[d] || 0) + 1;
            });

            const canInstall = installedDecorations.length < 20;

            // 속성별, 품질별, 이름별로 정렬 (순서 고정)
            const sortedDecorEntries = Object.entries(decorCounts).sort((a, b) => {
                const dataA = DECORATION_TYPES[a[0]];
                const dataB = DECORATION_TYPES[b[0]];
                if (!dataA || !dataB) return 0;
                
                // 1. 속성별 정렬
                const attrOrder = { fire: 0, water: 1, wind: 2, earth: 3, light: 4, dark: 5 };
                const attrDiff = (attrOrder[dataA.attr] || 0) - (attrOrder[dataB.attr] || 0);
                if (attrDiff !== 0) return attrDiff;
                
                // 2. 품질별 정렬 (높은 순)
                const qualityOrder = { epic: 0, rare: 1, common: 2 };
                const qualityDiff = (qualityOrder[dataA.quality] || 2) - (qualityOrder[dataB.quality] || 2);
                if (qualityDiff !== 0) return qualityDiff;
                
                // 3. 이름별 정렬
                return dataA.name.localeCompare(dataB.name);
            });

            listContainer.innerHTML = `
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                    ${sortedDecorEntries.map(([key, count]) => {
                        const decoData = DECORATION_TYPES[key];
                        if (!decoData) return '';
                        
                        const qualityLabel = decoData.quality === 'epic' ? '⭐' : decoData.quality === 'rare' ? '💎' : '';
                        return `
                            <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px; background: var(--bg); border: 1px solid var(--border); border-radius: 4px;">
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    <span style="font-size: 1.3rem;">${qualityLabel}${decoData.icon}</span>
                                    <div>
                                        <div style="font-weight: 700; font-size: 0.9rem;">${decoData.name} ×${count}</div>
                                        <div style="font-size: 0.75rem; color: #888;">${decoData.attr} +${decoData.power}</div>
                                    </div>
                                </div>
                                <button onclick="placeDecorationInTerrarium('${key}')" style="padding: 6px 10px; border: none; border-radius: 4px; cursor: pointer; font-size: 0.8rem;" ${!canInstall ? 'disabled' : ''}>
                                    ${canInstall ? '설치' : '가득'}
                                </button>
                            </div>
                        `;
                    }).join('')}
                </div>
            `;
        }

        function placeDecorationInTerrarium(decorationType) {
            if (!inventory.decorations) inventory.decorations = [];
            
            // 최대 20개 체크
            if (installedDecorations.length >= 20) {
                showNotification('테라리움이 가득 찼습니다 (최대 20개)');
                return;
            }

            const invIndex = inventory.decorations.indexOf(decorationType);
            if (invIndex === -1) return;

            const decoData = DECORATION_TYPES[decorationType];

            // 같은 타입의 장식물이 있는지 확인 (위치 고정을 위해)
            const existingIndices = installedDecorations
                .map((d, i) => ({ type: typeof d === 'string' ? d : d.type, index: i }))
                .filter(d => d.type === decorationType)
                .map(d => d.index);
            
            let targetIndex = installedDecorations.length; // 기본값: 맨 뒤
            
            if (existingIndices.length > 0) {
                // 같은 타입이 있으면 그 다음 위치에 배치
                targetIndex = Math.max(...existingIndices) + 1;
            }

            // 인벤토리에서 제거
            inventory.decorations.splice(invIndex, 1);
            
            // 설치 목록에 추가 (위치 정보 포함)
            installedDecorations.splice(targetIndex, 0, { type: decorationType, index: targetIndex });
            
            // 인덱스 재정렬
            installedDecorations.forEach((d, i) => {
                if (typeof d === 'object') {
                    d.index = i;
                }
            });

            // 환경 재계산
            recalculateTerrariumEnvironment();

            // 만족도 즉시 업데이트
            spirits.forEach(spirit => {
                if (!spirit.isDead && !spirit.isCompleted) {
                    spirit.satisfaction = calculateSatisfaction(spirit);
                }
            });
            
            saveGame();
            renderTerrariumManagement();
            renderInventory();
            renderSpirits();  // 만족도 변경 반영
            showNotification(`${decoData.icon} ${decoData.name} 설치 완료`);
        }

        function removeDecorationFromTerrarium(decorationType) {
            // 문자열 또는 객체 모두 지원
            const index = installedDecorations.findIndex(d => 
                (typeof d === 'string' ? d : d.type) === decorationType
            );
            if (index === -1) return;

            const decoData = DECORATION_TYPES[decorationType];

            // 설치 목록에서 제거하고 인벤토리에 추가
            installedDecorations.splice(index, 1);
            
            // 인덱스 재정렬
            installedDecorations.forEach((d, i) => {
                if (typeof d === 'object') {
                    d.index = i;
                }
            });
            
            if (!inventory.decorations) inventory.decorations = [];
            inventory.decorations.push(decorationType);

            // 환경 재계산
            recalculateTerrariumEnvironment();
            
            // 정령들이 사라진 장식을 찾는 메시지 (3분 이내 랜덤)
            spirits.forEach(spirit => {
                if (!spirit.isDead && !spirit.isCompleted) {
                    const searchMessages = [
                        `${spirit.name}이(가) ${decoData.name}이(가) 어디갔는지 찾습니다.`,
                        `${spirit.name}이(가) ${decoData.name}을(를) 두리번거리며 찾습니다.`,
                        `${spirit.name}이(가) 사라진 ${decoData.name}을(를) 찾아 헤맵니다.`,
                        `${spirit.name}이(가) ${decoData.name}이(가) 없어져서 슬퍼합니다.`,
                        `${spirit.name}이(가) ${decoData.name}이(가) 그리워 보입니다.`
                    ];
                    const randomMessage = searchMessages[Math.floor(Math.random() * searchMessages.length)];
                    
                    // 0~180초(3분) 사이 랜덤 타이밍
                    const randomDelay = Math.random() * 180000; // 0 ~ 180000ms (0 ~ 3분)
                    
                    console.log(`${spirit.name}: ${randomDelay/1000}초 후에 "${randomMessage}" 표시 예정`);
                    
                    setTimeout(() => {
                        // 타임아웃 실행 시점에도 정령이 살아있고 완성되지 않았는지 재확인
                        const currentSpirit = spirits.find(s => s.id === spirit.id);
                        if (currentSpirit && !currentSpirit.isDead && !currentSpirit.isCompleted) {
                            console.log(`${currentSpirit.name}: 장식물 반응 표시 - "${randomMessage}"`);
                            currentSpirit.status = randomMessage;
                            
                            // 일지 추가
                            addLog(currentSpirit, randomMessage);
                            
                            updateSpiritCard(currentSpirit);
                        }
                    }, randomDelay);
                }
            });

            // 만족도 즉시 업데이트
            spirits.forEach(spirit => {
                if (!spirit.isDead && !spirit.isCompleted) {
                    spirit.satisfaction = calculateSatisfaction(spirit);
                }
            });
            
            saveGame();
            renderTerrariumManagement();
            renderInventory();
            renderSpirits();  // 만족도 변경 반영
            showNotification(`${decoData.icon} ${decoData.name} 회수 완료`);
        }

        // 랜덤 메시지 생성
        function getRandomMessage(spirit) {
            if (spirit.isDead || spirit.isCompleted) return spirit.status;
            
            const affection = spirit.parameters.affection || 0;
            const now = Date.now();
            const timeSinceLastFed = spirit.lastFed ? (now - spirit.lastFed) / 1000 : Infinity;
            const timeSinceLastMusic = spirit.lastMusic ? (now - spirit.lastMusic) / 1000 : Infinity;
            
            let availableMessages = [];
            
            // 배고픔 (5분=300초 이상 안 먹임) - 70% 확률로 배고픔 메시지
            if (timeSinceLastFed > 300 && Math.random() < 0.7) {
                availableMessages = [...RANDOM_MESSAGES.hungry];
            }
            // 배고픔이 아니거나, 배고픔이지만 30% 확률로 다른 메시지
            else {
                // 최근에 음악 들음 (5분=300초 이내, 30% 확률)
                if (timeSinceLastMusic < 300 && spirit.lastMusicType && Math.random() < 0.3) {
                    const musicName = MUSIC_TYPES[spirit.lastMusicType].name;
                    availableMessages = RANDOM_MESSAGES.music.map(msg => 
                        msg.replace('{music}', musicName)
                    );
                }
                // 장식물 설치됨 (30% 확률)
                else if (installedDecorations.length > 0 && Math.random() < 0.3) {
                    const randomDeco = installedDecorations[Math.floor(Math.random() * installedDecorations.length)];
                    const decoType = typeof randomDeco === 'string' ? randomDeco : randomDeco.type;
                    if (RANDOM_MESSAGES.decorations[decoType]) {
                        availableMessages = [...RANDOM_MESSAGES.decorations[decoType]];
                    }
                }
                // 테라리움이 텅 비어있음 (30% 확률)
                else if (installedDecorations.length === 0 && Math.random() < 0.3) {
                    availableMessages = [
                        `${spirit.name}이(가) 텅 빈 테라리움 안을 빙글빙글 돌아다닙니다.`,
                        `${spirit.name}이(가) 심심해 보입니다.`,
                        `${spirit.name}이(가) 아무것도 없는 공간을 두리번거립니다.`,
                        `${spirit.name}이(가) 무료해 보입니다.`
                    ];
                }
                // 잠 (조명에 따라, 15% 확률)
                else if (Math.random() < 0.15) {
                    if (lightMode) {
                        availableMessages = [...RANDOM_MESSAGES.napLight];
                    } else {
                        availableMessages = [...RANDOM_MESSAGES.sleepDark];
                    }
                }
            }
            
            // 위 조건에 해당 안 되면 애정도별 메시지
            if (availableMessages.length === 0) {
                if (affection >= 100) {
                    availableMessages = [...RANDOM_MESSAGES.affectionVeryHigh, ...RANDOM_MESSAGES.basic];
                } else if (affection >= 50) {
                    availableMessages = [...RANDOM_MESSAGES.affectionHigh, ...RANDOM_MESSAGES.basic];
                } else if (affection >= 30) {
                    availableMessages = [...RANDOM_MESSAGES.affectionMedium, ...RANDOM_MESSAGES.basic];
                } else if (affection >= 10) {
                    availableMessages = [...RANDOM_MESSAGES.affectionLow, ...RANDOM_MESSAGES.basic];
                } else {
                    availableMessages = [...RANDOM_MESSAGES.affectionVeryLow, ...RANDOM_MESSAGES.basic];
                }
            }
            
            // 랜덤 선택
            const randomMessage = availableMessages[Math.floor(Math.random() * availableMessages.length)];
            return randomMessage.replace('{name}', spirit.name);
        }
        
        // 30초마다 랜덤 메시지 업데이트
        // 30초마다 랜덤 메시지 업데이트
        // 정령 간 상호작용
        function triggerSpiritInteraction() {
            console.log('[상호작용] 체크 시작');
            
            if (isPaused) {
                console.log('[상호작용] 일시정지 중');
                return false;
            }
            
            // 살아있고 완성되지 않은 정령만
            const activeSpirits = spirits.filter(s => !s.isDead && !s.isCompleted);
            console.log('[상호작용] 활성 정령 수:', activeSpirits.length, activeSpirits.map(s => s.name));
            
            // 2마리 이상일 때만 상호작용
            if (activeSpirits.length < 2) {
                console.log('[상호작용] 정령 부족 (2마리 이상 필요)');
                return false;
            }
            
            // 50% 확률로 상호작용 발생 (테스트용 높은 확률!)
            const randomValue = Math.random();
            console.log('[상호작용] 확률 체크:', randomValue, '/ 0.5');
            if (randomValue > 0.5) {
                console.log('[상호작용] 확률 실패');
                return false;
            }
            
            console.log('[상호작용] 확률 성공! 상호작용 진행');
            
            // 랜덤하게 2마리 선택
            const spirit1 = activeSpirits[Math.floor(Math.random() * activeSpirits.length)];
            let spirit2;
            do {
                spirit2 = activeSpirits[Math.floor(Math.random() * activeSpirits.length)];
            } while (spirit2.id === spirit1.id);
            
            // 상호작용 종류 결정
            const interactionTypes = ['decoration', 'sharing', 'fight', 'rest', 'song', 'play', 'talk'];
            const weights = [20, 10, 5, 15, 10, 25, 15]; // 가중치 (%)
            
            let random = Math.random() * 100;
            let selectedType = 'play'; // 기본값
            let cumulative = 0;
            
            for (let i = 0; i < interactionTypes.length; i++) {
                cumulative += weights[i];
                if (random < cumulative) {
                    selectedType = interactionTypes[i];
                    break;
                }
            }
            
            console.log('[상호작용] 선택된 타입:', selectedType, '(랜덤 값:', random, ')');
            
            // 메시지 선택 및 적용
            const messages = RANDOM_MESSAGES.interaction[selectedType];
            console.log('[상호작용] 메시지 후보 수:', messages.length);
            
            let message = messages[Math.floor(Math.random() * messages.length)];
            console.log('[상호작용] 선택된 메시지 템플릿:', message);
            
            message = message
                .replace('{name1}', spirit1.name)
                .replace('{name2}', spirit2.name);
            
            console.log('[상호작용] 최종 메시지:', message);
            
            // 장식물 상호작용일 경우 장식물 이름 추가
            if (selectedType === 'decoration') {
                console.log('[상호작용] 장식물 개수:', installedDecorations.length);
                if (installedDecorations.length > 0) {
                    const randomDeco = installedDecorations[Math.floor(Math.random() * installedDecorations.length)];
                    const decoType = typeof randomDeco === 'string' ? randomDeco : randomDeco.type;
                    console.log('[상호작용] 선택된 장식물:', decoType);
                    const decoData = DECORATION_TYPES[decoType];
                    if (decoData) {
                        message = message.replace('{deco}', decoData.name);
                        console.log('[상호작用] 장식물 이름 적용:', decoData.name);
                    } else {
                        console.log('[상호작용] 장식물 데이터 없음, 취소');
                        return false; // 장식물 데이터 없으면 취소
                    }
                } else {
                    console.log('[상호작용] 장식물 없음, 취소');
                    return false; // 장식물 없으면 취소
                }
            }
            
            // 효과 적용
            switch (selectedType) {
                case 'sharing': // 먹이 나눔 - 둘 다 성장 +1
                    spirit1.growth = Math.min(100, spirit1.growth + 1);
                    spirit2.growth = Math.min(100, spirit2.growth + 1);
                    break;
                    
                case 'song': // 노래 - 랜덤 스탯 +1
                    const statTypes = ['intelligence', 'strength', 'charm'];
                    const randomStat = statTypes[Math.floor(Math.random() * statTypes.length)];
                    spirit2.parameters[randomStat] = Math.min(100, spirit2.parameters[randomStat] + 1);
                    break;
                    
                case 'fight': // 싸움 - 약간의 스트레스, 애정도 -1
                    spirit1.parameters.affection = Math.max(0, spirit1.parameters.affection - 1);
                    spirit2.parameters.affection = Math.max(0, spirit2.parameters.affection - 1);
                    break;
                    
                case 'rest': // 휴식 - 만족도 회복
                    // 특별한 효과 없음, 메시지만
                    break;
            }
            
            // 두 정령 모두 같은 메시지 표시
            spirit1.status = message;
            spirit2.status = message;
            console.log('[상호작용] 메시지 적용 완료:', spirit1.name, '/', spirit2.name);
            
            // 상호작용 시간 기록 (메시지 유지용)
            const now = Date.now();
            spirit1.lastSpiritInteraction = now;
            spirit2.lastSpiritInteraction = now;
            
            // 일지에 기록
            addLog(spirit1, message);
            console.log('[상호작용] 일지 기록 완료');
            
            // 성장도 체크 (100 이상이면 진화)
            if (spirit1.growth >= 100 && !spirit1.isCompleted) {
                completeSpirit(spirit1);
            }
            if (spirit2.growth >= 100 && !spirit2.isCompleted) {
                completeSpirit(spirit2);
            }
            
            saveGame();
            updateAllSpiritCards();
            
            console.log('[상호작용] ✅ 상호작용 성공!');
            return true; // 상호작용 발생!
        }

        function updateRandomMessages() {
            if (isPaused) return; // 일시정지 중이면 실행 안 함
            
            // 정령 간 상호작용 먼저 시도 (메시지 덮어쓰기 방지)
            const interactionOccurred = triggerSpiritInteraction();
            
            const now = Date.now();
            spirits.forEach(spirit => {
                if (!spirit.isDead && !spirit.isCompleted) {
                    // 정령 간 상호작용이 발생했으면 해당 정령 메시지 유지
                    if (interactionOccurred && spirit.lastSpiritInteraction && now - spirit.lastSpiritInteraction < 15000) {
                        return;
                    }
                    
                    // 최근 10초 이내에 플레이어 상호작용했으면 메시지 유지
                    const recentInteraction = (
                        (spirit.lastFeed && now - spirit.lastFeed < 10000) ||
                        (spirit.lastPat && now - spirit.lastPat < 10000) ||
                        (spirit.lastMusic && now - spirit.lastMusic < 10000)
                    );
                    
                    if (recentInteraction) {
                        return; // 메시지 유지
                    }
                    
                    // 모든 정령의 메시지를 15초마다 랜덤 업데이트
                    const oldStatus = spirit.status;
                    const newStatus = getRandomMessage(spirit);
                    
                    // 메시지가 변경되었고, 특정 시스템 메시지가 아니면 일지에 기록
                    if (newStatus !== oldStatus && !newStatus.includes('듣고 있습니다')) {
                        addLog(spirit, newStatus);
                    }
                    
                    spirit.status = newStatus;
                }
            });
            
            updateAllSpiritCards();
        }
        
        // 5분 방치 체크 (애정도 감소)
        function checkNeglect() {
            if (isPaused) return; // 일시정지 중이면 실행 안 함
            
            const now = Date.now();
            spirits.forEach(spirit => {
                if (spirit.isDead || spirit.isCompleted) return;
                
                // 알, 애벌레, 번데기 상태에서는 방치 체크 안 함
                if (!spirit.stage || spirit.stage === 'egg' || spirit.stage === 'larva' || spirit.stage === 'pupa') {
                    return;
                }
                
                // lastInteraction이 없으면 현재 시간으로 초기화 (구버전 호환)
                if (!spirit.lastInteraction) {
                    spirit.lastInteraction = now;
                    return;
                }
                
                // 일시정지 시간 제외한 실제 경과 시간 계산
                const currentPausedTime = isPaused ? (now - pausedAt) : 0;
                const effectivePausedTime = totalPausedTime + currentPausedTime;
                
                const timeSinceLastInteraction = (now - spirit.lastInteraction - effectivePausedTime) / 1000; // 초
                const minutesSinceInteraction = timeSinceLastInteraction / 60;
                
                // 5분마다 애정도 -1 감소
                // lastAffectionDrop이 없거나 5분 이상 지났으면 감소
                if (!spirit.lastAffectionDrop) {
                    spirit.lastAffectionDrop = now;
                }
                
                const timeSinceAffectionDrop = (now - spirit.lastAffectionDrop - effectivePausedTime) / 1000; // 초
                if (timeSinceAffectionDrop >= 300) { // 5분 = 300초
                    if (spirit.parameters.affection > 0) {
                        spirit.parameters.affection -= 1;
                        spirit.lastAffectionDrop = now;
                        addLog(spirit, '방치되어 애정도가 감소했습니다 (-1)');
                        saveGame();
                    }
                }
                
                // 아픈 상태에서 30분 방치 시 도망감
                if (spirit.isSick && !spirit.sickWarned && minutesSinceInteraction >= 30) {
                    spirit.sickWarned = true;
                    spirit.status = `${spirit.name}이(가) 아파서 괴로워합니다... 🤒💔`;
                    addLog(spirit, '아픈 상태로 오래 방치되고 있습니다!');
                    showNotification(`${spirit.name}이(가) 매우 괴로워합니다! 곧 떠날 수 있습니다!`);
                    saveGame();
                }
                
                // 아픈 상태에서 1시간 방치 시 도망감
                if (spirit.isSick && minutesSinceInteraction >= 60) {
                    spirit.status = `${spirit.name}이(가) 테라리움을 떠났습니다... 😢`;
                    addLog(spirit, '아픈 상태로 방치되어 떠났습니다');
                    showNotification(`😢 ${spirit.name}이(가) 테라리움을 떠났습니다...`);
                    deleteSpirit(spirit.id);
                    return;
                }
                
                // 건강한 상태에서 1시간(3600초) 방치 시 도망감
                if (!spirit.isSick && timeSinceLastInteraction >= 3600) {
                    spirit.status = `${spirit.name}이(가) 외로워서 테라리움을 떠났습니다... 😢`;
                    addLog(spirit, '오래 방치되어 떠났습니다');
                    showNotification(`😢 ${spirit.name}이(가) 외로워서 떠났습니다...`);
                    deleteSpirit(spirit.id);
                    return;
                }
            });
            updateAllSpiritCards();
        }


        // 데이터 백업 시스템
        function createBackup() {
            const backupData = {
                version: GAME_VERSION,
                collection: collection,
                encyclopedia: encyclopedia,
                timestamp: Date.now()
            };
            
            const backupJson = JSON.stringify(backupData, null, 2);
            const blob = new Blob([backupJson], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `spirit-garden-backup-${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            showNotification('백업 파일이 다운로드되었습니다!');
        }
        
        function importBackup() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const backupData = JSON.parse(event.target.result);
                        
                        // 백업 데이터 병합 (기존 데이터 유지)
                        if (backupData.collection && Array.isArray(backupData.collection)) {
                            backupData.collection.forEach(item => {
                                // 중복 체크 (같은 정령이 이미 있는지)
                                const exists = collection.some(c => 
                                    c.name === item.name && 
                                    c.originalName === item.originalName &&
                                    c.completedAt === item.completedAt
                                );
                                if (!exists) {
                                    collection.push(item);
                                }
                            });
                        }
                        
                        if (backupData.encyclopedia && typeof backupData.encyclopedia === 'object') {
                            // 도감 데이터 병합 (카운트 누적)
                            for (let key in backupData.encyclopedia) {
                                if (!encyclopedia[key]) {
                                    encyclopedia[key] = 0;
                                }
                                encyclopedia[key] += backupData.encyclopedia[key];
                            }
                        }
                        
                        saveGame();
                        renderCollection();
                        renderEncyclopedia();
                        showNotification(`백업 복원 완료! (앨범 ${backupData.collection?.length || 0}개 복원)`);
                    } catch (err) {
                        showNotification('백업 파일을 읽을 수 없습니다: ' + err.message);
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }


        function removeAllDecorations() {
            if (installedDecorations.length === 0) {
                showNotification('설치된 장식물이 없습니다');
                return;
            }
            
            showConfirm(
                '장식물 전체 해제',
                `설치된 장식물 ${installedDecorations.length}개를 모두 해제하시겠습니까?`,
                () => {
                    // 모든 장식물을 인벤토리로 반환
                installedDecorations.forEach(deco => {
                    // 문자열 또는 객체 모두 지원
                    const decoType = typeof deco === 'string' ? deco : deco.type;
                    inventory.decorations.push(decoType);
                    
                    // 테라리움 속성 감소
                    const decoData = DECORATION_TYPES[decoType];
                    if (decoData && terrarium[decoData.attr] !== undefined) {
                        terrarium[decoData.attr] = Math.max(0, terrarium[decoData.attr] - decoData.power);
                    }
                });
                
                installedDecorations = [];
                
                // 만족도 즉시 업데이트
                spirits.forEach(spirit => {
                    if (!spirit.isDead && !spirit.isCompleted) {
                        spirit.satisfaction = calculateSatisfaction(spirit);
                    }
                });
                
                saveGame();
                    renderTerrariumManagement();
                    renderInventory();
                    renderSpirits();  // 만족도 변경 반영
                    showNotification('모든 장식물을 해제했습니다');
                }
            );
        }
        function closeModal(modalId) {
            document.getElementById(modalId).classList.remove('active');
        }

        function showNotification(message) {
            // 기존 알림들의 개수를 세서 위치 조정
            const existingNotifs = document.querySelectorAll('.notification');
            const offset = existingNotifs.length * 70; // 각 알림마다 70px 간격
            
            const notif = document.createElement('div');
            notif.className = 'notification';
            notif.textContent = message;
            notif.style.top = `${80 + offset}px`;
            document.body.appendChild(notif);
            
            setTimeout(() => {
                notif.style.animation = 'slideOut 0.3s ease-out';
                setTimeout(() => notif.remove(), 300);
            }, 3000);
        }

        function updateTimeDisplay() {
            const now = new Date();
            const timeStr = now.toLocaleTimeString('ko-KR', { 
                hour: '2-digit', 
                minute: '2-digit',
                second: '2-digit'
            });
            document.getElementById('timeDisplay').textContent = timeStr;
        }

        // 게임 루프
        setInterval(() => {
            saveGame();
        }, 5000);

        // 1초마다 버튼 상태 및 정령 상태 체크
        setInterval(() => {
            checkSpiritStatus();
            // garden 탭이 활성화된 경우에만 카드 업데이트
            if (currentTab === 'garden') {
                updateCooldownDisplay();  // 쿨타임 텍스트만 업데이트 (성능 최적화)
                spirits.forEach(spirit => {
                    updateSpiritCard(spirit);
                });
            }
            updateGatherButton();
        }, 1000);

        // 1분마다 성장도 증가
        setInterval(() => {
            applyGrowth();
        }, 60000);  // 60000ms = 1분

        // 5분마다 테라리움 환경 효과 적용
        setInterval(() => {
            applyTerrariumGrowth();
        }, 300000);  // 300000ms = 5분

        // 만족도 업데이트 (1분마다)
        setInterval(() => {
            if (isPaused) return; // 일시정지 중이면 실행 안 함
            
            spirits.forEach(spirit => {
                if (spirit.isDead || spirit.isCompleted) return;
                
                // 성장도 체크 (100 이상이면 자동 진화)
                if (spirit.growth >= STAGE_REQUIREMENTS.adult && !spirit.isCompleted) {
                    completeSpirit(spirit);
                    return;
                }
                
                const oldSatisfaction = spirit.satisfaction || 'mid';
                const newSatisfaction = calculateSatisfaction(spirit);
                spirit.satisfaction = newSatisfaction;
                
                // 만족도에 따른 애정도 변화
                if (newSatisfaction === 'high') {
                    spirit.parameters.affection += 1;
                } else if (newSatisfaction === 'low') {
                    spirit.parameters.affection = Math.max(0, spirit.parameters.affection - 1);
                }
                
                // 만족도가 변경되었을 때 로그
                if (oldSatisfaction !== newSatisfaction) {
                    const satisfactionTexts = {
                        high: '매우 만족스러워 보입니다!',
                        mid: '평온해 보입니다.',
                        low: '불만족스러워 보입니다...'
                    };
                    addLog(spirit, satisfactionTexts[newSatisfaction]);
                }
            });
            saveGame();
            updateAllSpiritCards();
        }, 60000); // 60초마다

        setInterval(updateTimeDisplay, 1000);
        setInterval(updateRandomMessages, 15000); // 15초마다 랜덤 메시지 업데이트
        setInterval(checkNeglect, 60000); // 1분마다 방치 체크

        // 모바일 디버깅 정보
        console.log('=== 모바일 디버깅 정보 ===');
        console.log('User Agent:', navigator.userAgent);
        console.log('화면 크기:', window.innerWidth, 'x', window.innerHeight);
        console.log('터치 지원:', 'ontouchstart' in window);
        console.log('현재 시간:', new Date().toISOString());
        
        // 초기화
        try {
            console.log('게임 초기화 시작...');
            loadGame();
            console.log('✅ loadGame 완료');
            renderSpirits();
            console.log('✅ renderSpirits 완료');
            renderInventory();
            console.log('✅ renderInventory 완료');
            updateTimeDisplay();
            console.log('✅ updateTimeDisplay 완료');
            applyLightMode();
            console.log('✅ applyLightMode 완료');
            updateCoinDisplay();
            console.log('✅ updateCoinDisplay 완료');
            console.log('🎉 게임 초기화 완료!');
        } catch (error) {
            console.error('❌ 초기화 오류:', error);
            console.error('오류 스택:', error.stack);
            alert('게임 초기화 중 오류가 발생했습니다: ' + error.message);
        }

        // 모달 배경 클릭 시 닫기
        document.querySelectorAll('.modal').forEach(modal => {
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.classList.remove('active');
                }
            });
        });
    </script>
</body>
</html>

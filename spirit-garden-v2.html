<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>나의 작은 테라리움 - Spirit Garden</title>
    <link href="https://fonts.googleapis.com/css2?family=Nanum+Myeongjo:wght@400;700;800&family=Gowun+Batang:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg: #fafaf8;
            --text: #2a2a2a;
            --border: #e0e0dc;
            --card: #ffffff;
            --shadow: rgba(0, 0, 0, 0.06);
            
            --fire: #ff6b4a;
            --water: #4a9eff;
            --wind: #7bdb8f;
            --earth: #d4a574;
            --light: #ffd94a;
            --dark: #8e7cc3;
        }

        body {
            font-family: 'Gowun Batang', serif;
            background: var(--bg);
            color: var(--text);
            line-height: 1.6;
            padding: 20px;
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            font-family: 'Nanum Myeongjo', serif;
            font-size: 2.5rem;
            font-weight: 800;
            text-align: center;
            margin-bottom: 10px;
            letter-spacing: -1px;
        }

        .subtitle {
            text-align: center;
            font-size: 0.9rem;
            color: #888;
            margin-bottom: 40px;
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            border-bottom: 1px solid var(--border);
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: none;
        }
        
        .tabs::-webkit-scrollbar {
            display: none;
        }

        .tab {
            padding: 12px 24px;
            background: none;
            border: none;
            font-family: 'Gowun Batang', serif;
            font-size: 1rem;
            cursor: pointer;
            color: #888;
            transition: all 0.3s;
            border-bottom: 2px solid transparent;
            white-space: nowrap;
            flex-shrink: 0;
        }

        .tab.active {
            color: var(--text);
            border-bottom-color: var(--text);
        }

        .tab:hover {
            color: var(--text);
        }

        .section {
            display: none;
        }

        .section.active {
            display: block;
        }

        .main-layout {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        .inventory-panel {
            background: var(--card);
            border: 1px solid var(--border);
            padding: 24px;
            height: fit-content;
            position: sticky;
            top: 20px;
        }

        .inventory-title {
            font-family: 'Nanum Myeongjo', serif;
            font-size: 1.2rem;
            font-weight: 700;
            margin-bottom: 16px;
        }

        .inventory-section {
            margin-bottom: 20px;
        }

        .inventory-label {
            font-size: 0.85rem;
            color: #888;
            margin-bottom: 8px;
        }

        .inventory-items {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .inventory-item {
            padding: 6px 12px;
            background: var(--bg);
            border: 1px solid var(--border);
            font-size: 0.85rem;
            display: flex;
            align-items: center;
            gap: 6px;
            border-radius: 4px;
        }

        .spirits-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 20px;
        }

        .spirit-card {
            background: var(--card);
            border: 1px solid var(--border);
            padding: 24px;
            transition: all 0.3s;
        }

        .spirit-card:hover {
            box-shadow: 0 4px 20px var(--shadow);
            transform: translateY(-2px);
        }

        .spirit-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 16px;
        }

        .spirit-icon {
            font-size: 3rem;
            line-height: 1;
        }
        
        .spirit-icon img {
            width: 3rem;
            height: 3rem;
            object-fit: contain;
        }

        .spirit-info {
            flex: 1;
            margin-left: 16px;
        }

        .spirit-name {
            font-family: 'Nanum Myeongjo', serif;
            font-size: 1.2rem;
            font-weight: 700;
            margin-bottom: 4px;
            cursor: pointer;
        }

        .spirit-name:hover {
            color: var(--fire);
        }

        .spirit-stage {
            font-size: 0.85rem;
            color: #888;
        }

        .progress-bar {
            height: 6px;
            background: var(--border);
            margin-bottom: 8px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--light), var(--fire));
            transition: width 0.5s;
        }

        .progress-text {
            font-size: 0.8rem;
            color: #888;
            margin-bottom: 16px;
        }

        .parameters {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            margin-bottom: 16px;
            padding: 12px;
            background: var(--bg);
            border: 1px solid var(--border);
        }

        .param {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.85rem;
        }

        .param-icon {
            font-size: 1.1rem;
        }

        .environment {
            margin-bottom: 16px;
            padding: 12px;
            background: var(--bg);
            border: 1px solid var(--border);
        }

        .env-title {
            font-size: 0.85rem;
            font-weight: 700;
            margin-bottom: 8px;
        }

        .env-bars {
            display: grid;
            gap: 6px;
        }

        .env-bar {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.8rem;
        }

        .env-bar-bg {
            flex: 1;
            height: 8px;
            background: var(--border);
            position: relative;
            overflow: hidden;
        }

        .env-bar-fill {
            height: 100%;
            transition: width 0.5s;
        }

        .spirit-status {
            font-size: 0.85rem;
            color: #888;
            margin-bottom: 4px;
            min-height: 40px;
        }

        .action-buttons {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        button {
            padding: 10px 16px;
            border: 1px solid var(--border);
            background: var(--card);
            font-family: 'Gowun Batang', serif;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            user-select: none;
            -webkit-user-select: none;
        }

        button:hover {
            background: var(--bg);
            border-color: var(--text);
        }

        button:active {
            transform: scale(0.98);
        }

        button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        select {
            padding: 8px 12px;
            border: 1px solid var(--border);
            background: var(--card);
            color: var(--text);
            font-family: 'Gowun Batang', serif;
            font-size: 0.9rem;
            border-radius: 4px;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            -webkit-appearance: none;
            appearance: none;
        }
        
        select:focus {
            outline: 2px solid var(--fire);
            outline-offset: 2px;
        }

        .new-spirit-btn {
            width: 100%;
            padding: 16px;
            font-size: 1rem;
            font-weight: 700;
            margin-top: 20px;
        }

        .walk-btn {
            width: 100%;
            padding: 16px;
            font-size: 1rem;
            font-weight: 700;
            margin-bottom: 20px;
            background: var(--light);
            border-color: var(--light);
            color: #000 !important;
        }

        .walk-btn:hover {
            background: var(--fire);
            border-color: var(--fire);
            color: #000 !important;
        }

        .walk-btn:disabled {
            color: #666 !important;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.6);
            z-index: 1000;
            align-items: flex-start;
            justify-content: center;
            padding: 20px;
            padding-top: 180px;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: var(--card);
            padding: 32px;
            max-width: 500px;
            width: 100%;
            border: 1px solid var(--border);
            margin-bottom: 40px;
        }

        .modal-title {
            font-family: 'Nanum Myeongjo', serif;
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 20px;
        }

        .food-grid, .music-grid, .decor-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-bottom: 20px;
        }

        .option-btn {
            padding: 16px;
            text-align: left;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .option-icon {
            font-size: 1.5rem;
        }

        .option-info {
            flex: 1;
        }

        .option-name {
            font-weight: 700;
            margin-bottom: 2px;
        }

        .option-effect {
            font-size: 0.8rem;
            color: #888;
        }

        .close-btn {
            width: 100%;
            margin-top: 16px;
        }

        .collection-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 20px;
        }
        
        .encyclopedia-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .encyclopedia-card {
            background: var(--card);
            border: 2px solid var(--border);
            padding: 20px;
            text-align: center;
            position: relative;
            min-height: 120px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        .encyclopedia-card.unlocked {
            border-color: #4CAF50;
        }
        
        .encyclopedia-card.locked {
            background: repeating-linear-gradient(
                45deg,
                var(--card),
                var(--card) 10px,
                var(--border) 10px,
                var(--border) 11px
            );
            opacity: 0.6;
        }
        
        .encyclopedia-icon {
            font-size: 3rem;
            margin-bottom: 8px;
        }
        
        .encyclopedia-icon img {
            width: 3rem;
            height: 3rem;
            object-fit: contain;
        }
        
        .encyclopedia-name {
            font-family: 'Nanum Myeongjo', serif;
            font-size: 1rem;
            font-weight: 700;
            color: var(--text);
        }
        
        .encyclopedia-count {
            font-size: 0.85rem;
            color: #888;
            margin-top: 4px;
        }

        .collection-card {
            background: var(--card);
            border: 1px solid var(--border);
            padding: 24px;
            text-align: center;
        }

        .collection-icon {
            font-size: 4rem;
            margin-bottom: 12px;
        }

        .collection-name {
            font-family: 'Nanum Myeongjo', serif;
            font-size: 1.2rem;
            font-weight: 700;
            margin-bottom: 8px;
        }

        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #888;
        }

        .empty-icon {
            font-size: 3rem;
            margin-bottom: 16px;
            opacity: 0.3;
        }

        .time-display {
            text-align: center;
            font-size: 0.9rem;
            color: #888;
            margin-bottom: 20px;
        }

        .notification {
            position: fixed;
            top: 80px;
            right: 20px;
            background: var(--card);
            border: 1px solid var(--border);
            padding: 16px 24px;
            box-shadow: 0 4px 20px var(--shadow);
            z-index: 999;
            animation: slideIn 0.3s ease-out;
            max-width: 300px;
            word-wrap: break-word;
        }

        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes slideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(400px);
                opacity: 0;
            }
        }

        .name-input {
            width: 100%;
            padding: 12px;
            font-family: 'Gowun Batang', serif;
            font-size: 1rem;
            border: 1px solid var(--border);
            margin-bottom: 16px;
        }

        .decor-btn:disabled::after {
            content: '재료 부족';
            position: absolute;
            top: 8px;
            right: 8px;
            font-size: 0.7rem;
            padding: 2px 6px;
            background: #f44;
            color: white;
            border-radius: 2px;
        }

        @media (max-width: 900px) {
            .main-layout {
                grid-template-columns: 1fr;
            }

            .inventory-panel {
                position: static;
            }
        }

        .light-toggle {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 60px;
            height: 32px;
            background: #4CAF50;
            border: none;
            border-radius: 16px;
            cursor: pointer;
            transition: background-color 0.3s ease;
            z-index: 1000;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            padding: 0;
        }
        
        /* 플로팅 스크롤 버튼 */
        .scroll-buttons {
            position: fixed;
            right: 20px;
            bottom: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 10000;
        }
        
        .scroll-btn {
            width: 45px;
            height: 45px;
            border: none;
            border-radius: 50%;
            background: var(--card);
            color: var(--text);
            cursor: pointer;
            font-size: 1.3rem;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            border: 1px solid var(--border);
            transition: all 0.2s ease;
        }
        
        .scroll-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        
        .scroll-btn:active {
            transform: scale(0.95);
        }
        
        /* 모바일 반응형 */
        @media (max-width: 768px) {
            .scroll-buttons {
                right: 15px;
                bottom: 15px;
            }
            
            .scroll-btn {
                width: 40px;
                height: 40px;
                font-size: 1.1rem;
            }
            
            /* 상점 레이아웃 1열로 변경 */
            .shop-grid {
                grid-template-columns: 1fr !important;
                gap: 15px !important;
            }
            
            /* 테라리움 미니어처 목록 1열로 변경 */
            #installedDecorList > div,
            #terrariumDecorList > div {
                grid-template-columns: 1fr !important;
            }
            
            /* 상점 섹션 패딩 조정 */
            .shop-section {
                padding: 20px !important;
            }
            
            /* 제목 크기 조정 */
            h1 {
                font-size: 1.8rem !important;
            }
            
            h2 {
                font-size: 1.5rem !important;
            }
            
            /* 탭 버튼 크기 조정 */
            .tab {
                padding: 10px 15px !important;
                font-size: 0.9rem !important;
            }
            
            /* 상점 제목 크기 조정 */
            .shop-section h3 {
                font-size: 1.1rem !important;
            }
            
            /* 전체 여백 조정 */
            body {
                padding: 10px !important;
            }
        }

        .light-toggle::before {
            content: '';
            position: absolute;
            width: 26px;
            height: 26px;
            border-radius: 50%;
            background: white;
            top: 3px;
            left: 3px;
            transition: transform 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        body.dark-mode .light-toggle {
            background: #666;
        }

        body.dark-mode .light-toggle::before {
            transform: translateX(28px);
        }

        .light-toggle #lightIcon {
            display: none;
        }

        body.dark-mode {
            --bg: #1a1a1a;
            --card: #2d2d2d;
            --text: #e0e0e0;
            --border: #404040;
        }

        body.dark-mode .spirit-name,
        body.dark-mode .spirit-stage,
        body.dark-mode .progress-text,
        body.dark-mode .param,
        body.dark-mode .spirit-status,
        body.dark-mode .env-title,
        body.dark-mode .modal-title,
        body.dark-mode .option-name,
        body.dark-mode .option-effect,
        body.dark-mode .inventory-label,
        body.dark-mode .collection-name,
        body.dark-mode h1,
        body.dark-mode h2,
        body.dark-mode .subtitle,
        body.dark-mode .time-display {
            color: #e0e0e0;
        }

        body.dark-mode button {
            color: #e0e0e0;
        }

        body.dark-mode button:disabled {
            color: #888;
        }
        
        /* 미니게임 모바일 대응 */
        @media (max-width: 768px) {
            #minigameArea {
                height: 200px !important;
            }
            
            #minigameSpirit {
                font-size: 2rem !important;
                bottom: 5px !important;
            }
            
            #shieldEffect {
                width: 60px !important;
                height: 60px !important;
            }
            
            .minigame-word {
                font-size: 0.8rem !important;
                padding: 5px 8px !important;
            }
            
            #minigameInput {
                font-size: 1rem !important;
                padding: 12px !important;
            }
            
            /* 미니게임 플레이 중 화면 고정 */
            body.minigame-active {
                overflow: hidden;
                position: fixed;
                width: 100%;
                height: 100%;
            }
            
            body.minigame-active #minigamePlay {
                position: fixed;
                left: 0;
                right: 0;
                bottom: 0;
                z-index: 9999;
                background: var(--bg);
                padding: 0;
                display: flex !important;
                flex-direction: column;
            }
            
            body.minigame-active #minigamePlay > div:first-child {
                /* 상태바 (하트, 점수, 포기버튼) */
                margin: 0;
                border-radius: 0;
                padding: 10px 15px !important;
            }
            
            body.minigame-active #minigameArea {
                flex: 0 0 auto;
                height: 220px !important;
                border-radius: 0;
                border-left: none;
                border-right: none;
                margin: 0;
            }
            
            body.minigame-active #minigamePlay > div:last-child {
                /* 입력창 컨테이너 */
                margin: 0 !important;
            }
            
            body.minigame-active #minigameInput {
                border-radius: 0;
                border-left: none;
                border-right: none;
                border-bottom: none;
            }
        }
        
        /* 튜토리얼 버튼 강조 효과 */
        @keyframes tutorialPulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 193, 7, 0.7); }
            50% { box-shadow: 0 0 20px 10px rgba(255, 193, 7, 0.4); }
            100% { box-shadow: 0 0 0 0 rgba(255, 193, 7, 0.7); }
        }
        
        .tutorial-highlight {
            animation: tutorialPulse 1.5s infinite !important;
            border: 3px solid #ffc107 !important;
            position: relative;
            z-index: 100;
        }
        
        .tutorial-highlight::after {
            content: '👇';
            position: absolute;
            top: -30px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 1.5rem;
            animation: bounce 0.5s infinite alternate;
        }
        
        @keyframes bounce {
            from { transform: translateX(-50%) translateY(0); }
            to { transform: translateX(-50%) translateY(-5px); }
        }
    </style>
</head>
<body>
    <!-- 오프닝 스토리 팝업 -->
    <div id="openingModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 99999; justify-content: center; align-items: center;">
        <div style="max-width: 500px; width: 90%; padding: 40px; text-align: center; display: flex; flex-direction: column; align-items: center;">
            <div style="min-height: 120px; display: flex; align-items: center; justify-content: center;">
                <div id="openingText" style="color: #e0e0e0; font-family: 'Nanum Myeongjo', serif; font-size: 1.1rem; line-height: 2; opacity: 0; transition: opacity 1s; word-break: keep-all;">
                </div>
            </div>
            <div style="height: 80px; display: flex; align-items: flex-start; justify-content: center; padding-top: 20px;">
                <button id="openingNextBtn" onclick="nextOpeningScene()" style="display: none; padding: 12px 40px; background: transparent; border: 1px solid #888; color: #888; font-family: 'Gowun Batang', serif; font-size: 1rem; cursor: pointer; transition: all 0.3s;">
                    다음
                </button>
            </div>
            <button id="openingSkipBtn" onclick="skipOpening()" style="position: absolute; top: 20px; right: 20px; background: none; border: none; color: #666; font-size: 0.9rem; cursor: pointer;">
                건너뛰기
            </button>
        </div>
    </div>

    <!-- 제목 영역 -->
    <div style="display: flex; justify-content: center; align-items: center; position: relative; margin-bottom: 10px;">
        <h1 style="margin: 0;">나의 작은 테라리움</h1>
        <button id="settingsBtn" onclick="switchTab('settings')" style="position: absolute; right: 0; background: none; border: none; cursor: pointer; font-size: 1.2rem; opacity: 0.5;" onmouseover="this.style.opacity='1'" onmouseout="this.style.opacity='0.5'">⚙️</button>
    </div>
    <div class="subtitle">Spirit Garden</div>

    <div class="time-display" id="timeDisplay"></div>

    <div class="tabs">
        <button class="tab active" onclick="switchTab('garden')">육성</button>
        <button class="tab" onclick="switchTab('terrarium')">테라리움</button>
        <button class="tab" onclick="switchTab('lab')">연구실</button>
        <button class="tab" onclick="switchTab('shop')">상점 💰<span id="coinDisplay">0</span></button>
        <button class="tab" onclick="switchTab('minigame')">미니게임</button>
        <button class="tab" onclick="switchTab('journal')">일지</button>
        <!-- 일시정지 / 조명 버튼 -->
        <button id="pauseBtn" onclick="togglePause()" style="padding: 8px 12px; background: #ff9800; color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 1.2rem; margin-left: auto;">⏸️</button>
        <button id="lightBtn" onclick="toggleLight()" style="padding: 8px 12px; background: #2196F3; color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 1.2rem;"><span id="lightIcon">☀️</span></button>
    </div>

    <div id="gardenSection" class="section active">
        <div class="main-layout">
            <div class="inventory-panel">
                <div style="margin-bottom: 16px;">
                    <label for="titleSelect" style="display: block; font-size: 0.9rem; margin-bottom: 6px; color: var(--text); font-weight: 600;">칭호 선택</label>
                    <select id="titleSelect" onchange="changeTitle()" style="width: 100%; padding: 10px; border: 2px solid var(--border); border-radius: 8px; background: var(--card); color: var(--text); font-size: 0.9rem; cursor: pointer;">
                        <option value="none">자동채집 (확률 절반)</option>
                        <option value="hawk_eye">매의 눈 (모든 채집물 확률 1.5배)</option>
                        <option value="gatherer">채집꾼 (먹이 확률 2배)</option>
                        <option value="musician">음악가 (레코드 확률 2배)</option>
                        <option value="collector">수집가 (테라리움 물품 확률 2배)</option>
                    </select>
                </div>

                <div style="margin-bottom: 16px;">
                    <label for="gatherLocationSelect" style="display: block; font-size: 0.9rem; margin-bottom: 6px; color: var(--text); font-weight: 600;">채집 장소</label>
                    <select id="gatherLocationSelect" onchange="changeGatherLocation()" style="width: 100%; padding: 10px; border: 2px solid var(--border); border-radius: 8px; background: var(--card); color: var(--text); font-size: 0.9rem; cursor: pointer;">
                        <option value="garden">🌸 정원 (모든 속성)</option>
                        <option value="lake">🌊 호수 (물·바람)</option>
                        <option value="forest">🌲 숲 (땅·불)</option>
                    </select>
                </div>

                <button class="walk-btn" onclick="goGather()" style="margin-bottom: 20px;">채집하기</button>

                <div class="inventory-title" onclick="toggleInventoryCollapse()" style="cursor: pointer; display: flex; justify-content: space-between; align-items: center;">
                    <span>내 소지품</span>
                    <span id="inventoryToggleIcon" style="font-size: 0.8rem; color: #888;">▼</span>
                </div>
                
                <div id="inventoryContent">
                    <div class="inventory-section">
                        <div class="inventory-label">🍎 먹이</div>
                        <div class="inventory-items" id="foodInventory">
                            <div class="inventory-item">없음</div>
                        </div>
                    </div>

                    <div class="inventory-section">
                        <div class="inventory-label">🎼 레코드</div>
                        <div class="inventory-items" id="musicInventory">
                            <div class="inventory-item">없음</div>
                        </div>
                    </div>

                    <div class="inventory-section">
                        <div class="inventory-label">🌳 미니어처</div>
                        <div class="inventory-items" id="decorInventory">
                            <div class="inventory-item">없음</div>
                        </div>
                    </div>
                </div>
            </div>

            <div>
                <div class="spirits-grid" id="spiritsGrid"></div>
                <button class="new-spirit-btn" onclick="createNewSpirit()">+ 새로운 알 받기</button>
            </div>
        </div>
    </div>

    <div id="encyclopediaSection" class="section" style="display: none;"></div>

    <div id="albumSection" class="section" style="display: none;"></div>
    
    <!-- 일지 섹션 -->
    <div id="labSection" class="section">
        
        <div style="max-width: 800px; margin: 0 auto;">
            <!-- 합성 영역 -->
            <div style="background: var(--card); border: 1px solid var(--border); padding: 16px; margin-bottom: 20px;">
                <h3 style="font-family: 'Nanum Myeongjo', serif; font-size: 1.2rem; margin-bottom: 15px; text-align: center;">재료 합성</h3>
                
                <div style="display: flex; justify-content: center; align-items: center; gap: 6px; margin-bottom: 15px;">
                    <!-- 슬롯 1 -->
                    <div id="labSlot1" onclick="openLabSlotModal(1)" style="width: 70px; height: 70px; flex-shrink: 0; border: 2px dashed var(--border); display: flex; flex-direction: column; justify-content: center; align-items: center; cursor: pointer; background: var(--bg); transition: all 0.2s;">
                        <div style="font-size: 1.3rem; margin-bottom: 2px;">➕</div>
                        <div style="font-size: 0.65rem; color: #888;">재료1</div>
                    </div>
                    
                    <div style="font-size: 1rem; color: #888; flex-shrink: 0;">+</div>
                    
                    <!-- 슬롯 2 -->
                    <div id="labSlot2" onclick="openLabSlotModal(2)" style="width: 70px; height: 70px; flex-shrink: 0; border: 2px dashed var(--border); display: flex; flex-direction: column; justify-content: center; align-items: center; cursor: pointer; background: var(--bg); transition: all 0.2s;">
                        <div style="font-size: 1.3rem; margin-bottom: 2px;">➕</div>
                        <div style="font-size: 0.65rem; color: #888;">재료2</div>
                    </div>
                    
                    <div style="font-size: 1rem; color: #888; flex-shrink: 0;">→</div>
                    
                    <!-- 결과 슬롯 -->
                    <div id="labResultSlot" style="width: 70px; height: 70px; flex-shrink: 0; border: 2px solid var(--border); display: flex; flex-direction: column; justify-content: center; align-items: center; background: var(--bg);">
                        <div style="font-size: 1.3rem; margin-bottom: 2px;">❓</div>
                        <div style="font-size: 0.65rem; color: #888;">결과</div>
                    </div>
                </div>
                
                <div style="text-align: center;">
                    <button id="synthesizeBtn" onclick="synthesize()" style="padding: 10px 30px; background: #9b59b6; color: white; border: none; font-size: 0.95rem; font-weight: 700; cursor: pointer; opacity: 0.5;" disabled>
                        🔮 합성하기
                    </button>
                </div>
                
                <div id="labMessage" style="margin-top: 12px; text-align: center; font-size: 0.85rem; color: #888; min-height: 20px;"></div>
            </div>
            
            <!-- 레시피 목록 -->
            <div style="background: var(--card); border: 1px solid var(--border); padding: 24px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; flex-wrap: wrap; gap: 12px;">
                    <h3 style="font-family: 'Nanum Myeongjo', serif; font-size: 1.3rem; margin: 0;">📜 레시피 목록</h3>
                    <div style="display: flex; align-items: center; gap: 8px; flex-wrap: wrap;">
                        <span id="recipeCountDisplay" style="font-size: 0.85rem; color: #888;"></span>
                        <select id="recipeFilterSelect" onchange="applyRecipeFilters()" style="padding: 6px 10px; border: 1px solid var(--border); background: var(--bg); color: var(--text); font-size: 0.85rem; cursor: pointer;">
                            <option value="all">📋 전체</option>
                            <option value="food">🍎 먹이</option>
                            <option value="decoration">🌳 미니어처</option>
                        </select>
                        <select id="recipeAttrFilter" onchange="applyRecipeFilters()" style="padding: 6px 10px; border: 1px solid var(--border); background: var(--bg); color: var(--text); font-size: 0.85rem; cursor: pointer;">
                            <option value="all">속성</option>
                            <option value="fire">🔥 불</option>
                            <option value="water">💧 물</option>
                            <option value="wind">🌪️ 바람</option>
                            <option value="earth">🌱 땅</option>
                            <option value="light">✨ 빛</option>
                            <option value="dark">🌙 어둠</option>
                            <option value="all_attr">🌈 전속성</option>
                        </select>
                        <select id="recipeQualityFilter" onchange="applyRecipeFilters()" style="padding: 6px 10px; border: 1px solid var(--border); background: var(--bg); color: var(--text); font-size: 0.85rem; cursor: pointer;">
                            <option value="all">품질</option>
                            <option value="common">일반</option>
                            <option value="rare">💎 희귀</option>
                            <option value="epic">⭐ 최상급</option>
                            <option value="legendary">👑 전설</option>
                        </select>
                    </div>
                </div>
                
                <div id="recipeList" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 12px;"></div>
            </div>
        </div>
    </div>
    
    <div id="journalSection" class="section">
        
        <!-- 서브탭 인덱스 -->
        <div style="display: flex; justify-content: center; gap: 8px; margin-bottom: 25px; flex-wrap: wrap; padding-top: 10px;">
            <button id="journalTabEncyclopedia" onclick="switchJournalTab('encyclopedia')" style="padding: 10px 20px; background: #9b59b6; color: white; border: none; border-radius: 20px; font-size: 0.9rem; font-weight: 600; cursor: pointer;">📚 도감</button>
            <button id="journalTabAlbum" onclick="switchJournalTab('album')" style="padding: 10px 20px; background: var(--bg); color: var(--text); border: 1px solid var(--border); border-radius: 20px; font-size: 0.9rem; font-weight: 600; cursor: pointer;">💝 앨범</button>
            <button id="journalTabAchievement" onclick="switchJournalTab('achievement')" style="padding: 10px 20px; background: var(--bg); color: var(--text); border: 1px solid var(--border); border-radius: 20px; font-size: 0.9rem; font-weight: 600; cursor: pointer;">🏅 업적</button>
            <button id="journalTabMemo" onclick="switchJournalTab('memo')" style="padding: 10px 20px; background: var(--bg); color: var(--text); border: 1px solid var(--border); border-radius: 20px; font-size: 0.9rem; font-weight: 600; cursor: pointer;">📝 메모</button>
            <button id="journalTabHelp" onclick="switchJournalTab('help')" style="padding: 10px 20px; background: var(--bg); color: var(--text); border: 1px solid var(--border); border-radius: 20px; font-size: 0.9rem; font-weight: 600; cursor: pointer;">❓ 도움말</button>
        </div>
        
        <!-- 도감 탭 -->
        <div id="journalEncyclopediaTab">
            <div class="encyclopedia-grid" id="encyclopediaGrid"></div>
        </div>
        
        <!-- 앨범 탭 -->
        <div id="journalAlbumTab" style="display: none;">
            <div class="collection-grid" id="collectionGrid"></div>
        </div>
        
        <!-- 업적 탭 -->
        <div id="journalAchievementTab" style="display: none; max-width: 700px; margin: 0 auto;">
            <!-- 업적 요약 -->
            <div style="background: var(--card); padding: 24px; border: 1px solid var(--border); border-radius: 12px; margin-bottom: 20px;">
                <h3 style="font-family: 'Nanum Myeongjo', serif; font-size: 1.3rem; margin-bottom: 16px; color: var(--text);">🏅 업적 현황</h3>
                <div id="achievementSummary" style="display: flex; gap: 20px; justify-content: center; flex-wrap: wrap;">
                    <!-- 자바스크립트로 채워짐 -->
                </div>
            </div>
            
            <!-- 키운 정령 수 업적 -->
            <div style="background: var(--card); padding: 24px; border: 1px solid var(--border); border-radius: 12px; margin-bottom: 20px;">
                <h3 style="font-family: 'Nanum Myeongjo', serif; font-size: 1.3rem; margin-bottom: 16px; color: var(--text);">
                    🦋 키운 정령의 수
                    <span id="albumCountDisplay" style="font-size: 0.9rem; color: #888; font-weight: normal; margin-left: 10px;"></span>
                </h3>
                <div id="albumAchievements" style="display: flex; flex-direction: column; gap: 12px;">
                    <!-- 자바스크립트로 채워짐 -->
                </div>
            </div>
            
            <!-- 도감 수집 업적 -->
            <div style="background: var(--card); padding: 24px; border: 1px solid var(--border); border-radius: 12px; margin-bottom: 20px;">
                <h3 style="font-family: 'Nanum Myeongjo', serif; font-size: 1.3rem; margin-bottom: 16px; color: var(--text);">
                    📚 도감 수집
                    <span id="encyclopediaCountDisplay" style="font-size: 0.9rem; color: #888; font-weight: normal; margin-left: 10px;"></span>
                </h3>
                <div id="encyclopediaAchievements" style="display: flex; flex-direction: column; gap: 12px;">
                    <!-- 자바스크립트로 채워짐 -->
                </div>
            </div>
            
            <!-- 레시피 발견 업적 -->
            <div style="background: var(--card); padding: 24px; border: 1px solid var(--border); border-radius: 12px; margin-bottom: 20px;">
                <h3 style="font-family: 'Nanum Myeongjo', serif; font-size: 1.3rem; margin-bottom: 16px; color: var(--text);">
                    🧪 레시피 발견
                    <span id="recipeCountDisplay" style="font-size: 0.9rem; color: #888; font-weight: normal; margin-left: 10px;"></span>
                </h3>
                <div id="recipeAchievements" style="display: flex; flex-direction: column; gap: 12px;">
                    <!-- 자바스크립트로 채워짐 -->
                </div>
            </div>
            
            <!-- 특별 업적 -->
            <div style="background: var(--card); padding: 24px; border: 1px solid var(--border); border-radius: 12px; margin-bottom: 20px;">
                <h3 style="font-family: 'Nanum Myeongjo', serif; font-size: 1.3rem; margin-bottom: 16px; color: var(--text);">
                    🏅 특별 업적
                    <span id="specialCountDisplay" style="font-size: 0.9rem; color: #888; font-weight: normal; margin-left: 10px;"></span>
                </h3>
                <div id="specialAchievements" style="display: flex; flex-direction: column; gap: 12px;">
                    <!-- 자바스크립트로 채워짐 -->
                </div>
            </div>
        </div>
        
        <!-- 메모 탭 -->
        <div id="journalMemoTab" style="display: none; max-width: 700px; margin: 0 auto;">
            <div style="background: var(--card); padding: 60px 24px; border: 1px solid var(--border); border-radius: 12px; text-align: center;">
                <div style="font-size: 4rem; margin-bottom: 20px;">🚧</div>
                <p style="font-size: 1.2rem; color: var(--text-muted); font-family: 'Gowun Batang', serif;">준비중...</p>
                <p style="font-size: 0.9rem; color: #888; margin-top: 12px;">스토리 추가 예정</p>
            </div>
        </div>
        
        <!-- 도움말 탭 -->
        <div id="journalHelpTab" style="display: none; max-width: 700px; margin: 0 auto;">
            <!-- 튜토리얼 다시보기 -->
            <div style="background: var(--card); padding: 24px; border: 1px solid var(--border); border-radius: 12px; margin-bottom: 20px;">
                <h3 style="font-family: 'Nanum Myeongjo', serif; font-size: 1.3rem; margin-bottom: 20px; color: var(--text);">📖 튜토리얼 다시보기</h3>
                <p style="font-size: 0.9rem; color: #888; margin-bottom: 16px;">게임 플레이에 도움이 되는 튜토리얼을 다시 볼 수 있습니다. 튜토리얼을 끝까지 완료하면 보상을 받을 수 있습니다.</p>
                
                <div id="tutorialReplayList" style="display: flex; flex-direction: column; gap: 12px;">
                    <!-- 동적으로 렌더링됨 -->
                </div>
            </div>
        </div>
    </div>
    
    <!-- 설정 섹션 -->
    <div id="settingsSection" class="section">
        <h2 style="text-align: center; font-family: 'Nanum Myeongjo', serif; font-size: 2rem; margin-bottom: 30px;">설정</h2>
        
        <div style="max-width: 600px; margin: 0 auto;">
            <!-- 데이터 관리 -->
            <div style="background: var(--card); padding: 24px; border: 1px solid var(--border); border-radius: 12px; margin-bottom: 20px;">
                <h3 style="font-family: 'Nanum Myeongjo', serif; font-size: 1.3rem; margin-bottom: 20px; color: var(--text);">데이터 관리</h3>
                
                <div style="display: flex; flex-direction: column; gap: 12px;">
                    <button onclick="exportGameData()" style="padding: 14px; background: var(--water); color: white; border: none; border-radius: 8px; font-size: 1rem; font-weight: 700; cursor: pointer;">
                        게임 데이터 내보내기
                    </button>
                    
                    <button onclick="importGameData()" style="padding: 14px; background: var(--wind); color: white; border: none; border-radius: 8px; font-size: 1rem; font-weight: 700; cursor: pointer;">
                        게임 데이터 불러오기
                    </button>
                    
                    <button onclick="manualRebuildEncyclopedia()" style="padding: 14px; background: var(--earth); color: white; border: none; border-radius: 8px; font-size: 1rem; font-weight: 700; cursor: pointer;">
                        앨범에서 도감 복구
                    </button>
                    
                    <button onclick="showAlbumBackupRestore()" style="padding: 14px; background: #e67e22; color: white; border: none; border-radius: 8px; font-size: 1rem; font-weight: 700; cursor: pointer;">
                        앨범 백업 복구
                    </button>
                    
                    <button onclick="showAlbumRecoveryDialog()" style="padding: 14px; background: #3498db; color: white; border: none; border-radius: 8px; font-size: 1rem; font-weight: 700; cursor: pointer;">
                        도감에서 앨범 복구
                    </button>
                    
                    <button onclick="repairBrokenSpirits()" style="padding: 14px; background: #9b59b6; color: white; border: none; border-radius: 8px; font-size: 1rem; font-weight: 700; cursor: pointer;">
                        연결 정령 관리
                    </button>
                </div>
                
                <div style="margin-top: 16px; padding: 12px; background: var(--bg); border-radius: 8px; font-size: 0.85rem; color: #888;">
                    💡 데이터 내보내기를 통해 게임 진행상황을 백업할 수 있습니다.<br>
                    다른 기기나 브라우저에서 불러오기를 통해 복원할 수 있습니다.<br>
                    📚 앨범 백업 복구: 정령 완성 시 자동 저장된 백업에서 앨범을 복구합니다.<br>
                    📖 도감에서 앨범 복구: 도감에는 있지만 앨범에 없는 정령을 복구합니다.
                </div>
            </div>
            
            <!-- 화면 설정 -->
            <div style="background: var(--card); padding: 24px; border: 1px solid var(--border); border-radius: 12px; margin-bottom: 20px;">
                <h3 style="font-family: 'Nanum Myeongjo', serif; font-size: 1.3rem; margin-bottom: 20px; color: var(--text);">화면 설정</h3>
                
                <div style="display: flex; justify-content: space-between; align-items: center; padding: 12px; background: var(--bg); border-radius: 8px;">
                    <div>
                        <div style="font-weight: 700; margin-bottom: 4px;">다크 모드 고정</div>
                        <div style="font-size: 0.85rem; color: #888;">활성화 시 조명 상태와 무관하게 다크 모드 유지</div>
                    </div>
                    <label style="position: relative; display: inline-block; width: 60px; height: 32px;">
                        <input type="checkbox" id="darkModeToggle" onchange="toggleDarkModeLock()" style="opacity: 0; width: 0; height: 0;">
                        <span style="position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 32px;">
                            <span id="darkModeSlider" style="position: absolute; content: ''; height: 24px; width: 24px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%;"></span>
                        </span>
                    </label>
                </div>
            </div>
            
            <!-- 이벤트 코드 -->
            <div style="background: var(--card); padding: 24px; border: 1px solid var(--border); border-radius: 12px; margin-bottom: 20px;">
                <h3 style="font-family: 'Nanum Myeongjo', serif; font-size: 1.3rem; margin-bottom: 20px; color: var(--text);">이벤트 코드</h3>
                
                <p style="font-size: 0.9rem; color: #888; margin-bottom: 16px;">이벤트 코드를 입력하면 시즌 정령 알을 받을 수 있습니다!</p>
                
                <div style="display: flex; gap: 8px; margin-bottom: 12px;">
                    <input type="text" id="eventCodeInput" placeholder="SGEVENT-로 시작하는 코드 입력..." style="flex: 1; padding: 12px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg); color: var(--text); font-family: monospace;">
                    <button onclick="redeemEventCode()" style="padding: 12px 20px; background: #333; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 700;">
                        사용
                    </button>
                </div>
            </div>
            
            <!-- 게임 초기화 -->
            <div style="background: var(--card); padding: 24px; border: 1px solid var(--border); border-radius: 12px; margin-bottom: 20px;">
                <h3 style="font-family: 'Nanum Myeongjo', serif; font-size: 1.3rem; margin-bottom: 20px; color: var(--text);">게임 초기화</h3>
                
                <button onclick="resetGame()" style="width: 100%; padding: 14px; background: #e74c3c; color: white; border: none; border-radius: 8px; font-size: 1rem; font-weight: 700; cursor: pointer;">
                    🔄 게임 초기화
                </button>
                
                <div style="margin-top: 16px; padding: 12px; background: var(--bg); border-radius: 8px; font-size: 0.85rem; color: #e74c3c;">
                    ⚠️ 주의: 모든 정령, 아이템, 진행 상황이 삭제됩니다.<br>
                    초기화 전 데이터 내보내기를 권장합니다.
                </div>
            </div>
            
            <!-- 게임 정보 -->
            <div style="background: var(--card); padding: 24px; border: 1px solid var(--border); border-radius: 12px;">
                <h3 style="font-family: 'Nanum Myeongjo', serif; font-size: 1.3rem; margin-bottom: 20px; color: var(--text);">게임 정보</h3>
                
                <div style="display: flex; flex-direction: column; gap: 12px; font-size: 0.9rem; color: var(--text);">
                    <div style="display: flex; justify-content: space-between; padding: 8px 0;">
                        <span>버전</span>
                        <span style="font-weight: 700;">베타</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- 앨범 상세 정보 모달 -->
    <div id="albumDetailModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 10000; justify-content: center; align-items: center;">
        <div id="albumDetailContent" style="background: var(--card); border: 2px solid var(--border); border-radius: 12px; padding: 30px; max-width: 500px; width: 90%; max-height: 80vh; overflow-y: auto;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <h2 id="modalTitle" style="font-family: 'Nanum Myeongjo', serif; font-size: 1.5rem; color: var(--text); margin: 0;"></h2>
                <button onclick="closeAlbumDetail()" style="background: none; border: none; font-size: 1.5rem; cursor: pointer; color: var(--text);">✕</button>
            </div>
            <div id="modalContent"></div>
            <div style="margin-top: 15px; text-align: center;">
                <button onclick="saveAlbumDetailImage()" style="padding: 10px 20px; background: var(--water); color: white; border: none; border-radius: 8px; font-size: 0.9rem; font-weight: 600; cursor: pointer;">
                    📷 이미지로 저장
                </button>
            </div>
        </div>
    </div>

    <div id="shopSection" class="section">
        <div style="max-width: 1000px; margin: 0 auto;">
            <!-- 상점 주인 대사 -->
            <div id="shopkeeperArea" style="background: var(--card); border: 1px solid var(--border); border-radius: 12px; padding: 20px; margin-bottom: 20px; display: flex; align-items: center; gap: 15px;">
                <div>
                    <img src="https://i.imgur.com/NxGyLzK.png" alt="상점 주인" style="width: 150px; height: 150px; object-fit: cover;">
                </div>
                <div style="flex: 1;">
                    <div style="font-size: 1rem; font-weight: 600; color: var(--fire); margin-bottom: 8px;">상점 주인</div>
                    <div style="font-family: 'Gowun Batang', serif; font-size: 1.1rem; color: var(--text); font-style: italic;" id="shopkeeperDialogue">
                        어서오세요...
                    </div>
                </div>
            </div>
            
            <div style="text-align: center; margin-bottom: 20px;">
                
                <!-- 카테고리 선택 드롭다운 -->
                <select id="shopCategorySelect" onchange="changeShopCategory()" style="padding: 12px 20px; font-size: 1rem; border: 2px solid var(--border); border-radius: 8px; background: var(--card); color: var(--text); cursor: pointer; min-width: 200px;">
                    <option value="all">📦 전체</option>
                    <option value="food">🍎 먹이</option>
                    <option value="decoration">🌳 미니어처</option>
                    <option value="music">레코드</option>
                </select>
            </div>

            <div class="shop-grid" style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 30px;">
                <!-- 판매 (소지품 → 코인) -->
                <div class="shop-section" style="background: var(--card); border: 1px solid var(--border); padding: 32px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                        <h3 style="font-family: 'Nanum Myeongjo', serif; font-size: 1.3rem; margin: 0; color: var(--fire);">💸 판매하기</h3>
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <button id="lockModeBtn" onclick="toggleLockMode()" style="padding: 8px 12px; font-size: 0.9rem; border: 1px solid var(--border); border-radius: 6px; background: var(--card); color: var(--text); cursor: pointer;" title="잠금 모드 전환">🔓</button>
                            <select id="sellFilterSelect" onchange="changeSellFilter()" style="padding: 8px 12px; font-size: 0.9rem; border: 1px solid var(--border); border-radius: 6px; background: var(--card); color: var(--text); cursor: pointer;">
                            <option value="all">전체</option>
                            <option value="fire">🔥 불</option>
                            <option value="water">💧 물</option>
                            <option value="wind">🌬️ 바람</option>
                            <option value="earth">🌱 땅</option>
                            <option value="light">✨ 빛</option>
                            <option value="dark">🌙 어둠</option>
                            <option value="intelligence">🧠 지력</option>
                            <option value="strength">💪 체력</option>
                            <option value="charm">💖 매력</option>
                            <option value="etc">📦 기타</option>
                        </select>
                        </div>
                    </div>
                    <div id="sellList"></div>
                </div>

                <!-- 구매 (코인 → 아이템) -->
                <div class="shop-section" style="background: var(--card); border: 1px solid var(--border); padding: 32px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                        <h3 style="font-family: 'Nanum Myeongjo', serif; font-size: 1.3rem; margin: 0; color: var(--water);">🛒 구매하기</h3>
                        <select id="buyFilterSelect" onchange="changeBuyFilter()" style="padding: 8px 12px; font-size: 0.9rem; border: 1px solid var(--border); border-radius: 6px; background: var(--card); color: var(--text); cursor: pointer;">
                            <option value="all">전체</option>
                            <option value="fire">🔥 불</option>
                            <option value="water">💧 물</option>
                            <option value="wind">🌬️ 바람</option>
                            <option value="earth">🌱 땅</option>
                            <option value="light">✨ 빛</option>
                            <option value="dark">🌙 어둠</option>
                            <option value="intelligence">🧠 지력</option>
                            <option value="strength">💪 체력</option>
                            <option value="charm">💖 매력</option>
                            <option value="etc">📦 기타</option>
                        </select>
                    </div>
                    <div id="buyList"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- 미니게임 섹션 -->
    <div id="minigameSection" class="section">
        <div style="max-width: 800px; margin: 0 auto;">
            
            <!-- 게임 시작 전 화면 -->
            <div id="minigameIntro" style="background: var(--card); border: 1px solid var(--border); padding: 40px; text-align: center;">
                <div style="font-size: 4rem; margin-bottom: 20px;">🛡️</div>
                <h3 style="font-family: 'Nanum Myeongjo', serif; font-size: 1.5rem; margin-bottom: 20px;">게임 방법</h3>
                <div style="text-align: left; max-width: 400px; margin: 0 auto 30px; line-height: 1.8; color: var(--text);">
                    <p>• 위에서 해충과 독버섯이 떨어집니다</p>
                    <p>• 단어를 타이핑해서 제거하세요</p>
                    <p>• 바닥에 닿으면 정령이 다칩니다</p>
                    <p>• 목숨 3개가 모두 소진되면 게임 오버!</p>
                </div>
                <div style="margin-bottom: 20px;">
                    <label style="font-weight: 600; margin-right: 10px;">난이도:</label>
                    <select id="minigameDifficulty" style="padding: 10px 20px; font-size: 1rem; border: 2px solid var(--border); border-radius: 8px; background: var(--card); color: var(--text);">
                        <option value="easy" selected>쉬움</option>
                        <option value="hard">어려움 (보상 2배)</option>
                    </select>
                </div>
                <button onclick="startMinigame()" style="padding: 16px 48px; font-size: 1.2rem; font-weight: 700; background: var(--fire); color: white; border: none; border-radius: 12px; cursor: pointer;">
                    게임 시작
                </button>
            </div>
            
            <!-- 게임 플레이 화면 -->
            <div id="minigamePlay" style="display: none;">
                <!-- 게임 상태 바 -->
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; padding: 15px 20px; background: var(--card); border: 1px solid var(--border); border-radius: 8px;">
                    <div style="font-size: 1.2rem;">
                        <span style="color: #e74c3c;">❤️</span> 
                        <span id="minigameLives">❤️❤️❤️</span>
                    </div>
                    <div style="font-size: 1.3rem; font-weight: 700; color: var(--fire);">
                        ⏱️ <span id="minigameTimer">60</span>초
                    </div>
                    <div style="font-size: 1.3rem; font-weight: 700; color: var(--text);">
                        점수: <span id="minigameScore">0</span>
                    </div>
                    <button onclick="endMinigame()" style="padding: 8px 16px; background: #888; color: white; border: none; border-radius: 6px; cursor: pointer;">포기</button>
                </div>
                
                <!-- 게임 영역 -->
                <div id="minigameArea" style="position: relative; width: 100%; height: 500px; background: linear-gradient(180deg, #87CEEB 0%, #E0F6FF 50%, #90EE90 95%, #228B22 100%); border: 3px solid var(--border); border-radius: 12px; overflow: hidden; user-select: none;">
                    <!-- 떨어지는 단어들이 여기에 생성됨 -->
                    
                    <!-- 정령 (하단) -->
                    <div id="minigameSpirit" style="position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); font-size: 4rem; transition: all 0.3s; filter: drop-shadow(0 4px 8px rgba(0,0,0,0.3));">
                        🐛
                    </div>
                    
                    <!-- 보호막 이펙트 -->
                    <div id="shieldEffect" style="position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%); width: 120px; height: 120px; border-radius: 50%; background: radial-gradient(circle, rgba(100,200,255,0.3) 0%, transparent 70%); opacity: 0; transition: opacity 0.2s;"></div>
                </div>
                
                <!-- 입력 영역 -->
                <div style="margin-top: 15px;">
                    <input type="text" id="minigameInput" placeholder="단어를 입력하세요..." autocomplete="off" autocapitalize="off" spellcheck="false" lang="ko"
                        style="width: 100%; padding: 18px 24px; font-size: 1.3rem; border: 3px solid var(--border); border-radius: 12px; text-align: center; font-family: 'Gowun Batang', serif; background: var(--card); color: var(--text); box-sizing: border-box; ime-mode: active;">
                </div>
            </div>
            
            <!-- 게임 결과 화면 -->
            <div id="minigameResult" style="display: none; background: var(--card); border: 1px solid var(--border); padding: 40px; text-align: center;">
                <div id="resultIcon" style="font-size: 5rem; margin-bottom: 20px;">🎉</div>
                <h3 id="resultTitle" style="font-family: 'Nanum Myeongjo', serif; font-size: 1.8rem; margin-bottom: 15px;">게임 종료!</h3>
                <div style="font-size: 1.5rem; margin-bottom: 10px; color: var(--text);">
                    최종 점수: <span id="finalScore" style="font-weight: 700; color: var(--fire);">0</span>
                </div>
                <div style="font-size: 1.1rem; margin-bottom: 30px; color: #888;">
                    처치한 해충: <span id="defeatedCount">0</span>마리
                </div>
                
                <!-- 보상 선택 -->
                <div id="rewardSection" style="margin-bottom: 30px;">
                    <h4 style="font-size: 1.2rem; margin-bottom: 20px; color: var(--text);">보상을 선택하세요</h4>
                    <div style="display: flex; gap: 20px; justify-content: center; flex-wrap: wrap;">
                        <button onclick="claimReward('coin')" class="reward-btn" style="padding: 20px 30px; background: linear-gradient(135deg, #FFD700, #FFA500); color: #333; border: none; border-radius: 12px; cursor: pointer; min-width: 150px;">
                            <div style="font-size: 2rem; margin-bottom: 8px;">💰</div>
                            <div style="font-weight: 700;">코인 받기</div>
                            <div id="coinRewardAmount" style="font-size: 0.9rem; margin-top: 4px;">+0</div>
                        </button>
                        <button onclick="claimReward('item')" class="reward-btn" style="padding: 20px 30px; background: linear-gradient(135deg, #9B59B6, #8E44AD); color: white; border: none; border-radius: 12px; cursor: pointer; min-width: 150px;">
                            <div style="font-size: 2rem; margin-bottom: 8px;">🎁</div>
                            <div style="font-weight: 700;">아이템 받기</div>
                            <div style="font-size: 0.9rem; margin-top: 4px;">랜덤 보상</div>
                        </button>
                    </div>
                </div>
                
                <button onclick="backToMinigameIntro()" style="padding: 14px 40px; font-size: 1rem; background: var(--border); color: var(--text); border: none; border-radius: 8px; cursor: pointer;">
                    돌아가기
                </button>
            </div>
        </div>
    </div>

    <div id="terrariumSection" class="section">
        <div style="max-width: 800px; margin: 0 auto;">
            <!-- 테라리움 환경 -->
            <div style="background: var(--card); border: 1px solid var(--border); padding: 32px; margin-bottom: 20px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <h2 style="font-family: 'Nanum Myeongjo', serif; font-size: 1.5rem; margin: 0;">테라리움 환경</h2>
                    <div style="display: flex; align-items: center; gap: 8px; padding: 8px 16px; background: #f0f0f0; border-radius: 8px;" title="미니어처 품질의 합계 (미니어처를 추가할수록 올라감)">
                        <span style="font-weight: 600; color: #666;">품질 합계:</span>
                        <span id="terrariumQuality" style="font-size: 1.2rem; font-weight: 700; color: #ff9800;">0.0</span>
                    </div>
                </div>
                <div class="env-bars" style="display: grid; gap: 12px;">
                    <div class="env-bar" style="display: flex; align-items: center; gap: 12px;">
                        <span style="font-size: 1.5rem;">🔥</span>
                        <div class="env-bar-bg" style="flex: 1; height: 12px; background: var(--border);">
                            <div class="env-bar-fill" id="terrFireBar" style="height: 100%; background: var(--fire); width: 0%;"></div>
                        </div>
                        <span id="terrFireValue" style="min-width: 30px; text-align: right;">0</span>
                    </div>
                    <div class="env-bar" style="display: flex; align-items: center; gap: 12px;">
                        <span style="font-size: 1.5rem;">💧</span>
                        <div class="env-bar-bg" style="flex: 1; height: 12px; background: var(--border);">
                            <div class="env-bar-fill" id="terrWaterBar" style="height: 100%; background: var(--water); width: 0%;"></div>
                        </div>
                        <span id="terrWaterValue" style="min-width: 30px; text-align: right;">0</span>
                    </div>
                    <div class="env-bar" style="display: flex; align-items: center; gap: 12px;">
                        <span style="font-size: 1.5rem;">🌬️</span>
                        <div class="env-bar-bg" style="flex: 1; height: 12px; background: var(--border);">
                            <div class="env-bar-fill" id="terrWindBar" style="height: 100%; background: var(--wind); width: 0%;"></div>
                        </div>
                        <span id="terrWindValue" style="min-width: 30px; text-align: right;">0</span>
                    </div>
                    <div class="env-bar" style="display: flex; align-items: center; gap: 12px;">
                        <span style="font-size: 1.5rem;">🌱</span>
                        <div class="env-bar-bg" style="flex: 1; height: 12px; background: var(--border);">
                            <div class="env-bar-fill" id="terrEarthBar" style="height: 100%; background: var(--earth); width: 0%;"></div>
                        </div>
                        <span id="terrEarthValue" style="min-width: 30px; text-align: right;">0</span>
                    </div>
                    <div class="env-bar" style="display: flex; align-items: center; gap: 12px;">
                        <span style="font-size: 1.5rem;">✨</span>
                        <div class="env-bar-bg" style="flex: 1; height: 12px; background: var(--border);">
                            <div class="env-bar-fill" id="terrLightBar" style="height: 100%; background: var(--light); width: 0%;"></div>
                        </div>
                        <span id="terrLightValue" style="min-width: 30px; text-align: right;">0</span>
                    </div>
                    <div class="env-bar" style="display: flex; align-items: center; gap: 12px;">
                        <span style="font-size: 1.5rem;">🌙</span>
                        <div class="env-bar-bg" style="flex: 1; height: 12px; background: var(--border);">
                            <div class="env-bar-fill" id="terrDarkBar" style="height: 100%; background: var(--dark); width: 0%;"></div>
                        </div>
                        <span id="terrDarkValue" style="min-width: 30px; text-align: right;">0</span>
                    </div>
                </div>
            </div>

            <!-- 설치된 미니어처 -->
            <div style="background: var(--card); border: 1px solid var(--border); padding: 32px; margin-bottom: 20px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                    <h2 style="font-family: 'Nanum Myeongjo', serif; font-size: 1.5rem; margin: 0;">설치된 미니어처</h2>
                    <button onclick="removeAllDecorations()" style="padding: 6px 12px; background: var(--fire); color: white; border: none; border-radius: 4px; font-size: 0.85rem; cursor: pointer;">
                        전체 해제
                    </button>
                </div>
                <div style="font-size: 0.9rem; color: #888; margin-bottom: 20px;">
                    <span id="installedCount">0 / 20</span>
                    <span style="margin-left: 12px;">👑 전설: <span id="legendaryCount" style="color: #9c27b0; font-weight: 600;">0</span> / 5</span>
                </div>
                <div id="installedDecorList"></div>
            </div>

            <!-- 인벤토리 미니어처 -->
            <div style="background: var(--card); border: 1px solid var(--border); padding: 32px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <h2 style="font-family: 'Nanum Myeongjo', serif; font-size: 1.5rem; margin: 0;">인벤토리 미니어처</h2>
                    <div id="terrariumFilterArea" style="display: flex; gap: 8px;"></div>
                </div>
                <div id="terrariumDecorList"></div>
            </div>
        </div>
    </div>

    <!-- Name Modal -->
    <div class="modal" id="nameModal">
        <div class="modal-content">
            <div class="modal-title">정령의 이름을 지어주세요</div>
            <input type="text" class="name-input" id="nameInput" placeholder="이름을 입력하세요" maxlength="10" onkeypress="if(event.key === 'Enter') confirmName()" lang="ko" style="ime-mode: active;">
            <button onclick="confirmName()" style="width: 100%;">확인</button>
        </div>
    </div>

    <!-- Feed Modal -->
    <div class="modal" id="feedModal">
        <div class="modal-content">
            <div class="modal-title">무엇을 먹일까요?</div>
            <div class="food-grid">
                <!-- 초기 더미 버튼 (renderFeedOptions()로 동적 생성됨) -->
            </div>
            <button class="close-btn" onclick="closeModal('feedModal')">닫기</button>
        </div>
    </div>

    <!-- Music Modal -->
    <div class="modal" id="musicModal">
        <div class="modal-content">
            <div class="modal-title">어떤 음악을 들려줄까요?</div>
            <div id="musicOptions"></div>
            <button class="close-btn" onclick="closeModal('musicModal')">닫기</button>
        </div>
    </div>

    <!-- Decorate Modal -->
    <div class="modal" id="decorateModal">
        <div class="modal-content">
            <div class="modal-title">테라리움 꾸미기</div>
            <div id="decorOptions"></div>
            <button class="close-btn" onclick="closeModal('decorateModal')">닫기</button>
        </div>
    </div>

    <!-- 커스텀 확인 모달 -->
    <div id="confirmModal" class="modal">
        <div class="modal-content" style="max-width: 400px;">
            <h3 id="confirmTitle" style="font-family: 'Nanum Myeongjo', serif; font-size: 1.3rem; margin-bottom: 15px; color: var(--text);"></h3>
            <p id="confirmMessage" style="margin-bottom: 25px; line-height: 1.6; color: var(--text); white-space: pre-line;"></p>
            <div style="display: flex; gap: 10px; justify-content: flex-end;">
                <button id="confirmCancelBtn" style="background: #888; color: white;">취소</button>
                <button id="confirmOkBtn" style="background: var(--fire); color: white;">확인</button>
            </div>
        </div>
    </div>

    <script>      let spirits = [];
        let collection = [];
        let encyclopedia = {}; // 도감: { evolutionKey: count }
        let encyclopediaDetails = {}; // 도감 상세: { evolutionKey: [정령 상세 정보 배열] } - 복구용 숨김 데이터
        let darkModeLocked = false; // 다크 모드 고정 여부
        let inventory = {
            music: [],
            decorations: [],
            food: ['fire', 'fire', 'fire', 'water', 'water', 'water', 'wind', 'wind', 'wind', 'earth', 'earth', 'earth'],
            medicine: [] // 약초
        };
        let terrarium = {
            fire: 0,
            water: 0,
            wind: 0,
            earth: 0,
            light: 0,
            dark: 0
        };
        let installedDecorations = []; // 설치된 미니어처 목록 (객체 배열: { type, index })
        let lightMode = true; // 조명 모드 (true: 빛, false: 어둠)
        let coins = 0; // 화폐
        let totalEggsCreated = 0; // 지금까지 생성된 알의 총 개수
        let hasVisitedShop = false; // 상점 첫 방문 여부
        let currentSpiritId = null;
        let pendingSpirit = null;
        let lastGatherTime = null;
        let currentTab = 'garden'; // 현재 활성 탭
        let currentTitle = 'none'; // 현재 칭호 (none, hawk_eye, gatherer, musician, collector)
        let currentShopCategory = 'all'; // 현재 상점 카테고리 (all, food, decoration, music)
        let sellFilter = 'all'; // 판매 필터 (all, fire, water, wind, earth, light, dark, intelligence, strength, charm)
        let buyFilter = 'all'; // 구매 필터 (all, fire, water, wind, earth, light, dark, intelligence, strength, charm)
        let shopFoldState = { etc: false, food: false, music: false, decoration: false }; // 상점 판매 카테고리 접기 상태 (true=접힘)
        let shopBuyFoldState = { etc: false, food: false, music: false, decoration: false }; // 상점 구매 카테고리 접기 상태 (true=접힘)
        let lockedItems = { food: [], decorations: [], music: [] }; // 판매 잠금된 아이템 목록
        let isLockMode = false; // 잠금 모드 상태
        let terrariumInvFilter = 'all'; // 테라리움 인벤토리 필터 (all, fire, water, wind, earth, light, dark, event)
        let terrariumQualityFilter = 'all'; // 테라리움 품질 필터 (all, common, rare, epic, legendary)
        let currentGatherLocation = 'garden'; // 현재 채집 장소 (garden, lake, forest)
        let lightToggleHistory = []; // 조명 변경 기록 (타임스탬프 배열)
        let isPaused = false; // 게임 일시정지 상태
        let pausedAt = null; // 일시정지 시작 시간
        let totalPausedTime = 0; // 총 일시정지 시간
        let activatedEvents = []; // 활성화된 이벤트 목록
        let lowSatisfactionStartTime = {}; // 정령별 불만 상태 시작 시간
        let achievements = {}; // 달성한 업적 목록 { achievementId: timestamp }
        let claimedAchievementRewards = []; // 보상 수령한 업적 목록

        // 업적 정의
        const ACHIEVEMENTS = {
            // 키운 정령의 수 (앨범)
            album_1: {
                id: 'album_1',
                category: 'album',
                requirement: 1,
                title: '테라리움 키퍼로서의 첫 시작',
                icon: '🌱',
                desc: '첫 번째 정령을 성충까지 키웠습니다.'
            },
            album_10: {
                id: 'album_10',
                category: 'album',
                requirement: 10,
                title: '초보 테라리움 키퍼',
                icon: '🌿',
                desc: '10마리의 정령을 성충까지 키웠습니다.'
            },
            album_25: {
                id: 'album_25',
                category: 'album',
                requirement: 25,
                title: '성장하는 테라리움 키퍼',
                icon: '🌳',
                desc: '25마리의 정령을 성충까지 키웠습니다.'
            },
            album_50: {
                id: 'album_50',
                category: 'album',
                requirement: 50,
                title: '숙련된 테라리움 키퍼',
                icon: '🌲',
                desc: '50마리의 정령을 성충까지 키웠습니다.'
            },
            album_70: {
                id: 'album_70',
                category: 'album',
                requirement: 70,
                title: '베테랑 테라리움 키퍼',
                icon: '🏆',
                desc: '70마리의 정령을 성충까지 키웠습니다.'
            },
            album_100: {
                id: 'album_100',
                category: 'album',
                requirement: 100,
                title: '전설의 테라리움 키퍼',
                icon: '👑',
                desc: '100마리의 정령을 성충까지 키웠습니다.'
            },
            // 도감 채운 수
            encyclopedia_5: {
                id: 'encyclopedia_5',
                category: 'encyclopedia',
                requirement: 5,
                title: '도감 수집가',
                icon: '📖',
                desc: '도감에 5종류의 정령을 등록했습니다.'
            },
            encyclopedia_10: {
                id: 'encyclopedia_10',
                category: 'encyclopedia',
                requirement: 10,
                title: '열정적인 수집가',
                icon: '📚',
                desc: '도감에 10종류의 정령을 등록했습니다.'
            },
            encyclopedia_25: {
                id: 'encyclopedia_25',
                category: 'encyclopedia',
                requirement: 25,
                title: '박학다식한 수집가',
                icon: '🔬',
                desc: '도감에 25종류의 정령을 등록했습니다.'
            },
            encyclopedia_50: {
                id: 'encyclopedia_50',
                category: 'encyclopedia',
                requirement: 50,
                title: '정령 박사',
                icon: '🎓',
                desc: '도감에 50종류의 정령을 등록했습니다.'
            },
            // 레시피 발견 수
            recipe_5: {
                id: 'recipe_5',
                category: 'recipe',
                requirement: 5,
                title: '견습 연금술사',
                icon: '🧪',
                desc: '5개의 레시피를 발견했습니다.'
            },
            recipe_15: {
                id: 'recipe_15',
                category: 'recipe',
                requirement: 15,
                title: '숙련 연금술사',
                icon: '⚗️',
                desc: '15개의 레시피를 발견했습니다.'
            },
            recipe_28: {
                id: 'recipe_28',
                category: 'recipe',
                requirement: 28,
                title: '마스터 연금술사',
                icon: '🔮',
                desc: '모든 레시피를 발견했습니다!'
            },
            // 레시피북 없이 직접 발견 (특별 업적)
            recipe_self_all: {
                id: 'recipe_self_all',
                category: 'recipe_special',
                requirement: 28,
                title: '진정한 연금술의 대가',
                icon: '🏅',
                desc: '레시피북 없이 모든 레시피를 직접 발견했습니다!'
            }
        };

        // 랜덤 문구 시스템
        const RANDOM_MESSAGES = {
            // 알 상태 기본 행동
            egg_basic: [
                '{name}이(가) 가만히 있습니다.',
                '{name}이(가) 조용히 놓여 있습니다.',
                '{name}에서 미세한 온기가 느껴집니다.',
                '{name}의 껍질이 살짝 흔들립니다.',
                '{name}에서 작은 소리가 들리는 것 같습니다.',
                '{name}이(가) 희미하게 빛납니다.',
                '{name}의 표면에 이슬이 맺혀 있습니다.',
                '{name}이(가) 따뜻하게 품어지길 기다리는 듯합니다.',
                '{name} 안에서 무언가 움직이는 것 같습니다.',
                '{name}이(가) 부화를 준비하고 있는 것 같습니다.'
            ],
            // 번데기 상태 기본 행동
            pupa_basic: [
                '{name}이(가) 미동도 하지 않습니다.',
                '{name}이(가) 조용히 변태 중입니다.',
                '{name}에서 약한 진동이 느껴집니다.',
                '{name}의 껍질이 아주 살짝 꿈틀거립니다.',
                '{name}이(가) 고요히 잠들어 있습니다.',
                '{name} 안에서 변화가 일어나고 있는 것 같습니다.',
                '{name}의 표면이 희미하게 빛납니다.',
                '{name}이(가) 나비가 될 꿈을 꾸고 있는 것 같습니다.',
                '{name}이(가) 새로운 모습을 준비하고 있습니다.',
                '{name}에서 신비로운 기운이 느껴집니다.'
            ],
            // 기본 행동 (조건 없음) - 애벌레용
            basic: [
                '{name}이(가) 꿈틀거립니다.',
                '{name}이(가) 몸을 부르르 떱니다.',
                '{name}이(가) 주변을 두리번거립니다.',
                '{name}이(가) 작게 울음소리를 냅니다.',
                '{name}이(가) 가만히 웅크리고 있습니다.',
                '{name}이(가) 천천히 움직입니다.',
                '{name}이(가) 테라리움 유리에 몸을 문지릅니다.',
                '{name}이(가) 몸을 살짝 떨고 있습니다.',
                '{name}이(가) 자신의 몸을 정리합니다.',
                '{name}이(가) 무언가를 찾는 듯합니다.',
                '{name}이(가) 외로워합니다.',
                '{name}이(가) 심심해 보입니다.',
                '{name}이(가) 한숨을 쉽니다.'
            ],
            // 알 상태 배고픔
            egg_hungry: [
                '{name}에서 허기진 기운이 느껴집니다.',
                '{name}이(가) 영양분이 필요한 것 같습니다.',
                '{name}의 빛이 조금 약해진 것 같습니다.',
                '{name}이(가) 힘없이 놓여 있습니다.'
            ],
            // 번데기 상태 배고픔
            pupa_hungry: [
                '{name}이(가) 힘없이 축 처져 있습니다.',
                '{name}에서 약한 기운이 느껴집니다.',
                '{name}의 변태가 느려진 것 같습니다.',
                '{name}이(가) 에너지가 부족해 보입니다.'
            ],
            // 배고픔 - 애벌레용
            hungry: [
                '{name}이(가) 배고파 보입니다.',
                '{name}이(가) 먹이를 찾고 있습니다.',
                '{name}이(가) 허기진 눈빛으로 당신을 봅니다.',
                '{name}이(가) 입맛을 다십니다.',
                '{name}이(가) 배를 움켜쥐고 있습니다.'
            ],
            // 알 상태 낮잠
            egg_napLight: [
                '{name}이(가) 햇살 아래에서 따뜻합니다.',
                '{name}에서 평온한 기운이 느껴집니다.',
                '{name}이(가) 포근하게 놓여 있습니다.'
            ],
            // 알 상태 밤잠
            egg_sleepDark: [
                '{name}이(가) 어둠 속에서 고요합니다.',
                '{name}이(가) 조용히 쉬고 있습니다.',
                '{name}에서 잔잔한 숨소리가 들리는 듯합니다.'
            ],
            // 번데기 상태 낮잠
            pupa_napLight: [
                '{name}이(가) 햇살 아래에서 변태 중입니다.',
                '{name}이(가) 따뜻한 빛을 받으며 쉬고 있습니다.',
                '{name}의 껍질이 햇살에 빛납니다.'
            ],
            // 번데기 상태 밤잠
            pupa_sleepDark: [
                '{name}이(가) 어둠 속에서 깊이 잠들어 있습니다.',
                '{name}이(가) 고요한 밤에 변화하고 있습니다.',
                '{name}이(가) 달빛 아래 조용히 쉬고 있습니다.'
            ],
            // 낮잠 (조명 켜짐) - 애벌레용
            napLight: [
                '{name}이(가) 낮잠을 자고 있습니다.',
                '{name}이(가) 햇살 아래에서 졸고 있습니다.',
                '{name}이(가) 편안하게 눈을 감고 있습니다.',
                '{name}이(가) 스르륵 잠이 들었습니다.',
                '{name}이(가) 나뭇잎 위에서 낮잠을 즐깁니다.'
            ],
            // 밤잠 (조명 꺼짐) - 애벌레용
            sleepDark: [
                '{name}이(가) 잠을 자고 있습니다.',
                '{name}이(가) 깊은 잠에 빠졌습니다.',
                '{name}이(가) 고요히 잠들어 있습니다.',
                '{name}이(가) 어둠 속에서 편히 쉬고 있습니다.',
                '{name}이(가) 조용히 꿈나라로 떠났습니다.'
            ],
            // 알 상태 애정도 낮음
            egg_affectionLow: [
                '{name}이(가) 쓸쓸해 보입니다.',
                '{name}에서 외로운 기운이 느껴집니다.',
                '{name}이(가) 관심이 필요한 것 같습니다.'
            ],
            // 번데기 상태 애정도 낮음
            pupa_affectionLow: [
                '{name}이(가) 외로워 보입니다.',
                '{name}에서 쓸쓸한 기운이 느껴집니다.',
                '{name}이(가) 보살핌이 필요해 보입니다.'
            ],
            // 애정도 낮음 (0-10) - 애벌레용
            affectionVeryLow: [
                '{name}이(가) 당신을 피해 테라리움 구석에 숨습니다.',
                '{name}이(가) 당신을 경계하며 멀리 떨어집니다.',
                '{name}이(가) 고개를 돌려 당신을 외면합니다.',
                '{name}이(가) 불안한 듯 몸을 떨고 있습니다.',
                '{name}이(가) 당신 앞에서 움츠러듭니다.'
            ],
            // 애정도 낮음 (10-30)
            affectionLow: [
                '{name}이(가) 당신을 빤히 바라봅니다.',
                '{name}이(가) 조심스럽게 당신을 관찰합니다.',
                '{name}이(가) 살짝 당신에게 다가옵니다.',
                '{name}이(가) 당신에게 관심을 보이기 시작합니다.',
                '{name}이(가) 호기심 어린 눈으로 당신을 봅니다.'
            ],
            // 애정도 중간 (30-50)
            affectionMedium: [
                '{name}이(가) 당신의 손에 뺨을 부빕니다.',
                '{name}이(가) 당신 주변을 빙글빙글 돕니다.',
                '{name}이(가) 당신의 손가락을 살짝 건드립니다.',
                '{name}이(가) 당신에게 애교를 부립니다.',
                '{name}이(가) 당신 곁에 가까이 다가옵니다.'
            ],
            // 애정도 높음 (50-100)
            affectionHigh: [
                '{name}이(가) 당신을 보며 행복해합니다.',
                '{name}이(가) 당신의 손바닥에서 뒹굽니다.',
                '{name}이(가) 당신에게 애정 어린 눈빛을 보냅니다.',
                '{name}이(가) 당신의 손을 꼭 붙잡습니다.',
                '{name}이(가) 당신과 함께 있어 즐거워 보입니다.'
            ],
            // 애정도 매우 높음 (100+)
            affectionVeryHigh: [
                '{name}이(가) 당신을 깊이 신뢰하고 있습니다.',
                '{name}이(가) 당신의 품에 파고듭니다.',
                '{name}이(가) 당신을 향한 사랑을 표현합니다.',
                '{name}이(가) 당신의 손에 입맞춤합니다.',
                '{name}이(가) 당신 없이는 못 산다는 듯 쳐다봅니다.'
            ],
            // 음악 관련 (최근에 음악 들음) - 애벌레용
            music: [
                '{name}이(가) {music}을(를) 흥얼거립니다.',
                '{name}이(가) {music}에 맞춰 춤을 춥니다.',
                '{name}이(가) {music}의 선율을 떠올립니다.',
                '{name}이(가) 음악에 취해 있습니다.',
                '{name}이(가) {music}의 여운에 젖어 있습니다.'
            ],
            // 알 상태 음악 관련
            egg_music: [
                '{name}에서 {music}에 반응하는 진동이 느껴집니다.',
                '{name}의 껍질이 {music}에 맞춰 희미하게 빛납니다.',
                '{name}이(가) {music}의 선율에 반응합니다.',
                '{name} 안에서 음악을 즐기는 듯한 기운이 느껴집니다.'
            ],
            // 번데기 상태 음악 관련
            pupa_music: [
                '{name}에서 {music}에 반응하는 약한 진동이 느껴집니다.',
                '{name}의 껍질이 {music}에 맞춰 살짝 떨립니다.',
                '{name}이(가) {music}의 선율에 미세하게 반응합니다.',
                '{name} 안에서 음악을 즐기는 듯한 기운이 느껴집니다.'
            ],
            // 미니어처 관련 (30개 전체)
            decorations: {
                // 불 속성
                fire_common1: [
                    '{name}이(가) 용암석에서 흐르는 열기를 바라봅니다.',
                    '{name}이(가) 용암석의 불을 신기하게 쳐다봅니다.',
                    '{name}이(가) 뜨거운 용암석 근처에서 따뜻함을 느낍니다.'
                ],
                fire_common2: [
                    '{name}이(가) 화산재를 톡톡 건드립니다.',
                    '{name}이(가) 화산재의 향을 맡고 있습니다.',
                    '{name}이(가) 화산재 더미 옆에서 놀고 있습니다.'
                ],
                fire_rare1: [
                    '{name}이(가) 불꽃 조각상을 경외하며 바라봅니다.',
                    '{name}이(가) 불꽃 조각상의 아름다움에 매료되어 있습니다.',
                    '{name}이(가) 불꽃 조각상 주변을 빙글빙글 돕니다.'
                ],
                fire_rare2: [
                    '{name}이(가) 타오르는 램프의 불빛을 구경합니다.',
                    '{name}이(가) 램프 불빛에 그림자를 드리웁니다.',
                    '{name}이(가) 램프의 따뜻한 빛을 즐깁니다.'
                ],
                fire_epic: [
                    '{name}이(가) 불사조 깃털의 신비로운 기운을 느낍니다.',
                    '{name}이(가) 불사조 깃털이 내뿜는 불꽃에 감탄합니다.',
                    '{name}이(가) 불사조 깃털 앞에서 경건해집니다.'
                ],
                
                // 물 속성
                water_common1: [
                    '{name}이(가) 분수의 물줄기를 구경합니다.',
                    '{name}이(가) 분수 물소리에 귀를 기울입니다.',
                    '{name}이(가) 분수에서 튀는 물방울과 놀고 있습니다.'
                ],
                water_common2: [
                    '{name}이(가) 조약돌을 톡톡 두드립니다.',
                    '{name}이(가) 매끈한 조약돌을 굴리고 있습니다.',
                    '{name}이(가) 조약돌 위에서 쉬고 있습니다.'
                ],
                water_rare1: [
                    '{name}이(가) 산호 장식의 색깔에 감탄합니다.',
                    '{name}이(가) 산호 사이를 헤엄치듯 움직입니다.',
                    '{name}이(가) 산호의 신비로운 모습을 관찰합니다.'
                ],
                water_rare2: [
                    '{name}이(가) 물방울 구슬에 자신의 모습을 비춰봅니다.',
                    '{name}이(가) 구슬 속 물방울을 신기하게 쳐다봅니다.',
                    '{name}이(가) 물방울 구슬을 굴리며 놀고 있습니다.'
                ],
                water_epic: [
                    '{name}이(가) 인어의 눈물이 빛나는 모습에 넋을 잃습니다.',
                    '{name}이(가) 인어의 눈물에서 나오는 물의 기운을 느낍니다.',
                    '{name}이(가) 인어의 눈물 앞에서 경건해집니다.'
                ],
                
                // 바람 속성
                wind_common1: [
                    '{name}이(가) 바람개비를 신기하게 바라봅니다.',
                    '{name}이(가) 바람개비가 도는 모습에 감탄합니다.',
                    '{name}이(가) 바람개비와 함께 빙글빙글 돕니다.'
                ],
                wind_common2: [
                    '{name}이(가) 부드러운 깃털을 살짝 만집니다.',
                    '{name}이(가) 깃털이 흔들리는 모습을 구경합니다.',
                    '{name}이(가) 깃털 위에서 가볍게 뛰어놉니다.'
                ],
                wind_rare1: [
                    '{name}이(가) 풍경 소리에 귀를 기울입니다.',
                    '{name}이(가) 풍경이 울리는 소리를 즐깁니다.',
                    '{name}이(가) 풍경과 함께 리듬을 타고 있습니다.'
                ],
                wind_rare2: [
                    '{name}이(가) 민들레 솜털의 씨앗이 날아가는 것을 바라봅니다.',
                    '{name}이(가) 민들레 솜털에 살짝 입김을 불어봅니다.',
                    '{name}이(가) 민들레 솜털 사이에서 숨바꼭질을 합니다.'
                ],
                wind_epic: [
                    '{name}이(가) 하늘의 깃털에서 나오는 바람을 느낍니다.',
                    '{name}이(가) 하늘의 깃털이 빛나는 모습에 감탄합니다.',
                    '{name}이(가) 하늘의 깃털 앞에서 경건해집니다.'
                ],
                
                // 땅 속성
                earth_common1: [
                    '{name}이(가) 화분의 흙냄새를 맡고 있습니다.',
                    '{name}이(가) 화분 속 식물을 살펴봅니다.',
                    '{name}이(가) 화분 주변을 기어다닙니다.'
                ],
                earth_common2: [
                    '{name}이(가) 이끼돌의 촉촉한 표면을 만집니다.',
                    '{name}이(가) 이끼 사이를 탐험하고 있습니다.',
                    '{name}이(가) 이끼돌에서 자연의 기운을 느낍니다.'
                ],
                earth_rare1: [
                    '{name}이(가) 나무 조각의 나이테를 세어봅니다.',
                    '{name}이(가) 나무 조각의 질감을 즐깁니다.',
                    '{name}이(가) 나무 조각 위를 오르내리고 있습니다.'
                ],
                earth_rare2: [
                    '{name}이(가) 버섯 군락을 신기하게 쳐다봅니다.',
                    '{name}이(가) 버섯 사이를 헤집고 다닙니다.',
                    '{name}이(가) 버섯의 포자 향을 맡고 있습니다.'
                ],
                earth_epic: [
                    '{name}이(가) 세계수 가지의 생명력을 느낍니다.',
                    '{name}이(가) 세계수 가지에서 나오는 고대의 기운에 압도됩니다.',
                    '{name}이(가) 세계수 가지 앞에서 경건해집니다.'
                ],
                
                // 빛 속성
                light_common1: [
                    '{name}이(가) 수정에 자신의 얼굴을 비춰봅니다.',
                    '{name}이(가) 빛나는 수정을 구경합니다.',
                    '{name}이(가) 수정이 반사하는 무지개를 쫓아갑니다.'
                ],
                light_common2: [
                    '{name}이(가) 반짝이 가루를 톡톡 건드립니다.',
                    '{name}이(가) 반짝이는 가루에 뒹굽니다.',
                    '{name}이(가) 반짝이 가루가 빛나는 모습을 즐깁니다.'
                ],
                light_rare1: [
                    '{name}이(가) 빛나는 보석의 광채에 넋을 잃습니다.',
                    '{name}이(가) 보석이 만들어내는 빛의 향연을 감상합니다.',
                    '{name}이(가) 보석 옆에서 함께 빛나고 있습니다.'
                ],
                light_rare2: [
                    '{name}이(가) 태양석의 따뜻한 빛을 쬡니다.',
                    '{name}이(가) 태양석 앞에서 몸을 쭉 펴고 있습니다.',
                    '{name}이(가) 태양석의 광채를 온몸으로 받고 있습니다.'
                ],
                light_epic: [
                    '{name}이(가) 별의 파편이 빛나는 모습에 경외합니다.',
                    '{name}이(가) 별의 파편에서 나오는 우주의 기운을 느낍니다.',
                    '{name}이(가) 별의 파편 앞에서 경건해집니다.'
                ],
                
                // 어둠 속성
                dark_common1: [
                    '{name}이(가) 흑요석의 깊은 어둠에 빠져듭니다.',
                    '{name}이(가) 흑요석의 매끈한 표면을 쓰다듬습니다.',
                    '{name}이(가) 흑요석 옆에서 조용히 명상합니다.'
                ],
                dark_common2: [
                    '{name}이(가) 검은 모래를 파헤치고 있습니다.',
                    '{name}이(가) 검은 모래 위에 그림을 그립니다.',
                    '{name}이(가) 검은 모래의 감촉을 즐깁니다.'
                ],
                dark_rare1: [
                    '{name}이(가) 달빛석을 조용히 바라봅니다.',
                    '{name}이(가) 달빛석의 은은한 빛에 잠깁니다.',
                    '{name}이(가) 달빛석과 함께 밤의 기운을 느낍니다.'
                ],
                dark_rare2: [
                    '{name}이(가) 그림자 수정 속을 들여다봅니다.',
                    '{name}이(가) 그림자 수정의 신비로운 모습에 매료됩니다.',
                    '{name}이(가) 그림자 수정이 만들어내는 어둠을 즐깁니다.'
                ],
                dark_epic: [
                    '{name}이(가) 밤의 정수에서 나오는 어둠의 힘을 느낍니다.',
                    '{name}이(가) 밤의 정수가 품은 신비에 압도됩니다.',
                    '{name}이(가) 밤의 정수 앞에서 경건해집니다.'
                ]
            },
            // 정령 간 상호작용
            interaction: {
                decoration: [
                    '{name1}과(와) {name2}이(가) 함께 {deco}을(를) 구경합니다.',
                    '{name1}이(가) {name2}에게 {deco}을(를) 보여줍니다.',
                    '{name1}과(와) {name2}이(가) {deco} 주위를 빙글빙글 돕니다.',
                    '{name1}과(와) {name2}이(가) {deco} 옆에서 함께 쉬고 있습니다.',
                    '{name1}이(가) {name2}와(과) {deco}을(를) 함께 즐기고 있습니다.'
                ],
                sharing: [
                    '{name1}이(가) {name2}에게 먹이를 나눠줍니다.',
                    '{name1}이(가) {name2}와(과) 먹이를 함께 먹습니다.',
                    '{name1}과(와) {name2}이(가) 서로의 먹이를 나누고 있습니다.'
                ],
                fight: [
                    '{name1}과(와) {name2}이(가) 서로를 깨뭅니다.',
                    '{name1}이(가) {name2}와(과) 장난스럽게 싸웁니다.',
                    '{name1}과(와) {name2}이(가) 으르렁거리며 대치합니다.',
                    '{name1}이(가) {name2}를(을) 쫓아다닙니다.'
                ],
                rest: [
                    '{name1}과(와) {name2}이(가) 서로에게 기대어 잠이 듭니다.',
                    '{name1}이(가) {name2} 옆에서 편안히 쉬고 있습니다.',
                    '{name1}과(와) {name2}이(가) 나란히 낮잠을 자고 있습니다.',
                    '{name1}이(가) {name2}를(을) 베개 삼아 잠들었습니다.',
                    '{name1}과(와) {name2}이(가) 함께 꿈나라로 떠났습니다.'
                ],
                song: [
                    '{name1}이(가) {name2}에게 자신이 좋아하는 노래를 불러줍니다.',
                    '{name1}과(와) {name2}이(가) 함께 노래를 부릅니다.',
                    '{name1}이(가) {name2}를(을) 위해 음악을 연주합니다.',
                    '{name1}이(가) {name2}와(과) 함께 춤을 춥니다.'
                ],
                play: [
                    '{name1}과(와) {name2}이(가) 숨바꼭질을 하고 있습니다.',
                    '{name1}이(가) {name2}와(과) 술래잡기를 즐깁니다.',
                    '{name1}과(와) {name2}이(가) 재미있게 놀고 있습니다.',
                    '{name1}이(가) {name2}를(을) 간지럽힙니다.',
                    '{name1}과(와) {name2}이(가) 함께 웃고 떠들고 있습니다.'
                ],
                talk: [
                    '{name1}과(와) {name2}이(가) 수다를 떨고 있습니다.',
                    '{name1}이(가) {name2}에게 무언가 이야기하고 있습니다.',
                    '{name1}과(와) {name2}이(가) 즐겁게 대화를 나눕니다.',
                    '{name1}이(가) {name2}의 이야기를 경청하고 있습니다.'
                ]
            }
        };

        const STAGE_REQUIREMENTS = {
            egg: 0,
            larva1: 10,
            larva2: 25,
            larva3: 45,
            pupa: 70,
            adult: 100
        };

        const STAGE_ICONS = {
            egg: '<img src="https://i.imgur.com/o7CifqJ.png" style="width:150px;height:150px;vertical-align:middle;">',
            larva1: '<img src="https://i.imgur.com/ORqIuM4.png" style="width:150px;height:150px;vertical-align:middle;">',
            larva2: '<img src="https://i.imgur.com/9sA8M5u.png" style="width:150px;height:150px;vertical-align:middle;">',
            larva3: '<img src="https://i.imgur.com/tXVDb33.png" style="width:150px;height:150px;vertical-align:middle;">',
            pupa: '<img src="https://i.imgur.com/YW0GzIN.png" style="width:150px;height:150px;vertical-align:middle;">',
            adult: '🦋'
        };

        const STAGE_NAMES = {
            egg: '알',
            larva1: '애벌레 1령',
            larva2: '애벌레 2령',
            larva3: '애벌레 3령',
            pupa: '번데기',
            adult: '성충'
        };
        
        // 성장 단계별 속성 외형 묘사
        const APPEARANCE_DESCRIPTIONS = {
            egg: {
                fire: '껍질이 따뜻하고 미세한 열기가 느껴집니다.',
                water: '촉촉하고 투명한 광택이 흐릅니다.',
                wind: '껍질이 부드럽고 가볍습니다.',
                earth: '단단하고 거친 질감이 있습니다.',
                light: '은은한 빛이 내부에서 비칩니다.',
                dark: '짙은 색으로 깊이를 알 수 없습니다.',
                normal: '평범한 흰색 알입니다.'
            },
            larva1: {
                fire: '몸이 붉게 물들고 따뜻한 기운이 느껴집니다.',
                water: '촉촉한 피부에서 물방울이 맺힙니다.',
                wind: '몸이 가볍고 바람에 흔들립니다.',
                earth: '단단한 갈색 피부로 덮여있습니다.',
                light: '온몸에서 은은한 빛이 납니다.',
                dark: '어두운 보라빛 몸을 하고 있습니다.',
                normal: '투명한 초록빛 몸을 하고 있습니다.'
            },
            larva2: {
                fire: '외견이 붉고, 만졌을 때 따뜻하며 머리카락이 불꽃처럼 일렁입니다.',
                water: '푸른빛이 도는 몸에서 시원한 기운이 나며, 몸 표면에 물결 무늬가 있습니다.',
                wind: '연한 하늘색 몸에 깃털 같은 솜털이 돋아있고, 공중에 둥둥 떠오릅니다.',
                earth: '갈색빛 몸에 작은 이끼가 자라고, 만지면 흙 냄새가 납니다.',
                light: '금빛으로 빛나는 몸에서 따뜻한 빛이 발산되며, 주변을 밝힙니다.',
                dark: '깊은 남색 몸에 별빛 같은 반점이 있고, 주변의 빛을 흡수합니다.',
                normal: '투명한 몸에 무지개빛이 은은하게 감돕니다.',
                // 혼합 속성
                'dark-earth': '어두운 갈색 몸에 밤 이슬이 맺히고 흙의 향기가 납니다.',
                'dark-fire': '검붉은 몸에서 어두운 열기가 피어오르며 신비로운 빛이 깜빡입니다.',
                'dark-light': '반은 빛나고 반은 어두운 몸이 황혼의 아름다움을 담고 있습니다.',
                'dark-water': '짙은 청색 몸에서 심해의 물결 무늬가 흐르고 차가운 기운이 납니다.',
                'dark-wind': '검은 솜털이 돋은 몸이 밤바람처럼 가볍게 흔들립니다.',
                'earth-fire': '붉은 흙빛 몸에 작은 불꽃 무늬가 있고 따뜻한 온기가 느껴집니다.',
                'earth-light': '황금빛 몸에 작은 새싹이 돋아나고 생명의 빛을 발합니다.',
                'earth-water': '청록색 몸에 이끼와 물방울이 함께 맺혀있고 촉촉합니다.',
                'earth-wind': '연두색 몸에서 풀잎 향기가 나고 산들바람에 흔들립니다.',
                'fire-light': '눈부신 황금빛 몸에서 태양 같은 열기와 빛이 뿜어져 나옵니다.',
                'fire-water': '붉은 보라빛 몸에서 증기가 피어오르고 열기와 습기가 뒤섞입니다.',
                'fire-wind': '주황색 몸 주변으로 뜨거운 바람이 일렁이며 흐릅니다.',
                'light-water': '맑은 하늘빛 몸에서 은은한 빛과 시원한 물방울이 흐릅니다.',
                'light-wind': '빛나는 흰 솜털에 둘러싸여 빛의 바람을 타고 떠오릅니다.',
                'water-wind': '하늘색 몸 주변에 물안개가 감돌고 산들바람이 불어옵니다.'
            },
            larva3: {
                fire: '온몸이 주황빛 불꽃으로 감싸여 있고, 숨을 쉴 때마다 작은 불똥이 튑니다.',
                water: '깊은 청록색 몸에서 작은 물줄기가 흘러내리고, 주변 공기가 축축합니다.',
                wind: '은빛 날개 비늘이 돋아나고, 움직일 때마다 바람이 일어납니다.',
                earth: '단단한 나무껍질 같은 외피에 작은 꽃봉오리가 피어있습니다.',
                light: '눈부신 황금빛으로 빛나며, 주변에 무지개 후광이 보입니다.',
                dark: '칠흑 같은 몸에 은하수 같은 빛의 띠가 흐르고, 그림자가 춤춥니다.',
                normal: '맑고 투명한 몸에 모든 색이 은은하게 어우러집니다.',
                // 혼합 속성
                'dark-earth': '검은 나무껍질 같은 외피에 밤꽃이 피어있고 어둠의 향기가 납니다.',
                'dark-fire': '검붉은 불꽃이 어둠 속에서 타오르며 작은 불똥과 그림자가 춤춥니다.',
                'dark-light': '빛과 어둠이 교차하는 몸에서 새벽과 황혼의 기운이 동시에 느껴집니다.',
                'dark-water': '깊은 남색 몸에서 밤바다의 물결이 흐르고 신비로운 물방울이 맺힙니다.',
                'dark-wind': '검은 날개 비늘이 돋아나며 밤바람이 소용돌이치고 그림자가 흩날립니다.',
                'earth-fire': '적갈색 몸에서 용암 같은 열기가 뿜어져 나오고 작은 꽃불이 핍니다.',
                'earth-light': '황금빛 나무껍질에 빛나는 꽃들이 만개하고 생명의 후광이 빛납니다.',
                'earth-water': '청록색 몸에 이끼와 물이끼가 자라고 계곡물이 흘러내립니다.',
                'earth-wind': '연두빛 몸에서 새싹이 돋아나고 봄바람에 실려 향기가 퍼집니다.',
                'fire-light': '찬란한 태양빛 불꽃이 온몸을 감싸고 눈부신 황금빛이 폭발합니다.',
                'fire-water': '붉은 몸에서 뜨거운 증기가 솟아오르고 물과 불이 역동적으로 충돌합니다.',
                'fire-wind': '주황빛 몸 주변으로 열풍이 소용돌이치고 불꽃이 바람을 타고 춤춥니다.',
                'light-water': '은은한 청백색 몸에서 맑은 빛과 물방울이 조화롭게 흐릅니다.',
                'light-wind': '빛나는 은빛 날개 비늘이 빛의 바람을 일으키며 무지개빛으로 반짝입니다.',
                'water-wind': '하늘빛 몸 주변에 물보라와 바람이 소용돌이치며 아름다운 안개를 만듭니다.'
            },
            pupa: {
                fire: '붉은 수정 같은 번데기에서 열기가 피어오르고, 내부에 불꽃이 춤춥니다.',
                water: '푸른 얼음 같은 번데기 속에서 물결이 일렁이며 변화가 일어납니다.',
                wind: '하얀 구름 같은 번데기가 공중에 떠있고, 바람에 맞춰 회전합니다.',
                earth: '나무 옹이 같은 번데기에서 새순이 돋아나고 있습니다.',
                light: '빛나는 크리스탈 번데기에서 무지개빛이 퍼져나옵니다.',
                dark: '검은 보석 같은 번데기에서 신비로운 별빛이 깜빡입니다.',
                normal: '순백의 번데기가 조용히 변화를 준비하고 있습니다.',
                // 혼합 속성 (15개 조합)
                'dark-earth': '짙은 갈색 번데기에서 밤의 기운과 대지의 향기가 뒤섞입니다.',
                'dark-fire': '검붉은 번데기에서 어둠 속 불꽃이 타오르며 신비로운 열기가 납니다.',
                'dark-light': '흑백이 교차하는 번데기에서 빛과 어둠이 조화롭게 춤춥니다.',
                'dark-water': '짙은 남색 번데기 속에서 심해의 물결이 일렁입니다.',
                'dark-wind': '검은 구름 같은 번데기가 밤바람을 타고 천천히 회전합니다.',
                'earth-fire': '붉은 흙빛 번데기에서 용암의 열기와 대지의 생명력이 느껴집니다.',
                'earth-light': '황금빛 나무 번데기에서 따뜻한 빛과 생명의 기운이 넘칩니다.',
                'earth-water': '청록색 번데기에서 숲의 이슬과 대지의 향기가 섞여 나옵니다.',
                'earth-wind': '연두빛 번데기가 미풍에 흔들리며 새싹의 향기를 풍깁니다.',
                'fire-light': '찬란한 황금빛 번데기에서 태양 같은 빛과 열기가 뿜어져 나옵니다.',
                'fire-water': '붉은 수증기로 둘러싸인 번데기에서 불과 물이 역동적으로 섞입니다.',
                'fire-wind': '주황빛 번데기 주변으로 뜨거운 바람이 소용돌이칩니다.',
                'light-water': '은은한 청백색 번데기에서 맑은 빛과 시원한 기운이 퍼집니다.',
                'light-wind': '빛나는 백색 번데기가 빛의 바람을 타고 부드럽게 떠오릅니다.',
                'water-wind': '하늘빛 번데기 주변에 물안개와 산들바람이 감돕니다.'
            }
        };

        const PARAM_ICONS = {
            intelligence: '🧠',
            strength: '💪',
            charm: '💖',
            affection: '❤️'
        };

        const ENV_ICONS = {
            fire: '🔥',
            water: '💧',
            wind: '🌬️',
            earth: '🌱',
            light: '✨',
            dark: '🌙'
        };
        
        const ENV_NAMES = {
            fire: '불',
            water: '물',
            wind: '바람',
            earth: '땅',
            light: '빛',
            dark: '어둠'
        };

        const MUSIC_TYPES = {
            classic: { name: '클래식 🎻', icon: '🎻', effect: '지력 +10' },
            jazz: { name: '재즈 🎷', icon: '🎷', effect: '매력 +10' },
            rock: { name: '록 🎸', icon: '🎸', effect: '체력 +10' },
            pop: { name: '팝 🎤', icon: '🎤', effect: '지력 +5, 매력 +5' },
            ballad: { name: '발라드 🎹', icon: '🎹', effect: '체력 +5, 매력 +5' },
            edm: { name: 'EDM 🎧', icon: '🎧', effect: '지력 +5, 체력 +5' }
        };

        const DECORATION_TYPES = {
            // 불 속성 (6개)
            fire_common1: { name: '용암석', icon: '🔥', attr: 'fire', power: 1, quality: 'common', price: 30 },
            fire_common2: { name: '화산재', icon: '🌋', attr: 'fire', power: 1, quality: 'common', price: 30 },
            fire_rare1: { name: '불꽃 조각상', icon: '🔆', attr: 'fire', power: 2, quality: 'rare', price: 60 },
            fire_rare2: { name: '타오르는 램프', icon: '🏮', attr: 'fire', power: 2, quality: 'rare', price: 60 },
            fire_epic: { name: '불사조 깃털', icon: '🦅', attr: 'fire', power: 3, quality: 'epic', price: 100 },
            fire_legendary: { name: '태초의 불꽃', icon: '🔱', attr: 'fire', power: 5, quality: 'legendary', price: 999 },
            
            // 물 속성 (6개)
            water_common1: { name: '분수', icon: '💧', attr: 'water', power: 1, quality: 'common', price: 30 },
            water_common2: { name: '조약돌', icon: '🪨', attr: 'water', power: 1, quality: 'common', price: 30 },
            water_rare1: { name: '산호 장식', icon: '🪸', attr: 'water', power: 2, quality: 'rare', price: 60 },
            water_rare2: { name: '물방울 구슬', icon: '💎', attr: 'water', power: 2, quality: 'rare', price: 60 },
            water_epic: { name: '인어의 눈물', icon: '🧜', attr: 'water', power: 3, quality: 'epic', price: 100 },
            water_legendary: { name: '심해의 심장', icon: '🫀', attr: 'water', power: 5, quality: 'legendary', price: 999 },
            
            // 바람 속성 (6개)
            wind_common1: { name: '바람개비', icon: '🌬️', attr: 'wind', power: 1, quality: 'common', price: 30 },
            wind_common2: { name: '부드러운 깃털', icon: '🪶', attr: 'wind', power: 1, quality: 'common', price: 30 },
            wind_rare1: { name: '풍경', icon: '🎐', attr: 'wind', power: 2, quality: 'rare', price: 60 },
            wind_rare2: { name: '민들레 솜털', icon: '🌾', attr: 'wind', power: 2, quality: 'rare', price: 60 },
            wind_epic: { name: '하늘의 깃털', icon: '☁️', attr: 'wind', power: 3, quality: 'epic', price: 100 },
            wind_legendary: { name: '폭풍의 눈', icon: '🌀', attr: 'wind', power: 5, quality: 'legendary', price: 999 },
            
            // 땅 속성 (6개)
            earth_common1: { name: '화분', icon: '🌱', attr: 'earth', power: 1, quality: 'common', price: 30 },
            earth_common2: { name: '이끼돌', icon: '🪵', attr: 'earth', power: 1, quality: 'common', price: 30 },
            earth_rare1: { name: '나무 조각', icon: '🌳', attr: 'earth', power: 2, quality: 'rare', price: 60 },
            earth_rare2: { name: '버섯 군락', icon: '🍄', attr: 'earth', power: 2, quality: 'rare', price: 60 },
            earth_epic: { name: '세계수 가지', icon: '🌲', attr: 'earth', power: 3, quality: 'epic', price: 100 },
            earth_legendary: { name: '대지의 정수', icon: '💎', attr: 'earth', power: 5, quality: 'legendary', price: 999 },
            
            // 빛 속성 (6개)
            light_common1: { name: '수정', icon: '✨', attr: 'light', power: 1, quality: 'common', price: 30 },
            light_common2: { name: '반짝이 가루', icon: '⭐', attr: 'light', power: 1, quality: 'common', price: 30 },
            light_rare1: { name: '빛나는 보석', icon: '💠', attr: 'light', power: 2, quality: 'rare', price: 60 },
            light_rare2: { name: '태양석', icon: '☀️', attr: 'light', power: 2, quality: 'rare', price: 60 },
            light_epic: { name: '별의 파편', icon: '🌟', attr: 'light', power: 3, quality: 'epic', price: 100 },
            light_legendary: { name: '천상의 광휘', icon: '👼', attr: 'light', power: 5, quality: 'legendary', price: 999 },
            
            // 어둠 속성 (6개)
            dark_common1: { name: '흑요석', icon: '🌙', attr: 'dark', power: 1, quality: 'common', price: 30 },
            dark_common2: { name: '검은 모래', icon: '🖤', attr: 'dark', power: 1, quality: 'common', price: 30 },
            dark_rare1: { name: '달빛석', icon: '🌑', attr: 'dark', power: 2, quality: 'rare', price: 60 },
            dark_rare2: { name: '그림자 수정', icon: '🔮', attr: 'dark', power: 2, quality: 'rare', price: 60 },
            dark_epic: { name: '밤의 정수', icon: '🌌', attr: 'dark', power: 3, quality: 'epic', price: 100 },
            dark_legendary: { name: '영원한 어둠', icon: '🕳️', attr: 'dark', power: 5, quality: 'legendary', price: 999 },
            
            // 복합 속성 (희귀)
            dual_fire_water: { name: '증기의 오르골', icon: '♨️', attr: 'dual', power: 1, quality: 'rare', price: 80, dualAttr: ['fire', 'water'] },
            dual_earth_wind: { name: '사막의 모래시계', icon: '⏳', attr: 'dual', power: 1, quality: 'rare', price: 80, dualAttr: ['earth', 'wind'] },
            dual_light_dark: { name: '황혼의 거울', icon: '🪞', attr: 'dual', power: 1, quality: 'rare', price: 80, dualAttr: ['light', 'dark'] },
            all_elements: { name: '무지개 프리즘', icon: '🌈', attr: 'all', power: 1, quality: 'rare', price: 120 }
            // 합성 미니어처은 SYNTH_ITEMS에서만 관리
        };

        const FOOD_NAMES = {
            fire: '불꽃열매',
            water: '맑은이슬',
            wind: '바람꿀',
            earth: '대지버섯',
            light: '빛나는 넥타',
            dark: '검은 꽃가루'
        };
        
        // 약초 아이템
        const MEDICINE = {
            name: '만병통치 약초',
            icon: '🌿',
            price: 50,
            description: '정령의 질병을 치료합니다'
        };

        // ===== 레시피북 정의 =====
        const RECIPE_BOOKS = {
            food: {
                name: '먹이 레시피북',
                icon: '📕',
                price: 500,
                desc: '모든 먹이 합성 레시피가 담긴 책',
                recipes: [
                    'fire_tart', 'water_jelly', 'wind_candy', 'earth_pie', 'light_cookie', 'dark_chocolate', 'rainbow_cake',
                    'fire_water_steam', 'fire_wind_heat', 'fire_earth_lava', 'fire_light_sun', 'fire_dark_ash',
                    'water_wind_mist', 'water_earth_mud', 'water_light_aurora', 'water_dark_abyss',
                    'wind_earth_sand', 'wind_light_sky', 'wind_dark_shadow',
                    'earth_light_crystal', 'earth_dark_cave',
                    'light_dark_twilight'
                ]
            },
            decoration: {
                name: '미니어처 레시피북',
                icon: '📗',
                price: 250,
                desc: '모든 미니어처 합성 레시피가 담긴 책',
                recipes: [
                    'flame_lamp', 'aqua_fountain', 'wind_chime', 'earth_statue', 'light_orb', 'shadow_crystal'
                ]
            }
        };

        // ===== 연구실 합성 시스템 =====
        // 합성 아이템 정의 (결과물)
        const SYNTH_ITEMS = {
            // 먹이 합성 결과물 (단일 속성)
            fire_tart: { name: '불꽃열매 타르트', icon: '🥧', type: 'food', attr: 'fire', attrGain: 6, affectionGain: 3, growthGain: 3 },
            water_jelly: { name: '이슬 에이드', icon: '🥤', type: 'food', attr: 'water', attrGain: 6, affectionGain: 3, growthGain: 3 },
            wind_candy: { name: '바람꿀차', icon: '🍵', type: 'food', attr: 'wind', attrGain: 6, affectionGain: 3, growthGain: 3 },
            earth_pie: { name: '대지버섯 볶음', icon: '🥘', type: 'food', attr: 'earth', attrGain: 6, affectionGain: 3, growthGain: 3 },
            light_cookie: { name: '넥타르', icon: '🍯', type: 'food', attr: 'light', attrGain: 6, affectionGain: 3, growthGain: 3 },
            dark_chocolate: { name: '다크 초콜릿', icon: '🍫', type: 'food', attr: 'dark', attrGain: 6, affectionGain: 3, growthGain: 3 },
            rainbow_cake: { name: '무지개 케이크', icon: '🎂', type: 'food', attr: 'all', attrGain: 3, affectionGain: 5, growthGain: 5 },
            
            // 먹이 합성 결과물 (혼합 속성) - 밸런스 조정: 성장 2, 속성 4
            fire_water_steam: { name: '스팀 푸딩', icon: '♨️', type: 'food', attr: 'dual', dualAttr: ['fire', 'water'], attrGain: 4, affectionGain: 3, growthGain: 2 },
            fire_wind_heat: { name: '열풍 크래커', icon: '🌪️', type: 'food', attr: 'dual', dualAttr: ['fire', 'wind'], attrGain: 4, affectionGain: 3, growthGain: 2 },
            fire_earth_lava: { name: '화산 스프', icon: '🍲', type: 'food', attr: 'dual', dualAttr: ['fire', 'earth'], attrGain: 4, affectionGain: 3, growthGain: 2 },
            fire_light_sun: { name: '태양 타르트', icon: '🌅', type: 'food', attr: 'dual', dualAttr: ['fire', 'light'], attrGain: 4, affectionGain: 3, growthGain: 2 },
            fire_dark_ash: { name: '잿빛 머랭쿠키', icon: '🖤', type: 'food', attr: 'dual', dualAttr: ['fire', 'dark'], attrGain: 4, affectionGain: 3, growthGain: 2 },
            water_wind_mist: { name: '안개 캔디', icon: '🌫️', type: 'food', attr: 'dual', dualAttr: ['water', 'wind'], attrGain: 4, affectionGain: 3, growthGain: 2 },
            water_earth_pond: { name: '연못 샐러드', icon: '🥗', type: 'food', attr: 'dual', dualAttr: ['water', 'earth'], attrGain: 4, affectionGain: 3, growthGain: 2 },
            water_light_ice: { name: '빙하 아이스바', icon: '🧊', type: 'food', attr: 'dual', dualAttr: ['water', 'light'], attrGain: 4, affectionGain: 3, growthGain: 2 },
            water_dark_deep: { name: '심해 젤리', icon: '🪼', type: 'food', attr: 'dual', dualAttr: ['water', 'dark'], attrGain: 4, affectionGain: 3, growthGain: 2 },
            wind_earth_desert: { name: '황야 비스킷', icon: '🏜️', type: 'food', attr: 'dual', dualAttr: ['wind', 'earth'], attrGain: 4, affectionGain: 3, growthGain: 2 },
            wind_light_cloud: { name: '구름 솜사탕', icon: '☁️', type: 'food', attr: 'dual', dualAttr: ['wind', 'light'], attrGain: 4, affectionGain: 3, growthGain: 2 },
            wind_dark_night: { name: '밤바람청', icon: '🌃', type: 'food', attr: 'dual', dualAttr: ['wind', 'dark'], attrGain: 4, affectionGain: 3, growthGain: 2 },
            earth_light_sprout: { name: '새싹 파이', icon: '🌿', type: 'food', attr: 'dual', dualAttr: ['earth', 'light'], attrGain: 4, affectionGain: 3, growthGain: 2 },
            earth_dark_mushroom: { name: '동굴 버섯 수프', icon: '🍄', type: 'food', attr: 'dual', dualAttr: ['earth', 'dark'], attrGain: 4, affectionGain: 3, growthGain: 2 },
            
            // 특수 먹이 - 성장 억제
            dark_nectar: { name: '암흑의 넥타르', icon: '🖤🍯', type: 'food', attr: 'special', attrGain: 0, affectionGain: 2, growthGain: -2, desc: '성장을 늦추는 신비한 음료' },
            
            // 특수 먹이 - 화해 효과 (앙숙 전용)
            reconciliation_flower: { name: '수선화 꽃잎', icon: '🌼💫', type: 'food', attr: 'special', attrGain: 0, affectionGain: 5, growthGain: 1, desc: '앙숙 관계인 정령에게 사용. 30분간 싸우지 않습니다', effectDuration: 30 * 60 * 1000, requiresRival: true },
            
            // 특수 먹이 - 친밀도 증가 효과
            acacia_honey: { name: '아카시아 꿀', icon: '🍯✨', type: 'food', attr: 'special', attrGain: 0, affectionGain: 3, growthGain: 2, desc: '30분간 다른 정령과 빠르게 친해집니다', effectDuration: 30 * 60 * 1000 },
            
            // 미니어처 합성 결과물
            flame_lamp: { name: '화염 램프', icon: '🏮', type: 'decoration', attr: 'fire', power: 3, quality: 'rare' },
            aqua_fountain: { name: '아쿠아 분수', icon: '⛲', type: 'decoration', attr: 'water', power: 3, quality: 'rare' },
            wind_chime: { name: '바람의 종', icon: '🔔', type: 'decoration', attr: 'wind', power: 3, quality: 'rare' },
            earth_statue: { name: '대지의 석상', icon: '🗿', type: 'decoration', attr: 'earth', power: 3, quality: 'rare' },
            light_orb: { name: '빛의 오브', icon: '💡', type: 'decoration', attr: 'light', power: 3, quality: 'rare' },
            shadow_crystal: { name: '그림자 결정', icon: '🔳', type: 'decoration', attr: 'dark', power: 3, quality: 'rare' }
        };
        
        // 합성 레시피 정의
        const RECIPES = {
            // 먹이 합성 (같은 먹이 5+5 = 타르트류 3개)
            fire_tart: {
                ingredients: [
                    { type: 'fire', category: 'food', count: 5 },
                    { type: 'fire', category: 'food', count: 5 }
                ],
                result: { type: 'fire_tart', count: 3 },
                category: 'food'
            },
            water_jelly: {
                ingredients: [
                    { type: 'water', category: 'food', count: 5 },
                    { type: 'water', category: 'food', count: 5 }
                ],
                result: { type: 'water_jelly', count: 3 },
                category: 'food'
            },
            wind_candy: {
                ingredients: [
                    { type: 'wind', category: 'food', count: 5 },
                    { type: 'wind', category: 'food', count: 5 }
                ],
                result: { type: 'wind_candy', count: 3 },
                category: 'food'
            },
            earth_pie: {
                ingredients: [
                    { type: 'earth', category: 'food', count: 5 },
                    { type: 'earth', category: 'food', count: 5 }
                ],
                result: { type: 'earth_pie', count: 3 },
                category: 'food'
            },
            light_cookie: {
                ingredients: [
                    { type: 'light', category: 'food', count: 5 },
                    { type: 'light', category: 'food', count: 5 }
                ],
                result: { type: 'light_cookie', count: 3 },
                category: 'food'
            },
            dark_chocolate: {
                ingredients: [
                    { type: 'dark', category: 'food', count: 5 },
                    { type: 'dark', category: 'food', count: 5 }
                ],
                result: { type: 'dark_chocolate', count: 3 },
                category: 'food'
            },
            rainbow_cake: {
                ingredients: [
                    { type: 'light', category: 'food', count: 3 },
                    { type: 'dark', category: 'food', count: 3 }
                ],
                result: { type: 'rainbow_cake', count: 1 },
                category: 'food'
            },
            // 혼합 속성 먹이 (서로 다른 속성 3+3 = 혼합 먹이 2개)
            fire_water_steam: {
                ingredients: [
                    { type: 'fire', category: 'food', count: 3 },
                    { type: 'water', category: 'food', count: 3 }
                ],
                result: { type: 'fire_water_steam', count: 2 },
                category: 'food'
            },
            fire_wind_heat: {
                ingredients: [
                    { type: 'fire', category: 'food', count: 3 },
                    { type: 'wind', category: 'food', count: 3 }
                ],
                result: { type: 'fire_wind_heat', count: 2 },
                category: 'food'
            },
            fire_earth_lava: {
                ingredients: [
                    { type: 'fire', category: 'food', count: 3 },
                    { type: 'earth', category: 'food', count: 3 }
                ],
                result: { type: 'fire_earth_lava', count: 2 },
                category: 'food'
            },
            fire_light_sun: {
                ingredients: [
                    { type: 'fire', category: 'food', count: 3 },
                    { type: 'light', category: 'food', count: 3 }
                ],
                result: { type: 'fire_light_sun', count: 2 },
                category: 'food'
            },
            fire_dark_ash: {
                ingredients: [
                    { type: 'fire', category: 'food', count: 3 },
                    { type: 'dark', category: 'food', count: 3 }
                ],
                result: { type: 'fire_dark_ash', count: 2 },
                category: 'food'
            },
            water_wind_mist: {
                ingredients: [
                    { type: 'water', category: 'food', count: 3 },
                    { type: 'wind', category: 'food', count: 3 }
                ],
                result: { type: 'water_wind_mist', count: 2 },
                category: 'food'
            },
            water_earth_pond: {
                ingredients: [
                    { type: 'water', category: 'food', count: 3 },
                    { type: 'earth', category: 'food', count: 3 }
                ],
                result: { type: 'water_earth_pond', count: 2 },
                category: 'food'
            },
            water_light_ice: {
                ingredients: [
                    { type: 'water', category: 'food', count: 3 },
                    { type: 'light', category: 'food', count: 3 }
                ],
                result: { type: 'water_light_ice', count: 2 },
                category: 'food'
            },
            water_dark_deep: {
                ingredients: [
                    { type: 'water', category: 'food', count: 3 },
                    { type: 'dark', category: 'food', count: 3 }
                ],
                result: { type: 'water_dark_deep', count: 2 },
                category: 'food'
            },
            wind_earth_desert: {
                ingredients: [
                    { type: 'wind', category: 'food', count: 3 },
                    { type: 'earth', category: 'food', count: 3 }
                ],
                result: { type: 'wind_earth_desert', count: 2 },
                category: 'food'
            },
            wind_light_cloud: {
                ingredients: [
                    { type: 'wind', category: 'food', count: 3 },
                    { type: 'light', category: 'food', count: 3 }
                ],
                result: { type: 'wind_light_cloud', count: 2 },
                category: 'food'
            },
            wind_dark_night: {
                ingredients: [
                    { type: 'wind', category: 'food', count: 3 },
                    { type: 'dark', category: 'food', count: 3 }
                ],
                result: { type: 'wind_dark_night', count: 2 },
                category: 'food'
            },
            earth_light_sprout: {
                ingredients: [
                    { type: 'earth', category: 'food', count: 3 },
                    { type: 'light', category: 'food', count: 3 }
                ],
                result: { type: 'earth_light_sprout', count: 2 },
                category: 'food'
            },
            earth_dark_mushroom: {
                ingredients: [
                    { type: 'earth', category: 'food', count: 3 },
                    { type: 'dark', category: 'food', count: 3 }
                ],
                result: { type: 'earth_dark_mushroom', count: 2 },
                category: 'food'
            },
            // 미니어처 합성 (같은 속성 common 미니어처 2개 = rare 미니어처 1개)
            flame_lamp: {
                ingredients: [
                    { type: 'fire_common1', category: 'decoration', count: 1 },
                    { type: 'fire_common2', category: 'decoration', count: 1 }
                ],
                result: { type: 'flame_lamp', count: 1 },
                category: 'decoration'
            },
            aqua_fountain: {
                ingredients: [
                    { type: 'water_common1', category: 'decoration', count: 1 },
                    { type: 'water_common2', category: 'decoration', count: 1 }
                ],
                result: { type: 'aqua_fountain', count: 1 },
                category: 'decoration'
            },
            wind_chime: {
                ingredients: [
                    { type: 'wind_common1', category: 'decoration', count: 1 },
                    { type: 'wind_common2', category: 'decoration', count: 1 }
                ],
                result: { type: 'wind_chime', count: 1 },
                category: 'decoration'
            },
            earth_statue: {
                ingredients: [
                    { type: 'earth_common1', category: 'decoration', count: 1 },
                    { type: 'earth_common2', category: 'decoration', count: 1 }
                ],
                result: { type: 'earth_statue', count: 1 },
                category: 'decoration'
            },
            light_orb: {
                ingredients: [
                    { type: 'light_common1', category: 'decoration', count: 1 },
                    { type: 'light_common2', category: 'decoration', count: 1 }
                ],
                result: { type: 'light_orb', count: 1 },
                category: 'decoration'
            },
            shadow_crystal: {
                ingredients: [
                    { type: 'dark_common1', category: 'decoration', count: 1 },
                    { type: 'dark_common2', category: 'decoration', count: 1 }
                ],
                result: { type: 'shadow_crystal', count: 1 },
                category: 'decoration'
            },
            // 특수 먹이 - 성장 억제
            dark_nectar: {
                ingredients: [
                    { type: 'dark_chocolate', category: 'food', count: 1 },
                    { type: 'light_cookie', category: 'food', count: 1 }
                ],
                result: { type: 'dark_nectar', count: 2 },
                category: 'food'
            }
        };
        
        // 연구실 슬롯 상태
        let labSlot1 = null; // { type: 'fire', category: 'food', count: 5 }
        let labSlot2 = null;
        let currentLabSlot = null; // 현재 선택 중인 슬롯
        let discoveredRecipes = []; // 발견한 레시피 목록
        let purchasedRecipeBooks = []; // 구매한 레시피북 목록 ('food', 'decoration')
        let selfDiscoveredRecipes = []; // 레시피북 없이 직접 발견한 레시피 목록
        const ENCYCLOPEDIA_HINTS = {
            // 전설
            'spiritking': '만개한 자연의 화신. 정령계의 유일무이한 지배자.',
            'titania': '나비를 거느리는 정령들의 군주.',
            'oberon': '나방을 거느리는 정령들의 군주.',
            
            // nostat (타이틀 없음) - 기본 속성
            'nostat-normal': '아무 속성도 깃들지 않은 정령.',
            'nostat-fire': '불의 기운을 품은 정령.',
            'nostat-water': '물의 기운을 품은 정령.',
            'nostat-wind': '바람의 기운을 품은 정령.',
            'nostat-earth': '땅의 기운을 품은 정령.',
            'nostat-light': '빛의 기운을 품은 정령.',
            'nostat-dark': '어둠의 기운을 품은 정령.',
            'nostat-balanced': '모든 속성을 품은 조화 정령.',
            'nostat-multi': '여러 속성이 뒤섞인 혼돈의 정령.',
            // nostat - 2속성 조합
            'nostat-fire-water': '불과 물이 만나 피어오른 증기의 정령.',
            'nostat-fire-wind': '불과 바람이 만나 만들어진 뜨거운 폭풍의 정령.',
            'nostat-earth-fire': '불과 대지가 만나 빚어낸 용암의 정령.',
            'nostat-fire-light': '불과 빛이 만나 찬란히 빛나는 태양의 정령.',
            'nostat-dark-fire': '불과 어둠이 만나 피어나는 연기의 정령.',
            'nostat-water-wind': '물과 바람이 만나 형성된 구름의 정령.',
            'nostat-earth-water': '물과 대지가 만나 뭉쳐진 진흙의 정령.',
            'nostat-light-water': '물과 빛이 만나 이어진 무지개의 정령.',
            'nostat-dark-water': '물과 어둠이 만나 눈앞을 가리는 안개의 정령.',
            'nostat-earth-wind': '바람과 대지가 만나 흩날리는 모래의 정령.',
            'nostat-light-wind': '바람과 빛이 만나 하늘을 메우는 오로라의 정령.',
            'nostat-dark-wind': '바람과 어둠이 만나 춤추는 회오리의 정령.',
            'nostat-earth-light': '대지와 빛이 만나 돌에 갇힌 빛, 수정의 정령.',
            'nostat-dark-earth': '대지와 어둠이 만나 서늘한 그림자, 그늘의 정령.',
            'nostat-dark-light': '빛과 어둠이 만나 현혹시키는 환영의 정령.',
            
            // intelligent (지식의 씨앗) - 기본 속성
            'intelligent-normal': '아무 속성도 깃들지 않은 정령.',
            'intelligent-fire': '불의 기운을 품은 정령.',
            'intelligent-water': '물의 기운을 품은 정령.',
            'intelligent-wind': '바람의 기운을 품은 정령.',
            'intelligent-earth': '땅의 기운을 품은 정령.',
            'intelligent-light': '빛의 기운을 품은 정령.',
            'intelligent-dark': '어둠의 기운을 품은 정령.',
            'intelligent-balanced': '모든 속성을 품은 조화 정령.',
            'intelligent-multi': '여러 속성이 뒤섞인 혼돈의 정령.',
            // intelligent - 2속성 조합
            'intelligent-fire-water': '불과 물이 만나 피어오른 증기의 정령.',
            'intelligent-fire-wind': '불과 바람이 만나 만들어진 뜨거운 폭풍의 정령.',
            'intelligent-earth-fire': '불과 대지가 만나 빚어낸 용암의 정령.',
            'intelligent-fire-light': '불과 빛이 만나 찬란히 빛나는 태양의 정령.',
            'intelligent-dark-fire': '불과 어둠이 만나 피어나는 연기의 정령.',
            'intelligent-water-wind': '물과 바람이 만나 형성된 구름의 정령.',
            'intelligent-earth-water': '물과 대지가 만나 뭉쳐진 진흙의 정령.',
            'intelligent-light-water': '물과 빛이 만나 이어진 무지개의 정령.',
            'intelligent-dark-water': '물과 어둠이 만나 눈앞을 가리는 안개의 정령.',
            'intelligent-earth-wind': '바람과 대지가 만나 흩날리는 모래의 정령.',
            'intelligent-light-wind': '바람과 빛이 만나 하늘을 메우는 오로라의 정령.',
            'intelligent-dark-wind': '바람과 어둠이 만나 춤추는 회오리의 정령.',
            'intelligent-earth-light': '대지와 빛이 만나 돌에 갇힌 빛, 수정의 정령.',
            'intelligent-dark-earth': '대지와 어둠이 만나 서늘한 그림자, 그늘의 정령.',
            'intelligent-dark-light': '빛과 어둠이 만나 현혹시키는 환영의 정령.',
            
            // strong (불굴의 기사) - 기본 속성
            'strong-normal': '아무 속성도 깃들지 않은 정령.',
            'strong-fire': '불의 기운을 품은 정령.',
            'strong-water': '물의 기운을 품은 정령.',
            'strong-wind': '바람의 기운을 품은 정령.',
            'strong-earth': '땅의 기운을 품은 정령.',
            'strong-light': '빛의 기운을 품은 정령.',
            'strong-dark': '어둠의 기운을 품은 정령.',
            'strong-balanced': '모든 속성을 품은 조화 정령.',
            'strong-multi': '여러 속성이 뒤섞인 혼돈의 정령.',
            // strong - 2속성 조합
            'strong-fire-water': '불과 물이 만나 피어오른 증기의 정령.',
            'strong-fire-wind': '불과 바람이 만나 만들어진 뜨거운 폭풍의 정령.',
            'strong-earth-fire': '불과 대지가 만나 빚어낸 용암의 정령.',
            'strong-fire-light': '불과 빛이 만나 찬란히 빛나는 태양의 정령.',
            'strong-dark-fire': '불과 어둠이 만나 피어나는 연기의 정령.',
            'strong-water-wind': '물과 바람이 만나 형성된 구름의 정령.',
            'strong-earth-water': '물과 대지가 만나 뭉쳐진 진흙의 정령.',
            'strong-light-water': '물과 빛이 만나 이어진 무지개의 정령.',
            'strong-dark-water': '물과 어둠이 만나 눈앞을 가리는 안개의 정령.',
            'strong-earth-wind': '바람과 대지가 만나 흩날리는 모래의 정령.',
            'strong-light-wind': '바람과 빛이 만나 하늘을 메우는 오로라의 정령.',
            'strong-dark-wind': '바람과 어둠이 만나 춤추는 회오리의 정령.',
            'strong-earth-light': '대지와 빛이 만나 돌에 갇힌 빛, 수정의 정령.',
            'strong-dark-earth': '대지와 어둠이 만나 서늘한 그림자, 그늘의 정령.',
            'strong-dark-light': '빛과 어둠이 만나 현혹시키는 환영의 정령.',
            
            // beautiful (달콤한 향기) - 기본 속성
            'beautiful-normal': '아무 속성도 깃들지 않은 정령.',
            'beautiful-fire': '불의 기운을 품은 정령.',
            'beautiful-water': '물의 기운을 품은 정령.',
            'beautiful-wind': '바람의 기운을 품은 정령.',
            'beautiful-earth': '땅의 기운을 품은 정령.',
            'beautiful-light': '빛의 기운을 품은 정령.',
            'beautiful-dark': '어둠의 기운을 품은 정령.',
            'beautiful-balanced': '모든 속성을 품은 조화 정령.',
            'beautiful-multi': '여러 속성이 뒤섞인 혼돈의 정령.',
            // beautiful - 2속성 조합
            'beautiful-fire-water': '불과 물이 만나 피어오른 증기의 정령.',
            'beautiful-fire-wind': '불과 바람이 만나 만들어진 뜨거운 폭풍의 정령.',
            'beautiful-earth-fire': '불과 대지가 만나 빚어낸 용암의 정령.',
            'beautiful-fire-light': '불과 빛이 만나 찬란히 빛나는 태양의 정령.',
            'beautiful-dark-fire': '불과 어둠이 만나 피어나는 연기의 정령.',
            'beautiful-water-wind': '물과 바람이 만나 형성된 구름의 정령.',
            'beautiful-earth-water': '물과 대지가 만나 뭉쳐진 진흙의 정령.',
            'beautiful-light-water': '물과 빛이 만나 이어진 무지개의 정령.',
            'beautiful-dark-water': '물과 어둠이 만나 눈앞을 가리는 안개의 정령.',
            'beautiful-earth-wind': '바람과 대지가 만나 흩날리는 모래의 정령.',
            'beautiful-light-wind': '바람과 빛이 만나 하늘을 메우는 오로라의 정령.',
            'beautiful-dark-wind': '바람과 어둠이 만나 춤추는 회오리의 정령.',
            'beautiful-earth-light': '대지와 빛이 만나 돌에 갇힌 빛, 수정의 정령.',
            'beautiful-dark-earth': '대지와 어둠이 만나 서늘한 그림자, 그늘의 정령.',
            'beautiful-dark-light': '빛과 어둠이 만나 현혹시키는 환영의 정령.',
            
            // sage (정령왕의 부름을 받은) - 기본 속성
            'sage-normal': '정령왕의 부름을 받은 백의 정령.',
            'sage-fire': '정령왕의 부름을 받은 불꽃의 정령.',
            'sage-water': '정령왕의 부름을 받은 물결의 정령.',
            'sage-wind': '정령왕의 부름을 받은 질풍의 정령.',
            'sage-earth': '정령왕의 부름을 받은 대지의 정령.',
            'sage-light': '정령왕의 부름을 받은 광명의 정령.',
            'sage-dark': '정령왕의 부름을 받은 암흑의 정령.',
            'sage-balanced': '정령왕의 부름을 받은 조화의 정령.',
            'sage-multi': '정령왕의 부름을 받은 혼돈의 정령.',
            // sage - 2속성 조합
            'sage-fire-water': '정령왕의 부름을 받은 증기의 정령.',
            'sage-fire-wind': '정령왕의 부름을 받은 폭풍의 정령.',
            'sage-earth-fire': '정령왕의 부름을 받은 용암의 정령.',
            'sage-fire-light': '정령왕의 부름을 받은 태양의 정령.',
            'sage-dark-fire': '정령왕의 부름을 받은 연기의 정령.',
            'sage-water-wind': '정령왕의 부름을 받은 구름의 정령.',
            'sage-earth-water': '정령왕의 부름을 받은 진흙의 정령.',
            'sage-light-water': '정령왕의 부름을 받은 무지개의 정령.',
            'sage-dark-water': '정령왕의 부름을 받은 안개의 정령.',
            'sage-earth-wind': '정령왕의 부름을 받은 모래의 정령.',
            'sage-light-wind': '정령왕의 부름을 받은 오로라의 정령.',
            'sage-dark-wind': '정령왕의 부름을 받은 회오리의 정령.',
            'sage-earth-light': '정령왕의 부름을 받은 수정의 정령.',
            'sage-dark-earth': '정령왕의 부름을 받은 그늘의 정령.',
            'sage-dark-light': '정령왕의 부름을 받은 환영의 정령.'
        };

        // 상태 키워드 시스템
        function getStatusKeywords(spirit) {
            const keywords = [];
            const keywordColor = '#2a2a2a';  // 검정색 통일
            
            // 🧬 유전받은 키워드 (부모에게서 물려받은 특성)
            if (spirit.inheritedKeywords && spirit.inheritedKeywords.length > 0) {
                spirit.inheritedKeywords.forEach(keyword => {
                    keywords.push({ text: `🧬 ${keyword}`, color: '#9c27b0', desc: `부모에게서 유전받은 특성입니다.` });
                });
            }
            
            // 애정도 기반
            if (spirit.parameters.affection >= 100) {
                keywords.push({ text: '사랑이 가득한', color: keywordColor, desc: '애정도가 최대치에 도달했습니다.' });
            } else if (spirit.parameters.affection >= 70) {
                keywords.push({ text: '애정 어린', color: keywordColor, desc: '애정도가 높습니다. 정령이 당신을 좋아합니다.' });
            } else if (spirit.parameters.affection <= 10) {
                keywords.push({ text: '경계하는', color: keywordColor, desc: '애정도가 너무 낮습니다. 먹이를 주거나 음악을 들려주세요.' });
            }
            
            // 질병 상태
            if (spirit.isSick) {
                keywords.push({ text: '질병에 걸린', color: keywordColor, desc: '정령이 아픕니다! 만병통치 약초로 치료해주세요.' });
            }
            
            // 화해의 꽃 효과 (30분간 지속)
            if (spirit.reconciliationUntil && spirit.reconciliationUntil > Date.now()) {
                const remaining = Math.ceil((spirit.reconciliationUntil - Date.now()) / 60000);
                keywords.push({ text: '🌼 화해 중', color: '#f9a825', desc: `${remaining}분간 다른 정령과 싸우지 않습니다.` });
            }
            
            // 아카시아 꿀 효과 (30분간 지속)
            if (spirit.acaciaHoneyUntil && spirit.acaciaHoneyUntil > Date.now()) {
                const remaining = Math.ceil((spirit.acaciaHoneyUntil - Date.now()) / 60000);
                keywords.push({ text: '🍯 친밀 효과', color: '#ff9800', desc: `${remaining}분간 다른 정령과의 호감도가 2배로 증가합니다.` });
            }
            
            // 음악 청취 횟수 (musicListened 카운트)
            if (spirit.musicListened >= 10) {
                keywords.push({ text: '음악을 사랑하는', color: keywordColor, desc: `음악을 ${spirit.musicListened}번 들었습니다.` });
            }
            
            // 스탯 50 기준 키워드 (유전받은 키워드는 중복 표시 안 함)
            const inherited = spirit.inheritedKeywords || [];
            if (spirit.parameters.intelligence >= 50 && !inherited.includes('똑똑한')) {
                keywords.push({ text: '똑똑한', color: keywordColor, desc: `지력이 50 이상입니다. (${spirit.parameters.intelligence}) 음악 청취 시 스탯 보너스 +2!` });
            }
            if (spirit.parameters.strength >= 50 && !inherited.includes('강한')) {
                keywords.push({ text: '강한', color: keywordColor, desc: `체력이 50 이상입니다. (${spirit.parameters.strength}) 질병에 걸리지 않습니다!` });
            }
            if (spirit.parameters.charm >= 50 && !inherited.includes('매력적인')) {
                keywords.push({ text: '매력적인', color: keywordColor, desc: `매력이 50 이상입니다. (${spirit.parameters.charm}) 다른 정령과 상호작용 확률이 높아집니다!` });
            }
            
            // 스탯 기반 경고
            if (spirit.parameters.intelligence <= 10) {
                keywords.push({ text: '사교성이 적은', color: keywordColor, desc: `지력이 너무 낮습니다. (${spirit.parameters.intelligence}) 다른 정령과 싸울 수 있습니다.` });
            }
            if (spirit.parameters.strength <= 5) {
                keywords.push({ text: '몸이 약한', color: keywordColor, desc: `체력이 너무 낮습니다. (${spirit.parameters.strength}) 질병에 걸리기 쉽습니다.` });
            }
            
            // 성장 단계 기반
            const stage = getStage(spirit.growth);
            if (stage === 'adult' && !spirit.isCompleted) {
                keywords.push({ text: '번데기가 된', color: keywordColor, desc: '번데기 단계입니다. 조금만 더 성장하면 앨범에 등록됩니다.' });
            }
            
            // 만족도 기반
            if (spirit.satisfaction === 'high') {
                keywords.push({ text: '행복한', color: keywordColor, desc: '정령의 만족도가 높습니다. 잘 돌봐주고 계시네요!' });
            } else if (spirit.satisfaction === 'low') {
                keywords.push({ text: '불만족스러운', color: keywordColor, desc: '정령의 만족도가 낮습니다. 먹이나 음악으로 관심을 보여주세요.' });
            }
            
            // 방치 시간 기반 (30분 이상)
            const timeSinceInteraction = Date.now() - (spirit.lastInteraction || Date.now());
            if (timeSinceInteraction > 30 * 60 * 1000) {
                const mins = Math.floor(timeSinceInteraction / 60000);
                keywords.push({ text: '외로운', color: keywordColor, desc: `${mins}분 동안 상호작용이 없었습니다.` });
            }
            
            // 테라리움 환경과 속성 일치도
            const dominantAttr = getDominantAttribute(spirit);
            const terrariumEnv = Object.keys(terrarium).reduce((a, b) => 
                terrarium[a] > terrarium[b] ? a : b
            );
            if (dominantAttr === terrariumEnv && terrarium[terrariumEnv] >= 30) {
                keywords.push({ text: '환경에 적응한', color: keywordColor, desc: `테라리움 환경(${ENV_NAMES[terrariumEnv]})이 정령의 주 속성과 맞습니다.` });
            }
            
            // 빛/어둠 시간 기반 (더 많은 쪽만 표시)
            const lightTime = spirit.lightTime || 0;
            const darkTime = spirit.darkTime || 0;
            if (lightTime >= 10 || darkTime >= 10) {
                if (lightTime > darkTime) {
                    keywords.push({ text: '태양을 동경하는', color: keywordColor, desc: '밝은 조명 환경에서 더 오래 자랐습니다.' });
                } else if (darkTime > lightTime) {
                    keywords.push({ text: '달을 숭배하는', color: keywordColor, desc: '어두운 조명 환경에서 더 오래 자랐습니다.' });
                }
                // 같으면 아무것도 표시 안 함
            }
            
            // 먹이 횟수 (feedCount 카운트)
            if (spirit.feedCount >= 20) {
                keywords.push({ text: '미식가', color: keywordColor, desc: `먹이를 ${spirit.feedCount}번 먹었습니다.` });
            }
            
            // 짝꿍 관계
            const bestFriend = getBestFriend(spirit);
            if (bestFriend) {
                keywords.push({ text: `짝꿍 : ${bestFriend.name}`, color: '#e91e63', desc: `${bestFriend.name}와(과) 짝꿍 관계입니다.` });
            }
            
            // 연모 관계
            const lover = getLover(spirit);
            if (lover) {
                keywords.push({ text: `연모 : ${lover.name}`, color: '#e91e63', desc: `${lover.name}에게 연모의 감정을 느끼고 있습니다. 둘 다 성장을 마치면 연결 알이 생길 수 있습니다.` });
            }
            
            // 앙숙 관계 (호감도 0 미만)
            if (spirit.relationships) {
                const activeSpirits = spirits.filter(s => !s.isDead && !s.isCompleted && s.id !== spirit.id);
                activeSpirits.forEach(other => {
                    const rel = spirit.relationships[other.id] || 0;
                    if (rel < 0) {
                        keywords.push({ text: `앙숙 : ${other.name}`, color: '#e74c3c', desc: `${other.name}와(과) 사이가 좋지 않습니다. (호감도: ${rel}) 수선화 꽃잎으로 화해시킬 수 있습니다.` });
                    }
                });
            }
            
            return keywords;
        }

                // 상점 가격표
        const SHOP_PRICES = {
            // 판매 가격 (인벤토리 → 코인)
            sell: {
                food_common: 8,    // 일반 먹이 판매
                food_rare: 15,     // 희귀 먹이 판매
                decoration: 15,    // 미니어처 1개 = 15코인
                music: 25          // 음악 1개 = 25코인
            },
            // 구매 가격 (코인 → 인벤토리)
            buy: {
                food_common: 20,   // 일반 먹이 (화수풍지)
                food_rare: 40,     // 희귀 먹이 (빛암)
                music: 80,         // 음악 레코드
                decoration: 50     // 미니어처
            }
        };

        const EVOLUTION_TYPES = {
            // 노멀 (스탯 100 미달)
            'nostat': { prefix: '', icon: '' },
            
            // 지력 100
            'intelligent': { prefix: '지식의 씨앗', icon: '📚' },
            
            // 체력 100
            'strong': { prefix: '불굴의 기사', icon: '⚔️' },
            
            // 매력 100
            'beautiful': { prefix: '달콤한 향기', icon: '🌸' },
            
            // 모든 스탯 100
            'sage': { prefix: '정령왕의 부름을 받은', icon: '👑' }
        };
        
        // 속성별 정령 이름
        const ATTRIBUTE_NAMES = {
            normal: { name: '백의 정령', icon: '⚪', desc: '순수한 백색의 빛을 지닌 정령.' },
            fire: { 
                name: '화염의 정령', 
                icon: { 
                    butterfly: '<img src="https://i.imgur.com/JlOx9TH.png" style="width:150px;height:auto;vertical-align:middle;">', 
                    moth: '<img src="https://i.imgur.com/lPP6SdC.png" style="width:150px;height:auto;vertical-align:middle;">' 
                }, 
                desc: '타오르는 열정을 간직한 화염의 정령.' 
            },
            water: { name: '빙하의 정령', icon: '💧', desc: '차가운 지혜를 품은 물의 정령.' },
            wind: { name: '질풍의 정령', icon: '🌬️', desc: '자유로운 바람을 담은 질풍의 정령.' },
            earth: { name: '대지의 정령', icon: '🌱', desc: '견고한 대지의 힘을 지닌 정령.' },
            light: { name: '광명의 정령', icon: '✨', desc: '찬란한 빛으로 가득한 광명의 정령.' },
            dark: { name: '암흑의 정령', icon: '🌙', desc: '신비로운 어둠을 담은 암흑의 정령.' },
            
            // 2속성 조합 (알파벳 순 정렬)
            'fire-water': { name: '바포르', icon: '💨', desc: '불과 물이 만나 탄생한 증기의 정령.' },
            'fire-wind': { name: '템페스투스', icon: '🌪️', desc: '불과 바람이 만든 뜨거운 폭풍의 정령.' },
            'earth-fire': { name: '라바', icon: '🌋', desc: '불과 대지가 빚어낸 용암의 정령.' },
            'fire-light': { name: '솔', icon: '☀️', desc: '불과 빛이 합쳐진 태양의 정령.' },
            'dark-fire': { name: '푸무스', icon: '💨', desc: '불과 어둠이 만든 연기의 정령.' },
            'water-wind': { name: '누베', icon: '☁️', desc: '물과 바람이 만든 구름의 정령.' },
            'earth-water': { name: '글리스', icon: '🪨', desc: '물과 대지가 섞인 진흙의 정령.' },
            'light-water': { name: '이리스', icon: '🌈', desc: '물과 빛이 만든 무지개의 정령.' },
            'dark-water': { name: '칼리고', icon: '🌫️', desc: '물과 어둠이 만든 안개의 정령.' },
            'earth-wind': { name: '하레나', icon: '🏜️', desc: '바람과 대지가 만든 모래의 정령.' },
            'light-wind': { name: '오로라', icon: '🌌', desc: '바람과 빛이 만든 오로라의 정령.' },
            'dark-wind': { name: '투르보', icon: '🌀', desc: '바람과 어둠이 만든 회오리의 정령.' },
            'earth-light': { name: '크리스탈', icon: '💎', desc: '대지와 빛이 만든 수정의 정령.' },
            'dark-earth': { name: '안트룸', icon: '⛰️', desc: '대지와 어둠이 만든 동굴의 정령.' },
            'dark-light': { name: '판타즈마', icon: '✨🌙', desc: '빛과 어둠이 만들어낸 환영의 정령.' },
            
            // 3속성 이상 (복합)
            balanced: { name: '조화의 정령', icon: '⚖️', desc: '모든 속성이 고르게 균형 잡힌 정령.' },
            multi: { name: '혼돈의 정령', icon: '🌪️', desc: '속성의 편차가 큰 혼돈의 정령.' }
        };
        
        // 합성 전용 정령
        const FUSION_TYPES = {
            // 같은 속성 상위 버전
            'fusion-fire': { name: '이프리트', icon: '🔥💥', desc: '두 불꽃이 만나 태어난 타오르는 화염의 정령.', recipe: ['fire', 'fire'], rarity: 'rare' },
            'fusion-water': { name: '엘라임', icon: '💧🌊', desc: '두 물결이 만나 태어난 깊이 가라앉는 호수의 정령.', recipe: ['water', 'water'], rarity: 'rare' },
            'fusion-wind': { name: '미네르바', icon: '🌬️🌪️', desc: '두 바람이 만나 태어난 거대한 폭풍의 정령.', recipe: ['wind', 'wind'], rarity: 'rare' },
            'fusion-earth': { name: '노아스', icon: '🌱🏔️', desc: '두 땅이 만나 태어난 우거진 산맥의 정령.', recipe: ['earth', 'earth'], rarity: 'rare' },
            'fusion-light': { name: '루미엘', icon: '✨⚡', desc: '두 빛이 만나 태어난 눈부신 섬광의 정령.', recipe: ['light', 'light'], rarity: 'rare' },
            'fusion-dark': { name: '녹투스', icon: '🌙🕳️', desc: '두 어둠이 만나 태어난 끝없는 심연의 정령.', recipe: ['dark', 'dark'], rarity: 'rare' },
            
            // 상극 속성 (균형 계열)
            'fusion-balance-flame': { name: '에테르나', icon: '🔥💧', desc: '불과 물이 만나 태어난 영원의 정령.', recipe: ['fire', 'water'], rarity: 'epic' },
            'fusion-balance-storm': { name: '사일렌시아', icon: '🌬️🌱', desc: '바람과 대지가 만나 태어난 고요의 정령.', recipe: ['wind', 'earth'], rarity: 'epic' },
            'fusion-balance-twilight': { name: '트와일라', icon: '✨🌙', desc: '빛과 어둠이 만나 태어난 황혼의 정령.', recipe: ['light', 'dark'], rarity: 'epic' },
            
            // 특수 조합
            'fusion-phoenix': { name: '솔라리스', icon: '🔥🐦', desc: '불과 빛이 만나 태어난 태양의 정령.', recipe: ['fire', 'light'], rarity: 'legendary' },
            'fusion-leviathan': { name: '아비수스', icon: '💧🐉', desc: '물과 어둠이 만나 태어난 심해의 정령.', recipe: ['water', 'dark'], rarity: 'legendary' },
            'fusion-dragon': { name: '템페스타', icon: '🔥🌬️', desc: '불과 바람이 만나 태어난 폭염의 정령.', recipe: ['fire', 'wind'], rarity: 'legendary' },
            'fusion-golem': { name: '크리스탈리아', icon: '🌱💎', desc: '대지와 빛이 만나 태어난 수정의 정령.', recipe: ['earth', 'light'], rarity: 'legendary' },
            'fusion-spirit-king': { name: '하모니아', icon: '👑✨', desc: '모든 원소를 품고 태어난 조화의 정령.', recipe: ['balanced', 'balanced'], rarity: 'legendary' },
            'fusion-chaos-king': { name: '코스모스', icon: '🌪️👑', desc: '세상의 혼돈을 품고 태어난 질서의 정령.', recipe: ['multi', 'multi'], rarity: 'legendary' },
            'fusion-balance-chaos': { name: '리멘', icon: '⚖️🌪️', desc: '조화와 혼돈을 품고 태어난 경계의 정령.', recipe: ['balanced', 'multi'], rarity: 'legendary' },
            
            // 전설 정령 연결
            'fusion-oblivion': { name: '오블리비온', icon: '🦋🌌', desc: '정령의 군주들이 만나 태어난 망각의 정령.', recipe: ['titania', 'oberon'], rarity: 'mythic' }
        };
        
        // ========== 이벤트 정령 시스템 ==========
        const EVENT_TYPES = {
            'christmas2025': {
                name: '기프티',
                icon: '🎄',
                attribute: 'event_christmas',
                desc: '산타 할아버지가 크리스마스 선물과 함께 특별한 정령의 알을 선물했어요!',
                validUntil: '2026-01-31',
                stages: {
                    egg: '<img src="https://i.imgur.com/I7hgZOP.png" style="width:150px;height:150px;vertical-align:middle;">',
                    larva1: '<img src="https://i.imgur.com/LabpyHo.png" style="width:150px;height:150px;vertical-align:middle;">',
                    larva2: '<img src="https://i.imgur.com/GD5netm.png" style="width:150px;height:150px;vertical-align:middle;">',
                    larva3: '<img src="https://i.imgur.com/GD5netm.png" style="width:150px;height:150px;vertical-align:middle;">',
                    pupa: '<img src="https://i.imgur.com/7pkn7bf.png" style="width:150px;height:150px;vertical-align:middle;">',
                    adult: '🎄'
                },
                rewards: [
                    { type: 'decoration', id: 'christmas_tree', name: '크리스마스 트리', icon: '🎄' },
                    { type: 'decoration', id: 'christmas_gift', name: '선물 상자', icon: '🎁' },
                    { type: 'food', id: 'christmas_cookie', name: '크리스마스 쿠키', icon: '🍪' },
                    { type: 'music', id: 'christmas_carol', name: '크리스마스 캐롤', icon: '🎵' }
                ],
                // 컬러 반전 버전 (25% 확률)
                shiny: {
                    name: '스노위',
                    icon: '❄️',
                    desc: '겨울의 눈꽃을 닮은 정령.',
                    stages: {
                        egg: '<img src="https://i.imgur.com/qh9ngkl.png" style="width:150px;height:150px;vertical-align:middle;">',
                        larva1: '<img src="https://i.imgur.com/cf83aWz.png" style="width:150px;height:150px;vertical-align:middle;">',
                        larva2: '<img src="https://i.imgur.com/hOFMEAC.png" style="width:150px;height:150px;vertical-align:middle;">',
                        larva3: '<img src="https://i.imgur.com/hOFMEAC.png" style="width:150px;height:150px;vertical-align:middle;">',
                        pupa: '<img src="https://i.imgur.com/bP78pu0.png" style="width:150px;height:150px;vertical-align:middle;">',
                        adult: '❄️'
                    },
                    chance: 0.4 // 40% 확률
                }
            }
        };
        
        // 이벤트 전용 아이템 정의
        const EVENT_ITEMS = {
            // 크리스마스 장식
            'christmas_tree': {
                name: '크리스마스 트리',
                icon: '🎄',
                type: 'decoration',
                event: 'christmas2025',
                quality: 'legendary',
                effects: { fire: 5, water: 5, wind: 5, earth: 5, light: 10, dark: 0 },
                desc: '특별한 크리스마스 선물. 모든 속성을 높여줍니다.'
            },
            // 크리스마스 선물상자
            'christmas_gift': {
                name: '선물 상자',
                icon: '🎁',
                type: 'decoration',
                event: 'christmas2025',
                quality: 'legendary',
                effects: { fire: 3, water: 3, wind: 3, earth: 3, light: 5, dark: 5 },
                desc: '특별한 크리스마스 선물. 무엇이 들어있을까요?'
            },
            // 크리스마스 먹이
            'christmas_cookie': {
                name: '크리스마스 쿠키',
                icon: '🍪',
                type: 'food',
                event: 'christmas2025',
                effects: { intelligence: 5, strength: 5, charm: 5, growth: 10 },
                desc: '특별한 크리스마스 선물. 모든 스탯을 크게 올려줍니다.'
            },
            // 크리스마스 음악
            'christmas_carol': {
                name: '크리스마스 캐롤',
                icon: '🎵',
                type: 'music',
                event: 'christmas2025',
                effects: { affection: 10, charm: 5 },
                desc: '특별한 크리스마스 선물. 애정도를 크게 올려줍니다.'
            }
        };
        
        // 이벤트 코드 생성 함수
        function generateEventCode(eventType) {
            const event = EVENT_TYPES[eventType];
            if (!event) return null;
            
            const data = {
                e: eventType,
                ts: Date.now()
            };
            
            try {
                const json = JSON.stringify(data);
                const base64 = btoa(unescape(encodeURIComponent(json)));
                return 'SGEVENT-' + base64;
            } catch (e) {
                console.error('이벤트 코드 생성 오류:', e);
                return null;
            }
        }
        
        // 이벤트 코드 해석 함수
        function decodeEventCode(code) {
            try {
                if (!code.startsWith('SGEVENT-')) return null;
                const base64 = code.substring(8);
                const json = decodeURIComponent(escape(atob(base64)));
                const data = JSON.parse(json);
                
                if (!data.e || !EVENT_TYPES[data.e]) return null;
                
                const event = EVENT_TYPES[data.e];
                
                // 유효기간 체크
                if (event.validUntil && new Date() > new Date(event.validUntil)) {
                    return { expired: true, eventType: data.e };
                }
                
                return {
                    eventType: data.e,
                    event: event,
                    timestamp: data.ts
                };
            } catch (e) {
                console.error('이벤트 코드 해석 오류:', e);
                return null;
            }
        }
        
        // 이벤트 알 생성 함수
        function createEventSpirit(eventType) {
            const event = EVENT_TYPES[eventType];
            if (!event) return null;
            
            // 이로치 확률 체크
            const isShiny = event.shiny && Math.random() < event.shiny.chance;
            
            const timestamp = new Date().toLocaleString('ko-KR', {
                month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit'
            });
            
            const spiritName = isShiny ? event.shiny.name : event.name;
            const birthMessage = isShiny 
                ? `✨ 이벤트 코드로 희귀한 ${spiritName}의 알이 태어났습니다!`
                : `🎄 이벤트 코드로 특별한 알이 태어났습니다!`;
            
            const spirit = {
                id: Date.now(),
                name: spiritName,
                originalName: spiritName,
                growth: 0,
                parameters: {
                    intelligence: 0,
                    strength: 0,
                    charm: 0,
                    affection: 0
                },
                hiddenAttributes: {
                    fire: 0, water: 0, wind: 0, earth: 0, light: 0, dark: 0
                },
                satisfaction: 'mid',
                lastFed: null,
                lastMusic: null,
                lastPat: null,
                lastDecorate: null,
                lastInteraction: Date.now(),
                status: isShiny ? '희귀한 알이 은은하게 빛나고 있습니다...' : '특별한 알이 빛나고 있습니다...',
                birthTime: Date.now(),
                logs: [
                    { time: timestamp, message: birthMessage }
                ],
                lightTime: 0,
                darkTime: 0,
                musicListened: 0,
                feedCount: 0,
                // 이벤트 전용 속성
                isEventSpirit: true,
                eventType: eventType,
                isShiny: isShiny // 이로치 여부
            };
            
            return spirit;
        }
        
        // 이벤트 정령 스테이지 아이콘 가져오기
        function getEventStageIcon(spirit) {
            if (!spirit.isEventSpirit || !spirit.eventType) return null;
            const event = EVENT_TYPES[spirit.eventType];
            if (!event) return null;
            
            const stage = getStage(spirit.growth);
            
            // 이로치면 이로치 스테이지 아이콘 사용
            if (spirit.isShiny && event.shiny && event.shiny.stages) {
                return event.shiny.stages[stage] || event.shiny.icon;
            }
            
            return event.stages[stage] || event.icon;
        }
        
        // 이벤트 정령 완성 시 보상 지급
        function giveEventRewards(eventType) {
            const event = EVENT_TYPES[eventType];
            if (!event || !event.rewards) return;
            
            event.rewards.forEach(reward => {
                if (reward.type === 'decoration') {
                    if (!inventory.decorations) inventory.decorations = [];
                    inventory.decorations.push(reward.id);
                } else if (reward.type === 'food') {
                    if (!inventory.food) inventory.food = [];
                    inventory.food.push(reward.id);
                } else if (reward.type === 'music') {
                    if (!inventory.music) inventory.music = [];
                    inventory.music.push(reward.id);
                }
            });
            
            const rewardNames = event.rewards.map(r => `${r.icon} ${r.name}`).join(', ');
            showNotification(`🎁 이벤트 보상 획득! ${rewardNames}`);
        }
        
        // 합성 관련 변수
        let fusionSlot1Spirit = null;
        let fusionSlot2Spirit = null;
        const FUSION_COST = 100;
        const BREED_COST = 50;
        
        // 모달 z-index 관리
        let currentZIndex = 10000;
        function getNextZIndex() {
            currentZIndex += 10;
            return currentZIndex;
        }

        function loadGame() {
            const saved = localStorage.getItem('spiritGardenV2');
            if (saved) {
                const data = JSON.parse(saved);
                spirits = data.spirits || [];
                
                // 문자열 id를 숫자 id로 변환 (연모 알 호환성)
                spirits.forEach(spirit => {
                    if (typeof spirit.id === 'string') {
                        spirit.id = Date.now() + Math.floor(Math.random() * 10000);
                    }
                });
                
                collection = data.collection || [];
                encyclopedia = data.encyclopedia || {};
                
                // 도감 데이터 형식 통일 (객체 → 숫자)
                Object.keys(encyclopedia).forEach(key => {
                    if (typeof encyclopedia[key] === 'object' && encyclopedia[key] !== null) {
                        encyclopedia[key] = encyclopedia[key].count || 1;
                    }
                });
                
                // ===== 스탯 타입 마이그레이션 (v41 이전 → v41+) =====
                // 이전 버전: intelligent-low, intelligent-mid, intelligent-high
                // 새 버전: intelligent
                const statLevelPattern = /^(intelligent|strong|beautiful)-(low|mid|high)$/;
                
                // 육성 중인 정령 마이그레이션
                spirits.forEach(spirit => {
                    if (spirit.evolutionType && statLevelPattern.test(spirit.evolutionType)) {
                        spirit.evolutionType = spirit.evolutionType.replace(/-(low|mid|high)$/, '');
                    }
                    if (spirit.evolutionData && spirit.evolutionData.type && statLevelPattern.test(spirit.evolutionData.type)) {
                        spirit.evolutionData.type = spirit.evolutionData.type.replace(/-(low|mid|high)$/, '');
                    }
                });
                
                // 앨범 마이그레이션
                collection.forEach(spirit => {
                    if (spirit.type && statLevelPattern.test(spirit.type)) {
                        spirit.type = spirit.type.replace(/-(low|mid|high)$/, '');
                    }
                });
                
                // 도감 마이그레이션 (키 변환 및 합산)
                const newEncyclopedia = {};
                Object.entries(encyclopedia).forEach(([key, count]) => {
                    // 키에서 -low, -mid, -high 제거
                    // 예: intelligent-mid-fire-butterfly → intelligent-fire-butterfly
                    const newKey = key.replace(/-(low|mid|high)-/, '-');
                    
                    if (!newEncyclopedia[newKey]) {
                        newEncyclopedia[newKey] = 0;
                    }
                    newEncyclopedia[newKey] += count;
                });
                encyclopedia = newEncyclopedia;
                // ===== 마이그레이션 끝 =====
                
                // 도감 상세 정보 로드 (복구용)
                encyclopediaDetails = data.encyclopediaDetails || {};
                
                // 기존 도감 데이터 호환성 처리 - 존재하지 않는 진화 타입 제거 (이벤트/합성 정령은 유지)
                collection = collection.filter(item => {
                    // 이벤트 정령은 항상 유지
                    if (item.type && item.type.startsWith('event_')) return true;
                    // 합성 정령(fusion-)은 항상 유지
                    if (item.type && (item.type.startsWith('fusion-') || FUSION_TYPES[item.type])) return true;
                    // isFusion 플래그가 있으면 유지
                    if (item.isFusion) return true;
                    // 티타니아/오베론은 항상 유지
                    if (item.type === 'titania' || item.type === 'oberon' || item.type === 'spiritking') return true;
                    // 일반 정령은 EVOLUTION_TYPES에 있는지 확인
                    return EVOLUTION_TYPES[item.type] !== undefined;
                });
                
                inventory = data.inventory || { 
                    music: [], 
                    decorations: [],
                    food: ['fire', 'fire', 'fire', 'water', 'water', 'water', 'wind', 'wind', 'wind', 'earth', 'earth', 'earth']
                };
                
                // 잘못된 음악 키 제거 (quest, lullaby 등 → classic, jazz 등)
                if (inventory.music) {
                    const validMusicKeys = ['classic', 'jazz', 'rock', 'pop', 'ballad', 'edm'];
                    // 이벤트 음악도 유효한 키에 추가
                    const eventMusicKeys = Object.keys(EVENT_ITEMS).filter(key => EVENT_ITEMS[key].type === 'music');
                    const allValidMusicKeys = [...validMusicKeys, ...eventMusicKeys];
                    inventory.music = inventory.music.filter(m => allValidMusicKeys.includes(m));
                }
                
                // 기존 미니어처 키를 새 형식으로 변환 (fire → fire_common1 등)
                const oldToNewDecoMapping = {
                    fire: 'fire_common1',
                    water: 'water_common1',
                    wind: 'wind_common1',
                    earth: 'earth_common1',
                    light: 'light_common1',
                    dark: 'dark_common1'
                };
                
                if (inventory.decorations) {
                    inventory.decorations = inventory.decorations.map(d => {
                        // 이미 새 형식이면 그대로, 아니면 변환
                        return oldToNewDecoMapping[d] || d;
                    });
                }
                
                if (installedDecorations) {
                    installedDecorations = installedDecorations.map(d => {
                        return oldToNewDecoMapping[d] || d;
                    });
                }
                
                terrarium = data.terrarium || {
                    fire: 0, water: 0, wind: 0, earth: 0, light: 0, dark: 0
                };
                installedDecorations = data.installedDecorations || [];
                
                // 기존 문자열 배열을 객체 배열로 변환 (하위 호환성)
                installedDecorations = installedDecorations.map((d, index) => {
                    if (typeof d === 'string') {
                        return { type: d, index: index };
                    }
                    return d;
                });
                
                lightMode = data.lightMode !== undefined ? data.lightMode : true;
                coins = data.coins || 0;
                totalEggsCreated = data.totalEggsCreated || 0;
                
                // 기존 데이터 호환: totalEggsCreated가 없으면 앨범+현재정령 수로 추정
                if (data.totalEggsCreated === undefined) {
                    totalEggsCreated = (collection.length || 0) + (spirits.length || 0);
                }
                
                lastGatherTime = data.lastGatherTime || null;
                currentTitle = data.currentTitle || 'none';
                currentGatherLocation = data.currentGatherLocation || 'garden';
                isPaused = data.isPaused || false;
                darkModeLocked = data.darkModeLocked || false;
                activatedEvents = data.activatedEvents || [];
                lowSatisfactionStartTime = data.lowSatisfactionStartTime || {};
                hasVisitedShop = data.hasVisitedShop || false;
                discoveredRecipes = data.discoveredRecipes || [];
                purchasedRecipeBooks = data.purchasedRecipeBooks || [];
                selfDiscoveredRecipes = data.selfDiscoveredRecipes || [];
                
                // 기존 데이터 호환: selfDiscoveredRecipes가 없으면 discoveredRecipes를 복사
                // (레시피북 시스템 도입 전에 발견한 레시피는 직접 발견으로 간주)
                if (data.selfDiscoveredRecipes === undefined && discoveredRecipes.length > 0) {
                    selfDiscoveredRecipes = [...discoveredRecipes];
                }
                
                achievements = data.achievements || {};
                claimedAchievementRewards = data.claimedAchievementRewards || [];
                labSlot1 = data.labSlot1 || null;
                labSlot2 = data.labSlot2 || null;
                
                // 로드 시 슬롯 비우기 (현재 시스템은 슬롯에 올려도 인벤토리에서 차감 안 함)
                labSlot1 = null;
                labSlot2 = null;
                
                lockedItems = data.lockedItems || { food: [], decorations: [], music: [] };
                if (!lockedItems.music) lockedItems.music = []; // 기존 세이브 호환

                // 칭호 UI 반영
                const titleSelect = document.getElementById('titleSelect');
                if (titleSelect) {
                    titleSelect.value = currentTitle;
                }
                
                // 일시정지 버튼 UI 반영
                const pauseBtn = document.getElementById('pauseBtn');
                if (pauseBtn && isPaused) {
                    pauseBtn.textContent = '▶️';
                    pauseBtn.classList.add('paused');
                    pauseBtn.title = '재개';
                    // 일시정지 상태로 로드되면 pausedAt을 현재 시간으로 설정
                    pausedAt = Date.now();
                }

                // 설치된 미니어처로 환경 재계산
                if (installedDecorations.length > 0) {
                    recalculateTerrariumEnvironment();
                }
                
                // 기존 정령들의 만족도 초기화 및 배고픔 타이머 리셋 (하위 호환성)
                const now = Date.now();
                spirits.forEach(spirit => {
                    if (!spirit.satisfaction) {
                        spirit.satisfaction = 'mid';
                    }
                    // 불러오기 시 배고픔 타이머 리셋 (오프라인 동안 죽지 않도록)
                    // 단, 이미 죽은 정령은 리셋하지 않음
                    if (!spirit.isDead && !spirit.isCompleted) {
                        spirit.lastFed = now;
                    }
                });

                // 조명 상태 적용
                applyLightMode();
            }
        }

        function saveGame() {
            localStorage.setItem('spiritGardenV2', JSON.stringify({
                spirits,
                collection,
                encyclopedia,
                encyclopediaDetails,
                inventory,
                terrarium,
                installedDecorations,
                lightMode,
                coins,
                totalEggsCreated,
                lastGatherTime,
                currentTitle,
                currentGatherLocation,
                isPaused,
                darkModeLocked,
                activatedEvents,
                lowSatisfactionStartTime,
                hasVisitedShop,
                discoveredRecipes,
                purchasedRecipeBooks,
                selfDiscoveredRecipes,
                achievements,
                claimedAchievementRewards,
                // labSlot은 저장하지 않음 (새 시스템에서는 합성 전까지 인벤토리 차감 안 함)
                lockedItems
            }));
        }

        const EGG_NAMES = [
            '반짝이는 알', '매끈매끈한 알', '얼룩무늬 알', '보라색 알',
            '투명한 알', '황금빛 알', '은빛 알', '검은색 알',
            '하얀색 알', '무지개 알', '작은 알', '큰 알',
            '따뜻한 알', '차가운 알', '부드러운 알', '단단한 알'
        ];
        
        function generateSpiritName() {
            totalEggsCreated++;
            saveGame();
            return `${totalEggsCreated}호`;
        }

        function addLog(spirit, message) {
            if (!spirit.logs) spirit.logs = [];
            const timestamp = new Date().toLocaleString('ko-KR', {
                month: '2-digit',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit'
            });
            spirit.logs.unshift({ time: timestamp, message }); // 최신이 위로
            if (spirit.logs.length > 50) spirit.logs.pop(); // 최대 50개 유지
            
            // 일지 추가 시에만 전체 렌더링
            renderSpirits();
        }

        // 업적 체크 및 달성 함수
        function checkAchievements() {
            const albumCount = collection.length;
            const encyclopediaCount = Object.keys(encyclopedia).length;
            let newAchievements = [];
            
            // 앨범 업적 체크
            Object.values(ACHIEVEMENTS).filter(a => a.category === 'album').forEach(achievement => {
                if (!achievements[achievement.id] && albumCount >= achievement.requirement) {
                    achievements[achievement.id] = Date.now();
                    newAchievements.push(achievement);
                }
            });
            
            // 도감 업적 체크
            Object.values(ACHIEVEMENTS).filter(a => a.category === 'encyclopedia').forEach(achievement => {
                if (!achievements[achievement.id] && encyclopediaCount >= achievement.requirement) {
                    achievements[achievement.id] = Date.now();
                    newAchievements.push(achievement);
                }
            });
            
            // 레시피 업적 체크
            const recipeCount = discoveredRecipes.length;
            Object.values(ACHIEVEMENTS).filter(a => a.category === 'recipe').forEach(achievement => {
                if (!achievements[achievement.id] && recipeCount >= achievement.requirement) {
                    achievements[achievement.id] = Date.now();
                    newAchievements.push(achievement);
                }
            });
            
            // 레시피북 없이 직접 발견 특별 업적 체크
            const selfDiscoveredCount = selfDiscoveredRecipes.length;
            Object.values(ACHIEVEMENTS).filter(a => a.category === 'recipe_special').forEach(achievement => {
                if (!achievements[achievement.id] && selfDiscoveredCount >= achievement.requirement) {
                    achievements[achievement.id] = Date.now();
                    newAchievements.push(achievement);
                }
            });
            
            // 새로운 업적 달성 시 알림
            newAchievements.forEach(achievement => {
                showNotification(`🏆 업적 달성! "${achievement.title}"`);
            });
            
            if (newAchievements.length > 0) {
                saveGame();
                renderJournal();
            }
            
            return newAchievements;
        }
        
        // 일지 서브탭 전환
        let currentJournalTab = 'encyclopedia'; // 기본 탭
        
        function switchJournalTab(tab) {
            currentJournalTab = tab;
            
            // 모든 탭 콘텐츠 숨기기
            const tabs = ['encyclopedia', 'album', 'achievement', 'memo', 'help'];
            tabs.forEach(t => {
                const tabContent = document.getElementById(`journal${t.charAt(0).toUpperCase() + t.slice(1)}Tab`);
                const tabBtn = document.getElementById(`journalTab${t.charAt(0).toUpperCase() + t.slice(1)}`);
                if (tabContent) tabContent.style.display = 'none';
                if (tabBtn) {
                    tabBtn.style.background = 'var(--bg)';
                    tabBtn.style.color = 'var(--text)';
                    tabBtn.style.border = '1px solid var(--border)';
                }
            });
            
            // 선택한 탭 표시
            const selectedContent = document.getElementById(`journal${tab.charAt(0).toUpperCase() + tab.slice(1)}Tab`);
            const selectedBtn = document.getElementById(`journalTab${tab.charAt(0).toUpperCase() + tab.slice(1)}`);
            if (selectedContent) selectedContent.style.display = 'block';
            if (selectedBtn) {
                selectedBtn.style.background = '#9b59b6';
                selectedBtn.style.color = 'white';
                selectedBtn.style.border = 'none';
            }
            
            // 탭별 렌더링 호출
            if (tab === 'encyclopedia') {
                renderEncyclopedia();
            } else if (tab === 'album') {
                renderCollection();
                // 튜토리얼2: 앨범 탭 열기 액션 체크
                checkTutorialAction('openAlbum');
            } else if (tab === 'achievement') {
                renderJournal();
            } else if (tab === 'help') {
                renderTutorialReplayList();
            }
        }
        
        // 일지 탭 렌더링
        function renderJournal() {
            const albumCount = collection.length;
            const encyclopediaCount = Object.keys(encyclopedia).length;
            const totalAchievements = Object.keys(ACHIEVEMENTS).length;
            const completedAchievements = Object.keys(achievements).length;
            const unclaimedRewards = Object.keys(achievements).filter(id => !claimedAchievementRewards.includes(id)).length;
            
            // 업적 요약
            const summaryDiv = document.getElementById('achievementSummary');
            if (summaryDiv) {
                summaryDiv.innerHTML = `
                    <div style="text-align: center; padding: 12px 20px; background: var(--bg); border-radius: 8px;">
                        <div style="font-size: 2rem; margin-bottom: 4px;">🏆</div>
                        <div style="font-size: 1.5rem; font-weight: 700; color: var(--text);">${completedAchievements} / ${totalAchievements}</div>
                        <div style="font-size: 0.85rem; color: #888;">달성한 업적</div>
                    </div>
                    <div style="text-align: center; padding: 12px 20px; background: var(--bg); border-radius: 8px; ${unclaimedRewards > 0 ? 'border: 2px solid #ffd700;' : ''}">
                        <div style="font-size: 2rem; margin-bottom: 4px;">💰</div>
                        <div style="font-size: 1.5rem; font-weight: 700; color: ${unclaimedRewards > 0 ? '#ffd700' : 'var(--text)'};">${unclaimedRewards > 0 ? unclaimedRewards * 25 : 0}</div>
                        <div style="font-size: 0.85rem; color: #888;">${unclaimedRewards > 0 ? `수령 가능 (${unclaimedRewards}개)` : '수령 완료'}</div>
                    </div>
                    <div style="text-align: center; padding: 12px 20px; background: var(--bg); border-radius: 8px;">
                        <div style="font-size: 2rem; margin-bottom: 4px;">📚</div>
                        <div style="font-size: 1.5rem; font-weight: 700; color: var(--text);">${encyclopediaCount}</div>
                        <div style="font-size: 0.85rem; color: #888;">도감 수집</div>
                    </div>
                `;
            }
            
            // 앨범 카운트 표시
            const albumCountDisplay = document.getElementById('albumCountDisplay');
            if (albumCountDisplay) {
                albumCountDisplay.textContent = `(현재 ${albumCount}마리)`;
            }
            
            // 도감 카운트 표시
            const encyclopediaCountDisplay = document.getElementById('encyclopediaCountDisplay');
            if (encyclopediaCountDisplay) {
                encyclopediaCountDisplay.textContent = `(현재 ${encyclopediaCount}종)`;
            }
            
            // 레시피 카운트 표시
            const recipeCountDisplay = document.getElementById('recipeCountDisplay');
            if (recipeCountDisplay) {
                recipeCountDisplay.textContent = `(현재 ${discoveredRecipes.length}개)`;
            }
            
            // 앨범 업적 렌더링
            const albumAchievementsDiv = document.getElementById('albumAchievements');
            if (albumAchievementsDiv) {
                const albumAchievements = Object.values(ACHIEVEMENTS).filter(a => a.category === 'album').sort((a, b) => a.requirement - b.requirement);
                albumAchievementsDiv.innerHTML = albumAchievements.map(achievement => {
                    const isCompleted = achievements[achievement.id];
                    const isRewardClaimed = claimedAchievementRewards.includes(achievement.id);
                    const progress = Math.min(albumCount, achievement.requirement);
                    const progressPercent = (progress / achievement.requirement) * 100;
                    const completedDate = isCompleted ? new Date(isCompleted).toLocaleDateString('ko-KR') : null;
                    
                    // 보상 버튼/상태 표시
                    let rewardDisplay = '';
                    if (isCompleted && !isRewardClaimed) {
                        rewardDisplay = `<button onclick="claimAchievementReward('${achievement.id}')" style="padding: 6px 12px; background: linear-gradient(135deg, #ffd700, #ffed4a); color: #333; border: none; border-radius: 6px; font-weight: 700; cursor: pointer; font-size: 0.8rem;">💰 25코인 받기</button>`;
                    } else if (isCompleted && isRewardClaimed) {
                        rewardDisplay = '<span style="color: #27ae60; font-size: 0.8rem; font-weight: 600;">✓ 수령완료</span>';
                    }
                    
                    return `
                        <div style="padding: 16px; background: ${isCompleted ? 'linear-gradient(135deg, rgba(255,215,0,0.1), rgba(255,215,0,0.05))' : 'var(--bg)'}; border-radius: 8px; border: 1px solid ${isCompleted ? 'rgba(255,215,0,0.3)' : 'var(--border)'};">
                            <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 8px;">
                                <span style="font-size: 1.8rem; ${isCompleted ? '' : 'filter: grayscale(100%); opacity: 0.5;'}">${achievement.icon}</span>
                                <div style="flex: 1;">
                                    <div style="font-weight: 700; color: ${isCompleted ? 'var(--text)' : '#888'}; font-size: 1.05rem;">${achievement.title}</div>
                                    <div style="font-size: 0.85rem; color: #888;">${achievement.desc}</div>
                                </div>
                                ${isCompleted ? '<span style="color: #ffd700; font-size: 1.2rem;">✓</span>' : ''}
                            </div>
                            <div style="background: var(--border); height: 6px; border-radius: 3px; overflow: hidden;">
                                <div style="width: ${progressPercent}%; height: 100%; background: ${isCompleted ? 'linear-gradient(90deg, #ffd700, #ffed4a)' : 'var(--water)'}; transition: width 0.3s;"></div>
                            </div>
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 6px; font-size: 0.8rem; color: #888;">
                                <span>${progress} / ${achievement.requirement}마리</span>
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    ${completedDate ? `<span>달성: ${completedDate}</span>` : ''}
                                    ${rewardDisplay}
                                </div>
                            </div>
                        </div>
                    `;
                }).join('');
            }
            
            // 도감 업적 렌더링
            const encyclopediaAchievementsDiv = document.getElementById('encyclopediaAchievements');
            if (encyclopediaAchievementsDiv) {
                const encyclopediaAchievements = Object.values(ACHIEVEMENTS).filter(a => a.category === 'encyclopedia').sort((a, b) => a.requirement - b.requirement);
                encyclopediaAchievementsDiv.innerHTML = encyclopediaAchievements.map(achievement => {
                    const isCompleted = achievements[achievement.id];
                    const isRewardClaimed = claimedAchievementRewards.includes(achievement.id);
                    const progress = Math.min(encyclopediaCount, achievement.requirement);
                    const progressPercent = (progress / achievement.requirement) * 100;
                    const completedDate = isCompleted ? new Date(isCompleted).toLocaleDateString('ko-KR') : null;
                    
                    // 보상 버튼/상태 표시
                    let rewardDisplay = '';
                    if (isCompleted && !isRewardClaimed) {
                        rewardDisplay = `<button onclick="claimAchievementReward('${achievement.id}')" style="padding: 6px 12px; background: linear-gradient(135deg, #ffd700, #ffed4a); color: #333; border: none; border-radius: 6px; font-weight: 700; cursor: pointer; font-size: 0.8rem;">💰 25코인 받기</button>`;
                    } else if (isCompleted && isRewardClaimed) {
                        rewardDisplay = '<span style="color: #27ae60; font-size: 0.8rem; font-weight: 600;">✓ 수령완료</span>';
                    }
                    
                    return `
                        <div style="padding: 16px; background: ${isCompleted ? 'linear-gradient(135deg, rgba(255,215,0,0.1), rgba(255,215,0,0.05))' : 'var(--bg)'}; border-radius: 8px; border: 1px solid ${isCompleted ? 'rgba(255,215,0,0.3)' : 'var(--border)'};">
                            <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 8px;">
                                <span style="font-size: 1.8rem; ${isCompleted ? '' : 'filter: grayscale(100%); opacity: 0.5;'}">${achievement.icon}</span>
                                <div style="flex: 1;">
                                    <div style="font-weight: 700; color: ${isCompleted ? 'var(--text)' : '#888'}; font-size: 1.05rem;">${achievement.title}</div>
                                    <div style="font-size: 0.85rem; color: #888;">${achievement.desc}</div>
                                </div>
                                ${isCompleted ? '<span style="color: #ffd700; font-size: 1.2rem;">✓</span>' : ''}
                            </div>
                            <div style="background: var(--border); height: 6px; border-radius: 3px; overflow: hidden;">
                                <div style="width: ${progressPercent}%; height: 100%; background: ${isCompleted ? 'linear-gradient(90deg, #ffd700, #ffed4a)' : 'var(--earth)'}; transition: width 0.3s;"></div>
                            </div>
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 6px; font-size: 0.8rem; color: #888;">
                                <span>${progress} / ${achievement.requirement}종</span>
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    ${completedDate ? `<span>달성: ${completedDate}</span>` : ''}
                                    ${rewardDisplay}
                                </div>
                            </div>
                        </div>
                    `;
                }).join('');
            }
            
            // 레시피 업적 렌더링
            const recipeAchievementsDiv = document.getElementById('recipeAchievements');
            if (recipeAchievementsDiv) {
                const recipeCount = discoveredRecipes.length;
                const recipeAchievements = Object.values(ACHIEVEMENTS).filter(a => a.category === 'recipe').sort((a, b) => a.requirement - b.requirement);
                recipeAchievementsDiv.innerHTML = recipeAchievements.map(achievement => {
                    const isCompleted = achievements[achievement.id];
                    const isRewardClaimed = claimedAchievementRewards.includes(achievement.id);
                    const progress = Math.min(recipeCount, achievement.requirement);
                    const progressPercent = (progress / achievement.requirement) * 100;
                    const completedDate = isCompleted ? new Date(isCompleted).toLocaleDateString('ko-KR') : null;
                    
                    // 보상 버튼/상태 표시
                    let rewardDisplay = '';
                    if (isCompleted && !isRewardClaimed) {
                        rewardDisplay = `<button onclick="claimAchievementReward('${achievement.id}')" style="padding: 6px 12px; background: linear-gradient(135deg, #ffd700, #ffed4a); color: #333; border: none; border-radius: 6px; font-weight: 700; cursor: pointer; font-size: 0.8rem;">💰 25코인 받기</button>`;
                    } else if (isCompleted && isRewardClaimed) {
                        rewardDisplay = '<span style="color: #27ae60; font-size: 0.8rem; font-weight: 600;">✓ 수령완료</span>';
                    }
                    
                    return `
                        <div style="padding: 16px; background: ${isCompleted ? 'linear-gradient(135deg, rgba(255,215,0,0.1), rgba(255,215,0,0.05))' : 'var(--bg)'}; border-radius: 8px; border: 1px solid ${isCompleted ? 'rgba(255,215,0,0.3)' : 'var(--border)'};">
                            <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 8px;">
                                <span style="font-size: 1.8rem; ${isCompleted ? '' : 'filter: grayscale(100%); opacity: 0.5;'}">${achievement.icon}</span>
                                <div style="flex: 1;">
                                    <div style="font-weight: 700; color: ${isCompleted ? 'var(--text)' : '#888'}; font-size: 1.05rem;">${achievement.title}</div>
                                    <div style="font-size: 0.85rem; color: #888;">${achievement.desc}</div>
                                </div>
                                ${isCompleted ? '<span style="color: #ffd700; font-size: 1.2rem;">✓</span>' : ''}
                            </div>
                            <div style="background: var(--border); height: 6px; border-radius: 3px; overflow: hidden;">
                                <div style="width: ${progressPercent}%; height: 100%; background: ${isCompleted ? 'linear-gradient(90deg, #ffd700, #ffed4a)' : '#9b59b6'}; transition: width 0.3s;"></div>
                            </div>
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 6px; font-size: 0.8rem; color: #888;">
                                <span>${progress} / ${achievement.requirement}개</span>
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    ${completedDate ? `<span>달성: ${completedDate}</span>` : ''}
                                    ${rewardDisplay}
                                </div>
                            </div>
                        </div>
                    `;
                }).join('');
            }
            
            // 특별 업적 렌더링
            const specialAchievementsDiv = document.getElementById('specialAchievements');
            if (specialAchievementsDiv) {
                const selfDiscoveredCount = selfDiscoveredRecipes.length;
                const specialAchievements = Object.values(ACHIEVEMENTS).filter(a => a.category === 'recipe_special').sort((a, b) => a.requirement - b.requirement);
                specialAchievementsDiv.innerHTML = specialAchievements.map(achievement => {
                    const isCompleted = achievements[achievement.id];
                    const isRewardClaimed = claimedAchievementRewards.includes(achievement.id);
                    const progress = Math.min(selfDiscoveredCount, achievement.requirement);
                    const progressPercent = (progress / achievement.requirement) * 100;
                    const completedDate = isCompleted ? new Date(isCompleted).toLocaleDateString('ko-KR') : null;
                    
                    // 레시피북 구매 여부에 따른 안내 메시지
                    const hasBookPurchased = purchasedRecipeBooks.length > 0;
                    const warningMsg = hasBookPurchased && !isCompleted
                        ? '<div style="font-size: 0.75rem; color: #e74c3c; margin-top: 8px;">⚠️ 레시피북을 구매하여 이 업적을 달성할 수 없습니다.</div>'
                        : '';
                    
                    // 보상 버튼/상태 표시
                    let rewardDisplay = '';
                    if (isCompleted && !isRewardClaimed) {
                        rewardDisplay = `<button onclick="claimAchievementReward('${achievement.id}')" style="padding: 6px 12px; background: linear-gradient(135deg, #ffd700, #ffed4a); color: #333; border: none; border-radius: 6px; font-weight: 700; cursor: pointer; font-size: 0.8rem;">💰 25코인 받기</button>`;
                    } else if (isCompleted && isRewardClaimed) {
                        rewardDisplay = '<span style="color: #27ae60; font-size: 0.8rem; font-weight: 600;">✓ 수령완료</span>';
                    }
                    
                    return `
                        <div style="padding: 16px; background: ${isCompleted ? 'linear-gradient(135deg, rgba(255,215,0,0.15), rgba(255,215,0,0.05))' : 'var(--bg)'}; border-radius: 8px; border: 2px solid ${isCompleted ? '#ffd700' : hasBookPurchased ? '#e74c3c' : 'var(--border)'};">
                            <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 8px;">
                                <span style="font-size: 1.8rem; ${isCompleted ? '' : 'filter: grayscale(100%); opacity: 0.5;'}">${achievement.icon}</span>
                                <div style="flex: 1;">
                                    <div style="font-weight: 700; color: ${isCompleted ? '#ffd700' : '#888'}; font-size: 1.05rem;">${achievement.title}</div>
                                    <div style="font-size: 0.85rem; color: #888;">${achievement.desc}</div>
                                </div>
                                ${isCompleted ? '<span style="color: #ffd700; font-size: 1.2rem;">✓</span>' : ''}
                            </div>
                            <div style="background: var(--border); height: 6px; border-radius: 3px; overflow: hidden;">
                                <div style="width: ${progressPercent}%; height: 100%; background: ${isCompleted ? 'linear-gradient(90deg, #ffd700, #ffed4a)' : '#27ae60'}; transition: width 0.3s;"></div>
                            </div>
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 6px; font-size: 0.8rem; color: #888;">
                                <span>직접 발견: ${progress} / ${achievement.requirement}개</span>
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    ${completedDate ? `<span>달성: ${completedDate}</span>` : ''}
                                    ${rewardDisplay}
                                </div>
                            </div>
                            ${warningMsg}
                        </div>
                    `;
                }).join('');
            }
        }
        
        // 업적 보상 수령 함수
        function claimAchievementReward(achievementId) {
            // 이미 수령했는지 확인
            if (claimedAchievementRewards.includes(achievementId)) {
                showNotification('이미 보상을 수령했습니다.');
                return;
            }
            
            // 달성했는지 확인
            if (!achievements[achievementId]) {
                showNotification('아직 달성하지 않은 업적입니다.');
                return;
            }
            
            // 보상 지급
            coins += 25;
            claimedAchievementRewards.push(achievementId);
            
            // 업적 정보 가져오기
            const achievement = ACHIEVEMENTS[achievementId];
            const achievementTitle = achievement ? achievement.title : '업적';
            
            saveGame();
            renderJournal();
            updateCoinDisplay();
            
            showNotification(`🎉 "${achievementTitle}" 보상 25코인을 받았습니다!`);
        }

        function createNewSpirit() {
            if (spirits.length >= 6) {
                showNotification('정원이 가득 찼습니다 (최대 6마리)');
                return;
            }

            totalEggsCreated++;
            const eggName = `${totalEggsCreated}호`;

            const spirit = {
                id: Date.now(),
                name: eggName,
                growth: 0,
                // 공개 스탯
                parameters: {
                    intelligence: 0,  // 지력
                    strength: 0,      // 체력
                    charm: 0,         // 매력
                    affection: 0      // 애정
                },
                // 숨겨진 속성 (진화 결정)
                hiddenAttributes: {
                    fire: 0,
                    water: 0,
                    wind: 0,
                    earth: 0,
                    light: 0,
                    dark: 0
                },
                satisfaction: 'mid',  // 만족도: 'high', 'mid', 'low'
                lastFed: null,
                lastMusic: null,
                lastPat: null,
                lastDecorate: null,
                lastInteraction: Date.now(),  // 마지막 상호작용 시간
                status: '배고파 보입니다...',
                birthTime: Date.now(),
                logs: [],  // 일지
                lightTime: 0,  // 빛 모드 누적 시간 (초)
                darkTime: 0,   // 어둠 모드 누적 시간 (초)
                musicListened: 0,  // 음악 청취 횟수
                feedCount: 0,      // 먹이 횟수
                relationships: {},  // 다른 정령과의 관계 { spiritId: 수치(0~100) }
                bond: null  // 영구 관계 { type: 'bestfriend' | 'lover', partnerId: 'id' }
            };

            spirits.push(spirit);
            saveGame();
            renderSpirits();
            showNotification(`${eggName}이(가) 태어났습니다! 🥚`);
            
            // 튜토리얼 체크
            checkTutorialAction('getEgg');
        }

        function changeName(spiritId) {
            currentSpiritId = spiritId;
            const spirit = spirits.find(s => s.id === spiritId);
            document.getElementById('nameInput').value = spirit.name;
            document.getElementById('nameModal').classList.add('active');
            
            // 튜토리얼: 이름 클릭 액션 체크
            checkTutorialAction('clickName');
        }
        
        // 이름 확인 함수
        function confirmName() {
            const spirit = spirits.find(s => s.id === currentSpiritId);
            if (!spirit) return;
            
            const newName = document.getElementById('nameInput').value.trim();
            if (!newName) {
                showNotification('이름을 입력해주세요');
                return;
            }
            spirit.name = newName;
            closeModal('nameModal');
            saveGame();
            updateSpiritCard(spirit);
            showNotification('이름을 변경했습니다');
            
            // 튜토리얼: 이름 변경 완료 액션 체크
            checkTutorialAction('rename');
        }

        // 정령의 주요 속성 찾기
        function getDominantAttribute(spirit) {
            if (!spirit.hiddenAttributes) {
                return 'normal';
            }
            
            let maxAttr = 'normal';
            let maxValue = 0;
            
            for (let attr in spirit.hiddenAttributes) {
                if (spirit.hiddenAttributes[attr] > maxValue) {
                    maxValue = spirit.hiddenAttributes[attr];
                    maxAttr = attr;
                }
            }
            
            // 최고 속성값이 50 미만이면 normal (백의 정령)
            if (maxValue < 50) {
                return 'normal';
            }
            
            return maxAttr;
        }

                function getStage(growth) {
            if (growth >= STAGE_REQUIREMENTS.adult) return 'adult';
            if (growth >= STAGE_REQUIREMENTS.pupa) return 'pupa';
            if (growth >= STAGE_REQUIREMENTS.larva3) return 'larva3';
            if (growth >= STAGE_REQUIREMENTS.larva2) return 'larva2';
            if (growth >= STAGE_REQUIREMENTS.larva1) return 'larva1';
            return 'egg';
        }
        
        // 현재 속성에 따른 외형 묘사 가져오기
        function getAppearanceDescription(spirit) {
            const stage = getStage(spirit.growth);
            
            // 성충이면 외형 묘사 없음
            if (stage === 'adult') return null;
            
            // 이벤트 정령 외형 묘사
            if (spirit.isEventSpirit && spirit.eventType) {
                const eventAppearances = {
                    christmas2025: {
                        normal: {
                            egg: '빨간색과 초록색 줄무늬의 알록달록한 알입니다.',
                            larva1: '초록색 몸에 빨간색 점 무늬가 있습니다.',
                            larva2: '초록색 몸에 빨간색 점 무늬가 있으며 머리 위에 별모양 더듬이가 있습니다.',
                            larva3: '초록색 몸에 빨간색 점 무늬가 있으며 머리 위의 별모양 더듬이가 반짝이고 있습니다.',
                            pupa: '반짝이는 금색 실로 감싸진 번데기입니다. 안에서 붉은 빛이 새어나옵니다.'
                        },
                        shiny: {
                            egg: '은은한 파란빛이 감도는 하얀 알입니다. 차가운 기운이 느껴집니다.',
                            larva1: '연한 파란색 몸에 은색 점 무늬가 있습니다.',
                            larva2: '연한 파란색 몸에 은색 점 무늬가 있으며 머리 위에 눈꽃 모양 더듬이가 있습니다.',
                            larva3: '연한 파란색 몸에 은색 점 무늬가 있으며 머리 위의 눈꽃 더듬이에서 눈이 흩날립니다.',
                            pupa: '반짝이는 은색 실로 감싸진 번데기입니다. 안에서 푸른 빛이 새어나옵니다.'
                        }
                    }
                };
                
                const eventDesc = eventAppearances[spirit.eventType];
                if (eventDesc) {
                    const variant = spirit.isShiny ? 'shiny' : 'normal';
                    if (eventDesc[variant] && eventDesc[variant][stage]) {
                        return eventDesc[variant][stage];
                    }
                }
            }
            
            // 알 ~ 번데기만 외형 묘사 있음
            if (!APPEARANCE_DESCRIPTIONS[stage]) return null;
            
            // 현재 속성 계산 (먹이 70% + 테라리움 30%)
            const foodAttrs = spirit.hiddenAttributes || { fire: 0, water: 0, wind: 0, earth: 0, light: 0, dark: 0 };
            const finalAttrs = {};
            for (let attr in foodAttrs) {
                finalAttrs[attr] = (foodAttrs[attr] * 0.7) + (terrarium[attr] * 0.3);
            }
            
            // 속성을 내림차순으로 정렬
            const sortedAttrs = Object.entries(finalAttrs)
                .sort((a, b) => b[1] - a[1]);
            
            const firstAttr = sortedAttrs[0][0];
            const firstValue = sortedAttrs[0][1];
            const secondAttr = sortedAttrs[1][0];
            const secondValue = sortedAttrs[1][1];
            
            // 속성이 10 미만이면 normal
            if (firstValue < 10) {
                return APPEARANCE_DESCRIPTIONS[stage]['normal'] || '평범한 모습입니다.';
            }
            
            // 2개 속성이 비슷한지 확인 (차이가 30% 이하)
            // larva2, larva3, pupa만 혼합 외형 있음
            if ((stage === 'larva2' || stage === 'larva3' || stage === 'pupa') && secondValue >= 10) {
                const diffPercent = ((firstValue - secondValue) / firstValue) * 100;
                
                if (diffPercent <= 30) {
                    // 혼합 속성!
                    const comboKey = [firstAttr, secondAttr].sort().join('-');
                    const mixedDesc = APPEARANCE_DESCRIPTIONS[stage][comboKey];
                    
                    if (mixedDesc) {
                        return mixedDesc;
                    }
                }
            }
            
            // 단일 속성
            return APPEARANCE_DESCRIPTIONS[stage][firstAttr] || '평범한 모습입니다.';
        }
        
        // 품질 등급을 점수로 변환
        function getQualityScore(quality) {
            const qualityScores = {
                'common': 1,     // 낮음
                'rare': 3,       // 보통
                'epic': 5,       // 높음
                'legendary': 7   // 전설
            };
            return qualityScores[quality] || 1;
        }
        
        // 테라리움 품질 합계 계산
        function calculateTerrariumQuality() {
            if (installedDecorations.length === 0) return 0;
            
            let totalQuality = 0;
            
            installedDecorations.forEach(deco => {
                // 문자열 또는 객체 모두 지원
                const key = typeof deco === 'string' ? deco : deco.type;
                const decoData = DECORATION_TYPES[key];
                const eventItem = EVENT_ITEMS[key];
                const synthItem = SYNTH_ITEMS[key];
                
                if (decoData) {
                    totalQuality += getQualityScore(decoData.quality);
                } else if (eventItem && eventItem.quality) {
                    totalQuality += getQualityScore(eventItem.quality);
                } else if (synthItem) {
                    totalQuality += 6; // 합성 미니어처은 최상급(5)과 전설(7) 사이
                }
            });
            
            return totalQuality;
        }
        
        // 정령별 불만 상태 지속 시간 체크 및 업데이트
        function updateLowSatisfactionTimer() {
            spirits.forEach(spirit => {
                if (spirit.isDead || spirit.isCompleted) return;
                
                const satisfaction = calculateSatisfaction(spirit);
                
                if (satisfaction === 'low') {
                    // 불만 상태인데 타이머가 없으면 시작
                    if (!lowSatisfactionStartTime[spirit.id]) {
                        lowSatisfactionStartTime[spirit.id] = Date.now();
                    }
                } else {
                    // 불만 상태가 아니면 타이머 리셋
                    delete lowSatisfactionStartTime[spirit.id];
                }
            });
        }
        
        // 정령이 상호작용을 거부하는 상태인지 확인 (불만 상태가 10분 이상 지속)
        function isSpiritRefusing(spiritId) {
            const startTime = lowSatisfactionStartTime[spiritId];
            if (!startTime) return false;
            const elapsed = Date.now() - startTime;
            return elapsed >= 10 * 60 * 1000; // 10분
        }
        
        // 거부 대사 반환
        function getRefusalMessage(spiritName, action) {
            const messages = {
                feed: [
                    `${spiritName}이(가) 고개를 돌립니다. 환경이 마음에 안 드는 것 같습니다.`,
                    `${spiritName}이(가) 먹이를 거부합니다. 기분이 안 좋아 보입니다.`,
                    `${spiritName}이(가) 슬픈 눈으로 쳐다봅니다. 불만이 쌓인 것 같습니다.`,
                    `${spiritName}이(가) 입을 꾹 다뭅니다. 무언가 불편한 것 같습니다.`,
                    `${spiritName}이(가) 무기력하게 있습니다. 힘이 없어 보입니다.`
                ],
                pet: [
                    `${spiritName}이(가) 손길을 피합니다. 환경이 마음에 안 드는 것 같습니다.`,
                    `${spiritName}이(가) 쓰다듬기를 거부합니다. 기분이 안 좋아 보입니다.`,
                    `${spiritName}이(가) 몸을 웅크립니다. 불만이 쌓인 것 같습니다.`,
                    `${spiritName}이(가) 고개를 저습니다. 무언가 불편한 것 같습니다.`,
                    `${spiritName}이(가) 삐진 듯 등을 돌립니다. 토라진 것 같습니다.`
                ]
            };
            const list = messages[action] || messages.feed;
            return list[Math.floor(Math.random() * list.length)];
        }
        
        // 만족도 계산 함수
        function calculateSatisfaction(spirit) {
            const stage = getStage(spirit.growth);
            
            // 죽었거나 완성된 정령은 만족도 계산 안 함
            if (spirit.isDead || spirit.isCompleted) return spirit.satisfaction || 'mid';
            
            // 미니어처가 없으면 낮음
            if (installedDecorations.length === 0) return 'low';
            
            // 테라리움 품질 합계
            const totalQuality = calculateTerrariumQuality();
            
            // 성장 단계별 품질 합계 요구치
            // 품질 점수: 일반=1, 희귀=3, 최상급=5, 합성=6, 전설=7
            // 알/애벌레1: 일반 3개(3) ~ 희귀 3개(9) 수준
            // 애벌레2: 희귀 3개(9) ~ 최상급 3개(15) 수준
            // 애벌레3: 최상급 3개(15) ~ 전설 3개(21) 수준
            // 번데기: 전설 3개(21) ~ 전설 5개(35) 수준
            let qualityThresholdMid, qualityThresholdHigh;
            
            if (stage === 'egg' || stage === 'larva1') {
                qualityThresholdMid = 3;   // 일반 3개
                qualityThresholdHigh = 9;  // 희귀 3개
            } else if (stage === 'larva2') {
                qualityThresholdMid = 9;   // 희귀 3개
                qualityThresholdHigh = 15; // 최상급 3개
            } else if (stage === 'larva3') {
                qualityThresholdMid = 15;  // 최상급 3개
                qualityThresholdHigh = 21; // 전설 3개
            } else { // pupa
                qualityThresholdMid = 21;  // 전설 3개
                qualityThresholdHigh = 35; // 전설 5개
            }
            
            // 알 ~ 애벌레1: 품질 합계만 확인
            if (stage === 'egg' || stage === 'larva1') {
                if (totalQuality >= qualityThresholdHigh) return 'high';
                else if (totalQuality >= qualityThresholdMid) return 'mid';
                else return 'low';
            }
            // 애벌레2, 애벌레3, 번데기: 품질 합계 + 속성 유사도
            else {
                // 정령의 현재 속성 계산
                const foodAttrs = spirit.hiddenAttributes || { fire: 0, water: 0, wind: 0, earth: 0, light: 0, dark: 0 };
                const spiritAttrs = {};
                for (let attr in foodAttrs) {
                    spiritAttrs[attr] = (foodAttrs[attr] * 0.7) + (terrarium[attr] * 0.3);
                }
                
                // 정령의 주 속성 찾기 (가장 높은 속성)
                let maxAttr = null;
                let maxValue = 0;
                for (let attr in spiritAttrs) {
                    if (spiritAttrs[attr] > maxValue) {
                        maxValue = spiritAttrs[attr];
                        maxAttr = attr;
                    }
                }
                
                // 속성이 10 미만이면 속성이 명확하지 않음 → 품질만으로 판단
                if (maxValue < 10) {
                    if (totalQuality >= qualityThresholdHigh) return 'high';
                    else if (totalQuality >= qualityThresholdMid) return 'mid';
                    else return 'low';
                }
                
                // 테라리움의 상위 2개 속성
                const topTerrariumAttrs = Object.entries(terrarium)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 2)
                    .map(([attr]) => attr);
                
                if (topTerrariumAttrs.includes(maxAttr)) {
                    // 속성 일치 시 요구치 완화
                    if (totalQuality >= qualityThresholdMid) return 'high';
                    else if (totalQuality >= qualityThresholdMid * 0.7) return 'mid';
                    else return 'low';
                } else {
                    // 속성 불일치 시 요구치 상향
                    if (totalQuality >= qualityThresholdHigh) return 'mid';
                    else return 'low';
                }
            }
        }

        function getNextStageRequirement(growth) {
            const stage = getStage(growth);
            const stages = Object.keys(STAGE_REQUIREMENTS);
            const currentIndex = stages.indexOf(stage);
            if (currentIndex < stages.length - 1) {
                return STAGE_REQUIREMENTS[stages[currentIndex + 1]];
            }
            return STAGE_REQUIREMENTS.adult;
        }

        function canDoAction(spirit, action) {
            const now = Date.now();
            const cooldown = 10000; // 10초

            if (action === 'feed') {
                return !spirit.lastFeed || (now - spirit.lastFeed > cooldown);
            }
            if (action === 'music') {
                return !spirit.lastMusic || (now - spirit.lastMusic > cooldown);
            }
            if (action === 'pat') {
                return !spirit.lastPat || (now - spirit.lastPat > cooldown);
            }
            if (action === 'decorate') {
                return !spirit.lastDecorate || (now - spirit.lastDecorate > cooldown);
            }
            return false;
        }

        // 커스텀 확인 창 표시
        function showConfirm(title, message, onConfirm, confirmText = '확인', cancelText = '취소', onCancel = null) {
            return new Promise((resolve) => {
                const modal = document.getElementById('confirmModal');
                const titleEl = document.getElementById('confirmTitle');
                const messageEl = document.getElementById('confirmMessage');
                const okBtn = document.getElementById('confirmOkBtn');
                const cancelBtn = document.getElementById('confirmCancelBtn');
                
                titleEl.textContent = title;
                messageEl.textContent = message;
                
                // 버튼 텍스트 설정
                okBtn.textContent = confirmText;
                cancelBtn.textContent = cancelText;
                
                // 동적 z-index 적용
                modal.style.zIndex = getNextZIndex();
                modal.classList.add('active');
                
                // 이전 이벤트 리스너 제거
                const newOkBtn = okBtn.cloneNode(true);
                const newCancelBtn = cancelBtn.cloneNode(true);
                newOkBtn.textContent = confirmText;
                newCancelBtn.textContent = cancelText;
                okBtn.parentNode.replaceChild(newOkBtn, okBtn);
                cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);
                
                // 확인 버튼
                document.getElementById('confirmOkBtn').onclick = () => {
                    modal.classList.remove('active');
                    if (onConfirm) onConfirm();
                    resolve(true);
                };
                
                // 취소 버튼
                document.getElementById('confirmCancelBtn').onclick = () => {
                    modal.classList.remove('active');
                    if (onCancel) onCancel();
                    resolve(false);
                };
            });
        }

        function openFeedModal(spiritId) {
            const spirit = spirits.find(s => s.id === spiritId);
            if (!canDoAction(spirit, 'feed')) {
                showNotification('아직 배가 부릅니다');
                return;
            }
            if (!inventory.food) inventory.food = [];
            if (inventory.food.length === 0) {
                showNotification('먹이가 없습니다. 채집을 해보세요!');
                return;
            }
            currentSpiritId = spiritId;
            renderFeedOptions();
            document.getElementById('feedModal').classList.add('active');
        }

        function renderFeedOptions() {
            if (!inventory.food) inventory.food = [];
            
            const modal = document.getElementById('feedModal');
            const spirit = spirits.find(s => s.id === currentSpiritId);
            
            const foodCounts = {};
            inventory.food.forEach(f => {
                foodCounts[f] = (foodCounts[f] || 0) + 1;
            });
            
            // medicine을 foodCounts에서 분리
            const medicineCount = foodCounts['medicine'] || 0;
            delete foodCounts['medicine'];
            
            let medicineSection = '';
            if (spirit && spirit.isSick && medicineCount > 0) {
                medicineSection = `
                    <button class="option-btn" onclick="giveMedicineFromModal(${currentSpiritId})">
                        <span class="option-icon">🌿</span>
                        <div class="option-info">
                            <div class="option-name">${MEDICINE.name} ×${medicineCount}</div>
                            <div class="option-effect">병을 완전히 치료합니다</div>
                        </div>
                    </button>
                `;
            } else if (spirit && spirit.isSick) {
                medicineSection = `
                    <div style="margin-bottom: 10px; padding: 10px; background: var(--card); border: 1px solid var(--border);">
                        <div style="font-size: 0.9rem; color: #666;">정령이 아픕니다! 약초가 필요합니다.</div>
                    </div>
                `;
            }
            
            // 이벤트 먹이와 일반 먹이 분리 (고정 순서)
            const FOOD_ORDER = ['fire', 'water', 'wind', 'earth', 'light', 'dark'];
            const eventFoods = [];
            const normalFoods = [];
            const synthFoods = [];
            const etcFoods = []; // 기타 먹이 (수선화 꽃잎, 아카시아 꿀)
            const ETC_FOOD_TYPES = ['reconciliation_flower', 'acacia_honey'];
            
            // 고정된 순서대로 정렬
            FOOD_ORDER.forEach(type => {
                if (foodCounts[type]) {
                    normalFoods.push([type, foodCounts[type]]);
                }
            });
            
            // 이벤트 먹이 (이벤트 아이템 키 순서대로)
            Object.keys(EVENT_ITEMS).forEach(type => {
                if (foodCounts[type] && EVENT_ITEMS[type].type === 'food') {
                    eventFoods.push([type, foodCounts[type]]);
                }
            });
            
            // 합성 먹이 (수선화 꽃잎, 아카시아 꿀 제외)
            Object.keys(SYNTH_ITEMS).forEach(type => {
                if (foodCounts[type] && SYNTH_ITEMS[type].type === 'food') {
                    if (ETC_FOOD_TYPES.includes(type)) {
                        etcFoods.push([type, foodCounts[type]]);
                    } else {
                        synthFoods.push([type, foodCounts[type]]);
                    }
                }
            });

            const content = `
                <div class="modal-title">무엇을 먹일까요?</div>
                ${eventFoods.length > 0 ? `
                    <div style="font-weight: 600; margin-bottom: 10px; color: #c41e3a;">🎄 이벤트 먹이</div>
                    <div class="food-grid" style="margin-bottom: 15px;">
                        ${eventFoods.map(([type, count]) => {
                            const item = EVENT_ITEMS[type];
                            return `
                                <button class="option-btn" style="border: 2px solid #c41e3a;" onclick="feedSpiritFromInventory(${currentSpiritId}, '${type}')">
                                    <span class="option-icon">${item.icon}</span>
                                    <div class="option-info">
                                        <div class="option-name">${item.name} ×${count}</div>
                                        <div class="option-effect" style="color: #c41e3a;">모든 스탯+5, 성장+10</div>
                                    </div>
                                </button>
                            `;
                        }).join('')}
                    </div>
                ` : ''}
                ${synthFoods.length > 0 ? `
                    <div style="font-weight: 600; margin-bottom: 10px; color: #9b59b6;">🔬 합성 먹이</div>
                    <div class="food-grid" style="margin-bottom: 15px;">
                        ${synthFoods.map(([type, count]) => {
                            const item = SYNTH_ITEMS[type];
                            let effectText;
                            if (item.attr === 'all') {
                                effectText = `전속성+${item.attrGain}`;
                            } else if (item.attr === 'dual' && item.dualAttr) {
                                effectText = `${item.dualAttr.join('+')} 각+${item.attrGain}`;
                            } else {
                                effectText = `${item.attr}+${item.attrGain}`;
                            }
                            return `
                                <button class="option-btn" style="border: 2px solid #9b59b6;" onclick="feedSpiritFromInventory(${currentSpiritId}, '${type}')">
                                    <span class="option-icon">${item.icon}</span>
                                    <div class="option-info">
                                        <div class="option-name">${item.name} ×${count}</div>
                                        <div class="option-effect" style="color: #9b59b6;">${effectText}, 애정+${item.affectionGain}</div>
                                    </div>
                                </button>
                            `;
                        }).join('')}
                    </div>
                ` : ''}
                <div style="font-weight: 600; margin-bottom: 10px; color: var(--text);">🍎 먹이</div>
                <div class="food-grid">
                    ${medicineSection}
                    ${normalFoods.map(([type, count]) => {
                        const isRare = type === 'light' || type === 'dark';
                        const gain = isRare ? 2 : 1;
                        const growth = isRare ? 3 : 2;
                        return `
                            <button class="option-btn" onclick="feedSpiritFromInventory(${currentSpiritId}, '${type}')">
                                <span class="option-icon">${ENV_ICONS[type]}</span>
                                <div class="option-info">
                                    <div class="option-name">${FOOD_NAMES[type]} ×${count}</div>
                                    <div class="option-effect">${ENV_ICONS[type]}+${gain} 성장+${growth}</div>
                                </div>
                            </button>
                        `;
                    }).join('')}
                </div>
                ${etcFoods.length > 0 ? `
                    <div style="font-weight: 600; margin: 15px 0 10px 0; color: var(--text);">📦 기타</div>
                    <div class="food-grid">
                        ${etcFoods.map(([type, count]) => {
                            const item = SYNTH_ITEMS[type];
                            let effectText = item.desc.split('.')[0]; // 설명의 첫 문장만
                            return `
                                <button class="option-btn" onclick="feedSpiritFromInventory(${currentSpiritId}, '${type}')">
                                    <span class="option-icon">${item.icon}</span>
                                    <div class="option-info">
                                        <div class="option-name">${item.name} ×${count}</div>
                                        <div class="option-effect">${effectText}</div>
                                    </div>
                                </button>
                            `;
                        }).join('')}
                    </div>
                ` : ''}
                <button class="close-btn" onclick="closeModal('feedModal')">닫기</button>
            `;
            modal.querySelector('.modal-content').innerHTML = content;
        }
        
        function giveMedicineFromModal(spiritId) {
            giveMedicine(spiritId);
            closeModal('feedModal');
        }

        function feedSpiritFromInventory(spiritId, foodType) {
            if (isPaused) {
                showNotification('게임이 일시정지 상태입니다');
                return;
            }
            
            const spirit = spirits.find(s => s.id === spiritId);
            if (!spirit) return;
            
            // 불만 상태가 10분 이상 지속되면 거부
            if (isSpiritRefusing(spiritId)) {
                spirit.status = getRefusalMessage(spirit.name, 'feed');
                addLog(spirit, spirit.status);
                closeModal('feedModal');
                renderSpirits();
                showNotification('😢 정령이 먹이를 거부합니다...');
                return;
            }

            if (!inventory.food) inventory.food = [];
            const foodIndex = inventory.food.indexOf(foodType);
            if (foodIndex === -1) {
                showNotification('먹이가 없습니다');
                return;
            }

            // 아카시아꿀, 수선화 꽃잎은 알/번데기 상태에서 사용 불가 (아이템 소모 전에 체크!)
            if (foodType === 'acacia_honey' || foodType === 'reconciliation_flower') {
                const stage = getStage(spirit.growth);
                if (stage === 'egg' || stage === 'pupa') {
                    const itemName = foodType === 'acacia_honey' ? '아카시아 꿀' : '수선화 꽃잎';
                    const stageKorean = stage === 'egg' ? '알' : '번데기';
                    showNotification(`❌ ${stageKorean} 상태에서는 ${itemName} 사용이 불가능합니다`);
                    return;
                }
            }

            // 수선화 꽃잎은 앙숙 관계가 있는 정령에게만 사용 가능 (아이템 소모 전에 체크!)
            if (foodType === 'reconciliation_flower') {
                const hasRival = spirit.relationships && Object.values(spirit.relationships).some(rel => rel < 0);
                if (!hasRival) {
                    showNotification('❌ 앙숙 관계인 정령에게만 사용할 수 있습니다');
                    return;
                }
            }

            // 먹이 소모
            inventory.food.splice(foodIndex, 1);

            // 이벤트 먹이 체크
            const eventItem = EVENT_ITEMS[foodType];
            if (eventItem && eventItem.type === 'food') {
                // 이벤트 먹이 효과 적용
                const effects = eventItem.effects;
                spirit.parameters.intelligence = Math.min(100, spirit.parameters.intelligence + (effects.intelligence || 0));
                spirit.parameters.strength = Math.min(100, spirit.parameters.strength + (effects.strength || 0));
                spirit.parameters.charm = Math.min(100, spirit.parameters.charm + (effects.charm || 0));
                // 질병 상태가 아닐 때만 성장
                if (!spirit.isSick) {
                    spirit.growth += effects.growth || 0;
                }
                spirit.parameters.affection += 3;
                
                spirit.lastFeed = Date.now();
                spirit.lastFed = Date.now();
                spirit.lastInteraction = Date.now();
                spirit.status = '특별한 음식을 먹었습니다!';
                
                if (!spirit.feedCount) spirit.feedCount = 0;
                spirit.feedCount += 1;
                
                addLog(spirit, `🎄 ${eventItem.name}을(를) 먹었습니다!`);
                addLog(spirit, '모든 능력이 크게 올랐습니다!');
                
                if (spirit.growth >= STAGE_REQUIREMENTS.adult && !spirit.isCompleted) {
                    completeSpirit(spirit);
                }
                
                closeModal('feedModal');
                saveGame();
                renderSpirits();
                renderInventory();
                showNotification(`${eventItem.icon} ${eventItem.name}을(를) 주었습니다! (모든 스탯 +5, 성장 +10)`);
                return;
            }
            
            // 합성 먹이 체크
            const synthItem = SYNTH_ITEMS[foodType];
            if (synthItem && synthItem.type === 'food') {
                // 합성 먹이 효과 적용
                if (!spirit.hiddenAttributes) {
                    spirit.hiddenAttributes = { fire: 0, water: 0, wind: 0, earth: 0, light: 0, dark: 0 };
                }
                
                // 속성 증가
                if (synthItem.attr === 'all') {
                    // 전체 속성 증가
                    Object.keys(spirit.hiddenAttributes).forEach(attr => {
                        spirit.hiddenAttributes[attr] = Math.min(500, spirit.hiddenAttributes[attr] + synthItem.attrGain);
                    });
                } else if (synthItem.attr === 'dual' && synthItem.dualAttr) {
                    // 혼합 속성 증가 (두 속성 모두)
                    synthItem.dualAttr.forEach(attr => {
                        spirit.hiddenAttributes[attr] = Math.min(500, spirit.hiddenAttributes[attr] + synthItem.attrGain);
                    });
                } else if (synthItem.attr === 'special') {
                    // 특수 먹이 (속성 증가 없음)
                } else {
                    spirit.hiddenAttributes[synthItem.attr] = Math.min(500, spirit.hiddenAttributes[synthItem.attr] + synthItem.attrGain);
                }
                
                // 애정도 증가
                spirit.parameters.affection += synthItem.affectionGain || 0;
                
                // 질병 상태가 아닐 때만 성장 (음수 성장도 허용, 단 0 미만으로는 안 내려감)
                if (!spirit.isSick) {
                    spirit.growth = Math.max(0, spirit.growth + (synthItem.growthGain || 0));
                }
                
                spirit.lastFeed = Date.now();
                spirit.lastFed = Date.now();
                spirit.lastInteraction = Date.now();
                spirit.status = '특별한 음식을 먹었습니다!';
                
                if (!spirit.feedCount) spirit.feedCount = 0;
                spirit.feedCount += 1;
                
                // 수선화 꽃잎 특수 효과 (앙숙 전용 - 싸움 방지)
                if (foodType === 'reconciliation_flower' && synthItem.effectDuration) {
                    spirit.reconciliationUntil = Date.now() + synthItem.effectDuration;
                    addLog(spirit, `${synthItem.icon} ${synthItem.name}을(를) 먹었습니다!`);
                    addLog(spirit, `🌼 30분간 다른 정령과 싸우지 않습니다!`);
                // 아카시아 꿀 특수 효과 (친밀도 증가)
                } else if (foodType === 'acacia_honey' && synthItem.effectDuration) {
                    spirit.acaciaHoneyUntil = Date.now() + synthItem.effectDuration;
                    addLog(spirit, `${synthItem.icon} ${synthItem.name}을(를) 먹었습니다!`);
                    addLog(spirit, `🍯 30분간 다른 정령과 빠르게 친해집니다!`);
                } else {
                    addLog(spirit, `${synthItem.icon} ${synthItem.name}을(를) 먹었습니다!`);
                }
                
                if (spirit.growth >= STAGE_REQUIREMENTS.adult && !spirit.isCompleted) {
                    completeSpirit(spirit);
                }
                
                closeModal('feedModal');
                saveGame();
                renderSpirits();
                renderInventory();
                
                let effectMsg;
                if (synthItem.attr === 'all') {
                    effectMsg = `전속성 +${synthItem.attrGain}`;
                } else if (synthItem.attr === 'dual' && synthItem.dualAttr) {
                    effectMsg = `${synthItem.dualAttr.join('+')} 각 +${synthItem.attrGain}`;
                } else if (synthItem.attr === 'special') {
                    if (foodType === 'reconciliation_flower') {
                        effectMsg = '30분간 화해 효과';
                    } else if (foodType === 'acacia_honey') {
                        effectMsg = '30분간 친밀 효과';
                    } else {
                        effectMsg = '특수 효과';
                    }
                } else {
                    effectMsg = `${synthItem.attr} +${synthItem.attrGain}`;
                }
                const growthText = synthItem.growthGain ? `, 성장 ${synthItem.growthGain > 0 ? '+' : ''}${synthItem.growthGain}` : '';
                showNotification(`${synthItem.icon} ${synthItem.name}을(를) 주었습니다! (${effectMsg}, 애정도 +${synthItem.affectionGain}${growthText})`);
                return;
            }

            const isRare = foodType === 'light' || foodType === 'dark';
            const attrGain = isRare ? 6 : 3;  // 희귀 +6, 일반 +3
            const growthGain = isRare ? 3 : 2;

            // 정령의 숨겨진 속성 증가
            if (!spirit.hiddenAttributes) {
                spirit.hiddenAttributes = {
                    fire: 0, water: 0, wind: 0, earth: 0, light: 0, dark: 0
                };
            }
            spirit.hiddenAttributes[foodType] = Math.min(500, spirit.hiddenAttributes[foodType] + attrGain);

            // 질병 상태가 아닐 때만 성장
            if (!spirit.isSick) {
                spirit.growth += growthGain;
            }
            spirit.lastFeed = Date.now();
            spirit.lastFed = Date.now();  // 배고픔 체크용
            spirit.lastInteraction = Date.now();  // 상호작용 시간 업데이트
            spirit.status = '맛있게 먹었습니다!';
            spirit.parameters.affection += 1;
            
            // 먹이 횟수 증가
            if (!spirit.feedCount) spirit.feedCount = 0;
            spirit.feedCount += 1;

            // 일지 추가
            addLog(spirit, `${FOOD_NAMES[foodType]}를 먹었습니다`);
            addLog(spirit, '맛있게 먹었습니다!');

            // 성충 체크 (100 이상이면 무조건 완료)
            if (spirit.growth >= STAGE_REQUIREMENTS.adult && !spirit.isCompleted) {
                completeSpirit(spirit);
            }

            closeModal('feedModal');
            saveGame();
            renderSpirits();  // 전체 렌더링으로 쿨타임 표시 업데이트
            renderInventory();
            showNotification(`${ENV_ICONS[foodType]} ${FOOD_NAMES[foodType]} 을(를) 주었습니다`);
            
            // 튜토리얼 체크
            checkTutorialAction('feed');
            
            // 속성 불균형 튜토리얼 체크
            checkImbalanceAndTutorial(spirit);
        }

        function openMusicModal(spiritId) {
            const spirit = spirits.find(s => s.id === spiritId);
            if (!canDoAction(spirit, 'music')) {
                showNotification('아직 음악을 듣고 있습니다');
                return;
            }
            if (inventory.music.length === 0) {
                showNotification('보유한 음악이 없습니다. 채집을 해보세요!');
                return;
            }
            currentSpiritId = spiritId;
            renderMusicOptions();
            document.getElementById('musicModal').classList.add('active');
        }

        function renderMusicOptions() {
            const container = document.getElementById('musicOptions');
            
            // 음악 개수 세기
            const musicCounts = {};
            inventory.music.forEach(m => {
                musicCounts[m] = (musicCounts[m] || 0) + 1;
            });
            
            // 이벤트 음악과 일반 음악 분리 (고정 순서)
            const eventMusic = [];
            const normalMusic = [];
            
            // 일반 음악 순서
            const musicOrder = ['classic', 'jazz', 'rock', 'pop', 'ballad', 'edm'];
            musicOrder.forEach(type => {
                if (musicCounts[type]) {
                    normalMusic.push([type, musicCounts[type]]);
                }
            });
            
            // 이벤트 음악 (이벤트 아이템 키 순서대로)
            Object.keys(EVENT_ITEMS).forEach(type => {
                if (musicCounts[type] && EVENT_ITEMS[type].type === 'music') {
                    eventMusic.push([type, musicCounts[type]]);
                }
            });
            
            // 이벤트 음악 HTML
            const eventMusicHTML = eventMusic.map(([type, count]) => {
                const item = EVENT_ITEMS[type];
                return `
                    <button class="option-btn" style="border: 2px solid #c41e3a;" onclick="playMusicByType('${type}')">
                        <span class="option-icon">${item.icon}</span>
                        <div class="option-info">
                            <div class="option-name">${item.name} ×${count}</div>
                            <div class="option-effect" style="color: #c41e3a;">애정도+10, 매력+5</div>
                        </div>
                    </button>
                `;
            }).join('');
            
            // 일반 음악 HTML
            const musicHTML = normalMusic.map(([type, count]) => {
                const musicData = MUSIC_TYPES[type];
                return `
                    <button class="option-btn" onclick="playMusicByType('${type}')">
                        <span class="option-icon">${musicData.icon}</span>
                        <div class="option-info">
                            <div class="option-name">${musicData.name} ×${count}</div>
                            <div class="option-effect">${musicData.effect}</div>
                        </div>
                    </button>
                `;
            }).join('');
            
            let html = '<div class="music-grid">';
            if (eventMusicHTML) {
                html += `<div style="width: 100%; font-weight: 600; color: #c41e3a; margin-bottom: 10px;">🎄 이벤트 음악</div>`;
                html += eventMusicHTML;
                if (musicHTML) {
                    html += `<div style="width: 100%; font-weight: 600; color: var(--text); margin: 15px 0 10px;">🎵 일반 음악</div>`;
                }
            }
            html += musicHTML + '</div>';
            container.innerHTML = html;
        }

        function playMusicByType(musicType) {
            const spiritId = currentSpiritId;
            
            // 해당 타입의 음악 찾기
            const musicIndex = inventory.music.indexOf(musicType);
            if (musicIndex === -1) {
                showNotification('해당 음악이 없습니다');
                return;
            }
            
            // 기존 playMusic 함수 호출
            playMusic(spiritId, musicType, musicIndex);
        }

        function playMusic(spiritId, musicType, inventoryIndex) {
            if (isPaused) {
                showNotification('게임이 일시정지 상태입니다');
                return;
            }
            
            const spirit = spirits.find(s => s.id === spiritId);
            if (!spirit) return;

            // 이벤트 음악 체크
            const eventItem = EVENT_ITEMS[musicType];
            if (eventItem && eventItem.type === 'music') {
                const effects = eventItem.effects;
                spirit.parameters.affection += effects.affection || 0;
                spirit.parameters.charm = Math.min(100, spirit.parameters.charm + (effects.charm || 0));
                
                spirit.lastMusic = Date.now();
                spirit.lastInteraction = Date.now();
                spirit.lastMusicType = musicType;
                
                if (!spirit.musicListened) spirit.musicListened = 0;
                spirit.musicListened += 1;
                
                // 성장 단계별 이벤트 음악 대사
                const eventStage = getStage(spirit.growth);
                if (eventStage === 'egg') {
                    spirit.status = `${spirit.name}에서 크리스마스 캐롤에 반응하는 따뜻한 진동이 느껴집니다.`;
                } else if (eventStage === 'pupa') {
                    spirit.status = `${spirit.name}이(가) 크리스마스 캐롤에 미세하게 꿈틀거립니다.`;
                } else {
                    spirit.status = `${spirit.name}이(가) 크리스마스 캐롤에 맞춰 행복해합니다!`;
                }
                addLog(spirit, `🎄 ${eventItem.name}을(를) 들었습니다!`);
                
                inventory.music.splice(inventoryIndex, 1);
                
                closeModal('musicModal');
                saveGame();
                renderSpirits();
                renderInventory();
                showNotification(`${eventItem.icon} ${eventItem.name}을(를) 들려주었습니다! (애정도 +10, 매력 +5)`);
                return;
            }

            const musicData = MUSIC_TYPES[musicType];
            
            // 만족도 즉시 계산
            spirit.satisfaction = calculateSatisfaction(spirit);
            const singleStatBonus = spirit.satisfaction === 'high' ? 2 : 0; // 단일 스탯 +2
            const dualStatBonus = spirit.satisfaction === 'high' ? 1 : 0;   // 복수 스탯 각 +1
            
            // 지력 50 이상이면 "똑똑한" 효과: 모든 스탯 보너스 +2
            const smartBonus = spirit.parameters.intelligence >= 50 ? 2 : 0;
            
            // 효과 적용 (만족도 높으면 보너스 + 똑똑한 보너스)
            if (musicType === 'classic') {
                spirit.parameters.intelligence = Math.min(100, spirit.parameters.intelligence + 10 + singleStatBonus + smartBonus);
            } else if (musicType === 'jazz') {
                spirit.parameters.charm = Math.min(100, spirit.parameters.charm + 10 + singleStatBonus + smartBonus);
            } else if (musicType === 'rock') {
                spirit.parameters.strength = Math.min(100, spirit.parameters.strength + 10 + singleStatBonus + smartBonus);
            } else if (musicType === 'pop') {
                spirit.parameters.intelligence = Math.min(100, spirit.parameters.intelligence + 5 + dualStatBonus + smartBonus);
                spirit.parameters.charm = Math.min(100, spirit.parameters.charm + 5 + dualStatBonus + smartBonus);
            } else if (musicType === 'ballad') {
                spirit.parameters.strength = Math.min(100, spirit.parameters.strength + 5 + dualStatBonus + smartBonus);
                spirit.parameters.charm = Math.min(100, spirit.parameters.charm + 5 + dualStatBonus + smartBonus);
            } else if (musicType === 'edm') {
                spirit.parameters.intelligence = Math.min(100, spirit.parameters.intelligence + 5 + dualStatBonus + smartBonus);
                spirit.parameters.strength = Math.min(100, spirit.parameters.strength + 5 + dualStatBonus + smartBonus);
            }

            // 애정도 증가 (만족도 높으면 +1 보너스)
            const affectionBonus = spirit.satisfaction === 'high' ? 3 : 2;
            spirit.parameters.affection += affectionBonus;

            spirit.lastMusic = Date.now();
            spirit.lastInteraction = Date.now();  // 상호작용 시간 업데이트
            spirit.lastMusicType = musicType; // 마지막으로 들은 음악 저장
            
            // 음악 청취 횟수 증가
            if (!spirit.musicListened) spirit.musicListened = 0;
            spirit.musicListened += 1;
            
            // 성장 단계 확인
            const stage = getStage(spirit.growth);
            const isEgg = stage === 'egg';
            const isPupaStage = stage === 'pupa';
            
            // 음악 관련 랜덤 메시지 (성장 단계별)
            let musicMessages = [];
            
            if (isEgg) {
                // 알 상태 음악 반응
                musicMessages = [
                    `${spirit.name}에서 음악에 반응하는 진동이 느껴집니다.`,
                    `${spirit.name}이(가) ${musicData.name}의 선율에 미세하게 떨립니다.`,
                    `${spirit.name}의 껍질이 음악에 맞춰 희미하게 빛납니다.`,
                    `${spirit.name} 안에서 음악을 좋아하는 것 같은 기운이 느껴집니다.`,
                    `${spirit.name}이(가) ${musicData.name}을(를) 듣고 평온해 보입니다.`
                ];
            } else if (isPupaStage) {
                // 번데기 상태 음악 반응
                musicMessages = [
                    `${spirit.name}에서 음악에 반응하는 약한 진동이 느껴집니다.`,
                    `${spirit.name}이(가) ${musicData.name}의 선율에 미세하게 꿈틀거립니다.`,
                    `${spirit.name}의 껍질이 음악에 맞춰 살짝 떨립니다.`,
                    `${spirit.name} 안에서 음악을 즐기는 것 같은 기운이 느껴집니다.`,
                    `${spirit.name}이(가) ${musicData.name}을(를) 들으며 변태를 준비합니다.`
                ];
            } else {
                // 애벌레 상태 음악 반응 (기존)
                musicMessages = [
                    `${spirit.name}이(가) ${musicData.name}을(를) 흥얼거립니다.`,
                    `${spirit.name}이(가) ${musicData.name}에 맞춰 춤을 춥니다.`,
                    `${spirit.name}이(가) ${musicData.name}의 선율을 떠올립니다.`,
                    `${spirit.name}이(가) 음악에 취해 있습니다.`,
                    `${spirit.name}이(가) ${musicData.name}의 여운에 젖어 있습니다.`
                ];
            }
            spirit.status = musicMessages[Math.floor(Math.random() * musicMessages.length)];

            // 일지 추가
            addLog(spirit, `${musicData.name}을(를) 들었습니다`);

            // 음악 소모
            inventory.music.splice(inventoryIndex, 1);

            closeModal('musicModal');
            saveGame();
            renderSpirits();  // 전체 렌더링으로 쿨타임 표시 업데이트
            renderInventory();
            const bonusText = spirit.satisfaction === 'high' ? ' (만족 보너스!)' : '';
            showNotification(`${musicData.name}을(를) 들려주었습니다${bonusText}`);
            
            // 튜토리얼 체크
            checkTutorialAction('music');
        }

        function patSpirit(spiritId) {
            if (isPaused) {
                showNotification('게임이 일시정지 상태입니다');
                return;
            }
            
            const spirit = spirits.find(s => s.id === spiritId);
            if (!spirit) return;
            
            // 불만 상태가 10분 이상 지속되면 거부
            if (isSpiritRefusing(spiritId)) {
                spirit.status = getRefusalMessage(spirit.name, 'pet');
                addLog(spirit, spirit.status);
                renderSpirits();
                showNotification('😢 정령이 쓰다듬기를 거부합니다...');
                return;
            }

            if (!canDoAction(spirit, 'pat')) {
                showNotification('아직 쓰다듬을 수 없습니다');
                return;
            }

            // 만족도 즉시 계산
            spirit.satisfaction = calculateSatisfaction(spirit);
            
            const currentAffection = spirit.parameters.affection || 0;
            const affectionBonus = spirit.satisfaction === 'high' ? 2 : 1;
            spirit.parameters.affection += affectionBonus;
            spirit.lastPat = Date.now();
            spirit.lastInteraction = Date.now();  // 상호작용 시간 업데이트
            
            // 성장 단계 확인
            const stage = getStage(spirit.growth);
            const isEgg = stage === 'egg';
            const isPupaStage = stage === 'pupa';
            
            // 애정도에 따른 반응 메시지
            let messages = [];
            let notificationEmoji = '';
            
            // 알 상태 대사
            if (isEgg) {
                if (currentAffection < 10) {
                    messages = [
                        `${spirit.name}에서 차가운 기운이 느껴집니다.`,
                        `${spirit.name}이(가) 아직 낯선 온기에 적응 중입니다.`,
                        `${spirit.name}의 껍질이 살짝 떨립니다.`
                    ];
                    notificationEmoji = '😟';
                } else if (currentAffection < 50) {
                    messages = [
                        `${spirit.name}에서 따뜻한 기운이 느껴집니다.`,
                        `${spirit.name}이(가) 당신의 온기를 좋아하는 것 같습니다.`,
                        `${spirit.name}의 껍질에서 미세한 진동이 느껴집니다.`
                    ];
                    notificationEmoji = '😊';
                } else {
                    messages = [
                        `${spirit.name}에서 행복한 기운이 전해집니다.`,
                        `${spirit.name}이(가) 당신의 손길에 반응합니다.`,
                        `${spirit.name} 안에서 무언가 기뻐하는 것 같습니다.`,
                        `${spirit.name}이(가) 포근한 온기에 만족해합니다.`
                    ];
                    notificationEmoji = '🥰';
                }
            }
            // 번데기 상태 대사
            else if (isPupaStage) {
                if (currentAffection < 10) {
                    messages = [
                        `${spirit.name}에서 미약한 반응이 느껴집니다.`,
                        `${spirit.name}이(가) 아직 당신의 손길에 익숙하지 않은 것 같습니다.`,
                        `${spirit.name}의 껍질이 살짝 경직됩니다.`
                    ];
                    notificationEmoji = '😟';
                } else if (currentAffection < 50) {
                    messages = [
                        `${spirit.name}에서 따뜻한 진동이 느껴집니다.`,
                        `${spirit.name}이(가) 당신의 손길에 편안해하는 것 같습니다.`,
                        `${spirit.name}의 껍질이 부드럽게 반응합니다.`
                    ];
                    notificationEmoji = '😊';
                } else {
                    messages = [
                        `${spirit.name}에서 행복한 진동이 전해집니다.`,
                        `${spirit.name}이(가) 당신의 손길을 기다렸던 것 같습니다.`,
                        `${spirit.name} 안에서 기쁨이 느껴집니다.`,
                        `${spirit.name}이(가) 당신의 사랑을 느끼고 있습니다.`
                    ];
                    notificationEmoji = '🥰';
                }
            }
            // 애벌레 상태 대사 (기존)
            else if (currentAffection < 10) {
                // 낯설어함, 경계함
                messages = [
                    `${spirit.name}이(가) 당신을 낯설어합니다...`,
                    `${spirit.name}이(가) 경계하며 물러섭니다`,
                    `${spirit.name}이(가) 조심스럽게 바라봅니다`,
                    `${spirit.name}이(가) 당신의 손길을 두려워합니다`,
                    `${spirit.name}이(가) 불안해하며 몸을 움츠립니다`,
                    `${spirit.name}이(가) 당신이 누구인지 궁금해합니다`,
                    `${spirit.name}이(가) 천천히 다가옵니다...`
                ];
                notificationEmoji = '😟';
            } else if (currentAffection < 50) {
                // 익숙해짐
                messages = [
                    `${spirit.name}이(가) 당신에게 익숙해졌습니다`,
                    `${spirit.name}이(가) 편안해 보입니다`,
                    `${spirit.name}이(가) 당신의 손길을 받아들입니다`,
                    `${spirit.name}이(가) 조금씩 마음을 엽니다`,
                    `${spirit.name}이(가) 당신을 신뢰하기 시작합니다`,
                    `${spirit.name}이(가) 기분이 좋아 보입니다`,
                    `${spirit.name}이(가) 당신 곁에 머뭅니다`
                ];
                notificationEmoji = '😊';
            } else {
                // 친해짐, 잘 따름
                messages = [
                    `${spirit.name}이(가) 당신을 무척 좋아합니다!`,
                    `${spirit.name}이(가) 당신을 따라다닙니다`,
                    `${spirit.name}이(가) 행복하게 당신을 바라봅니다`,
                    `${spirit.name}이(가) 당신에게 애교를 부립니다`,
                    `${spirit.name}이(가) 당신의 손을 비빕니다`,
                    `${spirit.name}이(가) 기뻐하며 펄쩍 뜁니다!`,
                    `${spirit.name}이(가) 당신 곁을 떠나지 않으려 합니다`,
                    `${spirit.name}이(가) 당신의 사랑을 온몸으로 느낍니다`
                ];
                notificationEmoji = '🥰';
            }
            
            spirit.status = messages[Math.floor(Math.random() * messages.length)];

            // 일지 추가
            addLog(spirit, '쓰다듬었습니다');
            addLog(spirit, spirit.status);

            saveGame();
            renderSpirits();  // 전체 렌더링으로 쿨타임 표시 업데이트
            const bonusText = spirit.satisfaction === 'high' ? ' (만족 보너스!)' : '';
            showNotification(`쓰다듬었습니다 (애정 +${affectionBonus}${bonusText})`);
            
            // 튜토리얼 체크
            checkTutorialAction('pat');
        }
        
        // 약 먹이기 함수
        function giveMedicine(spiritId) {
            if (isPaused) {
                showNotification('게임이 일시정지 상태입니다');
                return;
            }
            
            const spirit = spirits.find(s => s.id === spiritId);
            if (!spirit) return;
            
            if (!spirit.isSick) {
                showNotification('이 정령은 건강합니다');
                return;
            }
            
            if (!inventory.food) inventory.food = [];
            const medicineIndex = inventory.food.indexOf('medicine');
            if (medicineIndex === -1) {
                showNotification('약초가 없습니다. 상점에서 구매하세요!');
                return;
            }
            
            // 약초 소모
            inventory.food.splice(medicineIndex, 1);
            
            // 병 치료
            spirit.isSick = false;
            spirit.sickWarned = false;
            delete spirit.sickTime;
            spirit.lastInteraction = Date.now(); // 상호작용 시간 업데이트
            
            const healMessages = [
                `${spirit.name}이(가) 약초를 먹고 건강해졌습니다! 💚`,
                `${spirit.name}의 병이 완전히 나았습니다!`,
                `${spirit.name}이(가) 활기를 되찾았습니다! 🌟`,
                `${spirit.name}이(가) 당신의 보살핌에 감사합니다`
            ];
            
            spirit.status = healMessages[Math.floor(Math.random() * healMessages.length)];
            
            // 일지 추가
            addLog(spirit, '약초를 먹고 건강해졌습니다');
            addLog(spirit, spirit.status);
            
            // 질병 튜토리얼: 약초 사용 액션 체크
            checkSickTutorialAction('useMedicine');
            
            saveGame();
            updateSpiritCard(spirit);
            renderInventory();
            showNotification(`${spirit.name}의 병이 나았습니다!`);
        }

        let inventoryCollapsed = localStorage.getItem('inventoryCollapsed') === 'true';
        
        function toggleInventoryCollapse() {
            inventoryCollapsed = !inventoryCollapsed;
            localStorage.setItem('inventoryCollapsed', inventoryCollapsed);
            updateInventoryCollapseUI();
        }
        
        function updateInventoryCollapseUI() {
            const content = document.getElementById('inventoryContent');
            const icon = document.getElementById('inventoryToggleIcon');
            
            if (content) {
                content.style.display = inventoryCollapsed ? 'none' : 'block';
            }
            if (icon) {
                icon.textContent = inventoryCollapsed ? '▶' : '▼';
            }
        }

        function changeTitle() {
            const select = document.getElementById('titleSelect');
            currentTitle = select.value;
            
            const titleNames = {
                'none': '자동채집',
                'hawk_eye': '🦅 매의 눈',
                'gatherer': '🍎 채집꾼',
                'musician': '음악가',
                'collector': '💎 수집가'
            };
            
            // 자동 채집 상태 업데이트
            if (currentTitle === 'none') {
                showNotification(`칭호를 ${titleNames[currentTitle]}(으)로 변경했습니다`);
            } else {
                showNotification(`칭호를 ${titleNames[currentTitle]}(으)로 변경했습니다`);
            }
            
            updateGatherButton();
            saveGame();
        }
        
        function changeShopCategory() {
            const select = document.getElementById('shopCategorySelect');
            currentShopCategory = select.value;
            renderShop();
        }

        function changeGatherLocation() {
            const select = document.getElementById('gatherLocationSelect');
            currentGatherLocation = select.value;
            saveGame();
            
            const locationNames = {
                garden: '🌸 정원',
                lake: '🌊 호수',
                forest: '🌲 숲'
            };
            showNotification(`채집 장소를 ${locationNames[currentGatherLocation]}(으)로 변경했습니다`);
        }

        function goGather() {
            if (isPaused) {
                showNotification('게임이 일시정지 상태입니다');
                return;
            }
            
            const now = Date.now();
            const gatherCooldown = 15000; // 15초

            // 쿨다운 체크
            if (lastGatherTime && (now - lastGatherTime < gatherCooldown)) {
                const remainingTime = Math.ceil((gatherCooldown - (now - lastGatherTime)) / 1000);
                showNotification(`${remainingTime}초 후에 다시 채집할 수 있습니다`);
                return;
            }
            
            // 선택된 장소에서 바로 채집
            gatherAtLocation(currentGatherLocation);
        }
        
        function gatherAtLocation(location, isAuto = false) {
            const now = Date.now();

            if (!inventory.food) inventory.food = [];
            if (!inventory.music) inventory.music = [];
            if (!inventory.decorations) inventory.decorations = [];

            const discoveries = [];
            
            // 자동 채집일 경우 확률 0.5배, 아닐 경우 1.0배
            const autoGatherMultiplier = isAuto ? 0.5 : 1.0;
            
            // 칭호별 확률 보너스
            const titleBonus = {
                hawk_eye: 1.5,    // 매의 눈: 모든 확률 1.5배
                gatherer: 1.0,    // 채집꾼: 먹이만 2배 (아래서 따로 처리)
                musician: 1.0,    // 음악가: 레코드만 2배 (아래서 따로 처리)
                collector: 1.0    // 수집가: 테라리움만 2배 (아래서 따로 처리)
            };
            
            const baseBonus = currentTitle !== 'none' && titleBonus[currentTitle] ? titleBonus[currentTitle] : 1.0;
            const foodBonus = currentTitle === 'gatherer' ? 2.0 : baseBonus;
            
            // 장소별 먹이 타입
            let locationFoodTypes = [];
            let locationDecoTypes = [];
            
            if (location === 'garden') {
                locationFoodTypes = ['fire', 'water', 'wind', 'earth'];  // 정원: 모든 기본 속성
                locationDecoTypes = ['fire', 'water', 'wind', 'earth'];
            } else if (location === 'lake') {
                locationFoodTypes = ['water', 'wind'];  // 호수: 물, 바람
                locationDecoTypes = ['water', 'wind'];
            } else if (location === 'forest') {
                locationFoodTypes = ['earth', 'fire'];  // 숲: 땅, 불
                locationDecoTypes = ['earth', 'fire'];
            }
            
            // 80% 확률로 일반 먹이 발견 (장소 고정)
            if (Math.random() < (0.8 * foodBonus * autoGatherMultiplier)) {
                const randomFood = locationFoodTypes[Math.floor(Math.random() * locationFoodTypes.length)];
                inventory.food.push(randomFood);
                discoveries.push(`🍎 ${FOOD_NAMES[randomFood]}`);
            }

            // 40% 확률로 희귀 먹이 발견 (빛암)
            if (Math.random() < (0.4 * foodBonus * autoGatherMultiplier)) {
                const rareFoodTypes = ['light', 'dark'];
                const randomRareFood = rareFoodTypes[Math.floor(Math.random() * rareFoodTypes.length)];
                inventory.food.push(randomRareFood);
                discoveries.push(`${FOOD_NAMES[randomRareFood]}`);
            }

            // 미니어처 채집 (장소별 + 등급별 확률)
            const decoBonus = currentTitle === 'collector' ? 2.0 : baseBonus;
            
            // 합성 전용 미니어처 목록 (채집 불가)
            const synthOnlyDecos = ['flame_lamp', 'aqua_fountain', 'wind_chime', 'earth_statue', 'light_orb', 'shadow_crystal'];
            
            // 50% 확률로 일반(common) 미니어처 (장소 고정)
            if (Math.random() < (0.5 * decoBonus * autoGatherMultiplier)) {
                const commonDecos = Object.keys(DECORATION_TYPES).filter(key => {
                    const deco = DECORATION_TYPES[key];
                    return deco.quality === 'common' && locationDecoTypes.includes(deco.attr) && !synthOnlyDecos.includes(key);
                });
                if (commonDecos.length > 0) {
                    const randomDeco = commonDecos[Math.floor(Math.random() * commonDecos.length)];
                    inventory.decorations.push(randomDeco);
                    discoveries.push(`${DECORATION_TYPES[randomDeco].icon} ${DECORATION_TYPES[randomDeco].name}`);
                }
            }
            
            // 20% 확률로 희귀(rare) 미니어처 (장소 고정)
            if (Math.random() < (0.2 * decoBonus * autoGatherMultiplier)) {
                const rareDecos = Object.keys(DECORATION_TYPES).filter(key => {
                    const deco = DECORATION_TYPES[key];
                    return deco.quality === 'rare' && locationDecoTypes.includes(deco.attr) && !synthOnlyDecos.includes(key);
                });
                if (rareDecos.length > 0) {
                    const randomDeco = rareDecos[Math.floor(Math.random() * rareDecos.length)];
                    inventory.decorations.push(randomDeco);
                    discoveries.push(`${DECORATION_TYPES[randomDeco].icon} ${DECORATION_TYPES[randomDeco].name}`);
                }
            }
            
            // 8% 확률로 최상급(epic) 미니어처 (장소 고정) - 자동 채집에서는 제외
            if (!isAuto && Math.random() < (0.08 * decoBonus)) {
                const epicDecos = Object.keys(DECORATION_TYPES).filter(key => {
                    const deco = DECORATION_TYPES[key];
                    return deco.quality === 'epic' && locationDecoTypes.includes(deco.attr) && !synthOnlyDecos.includes(key);
                });
                if (epicDecos.length > 0) {
                    const randomDeco = epicDecos[Math.floor(Math.random() * epicDecos.length)];
                    inventory.decorations.push(randomDeco);
                    discoveries.push(`${DECORATION_TYPES[randomDeco].icon} ${DECORATION_TYPES[randomDeco].name} (최상급!)`);
                }
            }

            // 15% 확률로 음악 레코드 발견
            const musicBonus = currentTitle === 'musician' ? 2.0 : baseBonus;
            if (Math.random() < (0.15 * musicBonus * autoGatherMultiplier)) {
                const musicKeys = Object.keys(MUSIC_TYPES);
                const randomMusic = musicKeys[Math.floor(Math.random() * musicKeys.length)];
                inventory.music.push(randomMusic);
                discoveries.push(`${MUSIC_TYPES[randomMusic].name}`);
            }

            if (discoveries.length === 0) {
                if (!isAuto) {
                    showNotification('아무것도 발견하지 못했습니다...');
                }
            } else {
                const locationNames = { garden: '🌸 정원', lake: '🌊 호수', forest: '🌲 숲' };
                if (isAuto) {
                    showNotification(`자동 채집: ${discoveries.join(', ')}`);
                } else {
                    showNotification(`${locationNames[location]} 채집: ${discoveries.join(', ')}`);
                }
            }

            lastGatherTime = now;
            saveGame();
            renderInventory();
            updateGatherButton();
            
            // 연구실 튜토리얼 체크
            checkInventoryAndLabTutorial();
        }
        
        // 자동 채집 (칭호 없음일 때만 작동)
        let autoGatherInterval = null;
        
        function startAutoGather() {
            if (autoGatherInterval) {
                clearInterval(autoGatherInterval);
            }
            
            autoGatherInterval = setInterval(() => {
                // 칭호가 없음(none)일 때만 자동 채집
                if (currentTitle !== 'none') return;
                
                // 일시정지 상태면 스킵
                if (isPaused) return;
                
                // 자동 채집 실행
                gatherAtLocation(currentGatherLocation, true);
            }, 15000); // 15초마다
        }
        
        function stopAutoGather() {
            if (autoGatherInterval) {
                clearInterval(autoGatherInterval);
                autoGatherInterval = null;
            }
        }

        function updateGatherButton() {
            const gatherBtn = document.querySelector('.walk-btn');
            if (!gatherBtn) return;

            const now = Date.now();
            const gatherCooldown = 15000; // 15초
            
            // 자동 채집 활성화 여부
            const isAutoGatherActive = currentTitle === 'none';
            
            // 일시정지 중이면 버튼 비활성화
            if (isPaused) {
                gatherBtn.disabled = true;
                gatherBtn.textContent = '채집하기 (일시정지)';
                return;
            }

            if (lastGatherTime && (now - lastGatherTime < gatherCooldown)) {
                gatherBtn.disabled = true;
                const remainingTime = Math.ceil((gatherCooldown - (now - lastGatherTime)) / 1000);
                if (isAutoGatherActive) {
                    gatherBtn.textContent = `자동 채집 (${remainingTime}초)`;
                } else {
                    gatherBtn.textContent = `채집하기 (${remainingTime}초)`;
                }
            } else {
                gatherBtn.disabled = false;
                if (isAutoGatherActive) {
                    gatherBtn.textContent = '자동 채집 중';
                } else {
                    gatherBtn.textContent = '채집하기';
                }
            }
        }

        function confirmDeleteSpirit(spiritId) {
            const spirit = spirits.find(s => s.id === spiritId);
            if (!spirit) return;
            
            // 연결로 태어난 정령인 경우 코드 반환 옵션 제공
            if (spirit.isBred && spirit.breedCode) {
                showBreedDeleteConfirm(spirit);
            } else {
                showConfirm(
                    '정령 보내기',
                    `정말로 ${spirit.name}을(를) 보내시겠습니까?\n\n이 작업은 되돌릴 수 없습니다.`,
                    () => deleteSpirit(spiritId, false)
                );
            }
        }
        
        async function showBreedDeleteConfirm(spirit) {
            // 연결 정령 삭제 시 선택지 제공
            const modal = document.createElement('div');
            modal.className = 'modal active';
            modal.id = 'breedDeleteModal';
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 400px;">
                    <h3 style="margin-bottom: 16px;">🥚 연결 정령 보내기</h3>
                    <p style="margin-bottom: 8px;">${spirit.name}은(는) 연결로 태어난 정령입니다.</p>
                    <p style="color: #888; font-size: 0.9rem; margin-bottom: 20px;">보내기 방식을 선택해주세요.</p>
                    
                    <div style="display: flex; flex-direction: column; gap: 10px;">
                        <button onclick="deleteSpirit(${spirit.id}, false); closeBreedDeleteModal();" style="padding: 12px; background: var(--card); border: 1px solid var(--border); border-radius: 8px; cursor: pointer;">
                            🌿 그냥 보내기<br>
                            <span style="font-size: 0.8rem; color: #888;">연결 코드는 사용된 상태로 유지</span>
                        </button>
                        <button onclick="deleteSpirit(${spirit.id}, true); closeBreedDeleteModal();" style="padding: 12px; background: linear-gradient(135deg, #667eea, #764ba2); color: white; border: none; border-radius: 8px; cursor: pointer;">
                            🔄 코드 반환하고 보내기<br>
                            <span style="font-size: 0.85rem; opacity: 0.9;">연결 코드를 다시 사용 가능하게</span>
                        </button>
                        <button onclick="closeBreedDeleteModal();" style="padding: 10px; background: transparent; border: 1px solid var(--border); border-radius: 8px; cursor: pointer; color: #888;">
                            취소
                        </button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }
        
        function closeBreedDeleteModal() {
            const modal = document.getElementById('breedDeleteModal');
            if (modal) modal.remove();
        }

        function deleteSpirit(spiritId, returnBreedCode = false) {
            const spirit = spirits.find(s => s.id === spiritId);
            if (!spirit) return;
            
            // 연결 코드 반환 처리
            if (returnBreedCode && spirit.breedCode) {
                // 앨범에서도 해당 코드 사용 기록 제거
                if (collection) {
                    collection.forEach(s => {
                        if (s.breedCode === spirit.breedCode) {
                            delete s.breedCode;
                        }
                    });
                }
                showNotification('🔄 연결 코드가 반환되었습니다. 다시 사용 가능합니다!');
            }
            
            spirits = spirits.filter(s => s.id !== spiritId);
            saveGame();
            renderSpirits();
            showNotification('정령을 떠나보냈습니다');
        }

        function renderInventory() {
            // 먹이가 없으면 초기화
            if (!inventory.food) {
                inventory.food = [];
            }

            // 먹이 인벤토리 (순서 고정: fire, water, wind, earth, light, dark + 이벤트 아이템)
            const foodContainer = document.getElementById('foodInventory');
            if (inventory.food.length === 0) {
                foodContainer.innerHTML = '<div class="inventory-item">없음</div>';
            } else {
                const foodCounts = {};
                inventory.food.forEach(f => {
                    foodCounts[f] = (foodCounts[f] || 0) + 1;
                });
                const foodOrder = ['fire', 'water', 'wind', 'earth', 'light', 'dark', 'medicine', 'reconciliation_flower', 'acacia_honey'];
                let foodHTML = foodOrder
                    .filter(type => foodCounts[type])
                    .map(type => {
                        let icon, name;
                        if (type === 'medicine') {
                            icon = MEDICINE.icon;
                            name = MEDICINE.name;
                        } else if (SYNTH_ITEMS[type]) {
                            icon = SYNTH_ITEMS[type].icon;
                            name = SYNTH_ITEMS[type].name;
                        } else {
                            icon = ENV_ICONS[type];
                            name = FOOD_NAMES[type];
                        }
                        return `
                            <div class="inventory-item" title="${name || ''}">
                                ${icon} ×${foodCounts[type]}
                            </div>
                        `;
                    }).join('');
                
                // 이벤트 먹이 아이템 추가
                Object.keys(foodCounts).forEach(key => {
                    if (EVENT_ITEMS[key] && EVENT_ITEMS[key].type === 'food') {
                        foodHTML += `
                            <div class="inventory-item" title="${EVENT_ITEMS[key].name}">
                                ${EVENT_ITEMS[key].icon} ×${foodCounts[key]}
                            </div>
                        `;
                    }
                });
                
                // 합성 먹이 아이템 추가 (수선화 꽃잎, 아카시아 꿀은 일반 먹이로 분류되어 제외)
                const etcFoods = ['reconciliation_flower', 'acacia_honey'];
                Object.keys(foodCounts).forEach(key => {
                    if (SYNTH_ITEMS[key] && SYNTH_ITEMS[key].type === 'food' && !etcFoods.includes(key)) {
                        foodHTML += `
                            <div class="inventory-item" title="${SYNTH_ITEMS[key].name}" style="border: 1px solid #9b59b6;">
                                ${SYNTH_ITEMS[key].icon} ×${foodCounts[key]}
                            </div>
                        `;
                    }
                });
                
                foodContainer.innerHTML = foodHTML || '<div class="inventory-item">없음</div>';
            }

            // 음악 인벤토리 (순서 고정: classic, jazz, rock, pop, ballad + 이벤트 아이템)
            const musicContainer = document.getElementById('musicInventory');
            if (!inventory.music) inventory.music = [];
            
            if (inventory.music.length === 0) {
                musicContainer.innerHTML = '<div class="inventory-item">없음</div>';
            } else {
                const musicCounts = {};
                inventory.music.forEach(m => {
                    musicCounts[m] = (musicCounts[m] || 0) + 1;
                });
                const musicOrder = ['classic', 'jazz', 'rock', 'pop', 'ballad', 'edm'];
                let musicHTML = musicOrder
                    .filter(type => musicCounts[type])
                    .map(type => `
                        <div class="inventory-item">
                            ${MUSIC_TYPES[type].icon} ×${musicCounts[type]}
                        </div>
                    `).join('');
                
                // 이벤트 음악 아이템 추가
                Object.keys(musicCounts).forEach(key => {
                    if (EVENT_ITEMS[key] && EVENT_ITEMS[key].type === 'music') {
                        musicHTML += `
                            <div class="inventory-item" title="${EVENT_ITEMS[key].name}">
                                ${EVENT_ITEMS[key].icon} ×${musicCounts[key]}
                            </div>
                        `;
                    }
                });
                
                musicContainer.innerHTML = musicHTML || '<div class="inventory-item">없음</div>';
            }

            // 미니어처 인벤토리 (등급별 표시 + 이벤트 아이템)
            const decorContainer = document.getElementById('decorInventory');
            if (!inventory.decorations) inventory.decorations = [];
            
            if (inventory.decorations.length === 0) {
                decorContainer.innerHTML = '<div class="inventory-item">없음</div>';
            } else {
                const decorCounts = {};
                inventory.decorations.forEach(d => {
                    decorCounts[d] = (decorCounts[d] || 0) + 1;
                });
                
                const decorHTML = Object.keys(decorCounts).map(key => {
                    // 일반 미니어처 체크
                    const decoData = DECORATION_TYPES[key];
                    if (decoData) {
                        const qualityLabel = decoData.quality === 'legendary' ? '👑' : decoData.quality === 'epic' ? '⭐' : decoData.quality === 'rare' ? '💎' : '';
                        const qualityBorderColor = decoData.quality === 'legendary' ? '#ffd700' : decoData.quality === 'epic' ? '#9b59b6' : decoData.quality === 'rare' ? '#3498db' : 'var(--border)';
                        return `
                            <div class="inventory-item" title="${decoData.name} (${decoData.attr} +${decoData.power})" style="border: 2px solid ${qualityBorderColor};">
                                ${qualityLabel}${decoData.icon} ×${decorCounts[key]}
                            </div>
                        `;
                    }
                    
                    // 합성 미니어처 체크
                    const synthItem = SYNTH_ITEMS[key];
                    if (synthItem && synthItem.type === 'decoration') {
                        return `
                            <div class="inventory-item" title="${synthItem.name} (${synthItem.attr} +${synthItem.power})" style="border: 2px solid #9b59b6;">
                                ${synthItem.icon} ×${decorCounts[key]}
                            </div>
                        `;
                    }
                    
                    // 이벤트 미니어처 체크
                    const eventItem = EVENT_ITEMS[key];
                    if (eventItem && eventItem.type === 'decoration') {
                        const qualityLabel = eventItem.quality === 'legendary' ? '👑' : eventItem.quality === 'epic' ? '⭐' : eventItem.quality === 'rare' ? '💎' : '';
                        const qualityBorderColor = eventItem.quality === 'legendary' ? '#ffd700' : eventItem.quality === 'epic' ? '#9b59b6' : eventItem.quality === 'rare' ? '#3498db' : '#c41e3a';
                        return `
                            <div class="inventory-item" title="${eventItem.name}" style="border: 2px solid ${qualityBorderColor};">
                                ${qualityLabel}${eventItem.icon} ×${decorCounts[key]}
                            </div>
                        `;
                    }
                    
                    return '';
                }).join('');
                
                decorContainer.innerHTML = decorHTML || '<div class="inventory-item">없음</div>';
            }
        }

        function manualCompleteSpirit(spiritId) {
            if (isPaused) {
                showNotification('게임이 일시정지 상태입니다');
                return;
            }
            
            const spirit = spirits.find(s => s.id === spiritId);
            if (!spirit) {
                showNotification('정령을 찾을 수 없습니다.');
                return;
            }
            
            if (spirit.growth >= 100 && !spirit.isCompleted) {
                try {
                    completeSpirit(spirit);
                    saveGame();
                    renderSpirits();
                    showNotification('✨ 정령이 진화합니다!');
                } catch (error) {
                    console.error('진화 오류:', error);
                    showNotification('진화 중 오류가 발생했습니다: ' + error.message);
                }
            } else {
                showNotification(`아직 진화할 수 없습니다. (성장도: ${Math.floor(spirit.growth)}/100)`);
            }
        }

        function completeSpirit(spirit) {
            // 이벤트 정령 별도 처리
            if (spirit.isEventSpirit && spirit.eventType) {
                const event = EVENT_TYPES[spirit.eventType];
                if (event) {
                    spirit.isCompleted = true;
                    
                    // 이로치 여부에 따라 다른 데이터 설정
                    const isShiny = spirit.isShiny && event.shiny;
                    const spiritName = isShiny ? event.shiny.name : event.name;
                    const spiritIcon = isShiny ? event.shiny.stages.adult : event.stages.adult;
                    const spiritDesc = isShiny ? event.shiny.desc : event.desc;
                    const eventTypeKey = isShiny ? `event_${spirit.eventType}_shiny` : `event_${spirit.eventType}`;
                    
                    spirit.evolutionData = {
                        type: eventTypeKey,
                        attributeType: event.attribute,
                        name: spiritName,
                        icon: spiritIcon,
                        desc: spiritDesc,
                        wingType: null,
                        isEvent: true,
                        isShiny: isShiny
                    };
                    
                    saveGame();
                    renderSpirits();
                    
                    if (isShiny) {
                        showNotification(`✨ ${spiritName}이(가) 완성되었습니다! 희귀한 정령이에요!`);
                    } else {
                        showNotification(`🎄 ${spiritName}이(가) 완성되었습니다! 육성 탭에서 확인해주세요.`);
                    }
                    return;
                }
            }
            
            // 연결 정령 전용 진화 (100% 확률)
            if (spirit.isBred && spirit.fusionType && FUSION_TYPES[spirit.fusionType]) {
                const fusion = FUSION_TYPES[spirit.fusionType];
                spirit.isCompleted = true;
                
                // 날개 타입 결정
                if (!spirit.lightTime) spirit.lightTime = 0;
                if (!spirit.darkTime) spirit.darkTime = 0;
                let wingType = spirit.lightTime > spirit.darkTime ? 'butterfly' : 'moth';
                
                const evolutionData = {
                    type: spirit.fusionType,
                    attributeType: spirit.fusionType,
                    name: fusion.name,
                    icon: fusion.icon,
                    desc: fusion.desc,
                    wingType: wingType,
                    isFusion: true,
                    fusionRarity: fusion.rarity
                };
                
                spirit.evolutionData = evolutionData;
                
                // 도감 등록 (숫자 형식으로 통일)
                if (!encyclopedia[spirit.fusionType] || typeof encyclopedia[spirit.fusionType] === 'object') {
                    // 객체 형식이면 숫자로 변환, 없으면 초기화
                    const prevCount = typeof encyclopedia[spirit.fusionType] === 'object' 
                        ? (encyclopedia[spirit.fusionType].count || 0) 
                        : (encyclopedia[spirit.fusionType] || 0);
                    encyclopedia[spirit.fusionType] = prevCount + 1;
                    if (prevCount === 0) {
                        showNotification(`🎉 새로운 합성 정령 "${fusion.name}" 도감 등록!`);
                    }
                } else {
                    encyclopedia[spirit.fusionType]++;
                }
                
                // 도감 상세 정보 저장 (복구용)
                if (!encyclopediaDetails[spirit.fusionType]) {
                    encyclopediaDetails[spirit.fusionType] = [];
                }
                encyclopediaDetails[spirit.fusionType].push({
                    originalName: spirit.name,
                    parameters: { ...spirit.parameters },
                    hiddenAttributes: { ...spirit.hiddenAttributes },
                    wingType: wingType,
                    lightTime: spirit.lightTime || 0,
                    darkTime: spirit.darkTime || 0,
                    completedAt: Date.now(),
                    isFusion: true,
                    fusionRarity: fusion.rarity,
                    type: spirit.fusionType,
                    attributeType: spirit.fusionType,
                    name: fusion.name,
                    icon: fusion.icon,
                    desc: fusion.desc
                });
                
                saveGame();
                renderSpirits();
                
                // 앨범 추가 및 정령 제거를 위한 확인창
                showConfirm(
                    '합성 정령 완성',
                    `🧬 ${fusion.name}이(가) 완성되었습니다!\n연결의 힘이 발현되었어요!`,
                    () => {
                        // 앨범에 추가
                        collection.push({
                            id: `album-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                            type: evolutionData.type,
                            attributeType: evolutionData.attributeType,
                            name: evolutionData.name,
                            icon: evolutionData.icon,
                            desc: evolutionData.desc,
                            parameters: { ...spirit.parameters },
                            hiddenAttributes: { ...spirit.hiddenAttributes },
                            originalName: spirit.name,
                            wingType: evolutionData.wingType,
                            lightTime: spirit.lightTime,
                            darkTime: spirit.darkTime,
                            completedAt: Date.now(),
                            isFusion: true,
                            fusionRarity: evolutionData.fusionRarity
                        });
                        
                        // 코인 보상
                        coins += 25;
                        
                        // 업적 체크
                        checkAchievements();
                        
                        // 정령 제거
                        spirits = spirits.filter(s => s.id !== spiritId);
                        saveGame();
                        updateCoinDisplay();
                        renderSpirits();
                        
                        showNotification(`✨ ${fusion.name}이(가) 앨범에 등록되고 떠났습니다. (+25코인)`);
                    },
                    '떠나보내기',
                    '조금 더 함께하기'
                );
                return;
            }
            
            // 스탯으로 진화 결정
            const params = spirit.parameters;
            
            // 스탯 계열 결정 (100 이상인 경우만 타이틀)
            let statType = '';
            let evolutionKey = '';
            
            // 현자 체크 (모든 스탯 100)
            if (params.intelligence >= 100 && params.strength >= 100 && params.charm >= 100) {
                statType = 'sage';
                evolutionKey = 'sage';
            } else {
                // 100 이상인 스탯 찾기
                const maxStats = [];
                if (params.intelligence >= 100) maxStats.push('intelligent');
                if (params.strength >= 100) maxStats.push('strong');
                if (params.charm >= 100) maxStats.push('beautiful');
                
                if (maxStats.length > 0) {
                    // 100 이상인 스탯 중 랜덤 선택
                    statType = maxStats[Math.floor(Math.random() * maxStats.length)];
                    evolutionKey = statType;
                } else {
                    // 아무 스탯도 100 미만 - 타이틀 없음
                    statType = 'nostat';
                    evolutionKey = 'nostat';
                }
            }

            // 속성 분석 (먹이 50% + 테라리움 50%)
            const foodAttrs = spirit.hiddenAttributes || { fire: 0, water: 0, wind: 0, earth: 0, light: 0, dark: 0 };
            const terrariumAttrs = terrarium || { fire: 0, water: 0, wind: 0, earth: 0, light: 0, dark: 0 };
            
            // 최종 속성 = (먹이 속성 × 0.7) + (테라리움 속성 × 0.3)
            const finalAttrs = {};
            for (let attr in foodAttrs) {
                finalAttrs[attr] = (foodAttrs[attr] * 0.7) + (terrariumAttrs[attr] * 0.3);
            }
            
            const sortedAttrs = Object.entries(finalAttrs)
                .sort((a, b) => b[1] - a[1]); // 내림차순 정렬
            
            // 최고 속성값
            const maxAttrValue = sortedAttrs[0][1];
            
            let attributeKey = '';
            let attributeData = null;
            
            if (maxAttrValue < 50) {
                // 모든 속성이 50 미만 - 백의 정령
                attributeKey = 'normal';
                attributeData = { name: '백의 정령', icon: '🤍', desc: '속성이 깃들지 않은 순수한 정령.' };
            } else {
                // 50 이상인 속성들만 필터링
                const significantAttrs = sortedAttrs.filter(([_, value]) => value >= 50);
                
                if (significantAttrs.length === 1) {
                    // 단일 속성 (하나만 60 이상)
                    attributeKey = significantAttrs[0][0];
                    attributeData = ATTRIBUTE_NAMES[attributeKey];
                    if (!attributeData) {
                        console.error('Missing ATTRIBUTE_NAMES for:', attributeKey);
                        // 가장 높은 단일 속성으로 폴백
                        attributeKey = sortedAttrs[0][0];
                        attributeData = ATTRIBUTE_NAMES[attributeKey] || ATTRIBUTE_NAMES['fire'];
                    }
                } else if (significantAttrs.length === 2) {
                    // 2속성: 1위와 2위 차이가 40% 이하면 조합, 초과면 단일
                    const first = significantAttrs[0][1];
                    const second = significantAttrs[1][1];
                    const diffPercent = ((first - second) / first) * 100;
                    
                    if (diffPercent <= 40) {
                        // 2속성 조합
                        const attr1 = significantAttrs[0][0];
                        const attr2 = significantAttrs[1][0];
                        const comboKey = [attr1, attr2].sort().join('-');
                        attributeData = ATTRIBUTE_NAMES[comboKey];
                        attributeKey = comboKey;
                        if (!attributeData) {
                            console.error('Missing ATTRIBUTE_NAMES for combo:', comboKey);
                            // 조합이 없으면 1순위 단일 속성으로 폴백
                            attributeKey = attr1;
                            attributeData = ATTRIBUTE_NAMES[attr1] || ATTRIBUTE_NAMES['fire'];
                        }
                    } else {
                        // 단일 속성 (차이가 너무 큼)
                        attributeKey = significantAttrs[0][0];
                        attributeData = ATTRIBUTE_NAMES[attributeKey];
                        if (!attributeData) {
                            console.error('Missing ATTRIBUTE_NAMES for:', attributeKey);
                            // 가장 높은 속성으로 폴백
                            attributeKey = sortedAttrs[0][0];
                            attributeData = ATTRIBUTE_NAMES[attributeKey] || ATTRIBUTE_NAMES['fire'];
                        }
                    }
                } else if (significantAttrs.length >= 3) {
                    // 3속성 이상 - 6개 속성 전체로 조화/혼돈 판정
                    const allSixAttrs = ['fire', 'water', 'earth', 'wind', 'light', 'dark'];
                    const allValues = allSixAttrs.map(attr => finalAttrs[attr] || 0);
                    const maxVal = Math.max(...allValues);
                    const minVal = Math.min(...allValues);
                    
                    // 차이 비율 계산 (최대값 기준)
                    const diffPercent = maxVal > 0 ? ((maxVal - minVal) / maxVal) * 100 : 0;
                    
                    if (diffPercent <= 25) {
                        // 조화 (6개 속성 차이 25% 이내)
                        attributeKey = 'balanced';
                        attributeData = ATTRIBUTE_NAMES['balanced'];
                    } else {
                        // 혼돈 (6개 속성 차이 25% 초과)
                        attributeKey = 'multi';
                        attributeData = ATTRIBUTE_NAMES['multi'];
                    }
                    if (!attributeData) {
                        console.error('Missing ATTRIBUTE_NAMES for:', attributeKey);
                        // 가장 높은 단일 속성으로 폴백
                        attributeKey = significantAttrs[0][0];
                        attributeData = ATTRIBUTE_NAMES[attributeKey] || ATTRIBUTE_NAMES['fire'];
                    }
                }
            }
            
            // 최종 이름과 아이콘 조합
            let finalName = '';
            let finalIcon = '';
            let finalDesc = '';
            
            // 날개 타입 먼저 결정 (티타니아/오베론 판정에 필요)
            if (!spirit.lightTime) spirit.lightTime = 0;
            if (!spirit.darkTime) spirit.darkTime = 0;
            
            let wingType = null;
            if (spirit.lightTime > spirit.darkTime) {
                wingType = 'butterfly';
            } else if (spirit.darkTime > spirit.lightTime) {
                wingType = 'moth';
            } else {
                wingType = 'butterfly'; // 동점이면 나비
            }
            
            // 속성 아이콘 가져오기 (나비/나방형 지원)
            const getAttrIcon = (attrData) => {
                if (!attrData || !attrData.icon) return '🤍';
                if (typeof attrData.icon === 'object') {
                    return attrData.icon[wingType] || attrData.icon.butterfly || '🤍';
                }
                return attrData.icon;
            };
            
            // 정령왕 조건 체크 (모든 스탯 100 + 모든 속성 500)
            const isKingStats = params.intelligence >= 100 && params.strength >= 100 && params.charm >= 100;
            const isKingAttributes = Object.values(finalAttrs).every(val => val >= 500);
            
            // 티타니아/오베론 조건 체크
            // 모든 스탯 70 이상 + 모든 속성 100 근접 (90 이상)
            const isPerfectStats = params.intelligence >= 70 && params.strength >= 70 && params.charm >= 70;
            const isPerfectAttributes = Object.values(finalAttrs).every(val => val >= 90);
            
            // 타이틀 없는 정령 여부
            const hasNoTitle = evolutionKey === 'nostat';
            
            if (isKingStats && isKingAttributes) {
                // 궁극의 정령 - 정령왕
                finalName = '정령왕';
                finalIcon = '👑🌸';
                finalDesc = '모든 것을 초월한 만개한 자연의 화신. 정령계의 유일무이한 지배자.';
            } else if (isPerfectStats && isPerfectAttributes) {
                // 완벽한 정령 - 티타니아/오베론
                if (wingType === 'butterfly') {
                    finalName = '티타니아';
                    finalIcon = '🦋✨';
                    finalDesc = '모든 힘을 완벽히 갖춘 나비의 여왕. 빛과 생명을 관장하는 전설적 존재.';
                } else {
                    finalName = '오베론';
                    finalIcon = '🦋🌙';
                    finalDesc = '모든 힘을 완벽히 갖춘 나방의 군주. 어둠과 신비를 지배하는 전설적 존재.';
                }
            } else if (attributeKey === 'normal') {
                // 속성 없음
                if (hasNoTitle) {
                    // 스탯도 낮음 - 순수한 백의 정령
                    if (attributeData) {
                        finalName = attributeData.name;
                        finalIcon = getAttrIcon(attributeData);
                        finalDesc = attributeData.desc;
                    } else {
                        finalName = '백의 정령';
                        finalIcon = '🤍';
                        finalDesc = '속성이 깃들지 않은 순수한 정령.';
                    }
                } else {
                    // 스탯은 높음 - "스탯 계열 + 백의 정령"
                    const evolution = EVOLUTION_TYPES[evolutionKey];
                    if (evolution && attributeData) {
                        finalName = `${evolution.prefix} ${attributeData.name}`;
                        finalIcon = `${evolution.icon}${getAttrIcon(attributeData)}`;
                        finalDesc = attributeData.desc;
                    } else if (evolution) {
                        // evolution은 있는데 attributeData가 없으면 백의 정령 사용
                        finalName = `${evolution.prefix} 백의 정령`;
                        finalIcon = `${evolution.icon}🤍`;
                        finalDesc = '속성이 깃들지 않은 순수한 정령.';
                    } else {
                        finalName = '백의 정령';
                        finalIcon = '🤍';
                        finalDesc = '속성이 깃들지 않은 순수한 정령.';
                    }
                }
            } else if (hasNoTitle) {
                // 스탯 부족하지만 속성 있음 - 속성 이름만 (타이틀 없음)
                if (attributeData) {
                    finalName = attributeData.name;
                    finalIcon = getAttrIcon(attributeData);
                    finalDesc = attributeData.desc;
                } else {
                    console.error('attributeData is undefined for key:', attributeKey);
                    // 가장 높은 단일 속성으로 폴백
                    const fallbackKey = sortedAttrs[0][0];
                    const fallbackData = ATTRIBUTE_NAMES[fallbackKey] || ATTRIBUTE_NAMES['fire'];
                    finalName = fallbackData.name;
                    finalIcon = getAttrIcon(fallbackData);
                    finalDesc = fallbackData.desc;
                    attributeKey = fallbackKey;
                }
            } else {
                // 스탯도 있고 속성도 있음 - "스탯 계열 + 속성 이름" 형태
                const evolution = EVOLUTION_TYPES[evolutionKey];
                if (evolution && attributeData) {
                    finalName = `${evolution.prefix} ${attributeData.name}`;
                    finalIcon = `${evolution.icon}${getAttrIcon(attributeData)}`;
                    finalDesc = attributeData.desc;
                } else {
                    console.error('Evolution data missing:', { evolutionKey, attributeKey, evolution, attributeData });
                    // 폴백: 속성만 사용
                    const fallbackKey = sortedAttrs[0][0];
                    const fallbackData = ATTRIBUTE_NAMES[fallbackKey] || ATTRIBUTE_NAMES['fire'];
                    finalName = fallbackData.name;
                    finalIcon = getAttrIcon(fallbackData);
                    finalDesc = fallbackData.desc;
                    attributeKey = fallbackKey;
                }
            }
            
            // evolutionKey 설정 (도감 등록용)
            let finalEvolutionType = evolutionKey;
            if (isKingStats && isKingAttributes) {
                // 정령왕
                finalEvolutionType = 'spiritking';
            } else if (isPerfectStats && isPerfectAttributes) {
                // 티타니아/오베론
                finalEvolutionType = wingType === 'butterfly' ? 'titania' : 'oberon';
            }
            // nostat인 경우 evolutionKey가 이미 'nostat'이므로 그대로 유지
            
            // 정령을 완성 상태로 표시 (아직 제거하지 않음)
            spirit.isCompleted = true;
            spirit.evolutionData = {
                type: finalEvolutionType,
                attributeType: attributeKey,
                name: finalName,
                icon: finalIcon,
                desc: finalDesc,
                wingType: wingType
            };
            
            saveGame();
            renderSpirits();
            showNotification('🎉 정령이 성장을 완료했습니다! 육성 탭에서 확인해주세요.');
        }
        
        function confirmEvolution(spiritId) {
            const spirit = spirits.find(s => s.id === spiritId);
            if (!spirit || !spirit.isCompleted) {
                console.log('confirmEvolution failed:', { spirit, spiritId, isCompleted: spirit?.isCompleted });
                return;
            }
            
            const evolutionData = spirit.evolutionData;
            console.log('Evolution data:', evolutionData);
            
            const affection = spirit.parameters.affection || 0;
            
            // 애정도별 엔딩 메시지
            let endingMessage = '';
            
            if (affection >= 150) {
                endingMessage = `${spirit.name}은(는) 당신에게 "ㅁㅁㅁㅁ"라는 말을 남기고 떠납니다.\n\n정령어 사전을 찾아보면 그 말은 "사랑해요"라는 의미입니다.`;
            } else if (affection >= 100) {
                endingMessage = `${spirit.name}은(는) 당신의 뺨에 입맞춤을 남기고 떠납니다.`;
            } else if (affection >= 50) {
                endingMessage = `${spirit.name}은(는) 당신에게 감사의 인사를 남기고 떠납니다.`;
            } else {
                endingMessage = `${spirit.name}이(가) 떠나갑니다.`;
            }
            
            showConfirm(
                '정령 완성',
                endingMessage,
                () => {
                    // 상태 키워드 계산 (유전 가능한 것들)
                    const statusKeywords = [];
                    if (spirit.parameters.intelligence >= 50) statusKeywords.push('똑똑한');
                    if (spirit.parameters.strength >= 50) statusKeywords.push('강한');
                    if (spirit.parameters.charm >= 50) statusKeywords.push('매력적인');
                    
                    // 모든 상태 키워드 저장 (앨범 표시용)
                    const allStatusKeywords = [];
                    
                    // 스탯 기반 긍정 키워드
                    if (spirit.parameters.intelligence >= 50) allStatusKeywords.push('똑똑한');
                    if (spirit.parameters.strength >= 50) allStatusKeywords.push('강한');
                    if (spirit.parameters.charm >= 50) allStatusKeywords.push('매력적인');
                    
                    // 스탯 기반 부정 키워드
                    if (spirit.parameters.intelligence <= 10) allStatusKeywords.push('사교성이 적은');
                    if (spirit.parameters.strength <= 5) allStatusKeywords.push('몸이 약한');
                    
                    // 애정도 기반
                    if (spirit.parameters.affection >= 100) allStatusKeywords.push('사랑이 가득한');
                    else if (spirit.parameters.affection >= 70) allStatusKeywords.push('애정 어린');
                    
                    // 만족도 기반
                    if (spirit.satisfaction === 'high') allStatusKeywords.push('행복한');
                    
                    // 빛/어둠 시간 기반
                    const lightTime = spirit.lightTime || 0;
                    const darkTime = spirit.darkTime || 0;
                    if (lightTime >= 10 && lightTime > darkTime) allStatusKeywords.push('태양을 동경하는');
                    else if (darkTime >= 10 && darkTime > lightTime) allStatusKeywords.push('달을 숭배하는');
                    
                    // 먹이/음악 횟수 기반
                    if (spirit.feedCount >= 20) allStatusKeywords.push('미식가');
                    if (spirit.musicListened >= 10) allStatusKeywords.push('음악을 사랑하는');
                    
                    // 유전받은 키워드
                    if (spirit.inheritedKeywords && spirit.inheritedKeywords.length > 0) {
                        spirit.inheritedKeywords.forEach(kw => {
                            if (!allStatusKeywords.includes(kw)) {
                                allStatusKeywords.push(`🧬 ${kw}`);
                            }
                        });
                    }
                    
                    // 앨범에 추가
                collection.push({
                    id: `album-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`, // 고유 ID
                    originalSpiritId: spiritId, // 원본 정령 ID (파트너 매칭용)
                    type: evolutionData.type,
                    attributeType: evolutionData.attributeType,
                    name: evolutionData.name,
                    icon: evolutionData.icon,
                    desc: evolutionData.desc,
                    parameters: { ...spirit.parameters },
                    hiddenAttributes: { ...spirit.hiddenAttributes },
                    originalName: spirit.name,
                    wingType: evolutionData.wingType,
                    lightTime: spirit.lightTime,
                    darkTime: spirit.darkTime,
                    completedAt: Date.now(),
                    // 이벤트 정령 정보 저장
                    isEventSpirit: spirit.isEventSpirit || false,
                    eventType: spirit.eventType || null,
                    // 관계 정보 저장
                    bond: spirit.bond || null,
                    // 상태 키워드 저장 (유전용)
                    statusKeywords: statusKeywords,
                    // 부모에게서 유전받은 키워드
                    inheritedKeywords: spirit.inheritedKeywords || [],
                    // 모든 상태 키워드 (앨범 표시용)
                    allStatusKeywords: allStatusKeywords
                });
                
                // 도감에 등록 (진화 타입별 카운트) - wingType 포함
                let encyclopediaKey;
                if (evolutionData.type === 'titania' || evolutionData.type === 'oberon' || evolutionData.type === 'spiritking') {
                    // 전설적 존재는 고유 키 사용
                    encyclopediaKey = evolutionData.type;
                } else if (evolutionData.type === 'nostat') {
                    // 수식어 없는 정령 (wingType 포함)
                    encyclopediaKey = `nostat-${evolutionData.attributeType}-${evolutionData.wingType}`;
                } else if (evolutionData.type && evolutionData.type.startsWith('event_')) {
                    // 이벤트 정령은 타입 그대로 사용
                    encyclopediaKey = evolutionData.type;
                } else {
                    // 일반 정령 (스탯-레벨-속성-wingType)
                    encyclopediaKey = `${evolutionData.type}-${evolutionData.attributeType}-${evolutionData.wingType}`;
                }
                
                if (!encyclopedia[encyclopediaKey]) {
                    encyclopedia[encyclopediaKey] = 0;
                }
                encyclopedia[encyclopediaKey]++;
                
                // 도감 상세 정보 저장 (복구용)
                if (!encyclopediaDetails[encyclopediaKey]) {
                    encyclopediaDetails[encyclopediaKey] = [];
                }
                encyclopediaDetails[encyclopediaKey].push({
                    originalName: spirit.name,
                    parameters: { ...spirit.parameters },
                    hiddenAttributes: { ...spirit.hiddenAttributes },
                    wingType: evolutionData.wingType,
                    lightTime: spirit.lightTime || 0,
                    darkTime: spirit.darkTime || 0,
                    completedAt: Date.now(),
                    isEventSpirit: spirit.isEventSpirit || false,
                    eventType: spirit.eventType || null,
                    // 진화 정보
                    type: evolutionData.type,
                    attributeType: evolutionData.attributeType,
                    name: evolutionData.name,
                    icon: evolutionData.icon,
                    desc: evolutionData.desc,
                    // 키워드 정보 (유전 및 앨범 표시용)
                    statusKeywords: statusKeywords,
                    inheritedKeywords: spirit.inheritedKeywords || [],
                    allStatusKeywords: allStatusKeywords
                });
                
                console.log('도감 등록:', encyclopediaKey, '카운트:', encyclopedia[encyclopediaKey]);
                
                // 코인 보상 (25코인)
                coins += 25;
                
                // 업적 체크
                checkAchievements();
                
                // 정령 제거
                spirits = spirits.filter(s => s.id !== spiritId);
                saveGame();
                updateCoinDisplay();
                
                // 자동 로컬 백업 (최근 10개 유지)
                try {
                    const backups = JSON.parse(localStorage.getItem('spiritGarden_autoBackups') || '[]');
                    backups.unshift({
                        timestamp: Date.now(),
                        collection: [...collection],
                        encyclopedia: {...encyclopedia}
                    });
                    // 최근 10개만 유지
                    if (backups.length > 10) backups.length = 10;
                    localStorage.setItem('spiritGarden_autoBackups', JSON.stringify(backups));
                } catch (e) {
                    console.warn('자동 백업 실패:', e);
                }
                
                    renderSpirits();
                    // 알림용 아이콘 (이미지 태그가 포함된 경우 이모지로 대체)
                    const notifyIcon = evolutionData.icon.includes('<img') ? '🦋' : evolutionData.icon;
                    showNotification(`${notifyIcon} ${spirit.name}이(가) ${evolutionData.name}(으)로 앨범에 등록되었습니다 (+25💰)`);
                    
                    // 연모 알 이벤트 체크
                    checkLoveEggEvent(spirit);
                    
                    // 첫 번째 정령 완성 시 두 번째 튜토리얼 시작
                    if (collection.length === 1 && !localStorage.getItem('spiritGarden_tutorial2Seen')) {
                        setTimeout(() => {
                            startTutorial2();
                        }, 1500);
                    }
                }
            );
        }
        
        // 연모 알 이벤트 체크
        function checkLoveEggEvent(completedSpirit) {
            // 연모 bond가 있는지 확인
            if (!completedSpirit.bond || completedSpirit.bond.type !== 'lover') return;
            
            const partnerId = completedSpirit.bond.partnerId;
            
            // 파트너가 앨범에 있는지 확인 (originalSpiritId로 검색)
            const partnerInAlbum = collection.find(item => item.originalSpiritId === partnerId);
            
            if (!partnerInAlbum) {
                // 아직 파트너가 앨범에 없음 - 파트너가 완성되면 그때 체크됨
                return;
            }
            
            // 이미 알을 받았는지 체크 (중복 방지)
            if (partnerInAlbum.loveEggReceived) return;
            
            // 30% 확률로 알 이벤트 발생
            if (Math.random() > 0.3) return;
            
            // 방금 추가된 정령 정보 (앨범에서 가장 최근 것)
            const justAdded = collection[collection.length - 1];
            
            // 중복 방지 플래그 설정
            partnerInAlbum.loveEggReceived = true;
            justAdded.loveEggReceived = true;
            saveGame();
            
            setTimeout(() => {
                showConfirm(
                    '💕 연모의 결실',
                    `${partnerInAlbum.originalName}와(과) ${justAdded.originalName}의 사랑이 결실을 맺었습니다!\n\n🥚 둘 사이에서 알이 나타났어요.\n\n알을 받으시겠습니까?`,
                    () => {
                        // 알 생성
                        createLoveEgg(partnerInAlbum, justAdded);
                    },
                    '받을게요 💕',
                    '괜찮아요',
                    () => {
                        showNotification('알이 사라졌습니다...');
                    }
                );
            }, 1500);
        }
        
        // 연모 알 생성
        function createLoveEgg(parent1, parent2) {
            // 슬롯 체크 (최대 6마리)
            if (spirits.length >= 6) {
                showNotification('❌ 정령 슬롯이 가득 찼습니다!');
                return;
            }
            
            // 부모 속성의 25%씩 = 총 50% 상속
            const parent1Attrs = parent1.hiddenAttributes || { fire: 0, water: 0, wind: 0, earth: 0, light: 0, dark: 0 };
            const parent2Attrs = parent2.hiddenAttributes || { fire: 0, water: 0, wind: 0, earth: 0, light: 0, dark: 0 };
            
            const inheritedAttrs = {};
            for (let attr in parent1Attrs) {
                inheritedAttrs[attr] = Math.floor((parent1Attrs[attr] + parent2Attrs[attr]) / 4);
            }
            
            // 부모 스탯의 25%씩 = 총 50% 상속
            const inheritedParams = {
                intelligence: Math.floor((parent1.parameters.intelligence + parent2.parameters.intelligence) / 4),
                strength: Math.floor((parent1.parameters.strength + parent2.parameters.strength) / 4),
                charm: Math.floor((parent1.parameters.charm + parent2.parameters.charm) / 4),
                affection: 10 // 사랑의 결실이므로 애정도 보너스
            };
            
            // 🧬 키워드 유전 시스템
            const parent1Keywords = parent1.statusKeywords || [];
            const parent2Keywords = parent2.statusKeywords || [];
            const inheritedKeywords = [];
            
            // 유전 가능한 키워드 목록
            const heritableKeywords = ['똑똑한', '강한', '매력적인'];
            
            heritableKeywords.forEach(keyword => {
                const p1Has = parent1Keywords.includes(keyword);
                const p2Has = parent2Keywords.includes(keyword);
                
                if (p1Has && p2Has) {
                    // 양쪽 부모 모두 가지고 있으면 100% 유전
                    inheritedKeywords.push(keyword);
                } else if (p1Has || p2Has) {
                    // 한쪽만 가지고 있으면 50% 확률로 유전
                    if (Math.random() < 0.5) {
                        inheritedKeywords.push(keyword);
                    }
                }
            });
            
            // 유전된 키워드에 따른 스탯 보너스
            if (inheritedKeywords.includes('똑똑한')) {
                inheritedParams.intelligence += 15; // 지력 보너스
            }
            if (inheritedKeywords.includes('강한')) {
                inheritedParams.strength += 15; // 체력 보너스
            }
            if (inheritedKeywords.includes('매력적인')) {
                inheritedParams.charm += 15; // 매력 보너스
            }
            
            // 이름 생성 (부모 이름 기반)
            const eggName = `${parent1.originalName}와${parent2.originalName}의 알`;
            
            // 유전 키워드 로그 메시지
            let inheritLog = `💕 ${parent1.originalName}와(과) ${parent2.originalName}의 사랑으로 태어났습니다.`;
            if (inheritedKeywords.length > 0) {
                inheritLog += ` 🧬 유전된 특성: ${inheritedKeywords.join(', ')}`;
            }
            
            const spirit = {
                id: Date.now(),
                name: eggName,
                stage: 'egg',
                growth: 0,
                parameters: inheritedParams,
                hiddenAttributes: inheritedAttrs,
                satisfaction: 'high', // 사랑받는 아이
                lastFed: null,
                lastMusic: null,
                lastPat: null,
                lastDecorate: null,
                lastInteraction: Date.now(),
                status: '사랑의 결실로 태어난 알이에요 💕',
                birthTime: Date.now(),
                logs: [inheritLog],
                lightTime: 0,
                darkTime: 0,
                musicListened: 0,
                feedCount: 0,
                relationships: {},
                bond: null,
                isLoveChild: true, // 연모 알 표시
                parents: [parent1.originalName, parent2.originalName],
                inheritedKeywords: inheritedKeywords // 유전받은 키워드 저장
            };
            
            spirits.push(spirit);
            saveGame();
            renderSpirits();
            
            // 유전 키워드에 따른 알림 메시지
            let notification = `💕 ${eggName}이(가) 태어났습니다! 부모의 능력을 조금 물려받았어요.`;
            if (inheritedKeywords.length > 0) {
                notification += ` 🧬 유전: ${inheritedKeywords.join(', ')}`;
            }
            showNotification(notification);
        }

        function showAlbumDetail(index) {
            const item = collection[index];
            if (!item) return;
            
            // 튜토리얼2: 앨범 상세 열기 액션 체크
            checkTutorialAction('openAlbumDetail');
            
            const modal = document.getElementById('albumDetailModal');
            const modalTitle = document.getElementById('modalTitle');
            const modalContent = document.getElementById('modalContent');
            
            // 최신 z-index 적용
            modal.style.zIndex = getNextZIndex();
            
            modalTitle.textContent = item.name;
            
            // 날개 정보
            let wingInfo = '';
            if (item.wingType === 'butterfly') {
                wingInfo = '🦋 나비의 날개';
            } else if (item.wingType === 'moth') {
                wingInfo = '🦋 나방의 날개';
            }
            
            // 조명 시간 계산
            const lightMinutes = Math.floor((item.lightTime || 0) / 60);
            const darkMinutes = Math.floor((item.darkTime || 0) / 60);
            
            // 속성 정보
            const hiddenAttrs = item.hiddenAttributes || { fire: 0, water: 0, wind: 0, earth: 0, light: 0, dark: 0 };
            
            // 애정도 체크
            const affection = item.parameters?.affection || 0;
            const canBreed = affection >= 50;
            
            // 갖고있던 상태 키워드 표시
            let keywordsHtml = '';
            const allStatusKeywords = item.allStatusKeywords || [];
            
            // 기존 데이터 호환 (allStatusKeywords가 없는 경우)
            if (allStatusKeywords.length === 0) {
                const statusKeywords = item.statusKeywords || [];
                const inheritedKeywords = item.inheritedKeywords || [];
                inheritedKeywords.forEach(kw => allStatusKeywords.push(`🧬 ${kw}`));
                statusKeywords.forEach(kw => {
                    if (!inheritedKeywords.includes(kw)) allStatusKeywords.push(kw);
                });
            }
            
            if (allStatusKeywords.length > 0) {
                const keywordTags = allStatusKeywords.map(kw => {
                    if (kw.startsWith('🧬')) {
                        return `<span style="display: inline-block; padding: 4px 10px; background: linear-gradient(135deg, #9c27b0, #673ab7); color: white; border-radius: 12px; font-size: 0.8rem; margin: 2px;">${kw}</span>`;
                    } else {
                        return `<span style="display: inline-block; padding: 4px 10px; background: var(--card); border: 1px solid var(--border); color: var(--text); border-radius: 12px; font-size: 0.8rem; margin: 2px;">${kw}</span>`;
                    }
                });
                
                keywordsHtml = `
                    <div style="background: var(--bg); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                        <h3 style="font-size: 1rem; margin-bottom: 10px; color: var(--text);">🏷️ 갖고있던 상태</h3>
                        <div style="display: flex; flex-wrap: wrap; gap: 4px;">
                            ${keywordTags.join('')}
                        </div>
                    </div>
                `;
            }
            
            modalContent.innerHTML = `
                <div style="text-align: center; margin-bottom: 20px;">
                    <div style="font-size: 4rem; margin-bottom: 10px;">${item.icon && item.icon.includes('<img') ? item.icon.replace(/width:\d+px;height:(auto|\d+px)/g, 'width:auto;height:auto') : (item.icon + (wingInfo ? '🦋' : ''))}</div>
                    <div style="font-size: 0.9rem; color: #888;">본명: ${item.originalName || '이름 없음'}</div>
                    ${wingInfo ? `<div style="font-size: 0.9rem; color: #888; margin-top: 4px;">${wingInfo}</div>` : ''}
                    ${item.desc ? `<div style="font-size: 0.9rem; color: #888; margin-top: 8px; line-height: 1.4; font-style: italic;">"${item.desc}"</div>` : ''}
                </div>
                
                <div style="background: var(--bg); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                    <h3 style="font-size: 1rem; margin-bottom: 10px; color: var(--text);">📊 기본 스탯</h3>
                    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px;">
                        <div class="param">🧠 지력: ${item.parameters.intelligence}</div>
                        <div class="param">💪 체력: ${item.parameters.strength}</div>
                        <div class="param">💖 매력: ${item.parameters.charm}</div>
                        <div class="param">❤️ 애정도: ${affection}</div>
                    </div>
                </div>
                
                <div style="background: var(--bg); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                    <h3 style="font-size: 1rem; margin-bottom: 10px; color: var(--text);">🌈 속성</h3>
                    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px;">
                        <div style="font-size: 0.85rem; padding: 8px; background: var(--card); border-radius: 4px;">🔥 화: ${hiddenAttrs.fire}</div>
                        <div style="font-size: 0.85rem; padding: 8px; background: var(--card); border-radius: 4px;">💧 수: ${hiddenAttrs.water}</div>
                        <div style="font-size: 0.85rem; padding: 8px; background: var(--card); border-radius: 4px;">🌬️ 풍: ${hiddenAttrs.wind}</div>
                        <div style="font-size: 0.85rem; padding: 8px; background: var(--card); border-radius: 4px;">🌱 지: ${hiddenAttrs.earth}</div>
                        <div style="font-size: 0.85rem; padding: 8px; background: var(--card); border-radius: 4px;">✨ 빛: ${hiddenAttrs.light}</div>
                        <div style="font-size: 0.85rem; padding: 8px; background: var(--card); border-radius: 4px;">🌙 암: ${hiddenAttrs.dark}</div>
                    </div>
                </div>
                
                <div style="background: var(--bg); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                    <h3 style="font-size: 1rem; margin-bottom: 10px; color: var(--text);">⏱️ 육성 정보</h3>
                    <div style="font-size: 0.85rem; line-height: 1.6;">
                        <div>☀️ 빛 시간: ${lightMinutes}분</div>
                        <div>🌙 어둠 시간: ${darkMinutes}분</div>
                        <div style="margin-top: 8px; color: #888;">등록 날짜: ${new Date(item.completedAt).toLocaleString('ko-KR')}</div>
                    </div>
                </div>
                
                ${keywordsHtml}
                
                <!-- 연결 섹션 -->
                <div id="breedSection" style="background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1)); padding: 15px; border-radius: 8px; border: 1px solid rgba(102, 126, 234, 0.3);">
                    <h3 style="font-size: 1rem; margin-bottom: 10px; color: var(--text);">🧬 연결</h3>
                    ${canBreed ? `
                        <p style="font-size: 0.85rem; color: #888; margin-bottom: 12px;">이 정령의 코드를 공유해 다른 정령과 연결할 수 있어요.</p>
                        <div style="display: flex; gap: 8px;">
                            <button onclick="openBreedCodeModal(${index})" style="flex: 1; padding: 10px; background: linear-gradient(135deg, #667eea, #764ba2); color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.9rem;">
                                📤 코드 생성
                            </button>
                            <button onclick="openBreedWithCodeModal(${index})" style="flex: 1; padding: 10px; background: linear-gradient(135deg, #11998e, #38ef7d); color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.9rem;">
                                📥 연결하기
                            </button>
                        </div>
                    ` : `
                        <p style="font-size: 0.85rem; color: #e74c3c;">❤️ 애정도 50 이상이어야 연결할 수 있습니다. (현재: ${affection})</p>
                    `}
                </div>
            `;
            
            modal.style.display = 'flex';
        }
        
        // 연결 코드 생성 모달
        function openBreedCodeModal(albumIndex) {
            const item = collection[albumIndex];
            if (!item) return;
            
            // 앨범 아이템에 id가 없으면 생성
            const spiritForCode = {
                ...item,
                id: item.id || `album-${albumIndex}`,
                attributes: item.hiddenAttributes || {},
                albumIndex: albumIndex  // 자기 자신 연결 방지용
            };
            
            const code = encodeSpiritData(spiritForCode);
            
            const modal = document.createElement('div');
            modal.id = 'breedCodeModal';
            const zIndex = getNextZIndex();
            modal.style.cssText = `position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: ${zIndex}; display: flex; justify-content: center; align-items: center;`;
            modal.innerHTML = `
                <div style="background: var(--card); padding: 24px; border-radius: 12px; max-width: 400px; width: 90%; border: 1px solid var(--border);">
                    <h3 style="margin-bottom: 16px;">📤 연결 코드 생성</h3>
                    <div style="text-align: center; margin-bottom: 16px;">
                        <div style="font-size: 2.5rem;">${item.icon}</div>
                        <div style="font-weight: 700;">${item.name}</div>
                    </div>
                    <div style="margin-bottom: 12px;">
                        <input type="text" id="generatedBreedCode" value="${code}" readonly style="width: 100%; padding: 10px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg); color: var(--text); font-family: monospace; font-size: 0.8rem; box-sizing: border-box;">
                    </div>
                    <button onclick="copyGeneratedCode()" style="width: 100%; padding: 12px; background: var(--water); color: white; border: none; border-radius: 6px; cursor: pointer; margin-bottom: 8px;">
                        📋 코드 복사
                    </button>
                    <p style="font-size: 0.8rem; color: #888; text-align: center; margin-bottom: 12px;">📋 코드는 1회만 사용 가능합니다</p>
                    <button onclick="closeBreedCodeModal()" style="width: 100%; padding: 10px; background: var(--card); border: 1px solid var(--border); border-radius: 6px; cursor: pointer;">
                        닫기
                    </button>
                </div>
            `;
            document.body.appendChild(modal);
        }
        
        function copyGeneratedCode() {
            const input = document.getElementById('generatedBreedCode');
            input.select();
            document.execCommand('copy');
            showNotification('📋 코드가 복사되었습니다!');
        }
        
        function closeBreedCodeModal() {
            const modal = document.getElementById('breedCodeModal');
            if (modal) modal.remove();
        }
        
        // 연결하기 모달
        function openBreedWithCodeModal(albumIndex) {
            const item = collection[albumIndex];
            if (!item) return;
            
            const modal = document.createElement('div');
            modal.id = 'breedWithCodeModal';
            const zIndex = getNextZIndex();
            modal.style.cssText = `position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: ${zIndex}; display: flex; justify-content: center; align-items: center;`;
            modal.innerHTML = `
                <div style="background: var(--card); padding: 24px; border-radius: 12px; max-width: 450px; width: 90%; max-height: 80vh; overflow-y: auto; border: 1px solid var(--border);">
                    <h3 style="margin-bottom: 16px;">정령 코드로 연결</h3>
                    <div style="display: flex; align-items: center; gap: 12px; padding: 12px; background: var(--bg); border-radius: 8px; margin-bottom: 16px;">
                        <div style="font-size: 2rem;">${item.icon}</div>
                        <div>
                            <div style="font-weight: 700;">${item.name}</div>
                            <div style="font-size: 0.85rem; color: #888;">내 정령</div>
                        </div>
                    </div>
                    <div style="margin-bottom: 12px;">
                        <input type="text" id="friendBreedCodeInput" placeholder="정령 코드 입력..." style="width: 100%; padding: 12px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg); color: var(--text); font-family: monospace; box-sizing: border-box;">
                    </div>
                    <div id="friendBreedPreview" style="display: none; padding: 12px; background: var(--bg); border-radius: 8px; margin-bottom: 12px;"></div>
                    <div id="breedResultPreview" style="display: none; padding: 12px; background: linear-gradient(135deg, rgba(255,215,0,0.1), rgba(255,255,255,0.05)); border-radius: 8px; margin-bottom: 12px; text-align: center;"></div>
                    <button onclick="executeBreedFromAlbum(${albumIndex})" style="width: 100%; padding: 12px; background: linear-gradient(135deg, #667eea, #764ba2); color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 1rem; margin-bottom: 8px;">
                        🧬 연결하기 (50💰)
                    </button>
                    <p style="font-size: 0.8rem; color: #888; text-align: center; margin-bottom: 12px;">내 정령은 유지되고, 새로운 알이 태어납니다!</p>
                    <button onclick="closeBreedWithCodeModal()" style="width: 100%; padding: 10px; background: var(--card); border: 1px solid var(--border); border-radius: 6px; cursor: pointer;">
                        닫기
                    </button>
                </div>
            `;
            document.body.appendChild(modal);
            
            // 코드 입력 이벤트 리스너
            setTimeout(() => {
                const input = document.getElementById('friendBreedCodeInput');
                if (input) {
                    input.addEventListener('input', () => updateBreedPreviewInModal(albumIndex));
                }
            }, 100);
        }
        
        function closeBreedWithCodeModal() {
            const modal = document.getElementById('breedWithCodeModal');
            if (modal) modal.remove();
        }
        
        function updateBreedPreviewInModal(albumIndex) {
            const item = collection[albumIndex];
            const codeInput = document.getElementById('friendBreedCodeInput');
            const friendPreview = document.getElementById('friendBreedPreview');
            const resultPreview = document.getElementById('breedResultPreview');
            
            const code = codeInput.value.trim();
            if (!code) {
                friendPreview.style.display = 'none';
                resultPreview.style.display = 'none';
                return;
            }
            
            const friendData = decodeSpiritData(code);
            if (!friendData) {
                friendPreview.innerHTML = '❌ 유효하지 않은 코드입니다.';
                friendPreview.style.display = 'block';
                friendPreview.style.color = '#e74c3c';
                resultPreview.style.display = 'none';
                return;
            }
            
            // 자기 자신 체크 - 고유 ID 비교 (ID가 있으면 ID로, 없으면 스탯 비교)
            const isSameSpirit = (myItem, friend) => {
                // 둘 다 ID가 있으면 ID로 비교
                if (myItem.id && friend.id) {
                    return myItem.id === friend.id;
                }
                // ID가 없으면 핵심 데이터로 비교 (하위 호환성)
                return myItem.name === friend.name &&
                       (myItem.originalName || myItem.name) === (friend.originalName || friend.name) &&
                       (myItem.attributeType || myItem.attribute) === friend.attribute &&
                       (myItem.parameters?.intelligence || 0) === (friend.parameters?.intelligence || 0) &&
                       (myItem.parameters?.strength || 0) === (friend.parameters?.strength || 0) &&
                       (myItem.parameters?.charm || 0) === (friend.parameters?.charm || 0);
            };
            
            if (isSameSpirit(item, friendData)) {
                friendPreview.innerHTML = '❌ 자기 자신과는 연결할 수 없습니다.';
                friendPreview.style.display = 'block';
                friendPreview.style.color = '#e74c3c';
                resultPreview.style.display = 'none';
                return;
            }
            
            const attr = ATTRIBUTE_NAMES[friendData.attribute] || ATTRIBUTE_NAMES.normal;
            const friendAttrs = friendData.attributes || {};
            const attrDisplay = [];
            ['fire', 'water', 'wind', 'earth', 'light', 'dark'].forEach(a => {
                if (friendAttrs[a] && friendAttrs[a] > 0) {
                    attrDisplay.push(`${ENV_ICONS[a]}${friendAttrs[a]}`);
                }
            });
            
            const originalNameDisplay = (friendData.originalName && friendData.originalName !== friendData.name) 
                ? `<div style="color: #aaa; font-size: 0.8rem; font-style: italic;">본명: ${friendData.originalName}</div>` 
                : '';
            
            friendPreview.innerHTML = `
                <div style="display: flex; align-items: center; gap: 12px;">
                    <div style="font-size: 2rem;">${attr.icon}</div>
                    <div style="flex: 1;">
                        <div style="font-weight: 700;">✅ ${friendData.name}</div>
                        ${originalNameDisplay}
                        <div style="font-size: 0.85rem; color: #888;">${attr.name}</div>
                        <div style="font-size: 0.85rem; margin-top: 4px;">
                            🧠${friendData.parameters.intelligence} | 💪${friendData.parameters.strength} | 💖${friendData.parameters.charm}
                        </div>
                        ${attrDisplay.length > 0 ? `<div style="font-size: 0.8rem; margin-top: 4px;">${attrDisplay.join(' ')}</div>` : ''}
                    </div>
                </div>
            `;
            friendPreview.style.display = 'block';
            friendPreview.style.color = 'var(--text)';
            
            // 예상 결과 계산
            const mySpirit = {
                ...item,
                attributes: item.hiddenAttributes || {}
            };
            const prediction = predictBreedResult(mySpirit, friendData);
            
            // 예상 상속 스탯
            const inheritParams = {
                intelligence: Math.floor(((item.parameters?.intelligence || 0) + (friendData.parameters?.intelligence || 0)) / 2),
                strength: Math.floor(((item.parameters?.strength || 0) + (friendData.parameters?.strength || 0)) / 2),
                charm: Math.floor(((item.parameters?.charm || 0) + (friendData.parameters?.charm || 0)) / 2)
            };
            
            resultPreview.innerHTML = `
                <div style="font-size: 0.85rem; color: #888; margin-bottom: 8px;">🥚 예상 결과</div>
                <div style="font-size: 2rem;">${prediction.icon}</div>
                <div style="font-weight: 700; margin: 4px 0;">${prediction.name}</div>
                <div style="font-size: 0.8rem; color: ${getRarityColor(prediction.rarity)}; margin-bottom: 8px;">${getRarityText(prediction.rarity)}</div>
                <div style="font-size: 0.8rem; color: #888;">
                    📊 상속 스탯: 🧠${inheritParams.intelligence} | 💪${inheritParams.strength} | 💖${inheritParams.charm}
                </div>
            `;
            resultPreview.style.display = 'block';
        }
        
        async function executeBreedFromAlbum(albumIndex) {
            const item = collection[albumIndex];
            if (!item) return;
            
            const codeInput = document.getElementById('friendBreedCodeInput');
            const breedCode = codeInput.value.trim();
            
            if (!breedCode) {
                showNotification('❌ 정령 코드를 입력해주세요');
                return;
            }
            
            // 정령 슬롯 체크
            if (spirits.length >= 6) {
                showNotification('❌ 정원이 가득 찼습니다! (최대 6마리)');
                return;
            }
            
            // 중복 코드 체크
            const allSpiritsAndAlbum = [...spirits, ...(collection || [])];
            const usedCode = allSpiritsAndAlbum.find(s => s.breedCode === breedCode);
            if (usedCode) {
                showNotification('❌ 이미 사용된 정령 코드입니다!');
                return;
            }
            
            const friendData = decodeSpiritData(breedCode);
            if (!friendData) {
                showNotification('❌ 유효하지 않은 코드입니다');
                return;
            }
            
            // 자기 자신과 연결 방지 - 고유 ID 비교
            const isSameSpirit = (myItem, friend) => {
                // 둘 다 ID가 있으면 ID로 비교
                if (myItem.id && friend.id) {
                    return myItem.id === friend.id;
                }
                // ID가 없으면 핵심 데이터로 비교 (하위 호환성)
                return myItem.name === friend.name &&
                       (myItem.originalName || myItem.name) === (friend.originalName || friend.name) &&
                       (myItem.attributeType || myItem.attribute) === friend.attribute &&
                       (myItem.parameters?.intelligence || 0) === (friend.parameters?.intelligence || 0) &&
                       (myItem.parameters?.strength || 0) === (friend.parameters?.strength || 0) &&
                       (myItem.parameters?.charm || 0) === (friend.parameters?.charm || 0);
            };
            
            if (isSameSpirit(item, friendData)) {
                showNotification('❌ 자기 자신과는 연결할 수 없습니다!');
                return;
            }
            
            if (coins < BREED_COST) {
                showNotification(`❌ 코인이 부족합니다 (필요: ${BREED_COST}💰)`);
                return;
            }
            
            const mySpirit = {
                ...item,
                attributes: item.hiddenAttributes || {}
            };
            const prediction = predictBreedResult(mySpirit, friendData);
            
            // 먼저 모든 창 닫기
            closeBreedWithCodeModal();
            closeAlbumDetail();
            
            const confirmed = await showConfirm('연결 확인',
                `${item.name}와(과) ${friendData.name}을(를) 연결하시겠습니까?\n\n예상 결과: ${prediction.name} (${getRarityText(prediction.rarity)})\n비용: ${BREED_COST}💰`);
            
            if (!confirmed) return;
            
            // 연결 결과 계산 (부모 스탯의 25%씩 = 총 50% 상속)
            const newParams = {
                intelligence: Math.floor(((item.parameters?.intelligence || 0) + (friendData.parameters?.intelligence || 0)) / 4),
                strength: Math.floor(((item.parameters?.strength || 0) + (friendData.parameters?.strength || 0)) / 4),
                charm: Math.floor(((item.parameters?.charm || 0) + (friendData.parameters?.charm || 0)) / 4),
                affection: 0
            };
            
            const myAttrs = item.hiddenAttributes || {};
            const friendAttrs = friendData.attributes || {};
            const newAttrs = {};
            ['fire', 'water', 'wind', 'earth', 'light', 'dark'].forEach(attr => {
                // 부모 속성의 25%씩 = 총 50% 상속
                const avg = Math.floor(((myAttrs[attr] || 0) + (friendAttrs[attr] || 0)) / 4);
                if (avg > 0) newAttrs[attr] = avg;
            });
            
            const isFusionType = prediction.key && FUSION_TYPES[prediction.key];
            const isEventResult = prediction.isEventResult && prediction.eventType;
            
            const timestamp = new Date().toLocaleString('ko-KR', {
                month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit'
            });
            
            const inheritInfo = [];
            if (newParams.intelligence > 0) inheritInfo.push(`🧠${newParams.intelligence}`);
            if (newParams.strength > 0) inheritInfo.push(`💪${newParams.strength}`);
            if (newParams.charm > 0) inheritInfo.push(`💖${newParams.charm}`);
            const attrInfo = Object.entries(newAttrs).map(([k, v]) => `${ENV_ICONS[k]}${v}`).join(' ');
            
            let newSpirit;
            
            if (isEventResult) {
                // 이벤트 정령 연결 결과
                const event = EVENT_TYPES[prediction.eventType];
                newSpirit = {
                    id: Date.now(),
                    name: event.name,
                    originalName: event.name,
                    growth: 0,
                    parameters: newParams,
                    hiddenAttributes: {
                        fire: 0, water: 0, wind: 0, earth: 0, light: 0, dark: 0
                    },
                    satisfaction: 'mid',
                    lastFed: null,
                    lastMusic: null,
                    lastPat: null,
                    lastDecorate: null,
                    lastInteraction: Date.now(),
                    status: '특별한 알이 빛나고 있습니다...',
                    birthTime: Date.now(),
                    logs: [
                        { time: timestamp, message: `🎄 ${item.name}와(과) ${friendData.name}의 연결로 특별한 알이 태어났습니다!` },
                        { time: timestamp, message: `📊 부모에게서 물려받은 능력: ${inheritInfo.join(' ')}` }
                    ],
                    lightTime: 0,
                    darkTime: 0,
                    musicListened: 0,
                    feedCount: 0,
                    bredWith: friendData.name,
                    breedCode: breedCode,
                    isBred: true,
                    isEventSpirit: true,
                    eventType: prediction.eventType
                };
            } else {
                // 일반 연결 결과
                const breedEggName = `${item.name}와${friendData.name}의 알`;
                newSpirit = {
                    id: Date.now(),
                    name: breedEggName,
                    originalName: null,
                    growth: 0,
                    parameters: newParams,
                    hiddenAttributes: {
                        fire: newAttrs.fire || 0,
                        water: newAttrs.water || 0,
                        wind: newAttrs.wind || 0,
                        earth: newAttrs.earth || 0,
                        light: newAttrs.light || 0,
                        dark: newAttrs.dark || 0
                    },
                    satisfaction: 'mid',
                    lastFed: null,
                    lastMusic: null,
                    lastPat: null,
                    lastDecorate: null,
                    lastInteraction: Date.now(),
                    status: '알이 따뜻합니다...',
                    birthTime: Date.now(),
                    logs: [
                        { time: timestamp, message: `🔗 ${item.name}와(과) ${friendData.name}의 연결로 태어났습니다.` },
                        { time: timestamp, message: `📊 부모에게서 물려받은 능력: ${inheritInfo.join(' ')} ${attrInfo}` }
                    ],
                    lightTime: 0,
                    darkTime: 0,
                    musicListened: 0,
                    feedCount: 0,
                    bredWith: friendData.name,
                    breedCode: breedCode,
                    fusionType: prediction.key || null,
                    fusionRarity: prediction.rarity || 'common',
                    isBred: true
                };
            }
            
            spirits.push(newSpirit);
            coins -= BREED_COST;
            
            if (isFusionType && prediction.key) {
                if (!encyclopedia[prediction.key]) {
                    encyclopedia[prediction.key] = 1;
                    showNotification(`🎉 새로운 연결 정령 "${prediction.name}" 도감 등록!`);
                } else {
                    encyclopedia[prediction.key]++;
                }
            }
            
            saveGame();
            renderSpirits();
            updateCoinDisplay();
            
            showNotification(`🎉 연결 성공! ${newSpirit.name}이(가) 태어났습니다!`);
            switchTab('garden');
        }
        
        function closeAlbumDetail() {
            const modal = document.getElementById('albumDetailModal');
            modal.style.display = 'none';
        }

        function applyGrowth() {
            if (isPaused) return; // 일시정지 중이면 성장 안 함
            if (tutorialActive) return; // 첫 튜토리얼 중이면 성장 안 함
            
            spirits.forEach(spirit => {
                if (spirit.isDead || spirit.isCompleted) return;
                
                // 질병 상태면 성장 멈춤
                if (spirit.isSick) return;

                // 성장도 +1
                const previousGrowth = spirit.growth;
                let growthAmount = 1;
                
                spirit.growth += growthAmount;

                console.log(`Spirit ${spirit.name}: growth ${previousGrowth} → ${spirit.growth}`);

                // 성충 체크 (100 이상이면 무조건 완료)
                if (spirit.growth >= STAGE_REQUIREMENTS.adult) {
                    console.log(`Completing spirit ${spirit.name} with growth ${spirit.growth}`);
                    completeSpirit(spirit);
                }
            });

            saveGame();
            updateAllSpiritCards();
        }

        function applyTerrariumGrowth() {
            if (isPaused) return; // 일시정지 중이면 실행 안 함
            if (tutorialActive) return; // 첫 튜토리얼 중이면 실행 안 함
            
            spirits.forEach(spirit => {
                if (spirit.isDead || spirit.isCompleted) return;  // 죽었거나 완성된 정령 제외

                // 조명 누적 시간 추가 (300초 = 5분)
                if (!spirit.lightTime) spirit.lightTime = 0;
                if (!spirit.darkTime) spirit.darkTime = 0;
                
                if (lightMode) {
                    spirit.lightTime += 300;
                } else {
                    spirit.darkTime += 300;
                }

                // 정령의 숨겨진 속성에 테라리움 환경값 추가
                if (!spirit.hiddenAttributes) {
                    spirit.hiddenAttributes = {
                        fire: 0, water: 0, wind: 0, earth: 0, light: 0, dark: 0
                    };
                }

                // 테라리움의 각 속성값만큼 정령의 속성 증가 (최대 500)
                Object.keys(terrarium).forEach(attr => {
                    if (terrarium[attr] > 0) {
                        spirit.hiddenAttributes[attr] = Math.min(500, spirit.hiddenAttributes[attr] + terrarium[attr]);
                    }
                });
                
                // 질병 체크 (5분마다, 이미 아프지 않은 경우)
                if (!spirit.isSick) {
                    checkForDisease(spirit);
                }
            });
            
            // 정령 관계 업데이트 (5분마다)
            updateSpiritRelationships();

            saveGame();
            updateAllSpiritCards();
        }
        
        // 정령 관계 업데이트 (5분마다 호출)
        function updateSpiritRelationships() {
            // 살아있고 완성되지 않은 정령들만 (알, 번데기, 성충 제외)
            const activeSpirits = spirits.filter(s => {
                if (s.isDead || s.isCompleted) return false;
                const stage = getStage(s.growth);
                // 알(egg), 번데기(pupa), 성충(adult)는 제외 - 애벌레만 관계 형성
                return stage === 'larva1' || stage === 'larva2' || stage === 'larva3';
            });
            
            if (activeSpirits.length < 2) return;
            
            // 각 정령 쌍에 대해 관계 업데이트
            for (let i = 0; i < activeSpirits.length; i++) {
                for (let j = i + 1; j < activeSpirits.length; j++) {
                    const spirit1 = activeSpirits[i];
                    const spirit2 = activeSpirits[j];
                    
                    // relationships 초기화
                    if (!spirit1.relationships) spirit1.relationships = {};
                    if (!spirit2.relationships) spirit2.relationships = {};
                    
                    // 현재 관계 수치 가져오기
                    const currentRel1 = spirit1.relationships[spirit2.id] || 0;
                    const currentRel2 = spirit2.relationships[spirit1.id] || 0;
                    
                    // 화해의 꽃 효과 체크 (싸움 방지용)
                    const now = Date.now();
                    const spirit1HasReconciliation = spirit1.reconciliationUntil && spirit1.reconciliationUntil > now;
                    const spirit2HasReconciliation = spirit2.reconciliationUntil && spirit2.reconciliationUntil > now;
                    const hasReconciliationEffect = spirit1HasReconciliation || spirit2HasReconciliation;
                    
                    // 지력 10 이하면 싸움 확률 20% (화해의 꽃 효과가 있으면 싸움 안 함)
                    const spirit1LowInt = (spirit1.parameters?.intelligence || 0) <= 10;
                    const spirit2LowInt = (spirit2.parameters?.intelligence || 0) <= 10;
                    
                    if ((spirit1LowInt || spirit2LowInt) && !hasReconciliationEffect && Math.random() < 0.2) {
                        // 싸움 발생! 관계 감소
                        const fightDamage = Math.floor(Math.random() * 5) + 1; // -1 ~ -5
                        const newRel1 = Math.max(-100, currentRel1 - fightDamage);
                        const newRel2 = Math.max(-100, currentRel2 - fightDamage);
                        
                        spirit1.relationships[spirit2.id] = newRel1;
                        spirit2.relationships[spirit1.id] = newRel2;
                        
                        // 앙숙 이벤트 (둘 다 0 미만 도달 시)
                        if (currentRel1 >= 0 && newRel1 < 0 && newRel2 < 0) {
                            showNotification(`${spirit1.name}와(과) ${spirit2.name}이(가) 앙숙이 되었습니다!`);
                            addLog(spirit1, `${spirit2.name}와(과) 앙숙이 되었습니다.`);
                            addLog(spirit2, `${spirit1.name}와(과) 앙숙이 되었습니다.`);
                        }
                        
                        // 싸움 알림 (가끔만)
                        if (Math.random() < 0.3) {
                            const troublemaker = spirit1LowInt ? spirit1 : spirit2;
                            const other = spirit1LowInt ? spirit2 : spirit1;
                            showNotification(`${troublemaker.name}이(가) ${other.name}와(과) 다퉜습니다!`);
                            addLog(troublemaker, `${other.name}와(과) 다퉜습니다. (지력 부족)`);
                            addLog(other, `${troublemaker.name}와(과) 다퉜습니다.`);
                        }
                        continue; // 싸우면 호감도 증가 스킵
                    }
                    
                    // 관계 변화량 (함께 있으면 자연스럽게 친해짐)
                    let change = Math.floor(Math.random() * 5) + 4; // +4 ~ +8
                    
                    // 매력 50 이상이면 호감도 증가량 보너스 (1.5배)
                    const spirit1HighCharm = (spirit1.parameters?.charm || 0) >= 50;
                    const spirit2HighCharm = (spirit2.parameters?.charm || 0) >= 50;
                    
                    if (spirit1HighCharm || spirit2HighCharm) {
                        change = Math.floor(change * 1.5);
                        // 매력 보너스 알림 (낮은 확률)
                        if (Math.random() < 0.05) {
                            const charmer = spirit1HighCharm ? spirit1 : spirit2;
                            const other = spirit1HighCharm ? spirit2 : spirit1;
                            addLog(charmer, `✨ ${other.name}에게 매력을 발산했습니다!`);
                        }
                    }
                    
                    // 아카시아 꿀 효과 체크 (30분간 지속) - 호감도 증가량 2배
                    const spirit1HasHoney = spirit1.acaciaHoneyUntil && spirit1.acaciaHoneyUntil > now;
                    const spirit2HasHoney = spirit2.acaciaHoneyUntil && spirit2.acaciaHoneyUntil > now;
                    
                    if (spirit1HasHoney || spirit2HasHoney) {
                        change = Math.floor(change * 2);
                        
                        // 둘 다 효과가 있으면 추가 보너스 (총 3배)
                        if (spirit1HasHoney && spirit2HasHoney) {
                            change = Math.floor(change * 1.5);
                        }
                    }
                    
                    // 관계 수치 업데이트 (범위: -100 ~ 100)
                    const newRel1 = Math.min(100, currentRel1 + change);
                    const newRel2 = Math.min(100, currentRel2 + change);
                    
                    spirit1.relationships[spirit2.id] = newRel1;
                    spirit2.relationships[spirit1.id] = newRel2;
                    
                    // 앙숙 해제 이벤트 (둘 다 음수였는데 둘 다 0 이상이 됨)
                    if (currentRel1 < 0 && currentRel2 < 0 && newRel1 >= 0 && newRel2 >= 0) {
                        showNotification(`🌼 ${spirit1.name}와(과) ${spirit2.name}이(가) 서로의 사과를 받아주었습니다.`);
                        addLog(spirit1, `🌼 ${spirit2.name}와(과) 화해했습니다.`);
                        addLog(spirit2, `🌼 ${spirit1.name}와(과) 화해했습니다.`);
                    }
                    
                    // 이미 bond가 있으면 이벤트 스킵
                    const hasBond1 = spirit1.bond && spirit1.bond.partnerId;
                    const hasBond2 = spirit2.bond && spirit2.bond.partnerId;
                    
                    // 짝꿍 이벤트 (둘 다 35 이상 도달 시, bond 없을 때만)
                    if (!hasBond1 && !hasBond2 && currentRel1 < 35 && newRel1 >= 35 && newRel2 >= 35) {
                        // 이미 연모인 경우 알림 안 함
                        if (newRel1 < 55 && newRel2 < 55) {
                            // 영구 관계 기록
                            spirit1.bond = { type: 'bestfriend', partnerId: spirit2.id };
                            spirit2.bond = { type: 'bestfriend', partnerId: spirit1.id };
                            
                            showNotification(`💕 ${spirit1.name}와(과) ${spirit2.name}이(가) 짝꿍이 되었습니다!`);
                            addLog(spirit1, `💕 ${spirit2.name}와(과) 짝꿍이 되었습니다!`);
                            addLog(spirit2, `💕 ${spirit1.name}와(과) 짝꿍이 되었습니다!`);
                        }
                    }
                    
                    // 연모 이벤트 (둘 다 55 이상 도달 시)
                    // 기존 짝꿍에서 연모으로 승급 가능
                    const areBestFriends = spirit1.bond?.type === 'bestfriend' && spirit1.bond?.partnerId === spirit2.id;
                    if (currentRel1 < 55 && newRel1 >= 55 && newRel2 >= 55) {
                        if (areBestFriends || (!hasBond1 && !hasBond2)) {
                            // 영구 관계 기록 (연모으로 승급)
                            spirit1.bond = { type: 'lover', partnerId: spirit2.id };
                            spirit2.bond = { type: 'lover', partnerId: spirit1.id };
                            
                            showNotification(`💗 ${spirit1.name}와(과) ${spirit2.name} 사이에 연모이 싹텄습니다!`);
                            addLog(spirit1, `💗 ${spirit2.name}에게 연모을 느끼고 있습니다...`);
                            addLog(spirit2, `💗 ${spirit1.name}에게 연모을 느끼고 있습니다...`);
                        }
                    }
                }
            }
        }
        
        // 연모 관계인 정령 찾기 (bond 기반)
        function getLover(spirit) {
            // bond가 있고 타입이 lover인 경우
            if (spirit.bond && spirit.bond.type === 'lover' && spirit.bond.partnerId) {
                const lover = spirits.find(s => s.id === spirit.bond.partnerId && !s.isDead && !s.isCompleted);
                return lover || null;
            }
            return null;
        }
        
        // 짝꿍 관계인 정령 찾기 (bond 기반)
        function getBestFriend(spirit) {
            // bond가 있고 타입이 bestfriend인 경우
            if (spirit.bond && spirit.bond.type === 'bestfriend' && spirit.bond.partnerId) {
                const bestFriend = spirits.find(s => s.id === spirit.bond.partnerId && !s.isDead && !s.isCompleted);
                return bestFriend || null;
            }
            return null;
        }
        
        // 병균 침입 체크 함수 (미니어처 10개 초과 시 5% 확률)
        function checkGermInvasion() {
            // 미니어처 10개 이하면 체크 안 함
            if (installedDecorations.length <= 10) return;
            
            // 5% 확률
            if (Math.random() > 0.05) return;
            
            // 감염 대상: 체력 50 미만 (강한 키워드 없는) 정령들
            const vulnerableSpirits = spirits.filter(s => 
                !s.isDead && 
                !s.isCompleted && 
                !s.isSick && 
                s.parameters.strength < 50 &&
                getStage(s.growth) !== 'egg' // 알은 제외
            );
            
            if (vulnerableSpirits.length === 0) {
                // 모든 정령이 면역이면 팝업만 표시
                showGermInvasionPopup(0);
                return;
            }
            
            // 취약한 정령들에게 질병 부여
            vulnerableSpirits.forEach(spirit => {
                spirit.isSick = true;
                spirit.sickTime = Date.now();
                spirit.status = `${spirit.name}이(가) 병균에 감염되었습니다... 🦠`;
                addLog(spirit, '🦠 테라리움에 침입한 병균에 감염되었습니다!');
            });
            
            saveGame();
            renderSpirits();
            
            // 병균 침입 팝업 표시
            showGermInvasionPopup(vulnerableSpirits.length);
        }
        
        // 병균 침입 팝업
        function showGermInvasionPopup(infectedCount) {
            const existingPopup = document.getElementById('germInvasionPopup');
            if (existingPopup) existingPopup.remove();
            
            let message = '';
            if (infectedCount === 0) {
                message = `
                    <div style="color: #4CAF50; font-size: 1.1rem;">
                        ✅ 모든 정령이 병균을 이겨냈습니다!
                    </div>
                `;
            } else {
                message = `
                    <div style="color: #f44336; font-size: 1.1rem; margin-bottom: 15px;">
                        ⚠️ ${infectedCount}마리의 정령이 감염되었습니다!
                    </div>
                    <div style="color: #888; font-size: 0.9rem;">
                        약초로 치료해주세요!
                    </div>
                `;
            }
            
            const popup = document.createElement('div');
            popup.id = 'germInvasionPopup';
            popup.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
            `;
            popup.innerHTML = `
                <div style="background: var(--card); padding: 30px; border-radius: 16px; max-width: 400px; text-align: center; border: 3px solid #f44336;">
                    <div style="font-size: 4rem; margin-bottom: 15px;">🦠</div>
                    <p style="color: var(--text); font-size: 1rem; margin-bottom: 20px;">
                        테라리움에 병균이 침입하여<br>오염되었습니다!
                    </p>
                    ${message}
                    <button onclick="document.getElementById('germInvasionPopup').remove()" style="
                        margin-top: 20px;
                        padding: 12px 30px;
                        background: #f44336;
                        color: white;
                        border: none;
                        border-radius: 8px;
                        font-size: 1rem;
                        font-weight: 600;
                        cursor: pointer;
                    ">확인</button>
                </div>
            `;
            document.body.appendChild(popup);
        }
        
        // 질병 체크 함수
        function checkForDisease(spirit) {
            // 이미 아프면 체크 안 함
            if (spirit.isSick) return;
            
            // 체력 50 이상이면 "강한" 효과: 질병 면역
            if (spirit.parameters.strength >= 50) return;
            
            let probability = 0;
            let reason = '';
            
            // 조건 1: 체력 5 이하 → 10% 확률
            if (spirit.parameters.strength <= 5) {
                probability = 0.1;
                reason = '체력이 약해 병에 걸렸습니다';
            }
            
            // 조건 2: 속성 불균형 (최고 속성 50 이상 & 최저 속성 10 이하) → 10% 확률
            if (probability === 0) {
                const attrs = spirit.hiddenAttributes || { fire: 0, water: 0, wind: 0, earth: 0, light: 0, dark: 0 };
                const attrValues = Object.values(attrs);
                const maxAttr = Math.max(...attrValues);
                const minAttr = Math.min(...attrValues);
                
                if (maxAttr >= 50 && minAttr <= 10) {
                    probability = 0.1;
                    reason = '속성 불균형으로 인해 병에 걸렸습니다';
                }
            }
            
            // 조건 3: 30분 이상 상호작용 없음 → 20% 확률
            if (probability === 0) {
                const now = Date.now();
                const lastFeed = spirit.lastFed || spirit.birthTime;
                const lastMusic = spirit.lastMusic || spirit.birthTime;
                const lastPat = spirit.lastPat || spirit.birthTime;
                
                const lastInteraction = Math.max(lastFeed, lastMusic, lastPat);
                const minutesSinceInteraction = (now - lastInteraction) / 1000 / 60;
                
                if (minutesSinceInteraction >= 30) {
                    probability = 0.2;
                    reason = '오랫동안 돌봄을 받지 못해 병에 걸렸습니다';
                }
            }
            
            // 조건별 확률로 질병 발생
            if (probability > 0 && Math.random() < probability) {
                spirit.isSick = true;
                spirit.sickTime = Date.now();
                spirit.status = `${spirit.name}이(가) 아파 보입니다... 🤒`;
                addLog(spirit, reason);
                showNotification(`${spirit.name}이(가) 병에 걸렸습니다!`);
                
                // 첫 질병 시 튜토리얼 시작
                if (!localStorage.getItem('spiritGarden_sickTutorialSeen')) {
                    setTimeout(() => {
                        startSickTutorial();
                    }, 1000);
                }
            }
        }

        function checkSpiritStatus() {
            // 첫 튜토리얼 중에는 상태 체크 안 함
            if (tutorialActive) return;
            
            const now = Date.now();
            spirits.forEach(spirit => {
                if (!spirit.lastFed) {
                    spirit.lastFed = spirit.birthTime;
                }

                const timeSinceLastFed = now - spirit.lastFed;
                const hours = timeSinceLastFed / 1000 / 60 / 60;

                // 24시간 경과 - 사망만 체크 (배고픔 메시지는 getRandomMessage에서 처리)
                if (hours >= 24) {
                    if (getStage(spirit.growth) === 'egg') {
                        spirit.status = '❌ 알이 깨져서 미동이 없습니다...';
                        spirit.isDead = true;
                    } else {
                        spirit.status = '❌ 테라리움 밖으로 나가 사라졌습니다...';
                        spirit.isDead = true;
                    }
                }
            });
        }

        function updateAllSpiritCards() {
            // 정령별 불만 상태 지속 시간 체크
            updateLowSatisfactionTimer();
            
            spirits.forEach(spirit => {
                updateSpiritCard(spirit);
            });
        }

        // 쿨타임 텍스트만 업데이트 (성능 최적화)
        function updateCooldownDisplay() {
            if (currentTab !== 'garden' || isPaused) return;
            
            const now = Date.now();
            spirits.forEach((spirit, index) => {
                const cards = document.querySelectorAll('.spirit-card');
                const card = cards[index];
                if (!card) return;
                
                // 버튼들 찾기
                const buttons = card.querySelectorAll('button');
                buttons.forEach(button => {
                    const text = button.textContent;
                    
                    // 먹이주기 버튼
                    if (text.includes('먹이주기')) {
                        const canFeed = !isPaused && canDoAction(spirit, 'feed') && !spirit.isDead;
                        if (!canFeed && spirit.lastFeed) {
                            const remaining = Math.max(0, Math.ceil((10000 - (now - spirit.lastFeed)) / 1000));
                            button.textContent = `${spirit.isSick ? '🤢 ' : ''}먹이주기 (${remaining}초)`;
                        } else if (canFeed) {
                            button.textContent = `${spirit.isSick ? '🤢 ' : ''}먹이주기`;
                        }
                    }
                    
                    // 음악 듣기 버튼
                    if (text.includes('음악 듣기')) {
                        const canMusic = !isPaused && canDoAction(spirit, 'music') && !spirit.isDead;
                        if (!canMusic && spirit.lastMusic) {
                            const remaining = Math.max(0, Math.ceil((10000 - (now - spirit.lastMusic)) / 1000));
                            button.textContent = `음악 듣기 (${remaining}초)`;
                        } else if (canMusic) {
                            button.textContent = `음악 듣기`;
                        }
                    }
                    
                    // 쓰다듬기 버튼
                    if (text.includes('쓰다듬기')) {
                        const canPat = !isPaused && canDoAction(spirit, 'pat') && !spirit.isDead;
                        if (!canPat && spirit.lastPat) {
                            const remaining = Math.max(0, Math.ceil((10000 - (now - spirit.lastPat)) / 1000));
                            button.textContent = `쓰다듬기 (${remaining}초)`;
                        } else if (canPat) {
                            button.textContent = `쓰다듬기`;
                        }
                    }
                });
            });
        }

        function updateSpiritCard(spirit) {
            const cards = document.querySelectorAll('.spirit-card');
            const index = spirits.findIndex(s => s.id === spirit.id);
            if (index === -1 || !cards[index]) return;

            const card = cards[index];
            const stage = getStage(spirit.growth);
            const nextReq = getNextStageRequirement(spirit.growth);
            const progress = (spirit.growth / nextReq) * 100;
            
            const canFeed = canDoAction(spirit, 'feed') && !spirit.isDead;
            const canMusic = canDoAction(spirit, 'music') && !spirit.isDead;
            const canPat = canDoAction(spirit, 'pat') && !spirit.isDead;

            let icon = STAGE_ICONS[stage];
            
            // 이벤트 정령 아이콘
            if (spirit.isEventSpirit && spirit.eventType) {
                const eventIcon = getEventStageIcon(spirit);
                if (eventIcon) icon = eventIcon;
            }
            // 일반 진화 아이콘
            else if (stage === 'adult' && spirit.evolutionType) {
                const evolutionData = EVOLUTION_TYPES[spirit.evolutionType];
                if (evolutionData) {
                    icon = evolutionData.icon;
                }
            }
            if (spirit.isDead) {
                icon = stage === 'egg' ? '💔' : '👻';
            }

            // 아이콘 업데이트
            const iconElement = card.querySelector('.spirit-icon');
            if (iconElement && iconElement.innerHTML !== icon) {
                iconElement.innerHTML = icon;
            }

            // 이름 업데이트
            const nameElement = card.querySelector('.spirit-name');
            if (nameElement && nameElement.textContent !== spirit.name) {
                nameElement.textContent = spirit.name;
            }

            // 스테이지 업데이트
            const stageElement = card.querySelector('.spirit-stage');
            if (stageElement) {
                stageElement.textContent = STAGE_NAMES[stage];
            }

            // 진행도 업데이트
            const progressFill = card.querySelector('.progress-fill');
            if (progressFill) {
                progressFill.style.width = `${Math.min(progress, 100)}%`;
            }

            const progressText = card.querySelector('.progress-text');
            if (progressText) {
                progressText.textContent = `성장 ${spirit.growth} / ${nextReq}`;
            }

            // 파라미터 업데이트
            const params = card.querySelectorAll('.param');
            if (params.length >= 4) {
                params[0].innerHTML = `<span class="param-icon">🧠</span>지력 ${spirit.parameters.intelligence}`;
                params[1].innerHTML = `<span class="param-icon">💪</span>체력 ${spirit.parameters.strength}`;
                params[2].innerHTML = `<span class="param-icon">💖</span>매력 ${spirit.parameters.charm}`;
                params[3].innerHTML = `<span class="param-icon">❤️</span>애정 ${spirit.parameters.affection}`;
            }

            // 상태 메시지 업데이트
            const statusElement = card.querySelector('.spirit-status');
            if (statusElement) {
                statusElement.textContent = spirit.status;
            }

            // 버튼 상태 업데이트
            const actionButtons = card.querySelector('.action-buttons');
            if (actionButtons) {
                const buttons = actionButtons.querySelectorAll('button');
                if (buttons.length >= 4) {
                    buttons[0].disabled = !canFeed;
                    buttons[1].disabled = !canMusic;
                    buttons[2].disabled = !canPat;
                    // buttons[3]는 보내기 버튼이므로 항상 활성화
                }
            }
        }

        function toggleLogs(spiritId) {
            const logsDiv = document.getElementById(`logs${spiritId}`);
            const toggleIcon = document.getElementById(`logToggle${spiritId}`);
            
            if (logsDiv.style.display === 'none') {
                logsDiv.style.display = 'block';
                toggleIcon.textContent = '▲';
            } else {
                logsDiv.style.display = 'none';
                toggleIcon.textContent = '▼';
            }
        }

        function renderSpirits() {
            const grid = document.getElementById('spiritsGrid');
            const now = Date.now(); // 쿨타임 계산용
            
            if (spirits.length === 0) {
                grid.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-icon">🥚</div>
                        <div>아직 정령이 없습니다<br>새로운 알을 받아보세요</div>
                    </div>
                `;
                return;
            }

            grid.innerHTML = spirits.map(spirit => {
                const stage = getStage(spirit.growth);
                const nextReq = getNextStageRequirement(spirit.growth);
                const progress = (spirit.growth / nextReq) * 100;
                
                const canFeed = !isPaused && canDoAction(spirit, 'feed') && !spirit.isDead;
                const canMusic = !isPaused && canDoAction(spirit, 'music') && !spirit.isDead;
                const canPat = !isPaused && canDoAction(spirit, 'pat') && !spirit.isDead;

                let icon = STAGE_ICONS[stage];
                
                // 이벤트 정령 아이콘
                if (spirit.isEventSpirit && spirit.eventType) {
                    const eventIcon = getEventStageIcon(spirit);
                    if (eventIcon) icon = eventIcon;
                }
                // 일반 진화 아이콘
                else if (stage === 'adult' && spirit.evolutionType) {
                    const evolutionData = EVOLUTION_TYPES[spirit.evolutionType];
                    if (evolutionData) {
                        icon = evolutionData.icon;
                    }
                }
                if (spirit.isDead) {
                    icon = stage === 'egg' ? '💔' : '👻';
                }

                // 하위 호환성을 위한 파라미터 체크
                if (!spirit.parameters.affection && spirit.parameters.mystery !== undefined) {
                    spirit.parameters.affection = spirit.parameters.mystery;
                    delete spirit.parameters.mystery;
                }
                if (!spirit.hiddenAttributes) {
                    spirit.hiddenAttributes = {
                        fire: 0, water: 0, wind: 0, earth: 0, light: 0, dark: 0
                    };
                }
                if (!spirit.logs) {
                    spirit.logs = [];
                }
                if (!spirit.lightTime) {
                    spirit.lightTime = 0;
                }
                if (!spirit.darkTime) {
                    spirit.darkTime = 0;
                }
                if (!spirit.musicListened) {
                    spirit.musicListened = 0;
                }
                if (!spirit.feedCount) {
                    spirit.feedCount = 0;
                }
                
                // 완성된 정령인 경우 특별한 카드 표시
                if (spirit.isCompleted && spirit.evolutionData) {
                    // 이미지 아이콘인 경우 원본 사이즈로 표시
                    const evolutionIcon = spirit.evolutionData.icon && spirit.evolutionData.icon.includes('<img') 
                        ? spirit.evolutionData.icon.replace(/width:\d+px;height:(auto|\d+px)/g, 'width:auto;height:auto')
                        : spirit.evolutionData.icon;
                    
                    return `
                        <div class="spirit-card" style="background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%); border: 3px solid #ffa500;">
                            <div style="text-align: center; padding: 20px;">
                                <div style="font-size: 4rem; margin-bottom: 15px;">${evolutionIcon}</div>
                                <div style="font-size: 1.3rem; font-weight: 700; color: #333; margin-bottom: 10px;">
                                    🎉 번데기에서 정령이 부화했습니다! 🎉
                                </div>
                                <div style="font-size: 1rem; color: #555; margin-bottom: 8px;">
                                    ${spirit.name} → ${spirit.evolutionData.name}
                                </div>
                                <div style="font-size: 0.9rem; color: #666; margin-bottom: 20px;">
                                    애정도: ${spirit.parameters.affection || 0}
                                </div>
                                <button onclick="confirmEvolution(${spirit.id})" style="
                                    background: #ff6b6b;
                                    color: white;
                                    border: none;
                                    padding: 15px 30px;
                                    font-size: 1.1rem;
                                    font-weight: 700;
                                    border-radius: 8px;
                                    cursor: pointer;
                                    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
                                ">
                                    확인하기
                                </button>
                            </div>
                        </div>
                    `;
                }
                // 외형 묘사 가져오기
                const appearance = getAppearanceDescription(spirit);

                return `
                    <div class="spirit-card" style="position: relative;">
                        ${(() => {
                            const satisfaction = spirit.satisfaction || 'mid';
                            const satisfactionIcons = { high: '', mid: '', low: '' };
                            const satisfactionTexts = { high: '만족', mid: '보통', low: '불만' };
                            const satisfactionColors = { high: '#4caf50', mid: '#ff9800', low: '#f44336' };
                            return `
                                <div style="position: absolute; top: 12px; right: 12px; display: flex; align-items: center; gap: 4px; padding: 4px 8px; background: ${satisfactionColors[satisfaction]}22; border: 1px solid ${satisfactionColors[satisfaction]}; border-radius: 12px; font-size: 0.75rem;">
                                    <span style="font-size: 1rem;">${satisfactionIcons[satisfaction]}</span>
                                    <span style="font-weight: 600; color: ${satisfactionColors[satisfaction]};">${satisfactionTexts[satisfaction]}</span>
                                </div>
                            `;
                        })()}
                        <div class="spirit-header">
                            <div class="spirit-icon">${icon}</div>
                            <div class="spirit-info">
                                <div class="spirit-name" onclick="changeName(${spirit.id})">${spirit.name}</div>
                                <div class="spirit-stage">${STAGE_NAMES[stage]}</div>
                                ${appearance ? `<div style="font-size: 0.8rem; color: #666; margin-top: 6px; line-height: 1.4;">${appearance}</div>` : ''}
                            </div>
                        </div>
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: ${Math.min(progress, 100)}%"></div>
                        </div>
                        <div class="progress-text">성장 ${spirit.growth} / ${nextReq}</div>
                        <div class="parameters">
                            <div class="param"><span class="param-icon">🧠</span>지력 ${spirit.parameters.intelligence}</div>
                            <div class="param"><span class="param-icon">💪</span>체력 ${spirit.parameters.strength}</div>
                            <div class="param"><span class="param-icon">💖</span>매력 ${spirit.parameters.charm}</div>
                            <div class="param"><span class="param-icon">❤️</span>애정 ${spirit.parameters.affection}</div>
                        </div>
                        ${(() => {
                            const foodAttrs = spirit.hiddenAttributes || { fire: 0, water: 0, wind: 0, earth: 0, light: 0, dark: 0 };
                            const terrariumAttrs = terrarium || { fire: 0, water: 0, wind: 0, earth: 0, light: 0, dark: 0 };
                            // 최종 속성 = (먹이 × 0.7) + (테라리움 × 0.3)
                            const attrs = {};
                            for (let attr in foodAttrs) {
                                attrs[attr] = (foodAttrs[attr] * 0.7) + (terrariumAttrs[attr] * 0.3);
                            }
                            const attrIcons = { fire: '🔥', water: '💧', wind: '🌬️', earth: '🌱', light: '✨', dark: '🌙' };
                            const attrNames = { fire: '불', water: '물', wind: '바람', earth: '땅', light: '빛', dark: '어둠' };
                            const attrValues = Object.values(attrs);
                            const maxAttr = Math.max(...attrValues);
                            const minAttr = Math.min(...attrValues);
                            const isImbalanced = maxAttr >= 50 && minAttr <= 10;
                            
                            return `
                                <div style="margin: 8px 0; padding: 8px; background: var(--bg); border: 1px solid ${isImbalanced ? '#f44336' : 'var(--border)'}; border-radius: 8px;">
                                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                                        <span style="font-size: 0.8rem; font-weight: 600; color: var(--text-muted);">속성 (먹이+환경)</span>
                                        ${isImbalanced ? '<span style="font-size: 0.75rem; color: #f44336; font-weight: 600;">⚠️ 불균형</span>' : ''}
                                    </div>
                                    <div style="display: grid; grid-template-columns: repeat(6, 1fr); gap: 4px; text-align: center;">
                                        ${Object.entries(attrs).map(([key, val]) => {
                                            const isMax = val === maxAttr && maxAttr > 0;
                                            const isLow = isImbalanced && val < 10; // 불균형 시 10 미만은 빨간색
                                            const isPerfect = val >= 90;
                                            return `
                                                <div style="font-size: 0.75rem; ${isPerfect ? 'color: #ff6f00; font-weight: 700;' : isLow ? 'color: #f44336; font-weight: 700;' : isMax ? 'color: #4caf50; font-weight: 700;' : ''}">
                                                    <div>${attrIcons[key]}</div>
                                                    <div>${Math.floor(val)}</div>
                                                </div>
                                            `;
                                        }).join('')}
                                    </div>
                                </div>
                            `;
                        })()}
                        ${(() => {
                            const keywords = getStatusKeywords(spirit);
                            if (keywords.length === 0) return '';
                            return `
                                <div style="margin: 12px 0; padding: 10px; background: var(--bg); border: 1px solid var(--border); display: flex; flex-wrap: wrap; gap: 6px;">
                                    ${keywords.map((kw, idx) => `
                                        <span 
                                            class="keyword-tag"
                                            title="${kw.desc || ''}"
                                            onclick="showKeywordDesc('${kw.text.replace(/'/g, "\\'")}', '${(kw.desc || '').replace(/'/g, "\\'")}')"
                                            style="
                                                display: inline-flex;
                                                align-items: center;
                                                padding: 4px 10px;
                                                background: #f5f5f5;
                                                border: 1px solid #ddd;
                                                font-size: 0.8rem;
                                                font-weight: 600;
                                                color: ${kw.color};
                                                cursor: pointer;
                                                transition: all 0.2s;
                                            "
                                            onmouseover="this.style.background='#e8e8e8'; this.style.transform='scale(1.02)';"
                                            onmouseout="this.style.background='#f5f5f5'; this.style.transform='scale(1)';"
                                        >
                                            ${kw.text}
                                        </span>
                                    `).join('')}
                                </div>
                            `;
                        })()}
                        <div class="spirit-status">${spirit.status}</div>
                        ${spirit.logs && spirit.logs.length > 0 ? `
                            <div style="margin-top: 6px; margin-bottom: 16px; border-top: 1px solid var(--border); padding-top: 6px;">
                                <div style="display: flex; justify-content: space-between; align-items: center; cursor: pointer; padding: 8px; background: var(--bg); border-radius: 6px;" onclick="toggleLogs(${spirit.id})">
                                    <span style="font-size: 0.9rem; font-weight: 600;">일지 (${spirit.logs.length}개)</span>
                                    <span id="logToggle${spirit.id}" style="font-size: 0.8rem;">▼</span>
                                </div>
                                <div id="logs${spirit.id}" style="display: none; margin-top: 8px; max-height: 200px; overflow-y: auto;">
                                    ${spirit.logs.map(log => `
                                        <div style="font-size: 0.85rem; color: #888; padding: 4px 0; border-bottom: 1px solid var(--border);">
                                            <span style="color: #666;">${log.time}</span> - ${log.message}
                                        </div>
                                    `).join('')}
                                </div>
                            </div>
                        ` : ''}
                        <div class="action-buttons">
                            ${spirit.isSick ? `
                                <button onclick="giveMedicine(${spirit.id})" style="background: var(--earth); color: white; font-weight: 700;">
                                    🌿 약초 사용
                                </button>
                            ` : ''}
                            <button onclick="openFeedModal(${spirit.id})" ${!canFeed ? 'disabled' : ''}>
                                ${spirit.isSick ? '🤒 ' : ''}먹이주기${!canFeed && spirit.lastFed ? ` (${Math.max(0, Math.ceil((10000 - (now - spirit.lastFed)) / 1000))}초)` : ''}
                            </button>
                            <button onclick="openMusicModal(${spirit.id})" ${!canMusic ? 'disabled' : ''}>
                                음악 듣기${!canMusic && spirit.lastMusic ? ` (${Math.max(0, Math.ceil((10000 - (now - spirit.lastMusic)) / 1000))}초)` : ''}
                            </button>
                            <button onclick="patSpirit(${spirit.id})" ${!canPat ? 'disabled' : ''}>
                                쓰다듬기${!canPat && spirit.lastPat ? ` (${Math.max(0, Math.ceil((10000 - (now - spirit.lastPat)) / 1000))}초)` : ''}
                            </button>
                            ${spirit.growth >= 100 && !spirit.isCompleted ? `
                                <button onclick="manualCompleteSpirit(${spirit.id})" style="background: #ffd700; color: #000; font-weight: 700;">
                                    진화하기
                                </button>
                            ` : ''}
                            <button onclick="confirmDeleteSpirit(${spirit.id})">
                                보내기
                            </button>
                        </div>
                    </div>
                `;
            }).join('');
            
            // 튜토리얼 진행 중이면 강조 표시 재적용
            if ((tutorialActive || tutorial2Active) && window.tutorialWaitingFor) {
                setTimeout(() => {
                    highlightTutorialTarget(window.tutorialWaitingFor);
                }, 100);
            }
            
            // 속성 불균형 튜토리얼 체크 (다른 튜토리얼이 진행 중이지 않을 때만)
            if (!localStorage.getItem('spiritGarden_imbalanceTutorialSeen') && 
                !tutorialActive && !tutorial2Active && !sickTutorialActive && !labTutorialActive && !imbalanceTutorialActive) {
                spirits.forEach(spirit => {
                    if (!spirit.isDead && !spirit.isCompleted) {
                        checkImbalanceAndTutorial(spirit);
                    }
                });
            }
        }

        function updateCoinDisplay() {
            const display = document.getElementById('coinDisplay');
            if (display) display.textContent = coins;
        }

        function changeSellFilter() {
            const select = document.getElementById('sellFilterSelect');
            sellFilter = select.value;
            renderSellList();
        }

        function changeBuyFilter() {
            const select = document.getElementById('buyFilterSelect');
            buyFilter = select.value;
            renderBuyList();
        }

        // 상점 주인 대사 시스템
        function updateShopkeeperDialogue() {
            const dialogueEl = document.getElementById('shopkeeperDialogue');
            if (!dialogueEl) return;
            
            let dialogue = '';
            let gaveGift = false;
            
            // 실제로 상점 탭에 있을 때만 대사 및 선물 처리
            const isInShopTab = currentTab === 'shop';
            
            // 우선순위 대사 체크
            if (!hasVisitedShop && isInShopTab) {
                // 첫 방문 (상점 탭에 있을 때만)
                dialogue = '처음 보는 얼굴이네요...';
                hasVisitedShop = true;
                saveGame();
            } else if (coins === 0 && isInShopTab) {
                // 0코인일 때 선물 (상점 탭에 있을 때만)
                dialogue = '...이거라도 가져가요.';
                coins += 10;
                gaveGift = true;
                saveGame();
                updateCoinDisplay();
            } else if (coins <= 50) {
                // 50코인 이하
                dialogue = '주머니가 가벼워 보이네요.';
            } else {
                // 일반 랜덤 대사
                const randomDialogues = [
                    '어서오세요...',
                    '날씨가 좋네요. ...싫다.',
                    '날이 추워서 일하기 싫어요.',
                    '<계산대에 엎드려 자고있다.>',
                    '또 오셨네요...',
                    '천천히 둘러보세요...',
                    '...뭘 봐요.',
                    '오늘은 특별한 건 없어요.',
                    '...하품.',
                    '손님이 오면 일해야 하잖아요...'
                ];
                dialogue = randomDialogues[Math.floor(Math.random() * randomDialogues.length)];
            }
            
            dialogueEl.textContent = dialogue;
            
            // 선물 받았을 때 알림
            if (gaveGift) {
                setTimeout(() => {
                    showNotification('💰 상점 주인에게 10코인을 받았습니다!');
                }, 500);
            }
        }
        
        // 상점 주인 대사 직접 설정
        function setShopkeeperDialogue(text) {
            const dialogueEl = document.getElementById('shopkeeperDialogue');
            if (dialogueEl) {
                dialogueEl.textContent = text;
            }
        }
        
        function renderShop() {
            // 튜토리얼 진행 중이면 접기 상태 모두 펼치기 (약초 찾기 쉽게)
            if (sickTutorialActive || tutorialActive || tutorial2Active) {
                shopFoldState = { etc: false, food: false, music: false, decoration: false };
                shopBuyFoldState = { etc: false, food: false, music: false, decoration: false };
            }
            
            updateCoinDisplay();
            updateShopkeeperDialogue();
            renderSellList();
            renderBuyList();
        }

        function renderSellList() {
            const container = document.getElementById('sellList');
            if (!container) return;

            // 카테고리별 아이템 배열
            const etcItems = [];
            const foodItems = [];
            const musicItems = [];
            const decoItems = [];

            if (currentShopCategory === 'all' || currentShopCategory === 'food') {
                // 먹이 판매 (순서 고정)
                if (inventory.food && inventory.food.length > 0) {
                    const foodCounts = {};
                    inventory.food.forEach(f => {
                        foodCounts[f] = (foodCounts[f] || 0) + 1;
                    });

                    const foodOrder = ['fire', 'water', 'wind', 'earth', 'light', 'dark'];
                    foodOrder.filter(type => foodCounts[type]).forEach(type => {
                        // 속성 필터 체크
                        if (sellFilter === 'all') {
                            // 전체 보기
                        } else if (['intelligence', 'strength', 'charm'].includes(sellFilter)) {
                            return; // 스탯 필터 시 먹이 숨김
                        } else if (type !== sellFilter) {
                            return; // 다른 속성이면 숨김
                        }
                        
                        const count = foodCounts[type];
                        const isRare = type === 'light' || type === 'dark';
                        const price = isRare ? SHOP_PRICES.sell.food_rare : SHOP_PRICES.sell.food_common;
                        const effectText = isRare ? `${ENV_ICONS[type]} 속성 +6, 성장 +3` : `${ENV_ICONS[type]} 속성 +3, 성장 +2`;
                        const rarityLabel = isRare ? ' <span style="font-size: 0.75rem; color: #9b59b6;">희귀</span>' : '';
                        const isLocked = lockedItems.food.includes(type);
                        
                        // 잠금 모드에 따른 버튼 결정
                        let actionButton;
                        if (isLockMode) {
                            // 잠금 모드: 잠금/해제 버튼
                            actionButton = isLocked 
                                ? `<button onclick="toggleItemLock('food', '${type}')" style="padding: 8px 16px; background: #27ae60; color: white; border: none; border-radius: 4px; cursor: pointer;">해제</button>`
                                : `<button onclick="toggleItemLock('food', '${type}')" style="padding: 8px 16px; background: #e74c3c; color: white; border: none; border-radius: 4px; cursor: pointer;">잠금</button>`;
                        } else {
                            // 판매 모드: 판매 버튼 (잠긴 아이템은 비활성화)
                            actionButton = isLocked
                                ? `<button disabled style="padding: 8px 16px; background: #888; color: white; border: none; border-radius: 4px; cursor: not-allowed;">🔒</button>`
                                : `<button onclick="sellItem('food', '${type}')" style="padding: 8px 16px; background: var(--fire); color: white; border: none; border-radius: 4px; cursor: pointer; white-space: nowrap; min-width: 50px;">판매</button>`;
                        }
                        
                        foodItems.push(`
                            <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px; background: var(--bg); border: 1px solid ${isLocked ? '#e74c3c' : 'var(--border)'}; margin-bottom: 10px; ${isLocked && !isLockMode ? 'opacity: 0.7;' : ''}">
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <span style="font-size: 1.5rem;">${ENV_ICONS[type]}</span>
                                    <div>
                                        <div style="font-weight: 700;">${FOOD_NAMES[type]} ×${count}${rarityLabel}${isLocked ? ' <span style="color: #e74c3c;">🔒</span>' : ''}</div>
                                        <div style="font-size: 0.85rem; color: #666;">${effectText}</div>
                                        <div style="font-size: 0.85rem; color: #888;">판매가: ${price}💰</div>
                                    </div>
                                </div>
                                ${actionButton}
                            </div>
                        `);
                    });
                    
                    // 이벤트 먹이 판매
                    Object.keys(foodCounts).forEach(type => {
                        const eventItem = EVENT_ITEMS[type];
                        if (!eventItem || eventItem.type !== 'food') return;
                        // 기타 필터일 때 이벤트 아이템 숨김
                        if (sellFilter === 'etc') return;
                        if (sellFilter !== 'all' && !['intelligence', 'strength', 'charm'].includes(sellFilter)) return;
                        
                        const count = foodCounts[type];
                        const isLocked = lockedItems.food.includes(type);
                        
                        let actionButton;
                        if (isLockMode) {
                            actionButton = isLocked 
                                ? `<button onclick="toggleItemLock('food', '${type}')" style="padding: 8px 16px; background: #27ae60; color: white; border: none; border-radius: 4px; cursor: pointer;">해제</button>`
                                : `<button onclick="toggleItemLock('food', '${type}')" style="padding: 8px 16px; background: #e74c3c; color: white; border: none; border-radius: 4px; cursor: pointer;">잠금</button>`;
                        } else {
                            actionButton = isLocked
                                ? `<button disabled style="padding: 8px 16px; background: #888; color: white; border: none; border-radius: 4px; cursor: not-allowed;">🔒</button>`
                                : `<button onclick="sellItem('food', '${type}')" style="padding: 8px 16px; background: #c41e3a; color: white; border: none; border-radius: 4px; cursor: pointer; white-space: nowrap; min-width: 50px;">판매</button>`;
                        }
                        
                        foodItems.push(`
                            <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px; background: var(--bg); border: 2px solid ${isLocked ? '#e74c3c' : '#c41e3a'}; margin-bottom: 10px; ${isLocked && !isLockMode ? 'opacity: 0.7;' : ''}">
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <span style="font-size: 1.5rem;">🎄${eventItem.icon}</span>
                                    <div>
                                        <div style="font-weight: 700;">${eventItem.name} ×${count} <span style="font-size: 0.75rem; color: #c41e3a;">이벤트</span>${isLocked ? ' <span style="color: #e74c3c;">🔒</span>' : ''}</div>
                                        <div style="font-size: 0.85rem; color: #c41e3a;">모든 스탯 +5, 성장 +10</div>
                                        <div style="font-size: 0.85rem; color: #888;">판매가: 15💰</div>
                                    </div>
                                </div>
                                ${actionButton}
                            </div>
                        `);
                    });
                    
                    // 합성 먹이 판매
                    Object.keys(foodCounts).forEach(type => {
                        const synthItem = SYNTH_ITEMS[type];
                        if (!synthItem || synthItem.type !== 'food') return;
                        
                        // 기타 아이템 (수선화 꽃잎, 아카시아 꿀)은 기타 필터에서만 표시
                        const isEtcItem = ['reconciliation_flower', 'acacia_honey'].includes(type);
                        if (isEtcItem) {
                            if (sellFilter !== 'all' && sellFilter !== 'etc') return;
                        } else {
                            if (sellFilter !== 'all') return;
                        }
                        
                        const count = foodCounts[type];
                        const isLocked = lockedItems.food.includes(type);
                        
                        let effectText;
                        if (synthItem.attr === 'all') {
                            effectText = `전속성 +${synthItem.attrGain}`;
                        } else if (synthItem.attr === 'dual') {
                            effectText = `${synthItem.dualAttr.join('+')} 각 +${synthItem.attrGain}`;
                        } else if (synthItem.attr === 'special') {
                            effectText = synthItem.desc;
                        } else {
                            effectText = `${synthItem.attr} +${synthItem.attrGain}`;
                        }
                        
                        const labelText = isEtcItem ? '<span style="font-size: 0.75rem; color: #888;">기타</span>' : '<span style="font-size: 0.75rem; color: #9b59b6;">합성</span>';
                        
                        let actionButton;
                        if (isLockMode) {
                            actionButton = isLocked 
                                ? `<button onclick="toggleItemLock('food', '${type}')" style="padding: 8px 16px; background: #27ae60; color: white; border: none; border-radius: 4px; cursor: pointer;">해제</button>`
                                : `<button onclick="toggleItemLock('food', '${type}')" style="padding: 8px 16px; background: #e74c3c; color: white; border: none; border-radius: 4px; cursor: pointer;">잠금</button>`;
                        } else {
                            actionButton = isLocked
                                ? `<button disabled style="padding: 8px 16px; background: #888; color: white; border: none; border-radius: 4px; cursor: not-allowed;">🔒</button>`
                                : `<button onclick="sellItem('food', '${type}')" style="padding: 8px 16px; background: #9b59b6; color: white; border: none; border-radius: 4px; cursor: pointer; white-space: nowrap; min-width: 50px;">판매</button>`;
                        }
                        
                        const itemHtml = `
                            <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px; background: var(--bg); border: 2px solid ${isLocked ? '#e74c3c' : '#9b59b6'}; margin-bottom: 10px; ${isLocked && !isLockMode ? 'opacity: 0.7;' : ''}">
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <span style="font-size: 1.5rem;">${isEtcItem ? '' : '🔬'}${synthItem.icon}</span>
                                    <div>
                                        <div style="font-weight: 700;">${synthItem.name} ×${count} ${labelText}${isLocked ? ' <span style="color: #e74c3c;">🔒</span>' : ''}</div>
                                        <div style="font-size: 0.85rem; color: #9b59b6;">${effectText}</div>
                                        <div style="font-size: 0.85rem; color: #888;">판매가: 8💰</div>
                                    </div>
                                </div>
                                ${actionButton}
                            </div>
                        `;
                        if (isEtcItem) {
                            etcItems.push(itemHtml);
                        } else {
                            foodItems.push(itemHtml);
                        }
                    });
                    
                    // 만병통치 약초 판매
                    if (foodCounts['medicine']) {
                        if (sellFilter === 'all' || sellFilter === 'etc') {
                            const count = foodCounts['medicine'];
                            const isLocked = lockedItems.food.includes('medicine');
                            
                            let actionButton;
                            if (isLockMode) {
                                actionButton = isLocked 
                                    ? `<button onclick="toggleItemLock('food', 'medicine')" style="padding: 8px 16px; background: #27ae60; color: white; border: none; border-radius: 4px; cursor: pointer;">해제</button>`
                                    : `<button onclick="toggleItemLock('food', 'medicine')" style="padding: 8px 16px; background: #e74c3c; color: white; border: none; border-radius: 4px; cursor: pointer;">잠금</button>`;
                            } else {
                                actionButton = isLocked
                                    ? `<button disabled style="padding: 8px 16px; background: #888; color: white; border: none; border-radius: 4px; cursor: not-allowed;">🔒</button>`
                                    : `<button onclick="sellItem('food', 'medicine')" style="padding: 8px 16px; background: #27ae60; color: white; border: none; border-radius: 4px; cursor: pointer; white-space: nowrap; min-width: 50px;">판매</button>`;
                            }
                            
                            etcItems.push(`
                                <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px; background: var(--bg); border: 1px solid ${isLocked ? '#e74c3c' : 'var(--border)'}; margin-bottom: 10px; ${isLocked && !isLockMode ? 'opacity: 0.7;' : ''}">
                                    <div style="display: flex; align-items: center; gap: 10px;">
                                        <span style="font-size: 1.5rem;">${MEDICINE.icon}</span>
                                        <div>
                                            <div style="font-weight: 700;">${MEDICINE.name} ×${count} <span style="font-size: 0.75rem; color: #888;">기타</span>${isLocked ? ' <span style="color: #e74c3c;">🔒</span>' : ''}</div>
                                            <div style="font-size: 0.85rem; color: #666;">${MEDICINE.description}</div>
                                            <div style="font-size: 0.85rem; color: #888;">판매가: 10💰</div>
                                        </div>
                                    </div>
                                    ${actionButton}
                                </div>
                            `);
                        }
                    }
                }
            }
            
            if (currentShopCategory === 'all' || currentShopCategory === 'decoration') {
                // 미니어처 판매 (속성 → 품질 → 이름 순 정렬)
                if (inventory.decorations && inventory.decorations.length > 0) {
                    const decorCounts = {};
                    inventory.decorations.forEach(d => {
                        decorCounts[d] = (decorCounts[d] || 0) + 1;
                    });
                    
                    // 합성 전용 아이템도 판매 가능하도록 변경 (제외 목록 삭제)

                    // 속성별, 품질별, 이름별로 정렬
                    const sortedDecoKeys = Object.keys(decorCounts).filter(key => DECORATION_TYPES[key]).sort((a, b) => {
                        const dataA = DECORATION_TYPES[a];
                        const dataB = DECORATION_TYPES[b];
                        if (!dataA || !dataB) return 0;
                        
                        // 1. 속성별 정렬
                        const attrOrder = { fire: 0, water: 1, wind: 2, earth: 3, light: 4, dark: 5 };
                        const attrDiff = (attrOrder[dataA.attr] || 0) - (attrOrder[dataB.attr] || 0);
                        if (attrDiff !== 0) return attrDiff;
                        
                        // 2. 품질별 정렬 (높은 순: legendary > epic > rare > common)
                        const qualityOrder = { legendary: 0, epic: 1, rare: 2, common: 3 };
                        const qualityDiff = (qualityOrder[dataA.quality] || 3) - (qualityOrder[dataB.quality] || 3);
                        if (qualityDiff !== 0) return qualityDiff;
                        
                        // 3. 이름별 정렬
                        return dataA.name.localeCompare(dataB.name);
                    });
                    
                    sortedDecoKeys.forEach(key => {
                        const decoData = DECORATION_TYPES[key];
                        if (!decoData) return; // 데이터 없으면 스킵
                        
                        // 속성 필터 체크
                        if (sellFilter === 'all') {
                            // 전체 보기
                        } else if (['intelligence', 'strength', 'charm'].includes(sellFilter)) {
                            return; // 스탯 필터 시 미니어처 숨김
                        } else if (decoData.attr === 'dual') {
                            if (!decoData.dualAttr || !decoData.dualAttr.includes(sellFilter)) return;
                        } else if (decoData.attr === 'all') {
                            // all 속성 미니어처은 모든 속성 필터에서 표시
                        } else if (decoData.attr !== sellFilter) {
                            return; // 다른 속성이면 숨김
                        }
                        
                        const count = decorCounts[key];
                        
                        const sellPrice = Math.floor(decoData.price * 0.5); // 판매가는 구매가의 50%
                        const qualityLabel = decoData.quality === 'legendary' ? '👑' : decoData.quality === 'epic' ? '⭐' : decoData.quality === 'rare' ? '💎' : '';
                        const qualityText = decoData.quality === 'legendary' ? '<span style="color: #ff6b35;">전설</span>' : decoData.quality === 'epic' ? '<span style="color: #9b59b6;">최상급</span>' : decoData.quality === 'rare' ? '<span style="color: #3498db;">희귀</span>' : '<span style="color: #888;">일반</span>';
                        
                        // 등급별 테두리 색
                        const qualityBorderColor = decoData.quality === 'legendary' ? '#ffd700' : decoData.quality === 'epic' ? '#9b59b6' : decoData.quality === 'rare' ? '#3498db' : 'var(--border)';
                        
                        // 속성 표시 (복합 속성 처리)
                        let attrDisplay = '';
                        if (decoData.attr === 'dual' && decoData.dualAttr) {
                            attrDisplay = decoData.dualAttr.map(a => ENV_ICONS[a]).join('') + ` +${decoData.power}`;
                        } else if (decoData.attr === 'all') {
                            attrDisplay = '🌈 전체 속성 +' + decoData.power;
                        } else {
                            const attrName = { fire: '불', water: '물', wind: '바람', earth: '땅', light: '빛', dark: '어둠' }[decoData.attr] || '';
                            attrDisplay = `${ENV_ICONS[decoData.attr]} ${attrName} 속성 +${decoData.power}`;
                        }
                        
                        const isLocked = lockedItems.decorations.includes(key);
                        
                        // 잠금 모드에 따른 버튼 결정
                        let actionButton;
                        if (isLockMode) {
                            // 잠금 모드: 잠금/해제 버튼
                            actionButton = isLocked 
                                ? `<button onclick="toggleItemLock('decoration', '${key}')" style="padding: 8px 16px; background: #27ae60; color: white; border: none; border-radius: 4px; cursor: pointer;">해제</button>`
                                : `<button onclick="toggleItemLock('decoration', '${key}')" style="padding: 8px 16px; background: #e74c3c; color: white; border: none; border-radius: 4px; cursor: pointer;">잠금</button>`;
                        } else {
                            // 판매 모드: 판매 버튼 (잠긴 아이템은 비활성화)
                            actionButton = isLocked
                                ? `<button disabled style="padding: 8px 16px; background: #888; color: white; border: none; border-radius: 4px; cursor: not-allowed;">🔒</button>`
                                : `<button onclick="sellItem('decoration', '${key}')" style="padding: 8px 16px; background: var(--fire); color: white; border: none; border-radius: 4px; cursor: pointer; white-space: nowrap; min-width: 50px;">판매</button>`;
                        }
                        
                        decoItems.push(`
                            <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px; background: var(--bg); border: 2px solid ${isLocked ? '#e74c3c' : qualityBorderColor}; border-radius: 6px; margin-bottom: 10px; ${isLocked && !isLockMode ? 'opacity: 0.7;' : ''}">
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <span style="font-size: 1.5rem;">${qualityLabel}${decoData.icon}</span>
                                    <div>
                                        <div style="font-weight: 700;">${decoData.name} ×${count}${isLocked ? ' <span style="color: #e74c3c;">🔒</span>' : ''}</div>
                                        <div style="font-size: 0.85rem; color: #666;">${attrDisplay} | ${qualityText}</div>
                                        <div style="font-size: 0.85rem; color: #888;">판매가: ${sellPrice}💰</div>
                                    </div>
                                </div>
                                ${actionButton}
                            </div>
                        `);
                    });
                    
                    // 이벤트 미니어처 판매
                    Object.keys(decorCounts).forEach(key => {
                        const eventItem = EVENT_ITEMS[key];
                        if (!eventItem || eventItem.type !== 'decoration') return;
                        if (sellFilter !== 'all') return;
                        
                        const count = decorCounts[key];
                        const isLocked = lockedItems.decorations.includes(key);
                        
                        let actionButton;
                        if (isLockMode) {
                            actionButton = isLocked 
                                ? `<button onclick="toggleItemLock('decoration', '${key}')" style="padding: 8px 16px; background: #27ae60; color: white; border: none; border-radius: 4px; cursor: pointer;">해제</button>`
                                : `<button onclick="toggleItemLock('decoration', '${key}')" style="padding: 8px 16px; background: #e74c3c; color: white; border: none; border-radius: 4px; cursor: pointer;">잠금</button>`;
                        } else {
                            actionButton = isLocked
                                ? `<button disabled style="padding: 8px 16px; background: #888; color: white; border: none; border-radius: 4px; cursor: not-allowed;">🔒</button>`
                                : `<button onclick="sellItem('decoration', '${key}')" style="padding: 8px 16px; background: #c41e3a; color: white; border: none; border-radius: 4px; cursor: pointer; white-space: nowrap; min-width: 50px;">판매</button>`;
                        }
                        
                        decoItems.push(`
                            <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px; background: var(--bg); border: 2px solid ${isLocked ? '#e74c3c' : '#c41e3a'}; margin-bottom: 10px; ${isLocked && !isLockMode ? 'opacity: 0.7;' : ''}">
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <span style="font-size: 1.5rem;">👑🎄${eventItem.icon}</span>
                                    <div>
                                        <div style="font-weight: 700;">${eventItem.name} ×${count} <span style="font-size: 0.75rem; color: #c41e3a;">이벤트</span>${isLocked ? ' <span style="color: #e74c3c;">🔒</span>' : ''}</div>
                                        <div style="font-size: 0.85rem; color: #c41e3a;">모든 속성 +5</div>
                                        <div style="font-size: 0.85rem; color: #888;">판매가: 25💰</div>
                                    </div>
                                </div>
                                ${actionButton}
                            </div>
                        `);
                    });
                    
                    // 합성 미니어처 판매
                    Object.keys(decorCounts).forEach(key => {
                        const synthItem = SYNTH_ITEMS[key];
                        if (!synthItem || synthItem.type !== 'decoration') return;
                        if (sellFilter !== 'all') return;
                        
                        const count = decorCounts[key];
                        const isLocked = lockedItems.decorations.includes(key);
                        
                        let actionButton;
                        if (isLockMode) {
                            actionButton = isLocked 
                                ? `<button onclick="toggleItemLock('decoration', '${key}')" style="padding: 8px 16px; background: #27ae60; color: white; border: none; border-radius: 4px; cursor: pointer;">해제</button>`
                                : `<button onclick="toggleItemLock('decoration', '${key}')" style="padding: 8px 16px; background: #e74c3c; color: white; border: none; border-radius: 4px; cursor: pointer;">잠금</button>`;
                        } else {
                            actionButton = isLocked
                                ? `<button disabled style="padding: 8px 16px; background: #888; color: white; border: none; border-radius: 4px; cursor: not-allowed;">🔒</button>`
                                : `<button onclick="sellItem('decoration', '${key}')" style="padding: 8px 16px; background: #9b59b6; color: white; border: none; border-radius: 4px; cursor: pointer; white-space: nowrap; min-width: 50px;">판매</button>`;
                        }
                        
                        decoItems.push(`
                            <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px; background: var(--bg); border: 2px solid ${isLocked ? '#e74c3c' : '#9b59b6'}; margin-bottom: 10px; ${isLocked && !isLockMode ? 'opacity: 0.7;' : ''}">
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <span style="font-size: 1.5rem;">🔬${synthItem.icon}</span>
                                    <div>
                                        <div style="font-weight: 700;">${synthItem.name} ×${count} <span style="font-size: 0.75rem; color: #9b59b6;">합성</span>${isLocked ? ' <span style="color: #e74c3c;">🔒</span>' : ''}</div>
                                        <div style="font-size: 0.85rem; color: #9b59b6;">${synthItem.attr} +${synthItem.power}</div>
                                        <div style="font-size: 0.85rem; color: #888;">판매가: 20💰</div>
                                    </div>
                                </div>
                                ${actionButton}
                            </div>
                        `);
                    });
                }
            }

            

            if (currentShopCategory === 'all' || currentShopCategory === 'music') {
                // 음악 판매 (순서 고정)
                if (inventory.music && inventory.music.length > 0) {
                    const musicCounts = {};
                    inventory.music.forEach(m => {
                        musicCounts[m] = (musicCounts[m] || 0) + 1;
                    });

                    const musicOrder = ['classic', 'jazz', 'rock', 'pop', 'ballad', 'edm'];
                    musicOrder.filter(type => musicCounts[type]).forEach(type => {
                        const musicData = MUSIC_TYPES[type];
                        
                        // 스탯 필터 체크 (음악 전용, 복합 스탯 음악도 해당 필터에 표시)
                        if (sellFilter === 'all') {
                            // 전체 보기일 때는 필터링 안 함
                        } else if (sellFilter === 'intelligence') {
                            if (!['classic', 'pop', 'edm'].includes(type)) return;
                        } else if (sellFilter === 'strength') {
                            if (!['rock', 'ballad', 'edm'].includes(type)) return;
                        } else if (sellFilter === 'charm') {
                            if (!['jazz', 'pop', 'ballad'].includes(type)) return;
                        } else if (['fire', 'water', 'wind', 'earth', 'light', 'dark'].includes(sellFilter)) {
                            return; // 속성 필터 시 음악 숨김
                        }
                        
                        const count = musicCounts[type];
                        const isLocked = lockedItems.music.includes(type);
                        
                        // 잠금 모드에 따른 버튼 결정
                        let actionBtn;
                        if (isLockMode) {
                            // 잠금 모드: 잠금/해제 버튼
                            actionBtn = isLocked 
                                ? `<button onclick="toggleItemLock('music', '${type}')" style="padding: 8px 16px; background: #27ae60; color: white; border: none; border-radius: 4px; cursor: pointer;">해제</button>`
                                : `<button onclick="toggleItemLock('music', '${type}')" style="padding: 8px 16px; background: #e74c3c; color: white; border: none; border-radius: 4px; cursor: pointer;">잠금</button>`;
                        } else {
                            // 일반 모드: 판매 버튼 또는 잠금 표시
                            actionBtn = isLocked 
                                ? `<button disabled style="padding: 8px 16px; background: #95a5a6; color: white; border: none; border-radius: 4px; cursor: not-allowed;">🔒 잠금</button>`
                                : `<button onclick="sellItem('music', '${type}')" style="padding: 8px 16px; background: var(--fire); color: white; border: none; border-radius: 4px; cursor: pointer; white-space: nowrap; min-width: 50px;">판매</button>`;
                        }
                        
                        musicItems.push(`
                            <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px; background: var(--bg); border: 1px solid ${isLocked ? '#27ae60' : 'var(--border)'}; margin-bottom: 10px;">
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <span style="font-size: 1.5rem;">🎵</span>
                                    <div>
                                        <div style="font-weight: 700;">${musicData.name} ×${count}</div>
                                        <div style="font-size: 0.85rem; color: #666;">${musicData.effect}</div>
                                        <div style="font-size: 0.85rem; color: #888;">판매가: ${SHOP_PRICES.sell.music}💰</div>
                                    </div>
                                </div>
                                ${actionBtn}
                            </div>
                        `);
                    });
                    
                    // 이벤트 음악 판매 (캐롤 등)
                    Object.keys(musicCounts).forEach(type => {
                        const eventItem = EVENT_ITEMS[type];
                        if (!eventItem || eventItem.type !== 'music') return;
                        if (sellFilter !== 'all' && !['intelligence', 'strength', 'charm'].includes(sellFilter)) return;
                        
                        const count = musicCounts[type];
                        const isLocked = lockedItems.music.includes(type);
                        
                        // 잠금 모드에 따른 버튼 결정
                        let actionBtn;
                        if (isLockMode) {
                            // 잠금 모드: 잠금/해제 버튼
                            actionBtn = isLocked 
                                ? `<button onclick="toggleItemLock('music', '${type}')" style="padding: 8px 16px; background: #27ae60; color: white; border: none; border-radius: 4px; cursor: pointer;">해제</button>`
                                : `<button onclick="toggleItemLock('music', '${type}')" style="padding: 8px 16px; background: #e74c3c; color: white; border: none; border-radius: 4px; cursor: pointer;">잠금</button>`;
                        } else {
                            // 일반 모드: 판매 버튼 또는 잠금 표시
                            actionBtn = isLocked 
                                ? `<button disabled style="padding: 8px 16px; background: #95a5a6; color: white; border: none; border-radius: 4px; cursor: not-allowed;">🔒 잠금</button>`
                                : `<button onclick="sellItem('music', '${type}')" style="padding: 8px 16px; background: #c41e3a; color: white; border: none; border-radius: 4px; cursor: pointer; white-space: nowrap; min-width: 50px;">판매</button>`;
                        }
                        
                        musicItems.push(`
                            <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px; background: var(--bg); border: 2px solid ${isLocked ? '#27ae60' : '#c41e3a'}; margin-bottom: 10px;">
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <span style="font-size: 1.5rem;">🎄${eventItem.icon}</span>
                                    <div>
                                        <div style="font-weight: 700;">${eventItem.name} ×${count} <span style="font-size: 0.75rem; color: #c41e3a;">이벤트</span></div>
                                        <div style="font-size: 0.85rem; color: #c41e3a;">모든 스탯 +5</div>
                                        <div style="font-size: 0.85rem; color: #888;">판매가: 12💰</div>
                                    </div>
                                </div>
                                ${actionBtn}
                            </div>
                        `);
                    });
                }
            }

            const totalItems = etcItems.length + foodItems.length + musicItems.length + decoItems.length;
            
            if (totalItems === 0) {
                container.innerHTML = '<p style="color: #888; text-align: center; padding: 20px;">판매할 물품이 없습니다</p>';
            } else {
                // 잠금 모드일 때는 안내 표시, 아닐 때는 일괄 판매 드롭다운
                let headerHtml = '';
                if (isLockMode) {
                    headerHtml = `
                        <div style="margin-bottom: 15px; padding: 12px; background: #fff3cd; border: 1px solid #ffc107; border-radius: 8px;">
                            <div style="font-weight: 600; color: #856404; font-size: 0.9rem;">🔒 잠금 모드</div>
                            <div style="font-size: 0.85rem; color: #856404; margin-top: 4px;">아이템을 클릭하면 판매가 잠금/해제됩니다.</div>
                        </div>
                    `;
                } else {
                    headerHtml = `
                        <div style="margin-bottom: 15px; display: flex; align-items: center; gap: 10px;">
                            <select id="bulkSellSelect" style="padding: 8px 12px; font-size: 0.9rem; border: 1px solid var(--border); border-radius: 6px; background: var(--card); color: var(--text); cursor: pointer; flex: 1;">
                                <option value="">📦 일괄 판매 선택...</option>
                                <optgroup label="🍎 먹이">
                                    <option value="food_common">일반 먹이 전체</option>
                                    <option value="food_rare">희귀 먹이 전체</option>
                                </optgroup>
                                <optgroup label="🎨 미니어처">
                                    <option value="deco_common">일반 미니어처 전체</option>
                                    <option value="deco_rare">희귀 이하 전체</option>
                                    <option value="deco_epic">최상급 이하 전체</option>
                                </optgroup>
                            </select>
                            <button onclick="executeBulkSell()" style="padding: 8px 16px; background: var(--fire); color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600; white-space: nowrap;">판매</button>
                        </div>
                        <div style="font-size: 0.8rem; color: #888; margin-bottom: 15px;">※ 잠금된 아이템은 제외됩니다</div>
                    `;
                }
                
                // 카테고리별 접기 가능한 섹션 생성
                let sectionsHtml = '';
                
                // 기타 섹션
                if (etcItems.length > 0) {
                    const isFolded = shopFoldState.etc;
                    sectionsHtml += `
                        <div class="shop-category-section" style="margin-bottom: 15px;">
                            <div onclick="toggleShopFold('etc')" style="display: flex; justify-content: space-between; align-items: center; padding: 10px 12px; background: #888; color: white; border-radius: 6px; cursor: pointer; margin-bottom: ${isFolded ? '0' : '10px'};">
                                <span style="font-weight: 600;">📦 기타 (${etcItems.length})</span>
                                <span>${isFolded ? '▶' : '▼'}</span>
                            </div>
                            <div id="shopEtcContent" style="display: ${isFolded ? 'none' : 'block'};">
                                ${etcItems.join('')}
                            </div>
                        </div>
                    `;
                }
                
                // 먹이 섹션
                if (foodItems.length > 0) {
                    const isFolded = shopFoldState.food;
                    sectionsHtml += `
                        <div class="shop-category-section" style="margin-bottom: 15px;">
                            <div onclick="toggleShopFold('food')" style="display: flex; justify-content: space-between; align-items: center; padding: 10px 12px; background: var(--fire); color: white; border-radius: 6px; cursor: pointer; margin-bottom: ${isFolded ? '0' : '10px'};">
                                <span style="font-weight: 600;">🍎 먹이 (${foodItems.length})</span>
                                <span>${isFolded ? '▶' : '▼'}</span>
                            </div>
                            <div id="shopFoodContent" style="display: ${isFolded ? 'none' : 'block'};">
                                ${foodItems.join('')}
                            </div>
                        </div>
                    `;
                }
                
                // 레코드 섹션
                if (musicItems.length > 0) {
                    const isFolded = shopFoldState.music;
                    sectionsHtml += `
                        <div class="shop-category-section" style="margin-bottom: 15px;">
                            <div onclick="toggleShopFold('music')" style="display: flex; justify-content: space-between; align-items: center; padding: 10px 12px; background: #9b59b6; color: white; border-radius: 6px; cursor: pointer; margin-bottom: ${isFolded ? '0' : '10px'};">
                                <span style="font-weight: 600;">🎵 레코드 (${musicItems.length})</span>
                                <span>${isFolded ? '▶' : '▼'}</span>
                            </div>
                            <div id="shopMusicContent" style="display: ${isFolded ? 'none' : 'block'};">
                                ${musicItems.join('')}
                            </div>
                        </div>
                    `;
                }
                
                // 미니어처 섹션
                if (decoItems.length > 0) {
                    const isFolded = shopFoldState.decoration;
                    sectionsHtml += `
                        <div class="shop-category-section" style="margin-bottom: 15px;">
                            <div onclick="toggleShopFold('decoration')" style="display: flex; justify-content: space-between; align-items: center; padding: 10px 12px; background: var(--earth); color: white; border-radius: 6px; cursor: pointer; margin-bottom: ${isFolded ? '0' : '10px'};">
                                <span style="font-weight: 600;">🌳 미니어처 (${decoItems.length})</span>
                                <span>${isFolded ? '▶' : '▼'}</span>
                            </div>
                            <div id="shopDecoContent" style="display: ${isFolded ? 'none' : 'block'};">
                                ${decoItems.join('')}
                            </div>
                        </div>
                    `;
                }
                
                container.innerHTML = headerHtml + sectionsHtml;
            }
        }
        
        // 상점 카테고리 접기/펼치기 토글
        function toggleShopFold(category) {
            shopFoldState[category] = !shopFoldState[category];
            renderSellList();
        }

        function renderBuyList() {
            const container = document.getElementById('buyList');
            if (!container) return;

            // 카테고리별 아이템 배열
            const etcItems = [];
            const foodItems = [];
            const musicItems = [];
            const decoItems = [];
            
            // 이벤트 아이템 섹션 (활성화된 이벤트가 있고, 기간 내일 때만)
            // 카테고리 필터에 맞는 이벤트 아이템만 표시
            if (activatedEvents && activatedEvents.length > 0) {
                activatedEvents.forEach(eventType => {
                    const event = EVENT_TYPES[eventType];
                    if (!event) return;
                    
                    // 이벤트 기간 체크
                    if (event.validUntil && new Date() > new Date(event.validUntil)) return;
                    
                    // 해당 이벤트의 아이템들
                    Object.keys(EVENT_ITEMS).forEach(itemKey => {
                        const item = EVENT_ITEMS[itemKey];
                        if (item.event !== eventType) return;
                        
                        // 카테고리 필터 적용
                        if (currentShopCategory !== 'all') {
                            if (currentShopCategory === 'food' && item.type !== 'food') return;
                            if (currentShopCategory === 'music' && item.type !== 'music') return;
                            if (currentShopCategory === 'decoration' && item.type !== 'decoration') return;
                        }
                        
                        // 세부 필터 적용
                        if (buyFilter !== 'all') {
                            // 기타 필터일 때 이벤트 아이템 숨김
                            if (buyFilter === 'etc') return;
                            // 속성 필터일 때 음악은 숨김
                            if (['fire', 'water', 'wind', 'earth', 'light', 'dark'].includes(buyFilter) && item.type === 'music') return;
                            // 스탯 필터일 때 먹이/미니어처은 숨김
                            if (['intelligence', 'strength', 'charm'].includes(buyFilter) && item.type !== 'music') return;
                        }
                        
                        const price = item.type === 'food' ? 30 : item.type === 'music' ? 100 : 50;
                        
                        // 보유량 계산
                        let ownedCount = 0;
                        if (item.type === 'food') {
                            ownedCount = inventory.food ? inventory.food.filter(f => f === itemKey).length : 0;
                        } else if (item.type === 'music') {
                            ownedCount = inventory.music ? inventory.music.filter(m => m === itemKey).length : 0;
                        } else if (item.type === 'decoration') {
                            // 인벤토리 + 테라리움에 설치된 미니어처
                            const inInventory = inventory.decorations ? inventory.decorations.filter(d => d === itemKey).length : 0;
                            const installed = installedDecorations ? installedDecorations.filter(d => d.type === itemKey).length : 0;
                            ownedCount = inInventory + installed;
                        }
                        
                        const itemHtml = `
                            <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px; background: var(--bg); border: 1px solid ${item.quality === 'legendary' ? '#ffd700' : item.quality === 'epic' ? '#9b59b6' : '#c41e3a'}; border-radius: 8px; margin-bottom: 10px;">
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <span style="font-size: 1.5rem;">${item.quality === 'legendary' ? '👑' : ''}${item.icon}</span>
                                    <div>
                                        <div style="font-weight: 700;">${item.name} <span style="font-size: 0.7rem; color: #ffd700;">🎄${item.quality === 'legendary' ? '전설' : '한정'}</span> <span style="font-size: 0.75rem; color: #888;">(보유: ${ownedCount})</span></div>
                                        <div style="font-size: 0.8rem; color: #888;">${item.desc}</div>
                                        <div style="font-size: 0.85rem; color: #ffd700;">가격: ${price}💰</div>
                                    </div>
                                </div>
                                <button onclick="buyEventItem('${itemKey}', ${price})" style="padding: 8px 16px; white-space: nowrap; min-width: 50px;">구매</button>
                            </div>
                        `;
                        
                        // 타입에 따라 해당 카테고리에 추가
                        if (item.type === 'food') foodItems.push(itemHtml);
                        else if (item.type === 'music') musicItems.push(itemHtml);
                        else if (item.type === 'decoration') decoItems.push(itemHtml);
                    });
                });
            }
            
            // 기타 아이템 구매 (만병통치 약초, 수선화 꽃잎, 아카시아 꿀)
            if ((currentShopCategory === 'all' || currentShopCategory === 'food') &&
                (buyFilter === 'all' || buyFilter === 'etc')) {
                // 만병통치 약초
                const medicineCount = inventory.food ? inventory.food.filter(f => f === 'medicine').length : 0;
                etcItems.push(`
                    <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px; background: var(--bg); border: 1px solid var(--border); margin-bottom: 10px; gap: 10px;">
                        <div style="display: flex; align-items: center; gap: 10px; flex: 1; min-width: 0;">
                            <span style="font-size: 1.5rem; flex-shrink: 0;">${MEDICINE.icon}</span>
                            <div style="min-width: 0;">
                                <div style="font-weight: 700;">${MEDICINE.name} <span style="font-size: 0.75rem; color: #888;">기타</span> <span style="font-size: 0.75rem; color: #888;">(보유: ${medicineCount})</span></div>
                                <div style="font-size: 0.85rem; color: #666;">${MEDICINE.description}</div>
                                <div style="font-size: 0.85rem; color: #888;">가격: ${MEDICINE.price}💰</div>
                            </div>
                        </div>
                        <button onclick="buyItem('food', 'medicine', ${MEDICINE.price})" style="padding: 8px 16px; white-space: nowrap; min-width: 50px; flex-shrink: 0;">구매</button>
                    </div>
                `);
                
                // 수선화 꽃잎
                const daffodil = SYNTH_ITEMS['reconciliation_flower'];
                const daffodilCount = inventory.food ? inventory.food.filter(f => f === 'reconciliation_flower').length : 0;
                etcItems.push(`
                    <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px; background: var(--bg); border: 1px solid var(--border); margin-bottom: 10px; gap: 10px;">
                        <div style="display: flex; align-items: center; gap: 10px; flex: 1; min-width: 0;">
                            <span style="font-size: 1.5rem; flex-shrink: 0;">${daffodil.icon}</span>
                            <div style="min-width: 0;">
                                <div style="font-weight: 700;">${daffodil.name} <span style="font-size: 0.75rem; color: #888;">기타</span> <span style="font-size: 0.75rem; color: #888;">(보유: ${daffodilCount})</span></div>
                                <div style="font-size: 0.85rem; color: #666;">${daffodil.desc}</div>
                                <div style="font-size: 0.85rem; color: #888;">가격: 25💰</div>
                            </div>
                        </div>
                        <button onclick="buyItem('food', 'reconciliation_flower', 25)" style="padding: 8px 16px; white-space: nowrap; min-width: 50px; flex-shrink: 0;">구매</button>
                    </div>
                `);
                
                // 아카시아 꿀
                const honey = SYNTH_ITEMS['acacia_honey'];
                const honeyCount = inventory.food ? inventory.food.filter(f => f === 'acacia_honey').length : 0;
                etcItems.push(`
                    <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px; background: var(--bg); border: 1px solid var(--border); margin-bottom: 10px; gap: 10px;">
                        <div style="display: flex; align-items: center; gap: 10px; flex: 1; min-width: 0;">
                            <span style="font-size: 1.5rem; flex-shrink: 0;">${honey.icon}</span>
                            <div style="min-width: 0;">
                                <div style="font-weight: 700;">${honey.name} <span style="font-size: 0.75rem; color: #888;">기타</span> <span style="font-size: 0.75rem; color: #888;">(보유: ${honeyCount})</span></div>
                                <div style="font-size: 0.85rem; color: #666;">${honey.desc}</div>
                                <div style="font-size: 0.85rem; color: #888;">가격: 25💰</div>
                            </div>
                        </div>
                        <button onclick="buyItem('food', 'acacia_honey', 25)" style="padding: 8px 16px; white-space: nowrap; min-width: 50px; flex-shrink: 0;">구매</button>
                    </div>
                `);
                
                // 레시피북 (연구실 튜토리얼 완료 또는 건너뛰기 후 표시)
                const labTutorialSeen = localStorage.getItem('spiritGarden_labTutorialSeen');
                if (labTutorialSeen) {
                    // 레시피북 (먹이)
                    const foodBookPurchased = purchasedRecipeBooks.includes('food');
                    etcItems.push(`
                        <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px; background: var(--bg); border: 2px solid ${foodBookPurchased ? '#27ae60' : '#9b59b6'}; border-radius: 6px; margin-bottom: 10px; gap: 10px;">
                            <div style="display: flex; align-items: center; gap: 10px; flex: 1; min-width: 0;">
                                <span style="font-size: 1.5rem; flex-shrink: 0;">${RECIPE_BOOKS.food.icon}</span>
                                <div style="min-width: 0;">
                                    <div style="font-weight: 700;">${RECIPE_BOOKS.food.name} <span style="font-size: 0.75rem; color: #9b59b6;">레시피</span></div>
                                    <div style="font-size: 0.85rem; color: #666;">${RECIPE_BOOKS.food.desc} (${RECIPE_BOOKS.food.recipes.length}개)</div>
                                    <div style="font-size: 0.85rem; color: #888;">가격: ${RECIPE_BOOKS.food.price}💰</div>
                                </div>
                            </div>
                            ${foodBookPurchased 
                                ? '<span style="padding: 8px 16px; color: #27ae60; font-weight: 700;">✓ 구매완료</span>'
                                : `<button onclick="buyRecipeBook('food')" style="padding: 8px 16px; white-space: nowrap; min-width: 50px; flex-shrink: 0; background: #9b59b6; color: white;">구매</button>`}
                        </div>
                    `);
                    
                    // 레시피북 (미니어처)
                    const decoBookPurchased = purchasedRecipeBooks.includes('decoration');
                    etcItems.push(`
                        <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px; background: var(--bg); border: 2px solid ${decoBookPurchased ? '#27ae60' : '#9b59b6'}; border-radius: 6px; margin-bottom: 10px; gap: 10px;">
                            <div style="display: flex; align-items: center; gap: 10px; flex: 1; min-width: 0;">
                                <span style="font-size: 1.5rem; flex-shrink: 0;">${RECIPE_BOOKS.decoration.icon}</span>
                                <div style="min-width: 0;">
                                    <div style="font-weight: 700;">${RECIPE_BOOKS.decoration.name} <span style="font-size: 0.75rem; color: #9b59b6;">레시피</span></div>
                                    <div style="font-size: 0.85rem; color: #666;">${RECIPE_BOOKS.decoration.desc} (${RECIPE_BOOKS.decoration.recipes.length}개)</div>
                                    <div style="font-size: 0.85rem; color: #888;">가격: ${RECIPE_BOOKS.decoration.price}💰</div>
                                </div>
                            </div>
                            ${decoBookPurchased 
                                ? '<span style="padding: 8px 16px; color: #27ae60; font-weight: 700;">✓ 구매완료</span>'
                                : `<button onclick="buyRecipeBook('decoration')" style="padding: 8px 16px; white-space: nowrap; min-width: 50px; flex-shrink: 0; background: #9b59b6; color: white;">구매</button>`}
                        </div>
                    `);
                }
            }
            
            // 먹이 구매 (카테고리가 all 또는 food, 속성 필터만 적용)
            if ((currentShopCategory === 'all' || currentShopCategory === 'food') &&
                (buyFilter === 'all' || ['fire', 'water', 'wind', 'earth', 'light', 'dark'].includes(buyFilter))) {
                // 일반 먹이
                ['fire', 'water', 'wind', 'earth'].forEach(type => {
                    if (buyFilter !== 'all' && type !== buyFilter) return;
                    
                    const ownedCount = inventory.food ? inventory.food.filter(f => f === type).length : 0;
                    foodItems.push(`
                        <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px; background: var(--bg); border: 1px solid var(--border); margin-bottom: 10px;">
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <span style="font-size: 1.5rem;">${ENV_ICONS[type]}</span>
                                <div>
                                    <div style="font-weight: 700;">${FOOD_NAMES[type]} <span style="font-size: 0.75rem; color: #888;">(보유: ${ownedCount})</span></div>
                                    <div style="font-size: 0.85rem; color: #666;">${ENV_ICONS[type]} 속성 +3, 성장 +2</div>
                                    <div style="font-size: 0.85rem; color: #888;">가격: ${SHOP_PRICES.buy.food_common}💰</div>
                                </div>
                            </div>
                            <button onclick="buyItem('food', '${type}', ${SHOP_PRICES.buy.food_common})" style="padding: 8px 16px; white-space: nowrap; min-width: 50px;">구매</button>
                        </div>
                    `);
                });

                // 희귀 먹이
                ['light', 'dark'].forEach(type => {
                    if (buyFilter !== 'all' && type !== buyFilter) return;
                    
                    const ownedCount = inventory.food ? inventory.food.filter(f => f === type).length : 0;
                    foodItems.push(`
                        <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px; background: var(--bg); border: 1px solid var(--border); margin-bottom: 10px;">
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <span style="font-size: 1.5rem;">${ENV_ICONS[type]}</span>
                                <div>
                                    <div style="font-weight: 700;">${FOOD_NAMES[type]} <span style="font-size: 0.75rem; color: #9b59b6;">희귀</span> <span style="font-size: 0.75rem; color: #888;">(보유: ${ownedCount})</span></div>
                                    <div style="font-size: 0.85rem; color: #666;">${ENV_ICONS[type]} 속성 +6, 성장 +3</div>
                                    <div style="font-size: 0.85rem; color: #888;">가격: ${SHOP_PRICES.buy.food_rare}💰</div>
                                </div>
                            </div>
                            <button onclick="buyItem('food', '${type}', ${SHOP_PRICES.buy.food_rare})" style="padding: 8px 16px; white-space: nowrap; min-width: 50px;">구매</button>
                        </div>
                    `);
                });
            }

            // 음악 구매 (카테고리가 all 또는 music, 스탯 필터 적용)
            if ((currentShopCategory === 'all' || currentShopCategory === 'music') &&
                (buyFilter === 'all' || ['intelligence', 'strength', 'charm'].includes(buyFilter))) {
                Object.keys(MUSIC_TYPES).forEach(type => {
                    // 스탯별 필터링 (복합 스탯 음악도 해당 필터에 표시)
                    if (buyFilter === 'intelligence' && !['classic', 'pop', 'edm'].includes(type)) return;
                    if (buyFilter === 'strength' && !['rock', 'ballad', 'edm'].includes(type)) return;
                    if (buyFilter === 'charm' && !['jazz', 'pop', 'ballad'].includes(type)) return;
                    
                    const musicData = MUSIC_TYPES[type];
                    const ownedCount = inventory.music ? inventory.music.filter(m => m === type).length : 0;
                    musicItems.push(`
                        <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px; background: var(--bg); border: 1px solid var(--border); margin-bottom: 10px;">
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <span style="font-size: 1.5rem;">🎵</span>
                                <div>
                                    <div style="font-weight: 700;">${musicData.name} <span style="font-size: 0.75rem; color: #888;">(보유: ${ownedCount})</span></div>
                                    <div style="font-size: 0.85rem; color: #666;">${musicData.effect}</div>
                                    <div style="font-size: 0.85rem; color: #888;">가격: ${SHOP_PRICES.buy.music}💰</div>
                                </div>
                            </div>
                            <button onclick="buyItem('music', '${type}', ${SHOP_PRICES.buy.music})" style="padding: 8px 16px; white-space: nowrap; min-width: 50px;">구매</button>
                        </div>
                    `);
                });
            }
            
            // 미니어처 구매 (카테고리가 all 또는 decoration, 속성 필터 적용, legendary 제외 - 미니게임 전용)
            if ((currentShopCategory === 'all' || currentShopCategory === 'decoration') &&
                (buyFilter === 'all' || ['fire', 'water', 'wind', 'earth', 'light', 'dark'].includes(buyFilter))) {
                
                // 합성 전용 아이템 (상점에서 제외)
                const synthOnlyItems = ['flame_lamp', 'aqua_fountain', 'wind_chime', 'earth_statue', 'light_orb', 'shadow_crystal'];
                
                // 속성 표시용 헬퍼 함수
                function getDecoAttrDisplay(data) {
                    if (data.attr === 'dual' && data.dualAttr) {
                        return data.dualAttr.map(a => ENV_ICONS[a]).join('') + ` +${data.power}`;
                    } else if (data.attr === 'all') {
                        return '🌈 전체 속성 +' + data.power;
                    } else {
                        return `${ENV_ICONS[data.attr]} +${data.power}`;
                    }
                }
                
                Object.keys(DECORATION_TYPES).forEach(key => {
                    const decoData = DECORATION_TYPES[key];
                    
                    // legendary는 상점에서 판매 안함 (미니게임 전용)
                    if (decoData.quality === 'legendary') return;
                    
                    // 합성 전용 아이템 제외
                    if (synthOnlyItems.includes(key)) return;
                    
                    // 속성 필터 (복합 속성은 all 필터에서만 표시하거나, 해당 속성 포함 시 표시)
                    if (buyFilter !== 'all') {
                        if (decoData.attr === 'dual') {
                            if (!decoData.dualAttr || !decoData.dualAttr.includes(buyFilter)) return;
                        } else if (decoData.attr === 'all') {
                            // all 속성 미니어처은 모든 속성 필터에서 표시
                        } else if (decoData.attr !== buyFilter) {
                            return;
                        }
                    }
                    
                    // 인벤토리 + 테라리움에 설치된 미니어처
                    const inInventory = inventory.decorations ? inventory.decorations.filter(d => d === key).length : 0;
                    const installed = installedDecorations ? installedDecorations.filter(d => d.type === key).length : 0;
                    const ownedCount = inInventory + installed;
                    const qualityLabel = decoData.quality === 'rare' ? '<span style="font-size: 0.75rem; color: #1565c0;">희귀</span>' :
                                        decoData.quality === 'epic' ? '<span style="font-size: 0.75rem; color: #e65100;">최상급</span>' : '';
                    
                    // 등급별 테두리 색
                    const qualityBorderColor = decoData.quality === 'legendary' ? '#ffd700' : decoData.quality === 'epic' ? '#9b59b6' : decoData.quality === 'rare' ? '#3498db' : 'var(--border)';
                    
                    decoItems.push(`
                        <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px; background: var(--bg); border: 2px solid ${qualityBorderColor}; border-radius: 6px; margin-bottom: 10px;">
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <span style="font-size: 1.5rem;">${decoData.icon}</span>
                                <div>
                                    <div style="font-weight: 700;">${decoData.name} ${qualityLabel} <span style="font-size: 0.75rem; color: #888;">(보유: ${ownedCount})</span></div>
                                    <div style="font-size: 0.85rem; color: #888;">가격: ${decoData.price}💰 | ${getDecoAttrDisplay(decoData)}</div>
                                </div>
                            </div>
                            <button onclick="buyItem('decoration', '${key}', ${decoData.price})" style="padding: 8px 16px; white-space: nowrap; min-width: 50px;">구매</button>
                        </div>
                    `);
                });
            }

            const totalItems = etcItems.length + foodItems.length + musicItems.length + decoItems.length;
            
            if (totalItems === 0) {
                container.innerHTML = '<p style="color: #888; text-align: center; padding: 20px;">구매 가능한 물품이 없습니다</p>';
            } else {
                // 카테고리별 접기 가능한 섹션 생성
                let sectionsHtml = '';
                
                // 기타 섹션
                if (etcItems.length > 0) {
                    const isFolded = shopBuyFoldState.etc;
                    sectionsHtml += `
                        <div class="shop-category-section" style="margin-bottom: 15px;">
                            <div onclick="toggleShopBuyFold('etc')" style="display: flex; justify-content: space-between; align-items: center; padding: 10px 12px; background: #888; color: white; border-radius: 6px; cursor: pointer; margin-bottom: ${isFolded ? '0' : '10px'};">
                                <span style="font-weight: 600;">📦 기타 (${etcItems.length})</span>
                                <span>${isFolded ? '▶' : '▼'}</span>
                            </div>
                            <div style="display: ${isFolded ? 'none' : 'block'};">
                                ${etcItems.join('')}
                            </div>
                        </div>
                    `;
                }
                
                // 먹이 섹션
                if (foodItems.length > 0) {
                    const isFolded = shopBuyFoldState.food;
                    sectionsHtml += `
                        <div class="shop-category-section" style="margin-bottom: 15px;">
                            <div onclick="toggleShopBuyFold('food')" style="display: flex; justify-content: space-between; align-items: center; padding: 10px 12px; background: var(--fire); color: white; border-radius: 6px; cursor: pointer; margin-bottom: ${isFolded ? '0' : '10px'};">
                                <span style="font-weight: 600;">🍎 먹이 (${foodItems.length})</span>
                                <span>${isFolded ? '▶' : '▼'}</span>
                            </div>
                            <div style="display: ${isFolded ? 'none' : 'block'};">
                                ${foodItems.join('')}
                            </div>
                        </div>
                    `;
                }
                
                // 레코드 섹션
                if (musicItems.length > 0) {
                    const isFolded = shopBuyFoldState.music;
                    sectionsHtml += `
                        <div class="shop-category-section" style="margin-bottom: 15px;">
                            <div onclick="toggleShopBuyFold('music')" style="display: flex; justify-content: space-between; align-items: center; padding: 10px 12px; background: #9b59b6; color: white; border-radius: 6px; cursor: pointer; margin-bottom: ${isFolded ? '0' : '10px'};">
                                <span style="font-weight: 600;">🎵 레코드 (${musicItems.length})</span>
                                <span>${isFolded ? '▶' : '▼'}</span>
                            </div>
                            <div style="display: ${isFolded ? 'none' : 'block'};">
                                ${musicItems.join('')}
                            </div>
                        </div>
                    `;
                }
                
                // 미니어처 섹션
                if (decoItems.length > 0) {
                    const isFolded = shopBuyFoldState.decoration;
                    sectionsHtml += `
                        <div class="shop-category-section" style="margin-bottom: 15px;">
                            <div onclick="toggleShopBuyFold('decoration')" style="display: flex; justify-content: space-between; align-items: center; padding: 10px 12px; background: var(--earth); color: white; border-radius: 6px; cursor: pointer; margin-bottom: ${isFolded ? '0' : '10px'};">
                                <span style="font-weight: 600;">🌳 미니어처 (${decoItems.length})</span>
                                <span>${isFolded ? '▶' : '▼'}</span>
                            </div>
                            <div style="display: ${isFolded ? 'none' : 'block'};">
                                ${decoItems.join('')}
                            </div>
                        </div>
                    `;
                }
                
                container.innerHTML = sectionsHtml;
            }
        }
        
        // 상점 구매 카테고리 접기/펼치기 토글
        function toggleShopBuyFold(category) {
            shopBuyFoldState[category] = !shopBuyFoldState[category];
            renderBuyList();
        }

        // 잠금 모드 토글
        function toggleLockMode() {
            isLockMode = !isLockMode;
            const btn = document.getElementById('lockModeBtn');
            if (btn) {
                if (isLockMode) {
                    btn.textContent = '🔒';
                    btn.style.background = '#e74c3c';
                    btn.style.color = 'white';
                    btn.style.borderColor = '#e74c3c';
                    btn.title = '판매 모드로 전환';
                    showNotification('🔒 잠금 모드: 아이템을 클릭하면 잠금됩니다');
                } else {
                    btn.textContent = '🔓';
                    btn.style.background = 'var(--card)';
                    btn.style.color = 'var(--text)';
                    btn.style.borderColor = 'var(--border)';
                    btn.title = '잠금 모드로 전환';
                    showNotification('🔓 판매 모드: 아이템을 클릭하면 판매됩니다');
                }
            }
            renderSellList();
        }

        // 아이템 판매 잠금 토글
        function toggleItemLock(category, type) {
            let lockCategory;
            if (category === 'food') lockCategory = 'food';
            else if (category === 'decoration') lockCategory = 'decorations';
            else if (category === 'music') lockCategory = 'music';
            else lockCategory = 'decorations';
            
            const index = lockedItems[lockCategory].indexOf(type);
            
            if (index === -1) {
                // 잠금 추가
                lockedItems[lockCategory].push(type);
                showNotification(`🔒 ${getItemDisplayName(category, type)} 판매 잠금`);
            } else {
                // 잠금 해제
                lockedItems[lockCategory].splice(index, 1);
                showNotification(`🔓 ${getItemDisplayName(category, type)} 잠금 해제`);
            }
            
            saveGame();
            renderSellList();
        }
        
        // 아이템 표시 이름 가져오기
        function getItemDisplayName(category, type) {
            if (category === 'food') {
                return FOOD_NAMES[type] || type;
            } else if (category === 'decoration') {
                const deco = DECORATION_TYPES[type];
                return deco ? deco.name : type;
            } else if (category === 'music') {
                const music = MUSIC_TYPES[type];
                if (music) return music.name;
                const eventMusic = EVENT_ITEMS[type];
                if (eventMusic) return eventMusic.name;
                return type;
            }
            return type;
        }
        
        // 일괄 판매 확인 모달 표시
        function showBulkSellConfirm(message, onConfirm) {
            const modal = document.createElement('div');
            modal.id = 'bulkSellConfirmModal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.7);
                z-index: 100000;
                display: flex;
                justify-content: center;
                align-items: center;
            `;
            
            modal.innerHTML = `
                <div style="background: var(--card); border-radius: 12px; padding: 24px; max-width: 400px; width: 90%; text-align: center;">
                    <div style="font-size: 2rem; margin-bottom: 15px;">📦</div>
                    <div style="font-size: 1rem; margin-bottom: 20px; color: var(--text);">${message}</div>
                    <div style="display: flex; gap: 10px; justify-content: center;">
                        <button id="bulkSellCancelBtn" style="padding: 10px 24px; background: var(--bg); border: 1px solid var(--border); border-radius: 8px; cursor: pointer; font-size: 1rem;">취소</button>
                        <button id="bulkSellConfirmBtn" style="padding: 10px 24px; background: var(--fire); color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 1rem; font-weight: 600;">판매</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            document.getElementById('bulkSellCancelBtn').onclick = () => {
                modal.remove();
            };
            
            document.getElementById('bulkSellConfirmBtn').onclick = () => {
                modal.remove();
                if (onConfirm) onConfirm();
            };
            
            modal.onclick = (e) => {
                if (e.target === modal) modal.remove();
            };
        }
        
        // 일괄 판매 실행 (드롭다운에서 선택 후)
        function executeBulkSell() {
            const select = document.getElementById('bulkSellSelect');
            
            if (!select || !select.value) {
                showNotification('판매할 항목을 선택해주세요');
                return;
            }
            
            const value = select.value;
            
            if (value === 'food_common') {
                bulkSellFood('common');
            } else if (value === 'food_rare') {
                bulkSellFood('rare');
            } else if (value === 'deco_common') {
                bulkSellByQuality('common');
            } else if (value === 'deco_rare') {
                bulkSellByQuality('rare');
            } else if (value === 'deco_epic') {
                bulkSellByQuality('epic');
            }
            
            // 드롭다운 초기화
            if (select) select.value = '';
        }
        
        // 미니어처 품질별 일괄 판매
        function bulkSellByQuality(maxQuality) {
            const qualityOrder = ['common', 'rare', 'epic', 'legendary'];
            const maxIndex = qualityOrder.indexOf(maxQuality);
            
            if (maxIndex === -1) return;
            
            // 판매할 미니어처 찾기 (잠금 제외)
            const toSell = [];
            inventory.decorations.forEach((type, idx) => {
                const deco = DECORATION_TYPES[type];
                if (!deco) return;
                
                // 잠금된 아이템은 제외
                if (lockedItems.decorations.includes(type)) return;
                
                const qualityIdx = qualityOrder.indexOf(deco.quality);
                if (qualityIdx !== -1 && qualityIdx <= maxIndex) {
                    toSell.push({ type, idx, price: Math.floor(deco.price * 0.5), name: deco.name });
                }
            });
            
            if (toSell.length === 0) {
                showNotification('판매할 미니어처가 없습니다 (잠금 제외)');
                return;
            }
            
            const totalPrice = toSell.reduce((sum, item) => sum + item.price, 0);
            const qualityText = maxQuality === 'common' ? '일반' : maxQuality === 'rare' ? '희귀 이하' : '최상급 이하';
            
            showBulkSellConfirm(`${qualityText} 미니어처 ${toSell.length}개를 ${totalPrice}💰에 판매하시겠습니까?`, () => {
                // 역순으로 삭제 (인덱스 변경 방지)
                const typesToRemove = toSell.map(item => item.type);
                typesToRemove.forEach(type => {
                    const idx = inventory.decorations.indexOf(type);
                    if (idx !== -1) inventory.decorations.splice(idx, 1);
                });
                
                coins += totalPrice;
                showNotification(`📦 ${toSell.length}개 미니어처 판매 완료! +${totalPrice}💰`);
                setShopkeeperDialogue('...대량 거래 감사합니다.');
                
                saveGame();
                renderSellList();
                renderBuyList();
                updateCoinDisplay();
                renderInventory();
            });
        }
        
        // 먹이 일괄 판매
        function bulkSellFood(type) {
            let targetTypes = [];
            let price = 0;
            let label = '';
            
            if (type === 'common') {
                targetTypes = ['fire', 'water', 'wind', 'earth'];
                price = SHOP_PRICES.sell.food_common;
                label = '일반';
            } else if (type === 'rare') {
                targetTypes = ['light', 'dark'];
                price = SHOP_PRICES.sell.food_rare;
                label = '희귀';
            }
            
            const toSell = [];
            inventory.food.forEach((foodType, idx) => {
                if (targetTypes.includes(foodType) && !lockedItems.food.includes(foodType)) {
                    toSell.push({ type: foodType, price: price });
                }
            });
            
            if (toSell.length === 0) {
                showNotification(`판매할 ${label} 먹이가 없습니다 (잠금 제외)`);
                return;
            }
            
            const totalPrice = toSell.reduce((sum, item) => sum + item.price, 0);
            
            // 커스텀 확인 모달 표시
            showBulkSellConfirm(`${label} 먹이 ${toSell.length}개를 ${totalPrice}💰에 판매하시겠습니까?`, () => {
                toSell.forEach(item => {
                    const idx = inventory.food.indexOf(item.type);
                    if (idx !== -1) inventory.food.splice(idx, 1);
                });
                
                coins += totalPrice;
                showNotification(`📦 ${toSell.length}개 먹이 판매 완료! +${totalPrice}💰`);
                setShopkeeperDialogue('...대량 거래 감사합니다.');
                
                saveGame();
                renderSellList();
                renderBuyList();
                updateCoinDisplay();
                renderInventory();
            });
        }
        
        function sellItem(category, type) {
            // 잠금 체크
            if (category === 'food' && lockedItems.food.includes(type)) {
                showNotification('🔒 이 아이템은 판매 잠금 상태입니다');
                return;
            }
            if (category === 'decoration' && lockedItems.decorations.includes(type)) {
                showNotification('🔒 이 아이템은 판매 잠금 상태입니다');
                return;
            }
            
            // 이벤트 아이템 체크
            const eventItem = EVENT_ITEMS[type];
            if (eventItem) {
                let inventoryArray;
                if (eventItem.type === 'food') inventoryArray = inventory.food;
                else if (eventItem.type === 'music') inventoryArray = inventory.music;
                else if (eventItem.type === 'decoration') inventoryArray = inventory.decorations;
                
                const index = inventoryArray ? inventoryArray.indexOf(type) : -1;
                if (index === -1) return;
                
                inventoryArray.splice(index, 1);
                const sellPrice = eventItem.type === 'food' ? 15 : eventItem.type === 'music' ? 12 : 25;
                coins += sellPrice;
                showShopNotification(eventItem.name, 'sell', sellPrice);
                setShopkeeperDialogue(`${sellPrice}코인입니다.`);
                
                saveGame();
                renderSellList();
                renderBuyList();
                updateCoinDisplay();
                renderInventory();
                return;
            }
            
            // 합성 아이템 체크
            const synthItem = SYNTH_ITEMS[type];
            if (synthItem) {
                let inventoryArray;
                if (synthItem.type === 'food') inventoryArray = inventory.food;
                else if (synthItem.type === 'decoration') inventoryArray = inventory.decorations;
                
                const index = inventoryArray ? inventoryArray.indexOf(type) : -1;
                if (index === -1) return;
                
                inventoryArray.splice(index, 1);
                const sellPrice = synthItem.type === 'food' ? 8 : 20;
                coins += sellPrice;
                showShopNotification(synthItem.name, 'sell', sellPrice);
                setShopkeeperDialogue(`${sellPrice}코인입니다.`);
                
                saveGame();
                renderSellList();
                renderBuyList();
                updateCoinDisplay();
                renderInventory();
                return;
            }
            
            let sellPrice = 0;
            let itemName = '';
            if (category === 'food') {
                const index = inventory.food.indexOf(type);
                if (index === -1) return;
                inventory.food.splice(index, 1);
                
                // medicine은 별도 처리
                if (type === 'medicine') {
                    sellPrice = 10; // 판매가 10
                    itemName = MEDICINE.name;
                } else {
                    const isRare = type === 'light' || type === 'dark';
                    sellPrice = isRare ? SHOP_PRICES.sell.food_rare : SHOP_PRICES.sell.food_common;
                    itemName = FOOD_NAMES[type];
                }
                coins += sellPrice;
                showShopNotification(itemName, 'sell', sellPrice);
            } else if (category === 'decoration') {
                const index = inventory.decorations.indexOf(type);
                if (index === -1) return;
                inventory.decorations.splice(index, 1);
                
                const decoData = DECORATION_TYPES[type];
                sellPrice = Math.floor(decoData.price * 0.5);
                itemName = decoData.name;
                coins += sellPrice;
                showShopNotification(itemName, 'sell', sellPrice);
            } else if (category === 'music') {
                const index = inventory.music.indexOf(type);
                if (index === -1) return;
                inventory.music.splice(index, 1);
                sellPrice = SHOP_PRICES.sell.music;
                itemName = MUSIC_TYPES[type].name;
                coins += sellPrice;
                showShopNotification(itemName, 'sell', sellPrice);
            }

            setShopkeeperDialogue(`${sellPrice}코인입니다.`);
            saveGame();
            renderSellList();
            renderBuyList();
            updateCoinDisplay();
            renderInventory();
        }

        // 레시피북 구매
        async function buyRecipeBook(bookType) {
            const book = RECIPE_BOOKS[bookType];
            if (!book) return;
            
            if (purchasedRecipeBooks.includes(bookType)) {
                showNotification('이미 구매한 레시피북입니다!');
                return;
            }
            
            if (coins < book.price) {
                showNotification('코인이 부족합니다!');
                setShopkeeperDialogue('...돈이 부족해 보이네요.');
                return;
            }
            
            const confirmed = await showConfirm(
                '레시피북 구매',
                `${book.icon} ${book.name}을(를) ${book.price}💰에 구매하시겠습니까?\n\n${book.recipes.length}개의 레시피가 연구실에 추가됩니다.\n\n⚠️ 레시피북으로 해금된 레시피는 "직접 발견" 업적에 포함되지 않습니다.`
            );
            
            if (!confirmed) return;
            
            coins -= book.price;
            purchasedRecipeBooks.push(bookType);
            
            // 해당 레시피들을 발견된 레시피에 추가 (이미 발견한 것은 제외)
            let newRecipes = 0;
            book.recipes.forEach(recipeId => {
                if (!discoveredRecipes.includes(recipeId)) {
                    discoveredRecipes.push(recipeId);
                    newRecipes++;
                }
            });
            
            saveGame();
            renderBuyList();
            updateCoinDisplay();
            applyRecipeFilters();
            checkAchievements(); // 레시피 업적 체크
            
            showNotification(`${book.icon} ${book.name} 구매 완료! (${newRecipes}개의 새 레시피 해금)`);
            setShopkeeperDialogue(`${book.name}이군요! 연구실에서 확인해보세요.`);
        }

        function buyItem(category, type, price) {
            if (coins < price) {
                showNotification('코인이 부족합니다!');
                setShopkeeperDialogue('...돈이 부족해 보이네요.');
                return;
            }

            coins -= price;
            let itemName = '';

            if (category === 'food') {
                if (!inventory.food) inventory.food = [];
                inventory.food.push(type);
                if (type === 'medicine') {
                    itemName = MEDICINE.name;
                    showShopNotification(itemName, 'buy', price);
                    // 질병 튜토리얼: 약초 구매 액션 체크
                    checkSickTutorialAction('buyMedicine');
                } else if (SYNTH_ITEMS[type]) {
                    // 합성 아이템 (수선화 꽃잎, 아카시아 꿀 등)
                    itemName = SYNTH_ITEMS[type].name;
                    showShopNotification(itemName, 'buy', price);
                } else {
                    itemName = FOOD_NAMES[type];
                    showShopNotification(itemName, 'buy', price);
                }
            } else if (category === 'music') {
                if (!inventory.music) inventory.music = [];
                inventory.music.push(type);
                itemName = MUSIC_TYPES[type].name;
                showShopNotification(itemName, 'buy', price);
            } else if (category === 'decoration') {
                if (!inventory.decorations) inventory.decorations = [];
                inventory.decorations.push(type);
                itemName = DECORATION_TYPES[type].name;
                showShopNotification(itemName, 'buy', price);
            }

            setShopkeeperDialogue('...감사합니다. 또 오세요.(오지마)');
            saveGame();
            renderSellList();
            renderBuyList();
            updateCoinDisplay();
            renderInventory();
            
            // 연구실 튜토리얼 체크
            checkInventoryAndLabTutorial();
        }
        
        // 이벤트 아이템 구매
        function buyEventItem(itemKey, price) {
            if (coins < price) {
                showNotification('코인이 부족합니다!');
                setShopkeeperDialogue('...돈이 부족해 보이네요.');
                return;
            }
            
            const item = EVENT_ITEMS[itemKey];
            if (!item) {
                showNotification('아이템을 찾을 수 없습니다');
                return;
            }
            
            // 이벤트 기간 체크
            const event = EVENT_TYPES[item.event];
            if (event && event.validUntil && new Date() > new Date(event.validUntil)) {
                showNotification('이벤트 기간이 종료되었습니다');
                return;
            }
            
            coins -= price;
            
            if (item.type === 'food') {
                if (!inventory.food) inventory.food = [];
                inventory.food.push(itemKey);
            } else if (item.type === 'music') {
                if (!inventory.music) inventory.music = [];
                inventory.music.push(itemKey);
            } else if (item.type === 'decoration') {
                if (!inventory.decorations) inventory.decorations = [];
                inventory.decorations.push(itemKey);
            }
            
            showShopNotification(`🎄 ${item.name}`, 'buy', price);
            setShopkeeperDialogue('...감사합니다. 또 오세요.(오지마)');
            
            saveGame();
            renderSellList();
            renderBuyList();
            updateCoinDisplay();
            renderInventory();
            
            // 연구실 튜토리얼 체크
            checkInventoryAndLabTutorial();
        }

        // 앨범 데이터로부터 도감 재구성
        function rebuildEncyclopediaFromAlbum() {
            console.log('앨범에서 도감 재구성 시작...');
            console.log('앨범 데이터:', collection);
            
            const newEncyclopedia = {};
            
            collection.forEach(spirit => {
                let encyclopediaKey;
                const wingType = spirit.wingType || 'butterfly'; // 기본값 나비형
                
                if (spirit.type === 'titania' || spirit.type === 'oberon' || spirit.type === 'spiritking') {
                    // 전설적 존재는 고유 키 사용
                    encyclopediaKey = spirit.type;
                } else if (spirit.type === 'nostat') {
                    // 수식어 없는 정령 (wingType 포함)
                    encyclopediaKey = `nostat-${spirit.attributeType}-${wingType}`;
                } else if (spirit.type && spirit.type.startsWith('fusion-')) {
                    // 연결 정령은 타입 그대로 사용
                    encyclopediaKey = spirit.type;
                } else if (spirit.type && spirit.type.startsWith('event_')) {
                    // 이벤트 정령은 타입 그대로 사용
                    encyclopediaKey = spirit.type;
                } else {
                    // 일반 정령 (스탯-속성-wingType)
                    encyclopediaKey = `${spirit.type}-${spirit.attributeType}-${wingType}`;
                }
                
                if (!newEncyclopedia[encyclopediaKey]) {
                    newEncyclopedia[encyclopediaKey] = 0;
                }
                newEncyclopedia[encyclopediaKey]++;
            });
            
            console.log('재구성된 도감:', newEncyclopedia);
            encyclopedia = newEncyclopedia;
            saveGame();
            
            return Object.keys(newEncyclopedia).length;
        }

        async function manualRebuildEncyclopedia() {
            if (collection.length === 0) {
                showNotification('앨범에 데이터가 없어 복구할 수 없습니다');
                return;
            }
            
            const confirmed = await showConfirm(
                '도감 복구',
                `앨범에 있는 ${collection.length}마리의 정령 데이터로 도감을 다시 구성합니다.\n\n기존 도감 데이터는 덮어씌워집니다.\n계속하시겠습니까?`
            );
            
            if (!confirmed) {
                return;
            }
            
            const recoveredCount = rebuildEncyclopediaFromAlbum();
            renderEncyclopedia();
            showNotification(`✅ 도감을 복구했습니다! (${recoveredCount}종)`);
        }
        
        // 도감 → 앨범 복구 (도감에 있는데 앨범에 없는 정령 복구)
        async function recoverAlbumFromEncyclopedia() {
            // 앨범에 있는 타입들 수집 (타입별 카운트)
            const albumCounts = {};
            collection.forEach(item => {
                if (!item.type) return;
                
                let key;
                if (item.type === 'nostat') {
                    key = `nostat-${item.attributeType}`;
                } else if (item.type.startsWith('event_') || item.type === 'titania' || item.type === 'oberon' || item.type === 'spiritking' || FUSION_TYPES[item.type]) {
                    key = item.type;
                } else {
                    key = `${item.type}-${item.attributeType}`;
                }
                albumCounts[key] = (albumCounts[key] || 0) + 1;
            });
            
            let recoveredCount = 0;
            const recoveredNames = [];
            
            // 도감 순회
            Object.entries(encyclopedia).forEach(([key, value]) => {
                const encyclopediaCount = typeof value === 'object' ? (value.count || 0) : (value || 0);
                if (encyclopediaCount <= 0) return;
                
                const albumCount = albumCounts[key] || 0;
                
                // 상세 정보 배열 확인
                const details = encyclopediaDetails[key] || [];
                
                // 상세 정보 개수를 기준으로 복구 (도감 카운트가 아닌 실제 저장된 상세 정보)
                // 상세 정보가 없으면 최대 1개만 복구 (중복 방지)
                const availableDetails = details.length > 0 ? details.length : Math.min(1, encyclopediaCount);
                
                // 앨범에 없는 것만 복구
                const missingCount = Math.max(0, availableDetails - albumCount);
                if (missingCount <= 0) return;
                
                // 복구할 정령 정보 생성
                for (let i = 0; i < missingCount; i++) {
                    // 상세 정보 인덱스: 앨범에 있는 수 + i
                    const detailIndex = albumCount + i;
                    const recoveredSpirit = createRecoveredSpirit(key, detailIndex < details.length ? detailIndex : null);
                    if (recoveredSpirit) {
                        collection.push(recoveredSpirit);
                        recoveredCount++;
                        if (!recoveredNames.includes(recoveredSpirit.name)) {
                            recoveredNames.push(recoveredSpirit.name);
                        }
                    }
                }
            });
            
            if (recoveredCount > 0) {
                saveGame();
                renderCollection();
            }
            
            return { count: recoveredCount, names: recoveredNames };
        }
        
        // 복구용 정령 데이터 생성 (상세 정보가 있으면 사용, 없으면 기본값)
        function createRecoveredSpirit(encyclopediaKey, detailIndex = null) {
            // 상세 정보가 있으면 그걸 사용
            if (encyclopediaDetails[encyclopediaKey] && detailIndex !== null) {
                const detail = encyclopediaDetails[encyclopediaKey][detailIndex];
                if (detail) {
                    return {
                        id: `recovered-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                        type: detail.type || encyclopediaKey,
                        attributeType: detail.attributeType || encyclopediaKey,
                        name: detail.name || '복구된 정령',
                        icon: detail.icon || '✨',
                        desc: detail.desc || '',
                        parameters: { ...detail.parameters },
                        hiddenAttributes: { ...detail.hiddenAttributes },
                        originalName: detail.originalName || '(복구됨)',
                        wingType: detail.wingType,
                        lightTime: detail.lightTime || 0,
                        darkTime: detail.darkTime || 0,
                        completedAt: detail.completedAt || Date.now(),
                        isEventSpirit: detail.isEventSpirit || false,
                        eventType: detail.eventType || null,
                        isFusion: detail.isFusion || false,
                        fusionRarity: detail.fusionRarity || null,
                        isRecovered: true,
                        recoveredFromDetails: true, // 상세 정보에서 복구됨
                        // 키워드 정보 복구
                        statusKeywords: detail.statusKeywords || [],
                        inheritedKeywords: detail.inheritedKeywords || [],
                        allStatusKeywords: detail.allStatusKeywords || []
                    };
                }
            }
            
            // 상세 정보가 없으면 기본값으로 생성
            const baseSpirit = {
                id: `recovered-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                completedAt: Date.now(),
                originalName: '(복구됨)',
                isRecovered: true, // 복구된 정령 표시
                parameters: { intelligence: 50, strength: 50, charm: 50, affection: 50 },
                hiddenAttributes: { fire: 0, water: 0, wind: 0, earth: 0, light: 0, dark: 0 }
            };
            
            // 전설 정령
            if (encyclopediaKey === 'titania') {
                return {
                    ...baseSpirit,
                    type: 'titania',
                    attributeType: 'light',
                    name: '티타니아',
                    icon: '🦋✨',
                    desc: '(복구된 정령)',
                    wingType: 'butterfly',
                    parameters: { intelligence: 100, strength: 100, charm: 100, affection: 100 }
                };
            }
            if (encyclopediaKey === 'oberon') {
                return {
                    ...baseSpirit,
                    type: 'oberon',
                    attributeType: 'dark',
                    name: '오베론',
                    icon: '🦋🌙',
                    desc: '(복구된 정령)',
                    wingType: 'moth',
                    parameters: { intelligence: 100, strength: 100, charm: 100, affection: 100 }
                };
            }
            if (encyclopediaKey === 'spiritking') {
                return {
                    ...baseSpirit,
                    type: 'spiritking',
                    attributeType: 'balanced',
                    name: '정령왕',
                    icon: '👑🌸',
                    desc: '(복구된 정령)',
                    wingType: 'butterfly',
                    parameters: { intelligence: 100, strength: 100, charm: 100, affection: 150 }
                };
            }
            
            // 합성/연결 정령
            if (FUSION_TYPES[encyclopediaKey]) {
                const fusion = FUSION_TYPES[encyclopediaKey];
                return {
                    ...baseSpirit,
                    type: encyclopediaKey,
                    attributeType: encyclopediaKey,
                    name: fusion.name,
                    icon: fusion.icon,
                    desc: '(복구된 정령)',
                    isFusion: true,
                    fusionRarity: fusion.rarity
                };
            }
            
            // 이벤트 정령
            if (encyclopediaKey.startsWith('event_')) {
                const eventKey = encyclopediaKey.replace('event_', '').replace('_shiny', '');
                const isShiny = encyclopediaKey.includes('_shiny');
                const event = EVENT_TYPES[eventKey];
                if (event) {
                    const data = isShiny && event.shiny ? event.shiny : event;
                    return {
                        ...baseSpirit,
                        type: encyclopediaKey,
                        attributeType: event.attribute,
                        name: data.name,
                        icon: data.stages ? data.stages.adult : '🎄',
                        desc: '(복구된 정령)',
                        isEventSpirit: true,
                        eventType: eventKey,
                        isShiny: isShiny
                    };
                }
                return null;
            }
            
            // 수식어 없는 정령 (nostat-{attr}-{wingType})
            if (encyclopediaKey.startsWith('nostat-')) {
                const keyParts = encyclopediaKey.replace('nostat-', '').split('-');
                let attrType, wingType;
                
                if (keyParts.length >= 2) {
                    // 새 형식: nostat-fire-butterfly
                    wingType = keyParts.pop(); // 마지막은 wingType
                    attrType = keyParts.join('-'); // 나머지는 속성 (복합속성 대응)
                } else {
                    // 구 형식: nostat-fire
                    attrType = keyParts[0];
                    wingType = 'butterfly'; // 기본값
                }
                
                const attrData = ATTRIBUTE_NAMES[attrType];
                if (attrData) {
                    const attrIcon = typeof attrData.icon === 'object' ? attrData.icon[wingType] || attrData.icon.butterfly : attrData.icon;
                    return {
                        ...baseSpirit,
                        type: 'nostat',
                        attributeType: attrType,
                        name: `${attrData.name}`,
                        icon: attrIcon,
                        desc: '(복구된 정령)',
                        wingType: wingType,
                        parameters: { intelligence: 10, strength: 10, charm: 10, affection: 50 }
                    };
                }
                return null;
            }
            
            // 일반 정령 (statType-attrType-wingType) - 새 시스템
            const parts = encyclopediaKey.split('-');
            if (parts.length >= 2) {
                let statType, attrType, wingType;
                
                // 마지막이 butterfly 또는 moth면 wingType
                const lastPart = parts[parts.length - 1];
                if (lastPart === 'butterfly' || lastPart === 'moth') {
                    wingType = parts.pop();
                } else {
                    wingType = 'butterfly'; // 기본값
                }
                
                if (parts.length === 2) {
                    // statType-attrType (단일 속성)
                    [statType, attrType] = parts;
                } else if (parts.length === 3) {
                    // statType-attr1-attr2 (복합 속성)
                    statType = parts[0];
                    attrType = `${parts[1]}-${parts[2]}`;
                }
                
                const evolution = EVOLUTION_TYPES[statType];
                const attrData = ATTRIBUTE_NAMES[attrType];
                
                if (evolution && attrData) {
                    // 스탯 타입에 따른 스탯 설정
                    const params = { intelligence: 30, strength: 30, charm: 30, affection: 50 };
                    if (statType === 'intelligent') params.intelligence = 100;
                    else if (statType === 'strong') params.strength = 100;
                    else if (statType === 'beautiful') params.charm = 100;
                    else if (statType === 'sage') {
                        params.intelligence = 100;
                        params.strength = 100;
                        params.charm = 100;
                    }
                    
                    const attrIcon = typeof attrData.icon === 'object' ? attrData.icon[wingType] || attrData.icon.butterfly : attrData.icon;
                    
                    return {
                        ...baseSpirit,
                        type: statType,
                        attributeType: attrType,
                        name: `${evolution.prefix} ${attrData.name}`,
                        icon: `${evolution.icon}${attrIcon}`,
                        desc: '(복구된 정령)',
                        wingType: wingType,
                        parameters: params
                    };
                }
            }
            
            return null;
        }
        
        // 앨범 복구 UI
        async function showAlbumRecoveryDialog() {
            // 먼저 복구 가능한 정령 수 계산
            const albumTypes = {};
            collection.forEach(item => {
                const key = getEncyclopediaKeyFromAlbumItem(item);
                if (key) {
                    albumTypes[key] = (albumTypes[key] || 0) + 1;
                }
            });
            
            let missingCount = 0;
            let withDetailsCount = 0; // 상세 정보가 있는 정령 수
            let noDetailsCount = 0; // 상세 정보가 없는 정령 수
            
            Object.entries(encyclopedia).forEach(([key, value]) => {
                const encyclopediaCount = typeof value === 'object' ? (value.count || 0) : (value || 0);
                if (encyclopediaCount <= 0) return;
                
                const albumCount = albumTypes[key] || 0;
                const details = encyclopediaDetails[key] || [];
                
                // 상세 정보 개수를 기준으로 복구 가능 수 계산
                const availableDetails = details.length > 0 ? details.length : Math.min(1, encyclopediaCount);
                const missing = Math.max(0, availableDetails - albumCount);
                
                if (missing > 0) {
                    missingCount += missing;
                    
                    for (let i = 0; i < missing; i++) {
                        const detailIndex = albumCount + i;
                        if (detailIndex < details.length) {
                            withDetailsCount++;
                        } else {
                            noDetailsCount++;
                        }
                    }
                }
            });
            
            if (missingCount === 0) {
                showNotification('✅ 모든 정령이 앨범에 있습니다. 복구할 항목이 없어요!');
                return;
            }
            
            let message = `도감에는 있지만 앨범에 없는 정령이 ${missingCount}마리 발견되었습니다.\n\n`;
            
            if (withDetailsCount > 0) {
                message += `📋 상세 정보 보존: ${withDetailsCount}마리\n(본명, 스탯 등 완벽 복구)\n\n`;
            }
            if (noDetailsCount > 0) {
                message += `⚠️ 기본값 복구: ${noDetailsCount}마리\n(이전 버전에서 진화한 정령 - 스탯이 기본값으로 설정됨)\n\n`;
            }
            
            message += `복구하시겠습니까?`;
            
            const confirmed = await showConfirmAsync(
                '앨범 복구',
                message,
                '복구하기',
                '취소'
            );
            
            if (confirmed) {
                const result = await recoverAlbumFromEncyclopedia();
                if (result.count > 0) {
                    showNotification(`✅ ${result.count}마리 복구 완료!\n${result.names.slice(0, 3).join(', ')}${result.names.length > 3 ? ' 외 ' + (result.names.length - 3) + '종' : ''}`);
                    renderCollection();
                } else {
                    showNotification('복구할 정령이 없습니다.');
                }
            }
        }
        
        // 앨범 아이템에서 도감 키 추출
        function getEncyclopediaKeyFromAlbumItem(item) {
            if (!item.type) return null;
            
            if (item.type === 'titania' || item.type === 'oberon' || item.type === 'spiritking') {
                return item.type;
            } else if (item.type === 'nostat') {
                return `nostat-${item.attributeType}`;
            } else if (item.type.startsWith('event_')) {
                return item.type;
            } else if (FUSION_TYPES[item.type]) {
                return item.type;
            } else {
                return `${item.type}-${item.attributeType}`;
            }
        }
        
        // Promise 기반 확인창 (showConfirm이 이미 Promise 반환)
        function showConfirmAsync(title, message, confirmText = '확인', cancelText = '취소') {
            return showConfirm(title, message);
        }
        
        // 앨범 백업 복구 기능
        async function showAlbumBackupRestore() {
            const backups = JSON.parse(localStorage.getItem('spiritGarden_autoBackups') || '[]');
            
            if (backups.length === 0) {
                showNotification('저장된 백업이 없습니다. 정령을 완성하면 자동으로 백업됩니다.');
                return;
            }
            
            // 백업 목록 HTML 생성
            let backupListHtml = '';
            backups.forEach((backup, index) => {
                const date = new Date(backup.timestamp);
                const dateStr = date.toLocaleString('ko-KR', {
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit'
                });
                const albumCount = backup.collection ? backup.collection.length : 0;
                const encyclopediaCount = backup.encyclopedia ? Object.keys(backup.encyclopedia).length : 0;
                const eventCount = backup.collection ? backup.collection.filter(item => item.type && item.type.startsWith('event_')).length : 0;
                
                const eventText = eventCount > 0 ? ' · <span style="color: #c41e3a;">🎄 이벤트 ' + eventCount + '마리</span>' : '';
                
                backupListHtml += '<div style="padding: 16px; background: var(--bg); border-radius: 8px; border: 1px solid var(--border);">' +
                    '<div style="display: flex; justify-content: space-between; align-items: center;">' +
                        '<div>' +
                            '<div style="font-weight: 700; margin-bottom: 4px;">' + dateStr + '</div>' +
                            '<div style="font-size: 0.85rem; color: #888;">' +
                                '앨범: ' + albumCount + '마리 · 도감: ' + encyclopediaCount + '종' + eventText +
                            '</div>' +
                        '</div>' +
                        '<button onclick="restoreAlbumBackup(' + index + ')" style="padding: 8px 16px; background: #333; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">' +
                            '복구' +
                        '</button>' +
                    '</div>' +
                '</div>';
            });
            
            // 백업 목록 모달 표시
            const modal = document.createElement('div');
            modal.className = 'modal active';
            modal.id = 'backupRestoreModal';
            modal.innerHTML = 
                '<div class="modal-content" style="max-width: 600px; max-height: 80vh; overflow-y: auto;">' +
                    '<h3 style="margin-bottom: 16px;">📚 앨범 백업 복구</h3>' +
                    '<p style="margin-bottom: 8px; color: #888;">정령 완성 시 자동 저장된 백업 목록입니다 (최근 10개)</p>' +
                    '<p style="margin-bottom: 16px; color: #e67e22; font-size: 0.85rem;">⚠️ 복구 시 현재 앨범과 도감이 백업 시점으로 덮어씌워집니다.</p>' +
                    '<div style="display: flex; flex-direction: column; gap: 12px; margin-bottom: 20px;">' +
                        backupListHtml +
                    '</div>' +
                    '<div style="display: flex; gap: 12px;">' +
                        '<button onclick="exportAlbumBackup()" style="flex: 1; padding: 12px; background: var(--water); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600;">' +
                            '💾 앨범 백업 다운로드' +
                        '</button>' +
                        '<button onclick="importAlbumBackup()" style="flex: 1; padding: 12px; background: var(--wind); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600;">' +
                            '📂 앨범 백업 불러오기' +
                        '</button>' +
                    '</div>' +
                    '<button onclick="closeBackupModal()" style="width: 100%; margin-top: 16px; padding: 12px; background: #6c757d; color: white; border: none; border-radius: 8px; cursor: pointer;">' +
                        '닫기' +
                    '</button>' +
                '</div>';
            document.body.appendChild(modal);
        }
        
        function closeBackupModal() {
            const modal = document.getElementById('backupRestoreModal');
            if (modal) modal.remove();
        }
        
        async function restoreAlbumBackup(index) {
            const backups = JSON.parse(localStorage.getItem('spiritGarden_autoBackups') || '[]');
            const backup = backups[index];
            
            if (!backup) {
                showNotification('백업을 찾을 수 없습니다.');
                return;
            }
            
            const date = new Date(backup.timestamp).toLocaleString('ko-KR');
            const confirmed = await showConfirm(
                '앨범 복구',
                `${date} 시점의 백업으로 복구하시겠습니까?\n\n앨범: ${backup.collection.length}마리\n도감: ${Object.keys(backup.encyclopedia).length}종\n\n⚠️ 현재 앨범과 도감이 덮어씌워집니다.`
            );
            
            if (!confirmed) return;
            
            collection = backup.collection || [];
            encyclopedia = backup.encyclopedia || {};
            saveGame();
            
            closeBackupModal();
            renderCollection();
            renderEncyclopedia();
            showNotification(`✅ ${date} 시점으로 앨범을 복구했습니다!`);
        }
        
        function exportAlbumBackup() {
            const backupData = {
                exportDate: new Date().toISOString(),
                collection: collection,
                encyclopedia: encyclopedia
            };
            
            const blob = new Blob([JSON.stringify(backupData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `spirit-garden-album-backup-${new Date().toISOString().slice(0,10)}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showNotification('💾 앨범 백업 파일을 다운로드했습니다.');
        }
        
        function importAlbumBackup() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                try {
                    const text = await file.text();
                    const data = JSON.parse(text);
                    
                    if (!data.collection || !Array.isArray(data.collection)) {
                        showNotification('❌ 유효하지 않은 백업 파일입니다.');
                        return;
                    }
                    
                    const confirmed = await showConfirm(
                        '앨범 복구',
                        `백업 파일에서 복구하시겠습니까?\n\n앨범: ${data.collection.length}마리\n도감: ${data.encyclopedia ? Object.keys(data.encyclopedia).length : 0}종\n\n⚠️ 현재 앨범과 도감이 덮어씌워집니다.`
                    );
                    
                    if (!confirmed) return;
                    
                    collection = data.collection;
                    encyclopedia = data.encyclopedia || {};
                    
                    // 도감이 비어있으면 앨범에서 재구성
                    if (Object.keys(encyclopedia).length === 0 && collection.length > 0) {
                        rebuildEncyclopediaFromAlbum();
                    }
                    
                    saveGame();
                    closeBackupModal();
                    renderCollection();
                    renderEncyclopedia();
                    showNotification(`✅ 백업 파일에서 앨범을 복구했습니다!`);
                } catch (err) {
                    console.error('백업 복구 오류:', err);
                    showNotification('❌ 백업 파일을 읽는 중 오류가 발생했습니다.');
                }
            };
            input.click();
        }
        
        // 연결 정령 관리 기능
        async function repairBrokenSpirits() {
            // 연결로 태어난 정령 찾기
            const bredSpirits = spirits.filter(spirit => spirit.isBred || spirit.breedCode);
            
            if (bredSpirits.length === 0) {
                showNotification('연결로 태어난 정령이 없습니다.');
                return;
            }
            
            // 연결 정령 목록 표시
            const modal = document.createElement('div');
            modal.className = 'modal active';
            modal.id = 'repairModal';
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 500px; max-height: 80vh; overflow-y: auto;">
                    <h3 style="margin-bottom: 16px;">🔧 연결 정령 관리</h3>
                    <p style="margin-bottom: 16px; color: #888;">연결로 태어난 정령: ${bredSpirits.length}마리</p>
                    
                    <div style="display: flex; flex-direction: column; gap: 12px; margin-bottom: 20px;">
                        ${bredSpirits.map(spirit => {
                            const stage = getStage(spirit.growth);
                            return `
                            <div style="padding: 12px; background: var(--bg); border-radius: 8px; border: 1px solid var(--border);">
                                <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
                                    <span style="font-size: 1.5rem;">${STAGE_ICONS[stage] || '🥚'}</span>
                                    <div>
                                        <div style="font-weight: 700;">${spirit.name || '이름 없음'}</div>
                                        <div style="font-size: 0.8rem; color: #888;">${STAGE_NAMES[stage] || '알'} · 성장 ${spirit.growth || 0}</div>
                                    </div>
                                </div>
                                <div style="font-size: 0.85rem; color: #888; margin-bottom: 8px;">
                                    🔗 ${spirit.bredWith || '알 수 없음'}의 코드로 연결
                                </div>
                                <div style="display: flex; gap: 8px;">
                                    <button onclick="repairSpirit(${spirit.id})" style="flex: 1; padding: 8px; background: var(--water); color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.85rem;">
                                        🔧 복구
                                    </button>
                                    <button onclick="deleteBrokenSpirit(${spirit.id}, true)" style="flex: 1; padding: 8px; background: #e74c3c; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.85rem;">
                                        🗑️ 삭제 (코드반환)
                                    </button>
                                </div>
                            </div>
                        `}).join('')}
                    </div>
                    
                    <div style="display: flex; gap: 10px;">
                        <button onclick="repairAllSpirits()" style="flex: 1; padding: 12px; background: var(--water); color: white; border: none; border-radius: 8px; cursor: pointer;">
                            🔧 모두 복구
                        </button>
                        <button onclick="closeRepairModal()" style="flex: 1; padding: 12px; background: var(--card); border: 1px solid var(--border); border-radius: 8px; cursor: pointer;">
                            닫기
                        </button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }
        
        function closeRepairModal() {
            const modal = document.getElementById('repairModal');
            if (modal) modal.remove();
        }
        
        function repairSpirit(spiritId) {
            const spirit = spirits.find(s => String(s.id) === String(spiritId));
            if (!spirit) {
                showNotification('❌ 정령을 찾을 수 없습니다');
                return;
            }
            
            const timestamp = new Date().toLocaleString('ko-KR', {
                month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit'
            });
            
            // 필수 필드 복구
            if (!spirit.parameters) {
                spirit.parameters = { intelligence: 0, strength: 0, charm: 0, affection: 0 };
            }
            if (spirit.parameters.affection === undefined) spirit.parameters.affection = 0;
            
            if (!spirit.hiddenAttributes) {
                spirit.hiddenAttributes = { fire: 0, water: 0, wind: 0, earth: 0, light: 0, dark: 0 };
            }
            
            if (!spirit.satisfaction) spirit.satisfaction = 'mid';
            if (!spirit.status) spirit.status = '복구되었습니다';
            if (!spirit.birthTime) spirit.birthTime = Date.now();
            if (!spirit.lastInteraction) spirit.lastInteraction = Date.now();
            if (spirit.lightTime === undefined) spirit.lightTime = 0;
            if (spirit.darkTime === undefined) spirit.darkTime = 0;
            if (spirit.musicListened === undefined) spirit.musicListened = 0;
            if (spirit.feedCount === undefined) spirit.feedCount = 0;
            if (spirit.growth === undefined) spirit.growth = 0;
            
            // logs 형식 복구
            if (!spirit.logs) {
                spirit.logs = [];
            } else if (spirit.logs.length > 0 && typeof spirit.logs[0] === 'string') {
                // 문자열 배열을 객체 배열로 변환
                spirit.logs = spirit.logs.map(msg => ({
                    time: timestamp,
                    message: msg
                }));
            }
            
            // 복구 로그 추가
            spirit.logs.unshift({ time: timestamp, message: '🔧 데이터가 복구되었습니다.' });
            
            saveGame();
            renderSpirits();
            closeRepairModal();
            showNotification(`✅ ${spirit.name} 복구 완료!`);
        }
        
        function repairAllSpirits() {
            const bredSpirits = spirits.filter(spirit => spirit.isBred || spirit.breedCode);
            
            bredSpirits.forEach(spirit => {
                repairSpiritSilent(spirit);
            });
            
            saveGame();
            renderSpirits();
            closeRepairModal();
            showNotification(`✅ ${bredSpirits.length}마리 정령 복구 완료!`);
        }
        
        function repairSpiritSilent(spirit) {
            const timestamp = new Date().toLocaleString('ko-KR', {
                month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit'
            });
            
            if (!spirit.parameters) {
                spirit.parameters = { intelligence: 0, strength: 0, charm: 0, affection: 0 };
            }
            if (spirit.parameters.affection === undefined) spirit.parameters.affection = 0;
            
            if (!spirit.hiddenAttributes) {
                spirit.hiddenAttributes = { fire: 0, water: 0, wind: 0, earth: 0, light: 0, dark: 0 };
            }
            
            if (!spirit.satisfaction) spirit.satisfaction = 'mid';
            if (!spirit.status) spirit.status = '복구되었습니다';
            if (!spirit.birthTime) spirit.birthTime = Date.now();
            if (!spirit.lastInteraction) spirit.lastInteraction = Date.now();
            if (spirit.lightTime === undefined) spirit.lightTime = 0;
            if (spirit.darkTime === undefined) spirit.darkTime = 0;
            if (spirit.musicListened === undefined) spirit.musicListened = 0;
            if (spirit.feedCount === undefined) spirit.feedCount = 0;
            if (spirit.growth === undefined) spirit.growth = 0;
            
            if (!spirit.logs) {
                spirit.logs = [];
            } else if (spirit.logs.length > 0 && typeof spirit.logs[0] === 'string') {
                spirit.logs = spirit.logs.map(msg => ({ time: timestamp, message: msg }));
            }
            
            spirit.logs.unshift({ time: timestamp, message: '🔧 데이터가 복구되었습니다.' });
        }
        
        function deleteBrokenSpirit(spiritId, returnCode) {
            const spirit = spirits.find(s => String(s.id) === String(spiritId));
            if (!spirit) {
                console.log('Spirit not found:', spiritId);
                showNotification('❌ 정령을 찾을 수 없습니다');
                return;
            }
            
            if (returnCode && spirit.breedCode) {
                // 앨범에서도 해당 코드 사용 기록 제거
                if (collection) {
                    collection.forEach(s => {
                        if (s.breedCode === spirit.breedCode) {
                            delete s.breedCode;
                        }
                    });
                }
                showNotification('🔄 연결 코드가 반환되었습니다!');
            }
            
            spirits = spirits.filter(s => String(s.id) !== String(spiritId));
            saveGame();
            renderSpirits();
            closeRepairModal();
            showNotification(`🗑️ ${spirit.name} 삭제 완료`);
        }

        // ========== 합성 시스템 ==========
        
        function switchFusionMode(mode) {
            const localBtn = document.getElementById('fusionModeLocal');
            const shareBtn = document.getElementById('fusionModeShare');
            const localPanel = document.getElementById('localFusionPanel');
            const sharePanel = document.getElementById('shareFusionPanel');
            
            if (mode === 'local') {
                localBtn.style.background = 'var(--text)';
                localBtn.style.color = 'var(--bg)';
                shareBtn.style.background = 'var(--card)';
                shareBtn.style.color = 'var(--text)';
                localPanel.style.display = 'block';
                sharePanel.style.display = 'none';
            } else {
                localBtn.style.background = 'var(--card)';
                localBtn.style.color = 'var(--text)';
                shareBtn.style.background = 'var(--text)';
                shareBtn.style.color = 'var(--bg)';
                localPanel.style.display = 'none';
                sharePanel.style.display = 'block';
                updateShareSpiritList();
            }
        }
        
        function getCompletedSpirits() {
            // 현재 육성 중인 완성 정령
            const currentCompleted = spirits.filter(s => s.isCompleted && !s.isDead);
            
            // 앨범에 있는 완성 정령 (id가 없으면 생성)
            const albumSpirits = (collection || []).map((s, index) => ({
                ...s,
                id: s.id || `album-${index}`,
                isFromAlbum: true,
                isCompleted: true
            }));
            
            return [...currentCompleted, ...albumSpirits];
        }
        
        function getCompletedSpiritsForBreeding() {
            // 연결용: 현재 육성 중인 완성 정령 + 앨범 정령 (합성으로 떠난 정령 제외)
            const currentCompleted = spirits.filter(s => s.isCompleted && !s.isDead);
            
            const albumSpirits = (collection || [])
                .filter(s => !s.fusedAway) // 합성으로 떠난 정령 제외
                .map((s, index) => ({
                    ...s,
                    id: s.id || `album-${index}`,
                    isFromAlbum: true,
                    isCompleted: true
                }));
            
            return [...currentCompleted, ...albumSpirits];
        }
        
        function selectFusionSpirit(slot) {
            const completed = getCompletedSpirits();
            if (completed.length === 0) {
                showNotification('❌ 완성된 정령이 없습니다');
                return;
            }
            
            // 이미 다른 슬롯에 선택된 정령 제외
            const otherSlotSpirit = slot === 1 ? fusionSlot2Spirit : fusionSlot1Spirit;
            const available = completed.filter(s => !otherSlotSpirit || s.id !== otherSlotSpirit.id);
            
            if (available.length === 0) {
                showNotification('❌ 선택 가능한 정령이 없습니다');
                return;
            }
            
            // 선택 모달 표시
            const modalHtml = `
                <div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 10000; display: flex; justify-content: center; align-items: center;">
                    <div style="background: var(--card); padding: 24px; border-radius: 12px; max-width: 400px; width: 90%; max-height: 70vh; overflow-y: auto;">
                        <h3 style="margin-bottom: 16px;">정령 선택 (슬롯 ${slot})</h3>
                        <div style="display: flex; flex-direction: column; gap: 10px;">
                            ${available.map(s => {
                                const attrName = ATTRIBUTE_NAMES[s.attribute] || ATTRIBUTE_NAMES.normal;
                                return `
                                    <div onclick="confirmFusionSpirit(${slot}, '${s.id}')" style="display: flex; align-items: center; gap: 12px; padding: 12px; background: var(--bg); border-radius: 8px; cursor: pointer; transition: transform 0.2s;" onmouseover="this.style.transform='scale(1.02)'" onmouseout="this.style.transform='scale(1)'">
                                        <span style="font-size: 2rem;">${getSpiritEmoji(s)}</span>
                                        <div>
                                            <div style="font-weight: 700;">${s.name}</div>
                                            <div style="font-size: 0.85rem; color: #888;">${attrName.icon} ${attrName.name}</div>
                                            <div style="font-size: 0.8rem; color: #666;">💖 애정도: ${s.parameters?.affection || 0}</div>
                                        </div>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                        <button onclick="closeFusionModal()" style="margin-top: 16px; width: 100%; padding: 12px; background: var(--border); border: none; border-radius: 6px; cursor: pointer;">취소</button>
                    </div>
                </div>
            `;
            
            const modal = document.createElement('div');
            modal.id = 'fusionSelectModal';
            modal.innerHTML = modalHtml;
            document.body.appendChild(modal);
        }
        
        function closeFusionModal() {
            const modal = document.getElementById('fusionSelectModal');
            if (modal) modal.remove();
        }
        
        function confirmFusionSpirit(slot, spiritId) {
            const spirit = spirits.find(s => s.id === spiritId);
            if (!spirit) return;
            
            if (slot === 1) {
                fusionSlot1Spirit = spirit;
            } else {
                fusionSlot2Spirit = spirit;
            }
            
            closeFusionModal();
            updateFusionSlots();
        }
        
        function updateFusionSlots() {
            const slot1 = document.getElementById('fusionSlot1');
            const slot2 = document.getElementById('fusionSlot2');
            const result = document.getElementById('fusionResult');
            const info = document.getElementById('fusionInfo');
            const btn = document.getElementById('fusionBtn');
            
            // 슬롯 1 업데이트
            if (fusionSlot1Spirit) {
                const attr1 = ATTRIBUTE_NAMES[fusionSlot1Spirit.attribute] || ATTRIBUTE_NAMES.normal;
                slot1.innerHTML = `
                    <div style="font-size: 2.5rem;">${getSpiritEmoji(fusionSlot1Spirit)}</div>
                    <div style="font-weight: 700; font-size: 0.9rem;">${fusionSlot1Spirit.name}</div>
                    <div style="font-size: 0.8rem; color: #888;">${attr1.icon} ${attr1.name}</div>
                `;
                slot1.style.borderStyle = 'solid';
                slot1.style.background = 'linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1))';
            } else {
                slot1.innerHTML = `
                    <div style="font-size: 3rem; opacity: 0.3;">🥚</div>
                    <div style="color: #888; font-size: 0.9rem;">정령 선택</div>
                `;
                slot1.style.borderStyle = 'dashed';
                slot1.style.background = 'transparent';
            }
            
            // 슬롯 2 업데이트
            if (fusionSlot2Spirit) {
                const attr2 = ATTRIBUTE_NAMES[fusionSlot2Spirit.attribute] || ATTRIBUTE_NAMES.normal;
                slot2.innerHTML = `
                    <div style="font-size: 2.5rem;">${getSpiritEmoji(fusionSlot2Spirit)}</div>
                    <div style="font-weight: 700; font-size: 0.9rem;">${fusionSlot2Spirit.name}</div>
                    <div style="font-size: 0.8rem; color: #888;">${attr2.icon} ${attr2.name}</div>
                `;
                slot2.style.borderStyle = 'solid';
                slot2.style.background = 'linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1))';
            } else {
                slot2.innerHTML = `
                    <div style="font-size: 3rem; opacity: 0.3;">🥚</div>
                    <div style="color: #888; font-size: 0.9rem;">정령 선택</div>
                `;
                slot2.style.borderStyle = 'dashed';
                slot2.style.background = 'transparent';
            }
            
            // 결과 예측
            if (fusionSlot1Spirit && fusionSlot2Spirit) {
                const prediction = predictFusionResult(fusionSlot1Spirit, fusionSlot2Spirit);
                result.innerHTML = `
                    <div style="font-size: 2.5rem;">${prediction.icon}</div>
                    <div style="font-weight: 700; font-size: 0.9rem;">${prediction.name}</div>
                    <div style="font-size: 0.75rem; color: ${getRarityColor(prediction.rarity)};">${getRarityText(prediction.rarity)}</div>
                `;
                result.style.background = 'linear-gradient(135deg, rgba(255,215,0,0.2), rgba(255,255,255,0.1))';
                
                // 애정도 체크
                const affection1 = fusionSlot1Spirit.parameters?.affection || 0;
                const affection2 = fusionSlot2Spirit.parameters?.affection || 0;
                const minAffection = 50;
                
                if (affection1 < minAffection || affection2 < minAffection) {
                    info.innerHTML = `❌ 두 정령 모두 애정도 ${minAffection} 이상이어야 합니다.<br>(${fusionSlot1Spirit.name}: ${affection1}, ${fusionSlot2Spirit.name}: ${affection2})`;
                    info.style.color = '#e74c3c';
                    btn.disabled = true;
                    btn.style.opacity = '0.5';
                } else if (coins < FUSION_COST) {
                    info.innerHTML = `❌ 코인이 부족합니다. (필요: ${FUSION_COST}💰, 보유: ${coins}💰)`;
                    info.style.color = '#e74c3c';
                    btn.disabled = true;
                    btn.style.opacity = '0.5';
                } else {
                    info.innerHTML = `✅ 합성 준비 완료! 두 정령은 자연으로 돌아가고 새 알이 태어납니다.`;
                    info.style.color = '#27ae60';
                    btn.disabled = false;
                    btn.style.opacity = '1';
                }
            } else {
                result.innerHTML = `
                    <div style="font-size: 3rem; opacity: 0.3;">❓</div>
                    <div style="color: #888; font-size: 0.9rem;">결과</div>
                `;
                result.style.background = 'linear-gradient(135deg, rgba(255,215,0,0.1), rgba(255,255,255,0.1))';
                info.innerHTML = '두 정령을 선택해주세요.';
                info.style.color = '#888';
                btn.disabled = true;
                btn.style.opacity = '0.5';
            }
        }
        
        function getMainAttribute(spirit) {
            const attrs = spirit.attributes || spirit.hiddenAttributes || {};
            let maxAttr = 'normal';
            let maxVal = 0;
            
            ['fire', 'water', 'wind', 'earth', 'light', 'dark'].forEach(attr => {
                if ((attrs[attr] || 0) > maxVal) {
                    maxVal = attrs[attr] || 0;
                    maxAttr = attr;
                }
            });
            
            return maxVal >= 50 ? maxAttr : 'normal';
        }
        
        function getStatType(spirit) {
            const params = spirit.parameters || {};
            const intel = params.intelligence || 0;
            const str = params.strength || 0;
            const charm = params.charm || 0;
            
            if (intel > str && intel > charm && intel >= 70) return 'intelligent';
            if (str > intel && str > charm && str >= 70) return 'strong';
            if (charm > intel && charm > str && charm >= 70) return 'beautiful';
            return null;
        }
        
        function predictFusionResult(spirit1, spirit2) {
            // 타입 추론 헬퍼 함수 (predictBreedResult와 동일)
            const getSpiritTypeInfo = (spirit) => {
                const type = spirit.type || spirit.evolutionType || spirit.evolutionData?.type;
                const name = spirit.name || '';
                
                // 정령왕 체크 (최상위)
                if (type === 'spiritking' || name === '정령왕') return { special: 'spiritking' };
                
                // 전설 정령 체크
                if (type === 'titania' || name === '티타니아') return { special: 'titania' };
                if (type === 'oberon' || name === '오베론') return { special: 'oberon' };
                
                // 정령왕의 부름을 받은 (모든 스탯 100) 체크
                if (type === 'sage' || name.includes('정령왕의 부름을 받은')) return { special: 'sage' };
                
                // 조화/혼돈 체크
                if (type === 'balanced' || name.includes('조화의 정령')) return { special: 'balanced' };
                if (type === 'multi' || name.includes('혼돈의 정령')) return { special: 'multi' };
                
                // 스탯 계열 체크
                const params = spirit.parameters || {};
                const intel = params.intelligence || 0;
                const str = params.strength || 0;
                const charm = params.charm || 0;
                
                if (intel >= 100 && str >= 100 && charm >= 100) return { special: 'sage' };
                
                // 이름에서 스탯 계열 추론 (새 타이틀)
                if (name.includes('지식의 씨앗')) return { stat: 'intelligent' };
                if (name.includes('불굴의 기사')) return { stat: 'strong' };
                if (name.includes('달콤한 향기')) return { stat: 'beautiful' };
                
                // 스탯 수치 기반 (100 이상)
                if (intel >= 100) return { stat: 'intelligent' };
                if (str >= 100) return { stat: 'strong' };
                if (charm >= 100) return { stat: 'beautiful' };
                
                // 속성 체크
                if (name.includes('화염') || name.includes('불꽃')) return { attr: 'fire' };
                if (name.includes('빙하') || name.includes('물')) return { attr: 'water' };
                if (name.includes('질풍') || name.includes('바람')) return { attr: 'wind' };
                if (name.includes('대지') || name.includes('땅')) return { attr: 'earth' };
                if (name.includes('광명') || name.includes('빛')) return { attr: 'light' };
                if (name.includes('암흑') || name.includes('어둠')) return { attr: 'dark' };
                
                return {};
            };
            
            const info1 = getSpiritTypeInfo(spirit1);
            const info2 = getSpiritTypeInfo(spirit2);
            
            // 1. 티타니아 + 오베론 = 오블리비온
            if ((info1.special === 'titania' && info2.special === 'oberon') ||
                (info1.special === 'oberon' && info2.special === 'titania')) {
                return { ...FUSION_TYPES['fusion-oblivion'], key: 'fusion-oblivion' };
            }
            
            // 2. 조화/혼돈 조합 체크
            if (info1.special === 'balanced' && info2.special === 'balanced') {
                return { ...FUSION_TYPES['fusion-spirit-king'], key: 'fusion-spirit-king' };
            }
            if (info1.special === 'multi' && info2.special === 'multi') {
                return { ...FUSION_TYPES['fusion-chaos-king'], key: 'fusion-chaos-king' };
            }
            if ((info1.special === 'balanced' && info2.special === 'multi') ||
                (info1.special === 'multi' && info2.special === 'balanced')) {
                return { ...FUSION_TYPES['fusion-balance-chaos'], key: 'fusion-balance-chaos' };
            }
            
            // 3. 속성 기반 합성
            const attr1 = info1.attr || getMainAttribute(spirit1);
            const attr2 = info2.attr || getMainAttribute(spirit2);
            
            // 정확한 레시피 매칭
            for (const [key, fusion] of Object.entries(FUSION_TYPES)) {
                const recipe = fusion.recipe;
                if ((recipe[0] === attr1 && recipe[1] === attr2) ||
                    (recipe[0] === attr2 && recipe[1] === attr1)) {
                    return { ...fusion, key };
                }
            }
            
            // 4. 기본 결과 - 부모 중 하나의 속성 랜덤 계승
            const inheritedAttr = Math.random() > 0.5 ? attr1 : attr2;
            const attrInfo = ATTRIBUTE_NAMES[inheritedAttr] || ATTRIBUTE_NAMES.normal;
            const attrIcon = typeof attrInfo.icon === 'object' ? attrInfo.icon.butterfly : attrInfo.icon;
            return {
                name: attrInfo.name,
                icon: attrIcon,
                desc: attrInfo.desc,
                rarity: 'common',
                inheritedAttr
            };
        }
        
        function getRarityColor(rarity) {
            switch(rarity) {
                case 'mythic': return '#ff00ff';
                case 'legendary': return '#ff6b35';
                case 'epic': return '#9b59b6';
                case 'rare': return '#3498db';
                case 'event': return '#c41e3a';
                default: return '#888';
            }
        }
        
        function getRarityText(rarity) {
            switch(rarity) {
                case 'mythic': return '🌌 신화';
                case 'legendary': return '⭐ 전설';
                case 'epic': return '💜 최상급';
                case 'rare': return '💙 희귀';
                case 'event': return '🎄 이벤트';
                default: return '일반';
            }
        }
        
        async function performFusion() {
            if (!fusionSlot1Spirit || !fusionSlot2Spirit) return;
            
            const affection1 = fusionSlot1Spirit.parameters?.affection || 0;
            const affection2 = fusionSlot2Spirit.parameters?.affection || 0;
            
            if (affection1 < 50 || affection2 < 50) {
                showNotification('❌ 애정도가 부족합니다');
                return;
            }
            
            if (coins < FUSION_COST) {
                showNotification('❌ 코인이 부족합니다');
                return;
            }
            
            const confirm = await showConfirm('정령 합성', 
                `${fusionSlot1Spirit.name}와(과) ${fusionSlot2Spirit.name}을(를) 합성하시겠습니까?\n\n두 정령은 자연으로 돌아가고 새 알이 태어납니다.\n비용: ${FUSION_COST}💰`);
            
            if (!confirm) return;
            
            // 결과 계산
            const result = predictFusionResult(fusionSlot1Spirit, fusionSlot2Spirit);
            
            // 스탯 계승 (부모 평균의 50~80%)
            const inheritRatio = 0.5 + Math.random() * 0.3;
            const newParams = {
                intelligence: Math.floor(((fusionSlot1Spirit.parameters?.intelligence || 0) + (fusionSlot2Spirit.parameters?.intelligence || 0)) / 2 * inheritRatio),
                strength: Math.floor(((fusionSlot1Spirit.parameters?.strength || 0) + (fusionSlot2Spirit.parameters?.strength || 0)) / 2 * inheritRatio),
                charm: Math.floor(((fusionSlot1Spirit.parameters?.charm || 0) + (fusionSlot2Spirit.parameters?.charm || 0)) / 2 * inheritRatio),
                affection: 0
            };
            
            // 부모 정령 제거 (앨범에 추가)
            [fusionSlot1Spirit, fusionSlot2Spirit].forEach(parent => {
                // 타입 결정: type > evolutionType > evolutionData.type > 'normal'
                const parentType = parent.type || parent.evolutionType || parent.evolutionData?.type || 'normal';
                
                // 앨범에 추가
                collection.push({
                    id: `album-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`, // 고유 ID
                    name: parent.name,
                    type: parentType,
                    attribute: parent.attribute,
                    attributeType: parent.attributeType,
                    parameters: { ...parent.parameters },
                    attributes: { ...parent.attributes },
                    wingType: parent.wingType || 'butterfly',
                    completedAt: new Date().toISOString(),
                    fusedAway: true // 합성으로 떠남 표시
                });
                
                // spirits에서 제거
                const idx = spirits.findIndex(s => s.id === parent.id);
                if (idx !== -1) spirits.splice(idx, 1);
            });
            
            // 새 알 생성
            const newAttribute = result.inheritedAttr || getMainAttribute(fusionSlot1Spirit);
            const isFusionType = result.key && FUSION_TYPES[result.key];
            const fusionEggName = `${fusionSlot1Spirit.name}와${fusionSlot2Spirit.name}의 알`;
            
            const newSpirit = {
                id: Date.now().toString(),
                name: fusionEggName,
                stage: 'egg',
                growth: 0,
                parameters: newParams,
                attributes: {},
                createdAt: new Date().toISOString(),
                logs: [`🧬 ${fusionSlot1Spirit.name}와(과) ${fusionSlot2Spirit.name}의 합성으로 태어났습니다.`],
                fusionType: result.key || null, // 합성 타입 저장
                fusionRarity: result.rarity || 'common'
            };
            
            // 초기 속성 설정 (합성 타입이면 특별 속성)
            if (isFusionType) {
                // 합성 전용 정령은 부모 속성 합
                const attrs1 = fusionSlot1Spirit.attributes || fusionSlot1Spirit.hiddenAttributes || {};
                const attrs2 = fusionSlot2Spirit.attributes || fusionSlot2Spirit.hiddenAttributes || {};
                ['fire', 'water', 'wind', 'earth', 'light', 'dark'].forEach(attr => {
                    newSpirit.attributes[attr] = Math.floor(((attrs1[attr] || 0) + (attrs2[attr] || 0)) / 2);
                });
            }
            
            spirits.push(newSpirit);
            coins -= FUSION_COST;
            
            // 합성 도감 등록
            if (isFusionType && result.key) {
                if (!encyclopedia[result.key]) {
                    encyclopedia[result.key] = 1;
                    showNotification(`🎉 새로운 합성 정령 "${result.name}" 도감 등록!`);
                } else {
                    encyclopedia[result.key]++;
                }
            }
            
            // 초기화
            fusionSlot1Spirit = null;
            fusionSlot2Spirit = null;
            
            saveGame();
            updateFusionSlots();
            renderSpirits();
            renderFusionEncyclopedia();
            updateCoinDisplay();
            
            showNotification(`🧬 합성 성공! ${result.name}의 알이 태어났습니다!`);
        }
        
        function renderFusionEncyclopedia() {
            const container = document.getElementById('fusionEncyclopedia');
            if (!container) return;
            
            const entries = Object.entries(FUSION_TYPES).map(([key, data]) => {
                const rawValue = encyclopedia[key];
                const discovered = rawValue ? true : false;
                const count = typeof rawValue === 'object' ? (rawValue.count || 0) : (rawValue || 0);
                return `
                    <div style="padding: 12px; background: ${discovered ? 'var(--bg)' : 'rgba(0,0,0,0.3)'}; border: 1px solid ${discovered ? getRarityColor(data.rarity) : 'var(--border)'}; border-radius: 8px; text-align: center;">
                        <div style="font-size: 2rem; ${discovered ? '' : 'filter: grayscale(1); opacity: 0.3;'}">${data.icon}</div>
                        <div style="font-weight: 700; font-size: 0.85rem; margin-top: 4px; ${discovered ? '' : 'color: #666;'}">${discovered ? data.name : '???'}</div>
                        <div style="font-size: 0.75rem; color: ${getRarityColor(data.rarity)};">${getRarityText(data.rarity)}</div>
                        ${discovered ? `<div style="font-size: 0.7rem; color: #888; margin-top: 4px;">x${count}</div>` : ''}
                    </div>
                `;
            });
            
            container.innerHTML = entries.join('');
        }
        
        // ========== 연결 코드 공유 시스템 ==========
        
        function updateShareSpiritList() {
            const select1 = document.getElementById('shareSpritSelect');
            const select2 = document.getElementById('myBreedSpirit');
            const completed = getCompletedSpiritsForBreeding();
            
            const options = completed.map(s => {
                const attr = ATTRIBUTE_NAMES[s.attribute] || ATTRIBUTE_NAMES.normal;
                const affection = s.parameters?.affection || 0;
                const fromAlbum = s.isFromAlbum ? ' [앨범]' : '';
                const affectionMark = affection >= 50 ? '💕' : '💔';
                return `<option value="${s.id}">${s.name} (${attr.icon} ${affectionMark}${affection})${fromAlbum}</option>`;
            }).join('');
            
            if (select1) select1.innerHTML = '<option value="">완성된 정령 선택...</option>' + options;
            if (select2) select2.innerHTML = '<option value="">내 정령 선택...</option>' + options;
        }
        
        function encodeSpiritData(spirit) {
            // 타입 결정: type > evolutionType > evolutionData.type > 'normal'
            const spiritType = spirit.type || spirit.evolutionType || spirit.evolutionData?.type || 'normal';
            
            const data = {
                id: spirit.id || null, // 고유 ID 추가
                n: spirit.name,
                o: spirit.originalName || spirit.name, // 본명 추가
                a: spirit.attribute,
                t: spiritType,
                i: spirit.parameters?.intelligence || 0,
                s: spirit.parameters?.strength || 0,
                c: spirit.parameters?.charm || 0,
                at: spirit.attributes || spirit.hiddenAttributes || {},
                ts: Date.now(),
                // 이벤트 정령 정보
                ev: spirit.isEventSpirit ? spirit.eventType : null
            };
            
            console.log('연결 코드 생성:', { spiritType, spirit: spirit.name }); // 디버깅용
            
            try {
                const json = JSON.stringify(data);
                const base64 = btoa(unescape(encodeURIComponent(json)));
                return 'SG1-' + base64;
            } catch (e) {
                console.error('인코딩 오류:', e);
                return null;
            }
        }
        
        function decodeSpiritData(code) {
            try {
                if (!code.startsWith('SG1-')) return null;
                const base64 = code.substring(4);
                const json = decodeURIComponent(escape(atob(base64)));
                const data = JSON.parse(json);
                
                // 유효성 검사
                if (!data.n || !data.ts) return null;
                
                return {
                    id: data.id || null, // 고유 ID 추가
                    name: data.n,
                    originalName: data.o || data.n, // 본명 추가
                    attribute: data.a || 'normal',
                    evolutionType: data.t || 'normal',
                    parameters: {
                        intelligence: data.i || 0,
                        strength: data.s || 0,
                        charm: data.c || 0
                    },
                    attributes: data.at || {},
                    // 이벤트 정령 정보
                    isEventSpirit: !!data.ev,
                    eventType: data.ev || null
                };
            } catch (e) {
                console.error('디코딩 오류:', e);
                return null;
            }
        }
        
        function updateShareCode() {
            const select = document.getElementById('shareSpritSelect');
            const display = document.getElementById('shareCodeDisplay');
            const input = document.getElementById('shareCodeInput');
            
            if (!select.value) {
                display.style.display = 'none';
                return;
            }
            
            // 현재 정령 또는 앨범에서 찾기
            const allCompleted = getCompletedSpiritsForBreeding();
            const spirit = allCompleted.find(s => s.id === select.value);
            if (!spirit) return;
            
            const code = encodeSpiritData(spirit);
            if (code) {
                input.value = code;
                display.style.display = 'flex';
            }
        }
        
        function copyShareCode() {
            const input = document.getElementById('shareCodeInput');
            input.select();
            document.execCommand('copy');
            showNotification('📋 코드가 복사되었습니다!');
        }
        
        // 친구 코드 입력 시 미리보기
        document.addEventListener('DOMContentLoaded', () => {
            const friendInput = document.getElementById('friendCodeInput');
            if (friendInput) {
                friendInput.addEventListener('input', () => {
                    const preview = document.getElementById('friendCodePreview');
                    const code = friendInput.value.trim();
                    
                    if (!code) {
                        preview.style.display = 'none';
                        updateBreedPreview();
                        return;
                    }
                    
                    const data = decodeSpiritData(code);
                    if (!data) {
                        preview.innerHTML = '❌ 유효하지 않은 코드입니다.';
                        preview.style.display = 'block';
                        preview.style.color = '#e74c3c';
                        document.getElementById('breedPreview').style.display = 'none';
                    } else {
                        const attr = ATTRIBUTE_NAMES[data.attribute] || ATTRIBUTE_NAMES.normal;
                        
                        // 속성치 표시
                        const friendAttrs = data.attributes || {};
                        const attrDisplay = [];
                        ['fire', 'water', 'wind', 'earth', 'light', 'dark'].forEach(a => {
                            if (friendAttrs[a] && friendAttrs[a] > 0) {
                                attrDisplay.push(`${ENV_ICONS[a]}${friendAttrs[a]}`);
                            }
                        });
                        
                        // 본명이 현재 이름과 다르면 표시
                        const originalNameDisplay = (data.originalName && data.originalName !== data.name) 
                            ? `<div style="color: #aaa; font-size: 0.8rem; font-style: italic;">본명: ${data.originalName}</div>` 
                            : '';
                        
                        preview.innerHTML = `
                            <div style="display: flex; align-items: center; gap: 12px;">
                                <div style="font-size: 2.5rem;">${attr.icon}</div>
                                <div style="flex: 1;">
                                    <div style="font-weight: 700; font-size: 1.1rem;">✅ ${data.name}</div>
                                    ${originalNameDisplay}
                                    <div style="color: #888; font-size: 0.85rem;">${attr.name}</div>
                                    <div style="margin-top: 6px; font-size: 0.9rem;">
                                        🧠 ${data.parameters.intelligence} | 💪 ${data.parameters.strength} | 💖 ${data.parameters.charm}
                                    </div>
                                    ${attrDisplay.length > 0 ? `<div style="margin-top: 4px; font-size: 0.85rem;">${attrDisplay.join(' ')}</div>` : ''}
                                </div>
                            </div>
                        `;
                        preview.style.display = 'block';
                        preview.style.color = 'var(--text)';
                        updateBreedPreview();
                    }
                });
            }
        });
        
        async function breedWithCode() {
            const mySelect = document.getElementById('myBreedSpirit');
            const codeInput = document.getElementById('friendCodeInput');
            const breedCode = codeInput.value.trim();
            
            if (!mySelect.value) {
                showNotification('❌ 내 정령을 선택해주세요');
                return;
            }
            
            // 정령 슬롯 체크 (최대 6마리)
            if (spirits.length >= 6) {
                showNotification('❌ 정원이 가득 찼습니다! (최대 6마리) 정령을 자연으로 보내주세요.');
                return;
            }
            
            // 중복 코드 체크 (이미 사용된 코드인지)
            const allSpiritsAndAlbum = [...spirits, ...(collection || [])];
            const usedCode = allSpiritsAndAlbum.find(s => s.breedCode === breedCode);
            if (usedCode) {
                showNotification('❌ 이미 사용된 연결 코드입니다!');
                return;
            }
            
            // 현재 정령 또는 앨범에서 찾기
            const allCompleted = getCompletedSpiritsForBreeding();
            const mySpirit = allCompleted.find(s => s.id === mySelect.value);
            if (!mySpirit) {
                showNotification('❌ 정령을 찾을 수 없습니다');
                return;
            }
            
            const friendData = decodeSpiritData(breedCode);
            if (!friendData) {
                showNotification('❌ 유효하지 않은 코드입니다');
                return;
            }
            
            // 애정도 체크
            const myAffection = mySpirit.parameters?.affection || 0;
            if (myAffection < 50) {
                showNotification(`❌ 내 정령의 애정도가 부족합니다 (현재: ${myAffection}, 필요: 50)`);
                return;
            }
            
            if (coins < BREED_COST) {
                showNotification(`❌ 코인이 부족합니다 (필요: ${BREED_COST}💰)`);
                return;
            }
            
            // 결과 예측
            const prediction = predictBreedResult(mySpirit, friendData);
            
            const confirm = await showConfirm('연결 확인',
                `${mySpirit.name}와(과) ${friendData.name}(친구 정령)을(를) 연결하시겠습니까?\n\n예상 결과: ${prediction.name} (${getRarityText(prediction.rarity)})\n내 정령은 유지되고 새 알이 태어납니다.\n비용: ${BREED_COST}💰`);
            
            if (!confirm) return;
            
            // 연결 결과 계산 (부모 스탯의 25%씩 = 총 50% 상속)
            const newParams = {
                intelligence: Math.floor(((mySpirit.parameters?.intelligence || 0) + (friendData.parameters?.intelligence || 0)) / 4),
                strength: Math.floor(((mySpirit.parameters?.strength || 0) + (friendData.parameters?.strength || 0)) / 4),
                charm: Math.floor(((mySpirit.parameters?.charm || 0) + (friendData.parameters?.charm || 0)) / 4),
                affection: 0
            };
            
            // 부모 속성의 25%씩 = 총 50% 상속
            const myAttrs = mySpirit.attributes || mySpirit.hiddenAttributes || {};
            const friendAttrs = friendData.attributes || {};
            const newAttrs = {};
            ['fire', 'water', 'wind', 'earth', 'light', 'dark'].forEach(attr => {
                const avg = Math.floor(((myAttrs[attr] || 0) + (friendAttrs[attr] || 0)) / 4);
                if (avg > 0) newAttrs[attr] = avg;
            });
            
            // 합성 타입 정령인지 확인
            const isFusionType = prediction.key && FUSION_TYPES[prediction.key];
            
            // 상속 정보 문자열 생성
            const inheritInfo = [];
            if (newParams.intelligence > 0) inheritInfo.push(`🧠${newParams.intelligence}`);
            if (newParams.strength > 0) inheritInfo.push(`💪${newParams.strength}`);
            if (newParams.charm > 0) inheritInfo.push(`💖${newParams.charm}`);
            const attrInfo = Object.entries(newAttrs).map(([k, v]) => `${ENV_ICONS[k]}${v}`).join(' ');
            
            // 로그 시간 포맷
            const timestamp = new Date().toLocaleString('ko-KR', {
                month: '2-digit',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit'
            });
            
            // 새 알 생성 (createNewSpirit과 동일한 구조)
            const breedEggName = `${mySpirit.name}와${friendData.name}의 알`;
            const newSpirit = {
                id: Date.now(),
                name: breedEggName,
                originalName: null,
                growth: 0,
                // 공개 스탯 (부모에게서 상속)
                parameters: newParams,
                // 숨겨진 속성 (부모에게서 상속)
                hiddenAttributes: {
                    fire: newAttrs.fire || 0,
                    water: newAttrs.water || 0,
                    wind: newAttrs.wind || 0,
                    earth: newAttrs.earth || 0,
                    light: newAttrs.light || 0,
                    dark: newAttrs.dark || 0
                },
                satisfaction: 'mid',
                lastFed: null,
                lastMusic: null,
                lastPat: null,
                lastDecorate: null,
                lastInteraction: Date.now(),
                status: '알이 따뜻합니다...',
                birthTime: Date.now(),
                logs: [
                    { time: timestamp, message: `🔗 ${mySpirit.name}와(과) ${friendData.name}의 연결로 태어났습니다.` },
                    { time: timestamp, message: `📊 부모에게서 물려받은 능력: ${inheritInfo.join(' ')} ${attrInfo}` }
                ],
                lightTime: 0,
                darkTime: 0,
                musicListened: 0,
                feedCount: 0,
                // 연결 관련 정보
                bredWith: friendData.name,
                breedCode: breedCode,
                fusionType: prediction.key || null,
                fusionRarity: prediction.rarity || 'common',
                isBred: true
            };
            
            spirits.push(newSpirit);
            coins -= BREED_COST;
            
            console.log('🥚 새 알 생성됨:', newSpirit);
            console.log('📋 현재 spirits:', spirits);
            
            // 합성 도감 등록
            if (isFusionType && prediction.key) {
                if (!encyclopedia[prediction.key]) {
                    encyclopedia[prediction.key] = 1;
                    showNotification(`🎉 새로운 연결 정령 "${prediction.name}" 도감 등록!`);
                } else {
                    encyclopedia[prediction.key]++;
                }
            }
            
            saveGame();
            renderSpirits();
            updateCoinDisplay();
            renderFusionEncyclopedia();
            
            showNotification(`🎉 연결 성공! ${isFusionType ? prediction.name : newSpirit.name}이(가) 태어났습니다!`);
            
            // 입력 초기화
            codeInput.value = '';
            mySelect.value = '';
            document.getElementById('friendCodePreview').style.display = 'none';
            document.getElementById('breedPreview').style.display = 'none';
            
            // 정원 탭으로 이동해서 새 알 보여주기
            switchTab('garden');
        }
        
        function predictBreedResult(mySpirit, friendData) {
            // 타입 추론 헬퍼 함수 (type 필드 + 이름 기반)
            const getSpiritTypeInfo = (spirit) => {
                const type = spirit.type || spirit.evolutionType || spirit.evolutionData?.type;
                const name = spirit.name || '';
                
                // 정령왕 체크 (최상위)
                if (type === 'spiritking' || name === '정령왕') return { special: 'spiritking' };
                
                // 전설 정령 체크
                if (type === 'titania' || name === '티타니아') return { special: 'titania' };
                if (type === 'oberon' || name === '오베론') return { special: 'oberon' };
                
                // 정령왕의 부름을 받은 (모든 스탯 100) 체크
                if (type === 'sage' || name.includes('정령왕의 부름을 받은')) return { special: 'sage' };
                
                // 조화/혼돈 체크
                if (type === 'balanced' || name.includes('조화의 정령')) return { special: 'balanced' };
                if (type === 'multi' || name.includes('혼돈의 정령')) return { special: 'multi' };
                
                // 스탯 계열 체크
                const params = spirit.parameters || {};
                const intel = params.intelligence || 0;
                const str = params.strength || 0;
                const charm = params.charm || 0;
                
                // 스탯이 100 이상이면 확실히 해당 계열
                if (intel >= 100 && str >= 100 && charm >= 100) return { special: 'sage' };
                
                // 이름에서 스탯 계열 추론 (새 타이틀)
                if (name.includes('지식의 씨앗')) return { stat: 'intelligent' };
                if (name.includes('불굴의 기사')) return { stat: 'strong' };
                if (name.includes('달콤한 향기')) return { stat: 'beautiful' };
                
                // 스탯 수치 기반 (100 이상)
                if (intel >= 100) return { stat: 'intelligent' };
                if (str >= 100) return { stat: 'strong' };
                if (charm >= 100) return { stat: 'beautiful' };
                
                // 속성 체크 (이름 기반)
                if (name.includes('화염') || name.includes('불꽃')) return { attr: 'fire' };
                if (name.includes('빙하') || name.includes('물')) return { attr: 'water' };
                if (name.includes('질풍') || name.includes('바람')) return { attr: 'wind' };
                if (name.includes('대지') || name.includes('땅')) return { attr: 'earth' };
                if (name.includes('광명') || name.includes('빛')) return { attr: 'light' };
                if (name.includes('암흑') || name.includes('어둠')) return { attr: 'dark' };
                
                return {};
            };
            
            const myInfo = getSpiritTypeInfo(mySpirit);
            const friendInfo = getSpiritTypeInfo(friendData);
            
            console.log('연결 타입 체크:', { 
                myName: mySpirit.name, 
                friendName: friendData.name,
                myInfo, 
                friendInfo 
            });
            
            // 1. 티타니아 + 오베론 = 오블리비온
            if ((myInfo.special === 'titania' && friendInfo.special === 'oberon') ||
                (myInfo.special === 'oberon' && friendInfo.special === 'titania')) {
                return { ...FUSION_TYPES['fusion-oblivion'], key: 'fusion-oblivion' };
            }
            
            // 2. 조화/혼돈 조합 체크
            if (myInfo.special === 'balanced' && friendInfo.special === 'balanced') {
                return { ...FUSION_TYPES['fusion-spirit-king'], key: 'fusion-spirit-king' };
            }
            if (myInfo.special === 'multi' && friendInfo.special === 'multi') {
                return { ...FUSION_TYPES['fusion-chaos-king'], key: 'fusion-chaos-king' };
            }
            if ((myInfo.special === 'balanced' && friendInfo.special === 'multi') ||
                (myInfo.special === 'multi' && friendInfo.special === 'balanced')) {
                return { ...FUSION_TYPES['fusion-balance-chaos'], key: 'fusion-balance-chaos' };
            }
            
            // 3. 이벤트 정령 연결
            const myEventType = mySpirit.isEventSpirit ? mySpirit.eventType : null;
            const friendEventType = friendData.isEventSpirit ? friendData.eventType : null;
            
            if (myEventType || friendEventType) {
                const eventType = myEventType || friendEventType;
                const event = EVENT_TYPES[eventType];
                if (event) {
                    return {
                        name: event.name,
                        icon: event.stages.egg,
                        desc: event.desc,
                        rarity: 'event',
                        isEventResult: true,
                        eventType: eventType
                    };
                }
            }
            
            // 4. 속성 기반 합성
            const myAttr = myInfo.attr || getMainAttribute(mySpirit);
            const friendAttr = friendInfo.attr || friendData.attribute || getMainAttributeFromData(friendData);
            
            // 정확한 레시피 매칭
            for (const [key, fusion] of Object.entries(FUSION_TYPES)) {
                const recipe = fusion.recipe;
                if ((recipe[0] === myAttr && recipe[1] === friendAttr) ||
                    (recipe[0] === friendAttr && recipe[1] === myAttr)) {
                    return { ...fusion, key };
                }
            }
            
            // 5. 기본 결과
            const inheritedAttr = Math.random() > 0.5 ? myAttr : friendAttr;
            const attrInfo = ATTRIBUTE_NAMES[inheritedAttr] || ATTRIBUTE_NAMES.normal;
            const attrIcon = typeof attrInfo.icon === 'object' ? attrInfo.icon.butterfly : attrInfo.icon;
            return {
                name: attrInfo.name,
                icon: attrIcon,
                desc: attrInfo.desc,
                rarity: 'common',
                inheritedAttr
            };
        }
        
        // friendData에서 속성 추출 (코드에서 디코딩된 데이터용)
        function getMainAttributeFromData(data) {
            const attrs = data.attributes || {};
            let maxAttr = 'normal';
            let maxVal = 0;
            
            ['fire', 'water', 'wind', 'earth', 'light', 'dark'].forEach(attr => {
                if ((attrs[attr] || 0) > maxVal) {
                    maxVal = attrs[attr] || 0;
                    maxAttr = attr;
                }
            });
            
            return maxVal >= 50 ? maxAttr : (data.attribute || 'normal');
        }
        
        function getStatTypeFromData(data) {
            const params = data.parameters || {};
            const intel = params.intelligence || 0;
            const str = params.strength || 0;
            const charm = params.charm || 0;
            
            if (intel > str && intel > charm && intel >= 70) return 'intelligent';
            if (str > intel && str > charm && str >= 70) return 'strong';
            if (charm > intel && charm > str && charm >= 70) return 'beautiful';
            return null;
        }
        
        function updateBreedPreview() {
            const mySelect = document.getElementById('myBreedSpirit');
            const codeInput = document.getElementById('friendCodeInput');
            const preview = document.getElementById('breedPreview');
            
            if (!mySelect.value || !codeInput.value.trim()) {
                preview.style.display = 'none';
                return;
            }
            
            // 현재 정령 또는 앨범에서 찾기
            const allCompleted = getCompletedSpiritsForBreeding();
            const mySpirit = allCompleted.find(s => s.id === mySelect.value);
            const friendData = decodeSpiritData(codeInput.value.trim());
            
            if (!mySpirit || !friendData) {
                preview.style.display = 'none';
                return;
            }
            
            const prediction = predictBreedResult(mySpirit, friendData);
            
            // 예상 상속 스탯 계산
            const inheritParams = {
                intelligence: Math.floor(((mySpirit.parameters?.intelligence || 0) + (friendData.parameters?.intelligence || 0)) / 2),
                strength: Math.floor(((mySpirit.parameters?.strength || 0) + (friendData.parameters?.strength || 0)) / 2),
                charm: Math.floor(((mySpirit.parameters?.charm || 0) + (friendData.parameters?.charm || 0)) / 2)
            };
            
            // 예상 상속 속성 계산
            const myAttrs = mySpirit.attributes || mySpirit.hiddenAttributes || {};
            const friendAttrs = friendData.attributes || {};
            const inheritAttrs = [];
            ['fire', 'water', 'wind', 'earth', 'light', 'dark'].forEach(attr => {
                const avg = Math.floor(((myAttrs[attr] || 0) + (friendAttrs[attr] || 0)) / 2);
                if (avg > 0) inheritAttrs.push(`${ENV_ICONS[attr]}${avg}`);
            });
            
            preview.innerHTML = `
                <div style="font-size: 0.85rem; color: #888; margin-bottom: 8px;">🥚 예상 결과</div>
                <div style="font-size: 2rem;">${prediction.icon}</div>
                <div style="font-weight: 700; margin: 4px 0;">${prediction.name}</div>
                <div style="font-size: 0.8rem; color: ${getRarityColor(prediction.rarity)}; margin-bottom: 8px;">${getRarityText(prediction.rarity)}</div>
                <div style="font-size: 0.8rem; color: #888; border-top: 1px solid var(--border); padding-top: 8px;">
                    <div style="margin-bottom: 4px;">📊 상속 스탯</div>
                    <div>🧠${inheritParams.intelligence} | 💪${inheritParams.strength} | 💖${inheritParams.charm}</div>
                    ${inheritAttrs.length > 0 ? `<div style="margin-top: 4px;">${inheritAttrs.join(' ')}</div>` : ''}
                </div>
            `;
            preview.style.display = 'block';
        }

        function renderEncyclopedia() {
            try {
                console.log('도감 렌더링 시작');
                console.log('현재 도감:', encyclopedia);
                console.log('현재 앨범:', collection);
                
                // 도감 카운트 가져오기 (숫자/객체 형식 모두 처리)
                function getEncyclopediaCount(key) {
                    const value = encyclopedia[key];
                    if (!value) return 0;
                    if (typeof value === 'object') return value.count || 0;
                    return value;
                }
                
                const grid = document.getElementById('encyclopediaGrid');
                if (!grid) {
                    console.error('encyclopediaGrid 엘리먼트를 찾을 수 없습니다');
                    return;
                }
                
                // encyclopedia가 null이거나 undefined인 경우 초기화
                if (!encyclopedia || typeof encyclopedia !== 'object') {
                    console.warn('⚠️ 도감 데이터가 유효하지 않음 - 초기화');
                    encyclopedia = {};
                }
                
                // 도감이 비어있는데 앨범에 데이터가 있으면 자동 복구
                if (Object.keys(encyclopedia).length === 0 && collection && collection.length > 0) {
                    console.log('⚠️ 도감이 비어있지만 앨범에 데이터 존재 - 자동 복구 시작');
                    try {
                        const recoveredCount = rebuildEncyclopediaFromAlbum();
                        showNotification(`도감을 복구했습니다! (${recoveredCount}종)`);
                    } catch (rebuildError) {
                        console.error('도감 복구 실패:', rebuildError);
                    }
                }
            
            const statTypes = [
                { key: 'nostat', name: '(타이틀 없음)' },
                { key: 'intelligent', name: '지식의 씨앗' },
                { key: 'strong', name: '불굴의 기사' },
                { key: 'beautiful', name: '달콤한 향기' },
                { key: 'sage', name: '정령왕의 부름을 받은 자' }
            ];
            
            // 속성별 그룹 정의
            const attributeGroups = [
                {
                    title: '⚪ 순수',
                    attrs: ['normal']
                },
                {
                    title: '🔥💧🌬️🌱✨🌙 기본 속성',
                    attrs: ['fire', 'water', 'wind', 'earth', 'light', 'dark']
                },
                {
                    title: '🔥 화염 조합',
                    attrs: ['fire-water', 'fire-wind', 'earth-fire', 'fire-light', 'dark-fire']
                },
                {
                    title: '💧 빙하 조합',
                    attrs: ['water-wind', 'earth-water', 'light-water', 'dark-water']
                },
                {
                    title: '🌬️ 질풍 조합',
                    attrs: ['earth-wind', 'light-wind', 'dark-wind']
                },
                {
                    title: '🌱 대지 조합',
                    attrs: ['earth-light', 'dark-earth']
                },
                {
                    title: '✨🌙 환혹',
                    attrs: ['dark-light']
                },
                {
                    title: '⚖️🌪️ 다속성',
                    attrs: ['balanced', 'multi']
                }
            ];
            
            let html = '';
            
            // 전설적 존재 (티타니아/오베론) - 맨 위에 특별 표시
            html += `<div style="grid-column: 1 / -1; margin-top: 10px; margin-bottom: 15px;">
                <h2 style="font-family: 'Nanum Myeongjo', serif; font-size: 1.5rem; color: var(--text); border-bottom: 3px solid gold; padding-bottom: 10px;">
                    전설적 존재
                </h2>
            </div>`;
            
            // 정령왕
            const spiritkingCount = getEncyclopediaCount('spiritking');
            const spiritkingUnlocked = spiritkingCount > 0;
            html += `
                <div class="${spiritkingUnlocked ? 'encyclopedia-card unlocked' : 'encyclopedia-card locked'}" style="min-height: 120px; border: 2px solid #ff69b4; background: ${spiritkingUnlocked ? 'linear-gradient(135deg, rgba(255,105,180,0.2), rgba(255,215,0,0.2))' : 'var(--card)'};">
                    <div class="encyclopedia-icon" style="font-size: 3rem;">${spiritkingUnlocked ? '👑🌸' : '?'}</div>
                    <div class="encyclopedia-name" style="font-size: 1rem; font-weight: 700;">${spiritkingUnlocked ? '정령왕' : '???????'}</div>
                    <div class="encyclopedia-count" style="font-size: 0.8rem;">${spiritkingUnlocked ? `${spiritkingCount}회` : '미달성'}</div>
                    <div style="font-size: 0.7rem; color: ${spiritkingUnlocked ? '#ff69b4' : '#888'}; margin-top: 5px;">${spiritkingUnlocked ? ENCYCLOPEDIA_HINTS['spiritking'] : '만개한 자연의 화신.'}</div>
                </div>
            `;
            
            // 티타니아
            const titaniaCount = getEncyclopediaCount('titania');
            const titaniaUnlocked = titaniaCount > 0;
            html += `
                <div class="${titaniaUnlocked ? 'encyclopedia-card unlocked' : 'encyclopedia-card locked'}" style="min-height: 120px; border: 2px solid gold;">
                    <div class="encyclopedia-icon" style="font-size: 3rem;">${titaniaUnlocked ? '🦋✨' : '?'}</div>
                    <div class="encyclopedia-name" style="font-size: 1rem; font-weight: 700;">${titaniaUnlocked ? '티타니아' : '???????'}</div>
                    <div class="encyclopedia-count" style="font-size: 0.8rem;">${titaniaUnlocked ? `${titaniaCount}회` : '미달성'}</div>
                    <div style="font-size: 0.7rem; color: ${titaniaUnlocked ? 'gold' : '#888'}; margin-top: 5px;">${titaniaUnlocked ? ENCYCLOPEDIA_HINTS['titania'] : '나비를 거느리는 정령들의 군주.'}</div>
                </div>
            `;
            
            // 오베론
            const oberonCount = getEncyclopediaCount('oberon');
            const oberonUnlocked = oberonCount > 0;
            html += `
                <div class="${oberonUnlocked ? 'encyclopedia-card unlocked' : 'encyclopedia-card locked'}" style="min-height: 120px; border: 2px solid gold;">
                    <div class="encyclopedia-icon" style="font-size: 3rem;">${oberonUnlocked ? '🦋🌙' : '?'}</div>
                    <div class="encyclopedia-name" style="font-size: 1rem; font-weight: 700;">${oberonUnlocked ? '오베론' : '???????'}</div>
                    <div class="encyclopedia-count" style="font-size: 0.8rem;">${oberonUnlocked ? `${oberonCount}회` : '미달성'}</div>
                    <div style="font-size: 0.7rem; color: ${oberonUnlocked ? 'gold' : '#888'}; margin-top: 5px;">${oberonUnlocked ? ENCYCLOPEDIA_HINTS['oberon'] : '나방을 거느리는 정령들의 군주.'}</div>
                </div>
            `;
            
            // 오블리비온
            const oblivionCount = getEncyclopediaCount('fusion-oblivion');
            const oblivionUnlocked = oblivionCount > 0;
            html += `
                <div class="${oblivionUnlocked ? 'encyclopedia-card unlocked' : 'encyclopedia-card locked'}" style="min-height: 120px; border: 2px solid #ff00ff;">
                    <div class="encyclopedia-icon" style="font-size: 3rem;">${oblivionUnlocked ? '🦋🌌' : '?'}</div>
                    <div class="encyclopedia-name" style="font-size: 1rem; font-weight: 700;">${oblivionUnlocked ? '오블리비온' : '???????'}</div>
                    <div class="encyclopedia-count" style="font-size: 0.8rem;">${oblivionUnlocked ? `${oblivionCount}회` : '미달성'}</div>
                    <div style="font-size: 0.7rem; color: ${oblivionUnlocked ? '#ff00ff' : '#888'}; margin-top: 5px;">${oblivionUnlocked ? '정령의 군주들 사이에서 태어난 망각의 정령.' : '군주들의 후예.'}</div>
                </div>
            `;
            
            attributeGroups.forEach(group => {
                // 그룹 헤더
                html += `<div style="grid-column: 1 / -1; margin-top: 30px; margin-bottom: 15px;">
                    <h2 style="font-family: 'Nanum Myeongjo', serif; font-size: 1.5rem; color: var(--text); border-bottom: 3px solid var(--fire); padding-bottom: 10px;">
                        ${group.title}
                    </h2>
                </div>`;
                
                group.attrs.forEach(attrType => {
                    const attributeData = ATTRIBUTE_NAMES[attrType];
                    if (!attributeData) return;
                    
                    // 속성 아이콘 (이미지가 있는 경우 이모티콘으로 대체)
                    const attrEmojis = {
                        fire: '🔥', water: '💧', wind: '🌬️', earth: '🌱', light: '✨', dark: '🌙', normal: '⚪',
                        'fire-water': '💨', 'fire-wind': '🌪️', 'earth-fire': '🌋', 'fire-light': '☀️', 'dark-fire': '💨',
                        'water-wind': '☁️', 'earth-water': '🪨', 'light-water': '🌈', 'dark-water': '🌫️',
                        'earth-wind': '🏜️', 'light-wind': '🌌', 'dark-wind': '🌀',
                        'earth-light': '💎', 'dark-earth': '⛰️', 'dark-light': '✨🌙',
                        balanced: '⚖️', multi: '🌪️'
                    };
                    const butterflyIcon = typeof attributeData.icon === 'object' ? attributeData.icon.butterfly : attributeData.icon;
                    const mothIcon = typeof attributeData.icon === 'object' ? attributeData.icon.moth : attributeData.icon;
                    const headerEmoji = attrEmojis[attrType] || '✨';
                    
                    // 속성 헤더 (이미지 없이 이름만)
                    html += `<div style="grid-column: 1 / -1; margin-top: 20px; margin-bottom: 10px;">
                        <h3 style="font-family: 'Nanum Myeongjo', serif; font-size: 1.2rem; color: var(--text); display: flex; align-items: center; gap: 10px;">
                            <span style="font-size: 1.5rem;">${headerEmoji}</span>
                            <span>${attributeData.name}</span>
                        </h3>
                    </div>`;
                    
                    // 나비형/나방형 각각 표시
                    const wingTypes = [
                        { key: 'butterfly', name: '나비형', emoji: '🦋' },
                        { key: 'moth', name: '나방형', emoji: '🦋' }
                    ];
                    
                    wingTypes.forEach(wingInfo => {
                        const currentIcon = wingInfo.key === 'butterfly' ? butterflyIcon : mothIcon;
                        
                        // 날개 타입 서브헤더
                        html += `<div style="grid-column: 1 / -1; margin-top: 10px; margin-bottom: 5px;">
                            <span style="font-size: 0.9rem; color: var(--text-muted); font-weight: 600;">
                                ${wingInfo.emoji} ${wingInfo.name}
                            </span>
                        </div>`;
                        
                        // 가로로 나열 (수식어 없음 + 3개 스탯 계열 + 현자)
                        statTypes.forEach(statInfo => {
                            let count = 0;
                            let displayName = '???????';
                            let displayIcon = '?';
                            let isUnlocked = false;
                            
                            // 이모티콘 버전 아이콘
                            const emojiIcon = headerEmoji;
                            
                            if (statInfo.key === 'nostat') {
                                // 수식어 없는 정령 - 이미지 사용 (150px)
                                count = getEncyclopediaCount(`nostat-${attrType}-${wingInfo.key}`);
                                isUnlocked = count > 0;
                                displayName = isUnlocked ? '(타이틀 없음)' : '???????';
                                // 이미지인 경우 150px로 조정
                                if (isUnlocked && currentIcon.includes('<img')) {
                                    displayIcon = currentIcon.replace(/width:\d+px;height:(auto|\d+px)/g, 'width:150px;height:auto');
                                } else {
                                    displayIcon = isUnlocked ? currentIcon : '?';
                                }
                            } else if (statInfo.key === 'sage') {
                                // 정령왕의 부름을 받은 자 - 이모티콘 사용
                                count = getEncyclopediaCount(`sage-${attrType}-${wingInfo.key}`);
                                isUnlocked = count > 0;
                                
                                if (isUnlocked) {
                                    const sageData = EVOLUTION_TYPES['sage'];
                                    displayName = sageData.prefix;
                                    displayIcon = `${sageData.icon}${emojiIcon}`;
                                }
                            } else {
                                // 스탯 계열 정령 (intelligent, strong, beautiful) - 이모티콘 사용
                                count = getEncyclopediaCount(`${statInfo.key}-${attrType}-${wingInfo.key}`);
                                isUnlocked = count > 0;
                                
                                if (isUnlocked) {
                                    const statData = EVOLUTION_TYPES[statInfo.key];
                                    displayName = statData.prefix;
                                    displayIcon = `${statData.icon}${emojiIcon}`;
                                }
                            }
                            
                            const cardClass = isUnlocked ? 'encyclopedia-card unlocked' : 'encyclopedia-card locked';
                            const countText = isUnlocked ? `${count}회` : '미달성';
                            
                            // 정령 전체 이름 생성
                            let fullName = '???????';
                            let hintKey = '';
                            
                            if (isUnlocked) {
                                if (statInfo.key === 'nostat') {
                                    fullName = attributeData.name;
                                    hintKey = `nostat-${attrType}`;
                                } else if (statInfo.key === 'sage') {
                                    const sageData = EVOLUTION_TYPES['sage'];
                                    fullName = `${sageData.prefix} ${attributeData.name}`;
                                    hintKey = `sage-${attrType}`;
                                } else {
                                    const statData = EVOLUTION_TYPES[statInfo.key];
                                    fullName = `${statData.prefix} ${attributeData.name}`;
                                    hintKey = `${statInfo.key}-${attrType}`;
                                }
                            }
                            
                            // 힌트 표시
                            let hint = '';
                            if (isUnlocked) {
                                hint = ENCYCLOPEDIA_HINTS[hintKey] || '';
                            } else {
                                if (statInfo.key === 'nostat') {
                                    hint = ENCYCLOPEDIA_HINTS[`nostat-${attrType}`] || '???';
                                } else if (statInfo.key === 'sage') {
                                    hint = ENCYCLOPEDIA_HINTS[`sage-${attrType}`] || '정령왕의 부름을 받은 정령.';
                                } else {
                                    hint = ENCYCLOPEDIA_HINTS[`${statInfo.key}-${attrType}`] || '???';
                                }
                            }
                            
                            // 아이콘이 이미지인지 이모티콘인지에 따라 스타일 다르게
                            const isImageIcon = displayIcon.includes('<img');
                            const iconStyle = isImageIcon ? '' : 'font-size: 2.5rem;';
                            
                            html += `
                                <div class="${cardClass}" style="min-height: 120px;">
                                    <div class="encyclopedia-icon" style="${iconStyle}">${displayIcon}</div>
                                    <div class="encyclopedia-name" style="font-size: 0.85rem; font-weight: 600;">${fullName}</div>
                                    <div class="encyclopedia-count" style="font-size: 0.75rem; margin-top: 4px;">${countText}</div>
                                    ${hint ? `<div style="font-size: 0.7rem; color: #888; margin-top: 6px; line-height: 1.3; padding: 0 8px; text-align: center;">${hint}</div>` : ''}
                                </div>
                            `;
                        });
                    });
                });
            });
            
            // 이벤트 정령 섹션
            html += `<div style="grid-column: 1 / -1; margin-top: 30px; margin-bottom: 15px;">
                <h2 style="font-family: 'Nanum Myeongjo', serif; font-size: 1.5rem; color: #c41e3a; border-bottom: 3px solid #c41e3a; padding-bottom: 10px;">
                    🎄 이벤트 정령
                </h2>
            </div>`;
            
            Object.entries(EVENT_TYPES).forEach(([eventKey, event]) => {
                // 일반 이벤트 정령
                const eventEncKey = `event_${eventKey}`;
                const eventCount = encyclopedia[eventEncKey] || 0;
                const isUnlocked = eventCount > 0;
                
                html += `
                    <div class="${isUnlocked ? 'encyclopedia-card unlocked' : 'encyclopedia-card locked'}" style="min-height: 120px; border: 2px solid #c41e3a;">
                        <div class="encyclopedia-icon" style="font-size: 3rem;">${isUnlocked ? event.stages.adult : event.stages.egg}</div>
                        <div class="encyclopedia-name" style="font-size: 1rem; font-weight: 700; color: #c41e3a;">${isUnlocked ? event.name : '???'}</div>
                        <div class="encyclopedia-count" style="font-size: 0.8rem;">${isUnlocked ? `${eventCount}회` : '미달성'}</div>
                        <div style="font-size: 0.7rem; color: ${isUnlocked ? '#c41e3a' : '#888'}; margin-top: 5px;">${isUnlocked ? event.desc : '이벤트 코드로 획득할 수 있는 특별한 정령.'}</div>
                    </div>
                `;
                
                // 이로치 버전이 있으면 별도 표시
                if (event.shiny) {
                    const shinyEncKey = `event_${eventKey}_shiny`;
                    const shinyCount = encyclopedia[shinyEncKey] || 0;
                    const isShinyUnlocked = shinyCount > 0;
                    
                    html += `
                        <div class="${isShinyUnlocked ? 'encyclopedia-card unlocked' : 'encyclopedia-card locked'}" style="min-height: 120px; border: 2px solid #87CEEB; background: ${isShinyUnlocked ? 'linear-gradient(135deg, rgba(135,206,235,0.1), rgba(255,255,255,0.1))' : 'var(--card)'};">
                            <div class="encyclopedia-icon" style="font-size: 3rem;">${isShinyUnlocked ? event.shiny.stages.adult : event.shiny.stages.egg}</div>
                            <div class="encyclopedia-name" style="font-size: 1rem; font-weight: 700; color: #87CEEB;">${isShinyUnlocked ? event.shiny.name : '???'} ${isShinyUnlocked ? '✨' : ''}</div>
                            <div class="encyclopedia-count" style="font-size: 0.8rem;">${isShinyUnlocked ? `${shinyCount}회` : '미달성'}</div>
                            <div style="font-size: 0.7rem; color: ${isShinyUnlocked ? '#87CEEB' : '#888'}; margin-top: 5px;">${isShinyUnlocked ? event.shiny.desc : '크리스마스에 드물게 나타나는 차가운 눈꽃.'}</div>
                        </div>
                    `;
                }
            });
            
            // 연결 정령 섹션
            html += '<div style="grid-column: 1 / -1; margin-top: 30px; margin-bottom: 15px;">' +
                '<h2 style="font-family: \'Nanum Myeongjo\', serif; font-size: 1.5rem; color: #9b59b6; border-bottom: 3px solid #9b59b6; padding-bottom: 10px;">' +
                    '💜 연결 정령' +
                '</h2>' +
            '</div>';
            
            // 레어리티별 그룹화
            const fusionGroups = {
                'rare': { title: '💎 희귀', entries: [] },
                'epic': { title: '⭐ 최상급', entries: [] },
                'legendary': { title: '👑 전설', entries: [] }
            };
            
            Object.entries(FUSION_TYPES).forEach(([key, data]) => {
                if (fusionGroups[data.rarity]) {
                    fusionGroups[data.rarity].entries.push({ key, ...data });
                }
            });
            
            // 레어리티 순서대로 표시
            ['rare', 'epic', 'legendary'].forEach(rarity => {
                const group = fusionGroups[rarity];
                if (group.entries.length === 0) return;
                
                // 레어리티 소제목
                const rarityColors = { rare: '#3498db', epic: '#9b59b6', legendary: '#f1c40f' };
                html += '<div style="grid-column: 1 / -1; margin-top: 20px; margin-bottom: 10px;">' +
                    '<h3 style="font-family: \'Nanum Myeongjo\', serif; font-size: 1.1rem; color: ' + rarityColors[rarity] + ';">' + group.title + '</h3>' +
                '</div>';
                
                group.entries.forEach(fusion => {
                    const fusionCount = encyclopedia[fusion.key] || 0;
                    const isUnlocked = fusionCount > 0;
                    const borderColor = rarityColors[rarity];
                    
                    // 레시피 힌트 생성
                    let recipeHint = '';
                    if (fusion.recipe) {
                        const recipeNames = fusion.recipe.map(r => {
                            if (ATTRIBUTE_NAMES[r]) {
                                const icon = ATTRIBUTE_NAMES[r].icon;
                                // icon이 object인 경우 (fire 등) 이모지로 대체
                                if (typeof icon === 'object') {
                                    const attrEmojis = { fire: '🔥', water: '💧', wind: '🌬️', earth: '🌱', light: '✨', dark: '🌙' };
                                    return attrEmojis[r] || '✨';
                                }
                                return icon;
                            }
                            if (r === 'intelligent') return '🧠';
                            if (r === 'strong') return '💪';
                            if (r === 'beautiful') return '💖';
                            if (r === 'balanced') return '⚖️';
                            return r;
                        });
                        recipeHint = recipeNames.join(' + ');
                    }
                    
                    html += '<div class="' + (isUnlocked ? 'encyclopedia-card unlocked' : 'encyclopedia-card locked') + '" style="min-height: 120px; border: 2px solid ' + borderColor + ';">' +
                        '<div class="encyclopedia-icon" style="font-size: 2.5rem;">' + (isUnlocked ? fusion.icon : '?') + '</div>' +
                        '<div class="encyclopedia-name" style="font-size: 0.9rem; font-weight: 700; color: ' + borderColor + ';">' + (isUnlocked ? fusion.name : '???') + '</div>' +
                        '<div class="encyclopedia-count" style="font-size: 0.75rem;">' + (isUnlocked ? fusionCount + '회' : '미달성') + '</div>' +
                        '<div style="font-size: 0.7rem; color: #888; margin-top: 5px;">' + (isUnlocked ? fusion.desc : '연결: ' + recipeHint) + '</div>' +
                    '</div>';
                });
            });
            
            grid.innerHTML = html;
            } catch (error) {
                console.error('도감 렌더링 오류:', error);
                console.error('오류 스택:', error.stack);
                console.error('현재 도감 데이터:', encyclopedia);
                console.error('현재 앨범 데이터:', collection);
                
                const grid = document.getElementById('encyclopediaGrid');
                if (grid) {
                    grid.innerHTML = `
                        <div style="text-align: center; padding: 40px;">
                            <div style="color: #f44336; font-size: 1.2rem; margin-bottom: 20px;">⚠️ 도감 렌더링 오류</div>
                            <div style="color: #666; margin-bottom: 20px;">
                                오류: ${error.message}<br>
                                도감 항목: ${Object.keys(encyclopedia).length}개<br>
                                앨범 항목: ${collection.length}개
                            </div>
                            <button onclick="manualRebuildEncyclopedia()" style="padding: 12px 24px; background: var(--water); color: white; border: none; border-radius: 8px; font-weight: 700; cursor: pointer; margin-right: 10px;">
                                📚 앨범에서 도감 복구
                            </button>
                            <button onclick="renderEncyclopedia()" style="padding: 12px 24px; background: var(--fire); color: white; border: none; border-radius: 8px; font-weight: 700; cursor: pointer;">
                                🔄 다시 시도
                            </button>
                        </div>
                    `;
                }
            }
        }

        // 앨범 상세 이미지 저장 기능
        async function saveAlbumDetailImage() {
            showNotification('📷 이미지 생성 중...');
            
            try {
                const content = document.getElementById('albumDetailContent');
                
                // 스크롤 위치 저장 및 맨 위로 이동
                const originalScrollTop = content.scrollTop;
                content.scrollTop = 0;
                
                // 저장 버튼 임시 숨기기
                const saveBtn = content.querySelector('button[onclick="saveAlbumDetailImage()"]').parentElement;
                const originalSaveBtnDisplay = saveBtn.style.display;
                saveBtn.style.display = 'none';
                
                // X 버튼 임시 숨기기
                const closeBtn = content.querySelector('button[onclick="closeAlbumDetail()"]');
                const originalCloseBtnDisplay = closeBtn.style.display;
                closeBtn.style.display = 'none';
                
                // 연결 섹션 임시 숨기기
                const breedSection = document.getElementById('breedSection');
                const originalBreedDisplay = breedSection ? breedSection.style.display : '';
                if (breedSection) breedSection.style.display = 'none';
                
                // 스크롤바 임시 제거 및 전체 높이로 확장
                const originalOverflow = content.style.overflowY;
                const originalMaxHeight = content.style.maxHeight;
                content.style.overflowY = 'visible';
                content.style.maxHeight = 'none';
                
                const canvas = await html2canvas(content, {
                    backgroundColor: getComputedStyle(document.body).getPropertyValue('--card') || '#ffffff',
                    scale: 2,
                    useCORS: true,
                    logging: false,
                    windowHeight: content.scrollHeight,
                    height: content.scrollHeight
                });
                
                // 모든 요소 복원
                saveBtn.style.display = originalSaveBtnDisplay;
                closeBtn.style.display = originalCloseBtnDisplay;
                if (breedSection) breedSection.style.display = originalBreedDisplay;
                content.style.overflowY = 'auto';
                content.style.maxHeight = '80vh';
                content.scrollTop = originalScrollTop;
                
                // 정령 이름 가져오기
                const spiritName = document.getElementById('modalTitle').textContent || 'spirit';
                
                // 이미지 다운로드
                const link = document.createElement('a');
                link.download = `${spiritName}-${new Date().toISOString().slice(0,10)}.png`;
                link.href = canvas.toDataURL('image/png');
                link.click();
                
                showNotification('✅ 이미지가 저장되었습니다!');
            } catch (error) {
                console.error('이미지 생성 오류:', error);
                showNotification('❌ 이미지 생성에 실패했습니다');
            }
        }

        function renderCollection() {
            try {
                console.log('앨범 렌더링 시작');
                const grid = document.getElementById('collectionGrid');
                if (!grid) {
                    console.error('collectionGrid 엘리먼트를 찾을 수 없습니다');
                    return;
                }
            
            if (collection.length === 0) {
                grid.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-icon">📖</div>
                        <div>아직 등록된 정령이 없습니다<br>정령을 성충까지 키워보세요</div>
                    </div>
                `;
                return;
            }

            // 역순으로 표시 (최근 것이 맨 앞에)
            const reversedCollection = [...collection].reverse();
            
            grid.innerHTML = reversedCollection.map((item, reverseIndex) => {
                const index = collection.length - 1 - reverseIndex; // 원본 인덱스
                // desc는 도감 아이템에 저장되어 있음
                const desc = item.desc || '';
                const originalName = item.originalName || item.name || '이름 없음';
                
                // 이미지 아이콘인지 확인
                const isImageIcon = item.icon && item.icon.includes('<img');
                
                // 날개 이모지 결정 (이미지 아이콘이면 붙이지 않음)
                let wingEmoji = '';
                if (!isImageIcon) {
                    if (item.wingType === 'butterfly') {
                        wingEmoji = '🦋';
                    } else if (item.wingType === 'moth') {
                        wingEmoji = '🦋'; // 나방도 나비 이모지 사용 (시각적으로 구분)
                    } else if (item.wingType === 'both') {
                        wingEmoji = '🦋🦋';
                    }
                }
                
                // 아이콘 표시 (이미지인 경우 150px로 조정)
                let displayIcon = item.icon;
                if (isImageIcon) {
                    displayIcon = item.icon.replace(/width:\d+px;height:(auto|\d+px)/g, 'width:150px;height:auto');
                }
                
                return `
                    <div class="collection-card" onclick="showAlbumDetail(${index})" style="cursor: pointer; transition: transform 0.2s;${item.isRecovered ? (item.recoveredFromDetails ? ' border: 2px dashed #27ae60;' : ' border: 2px dashed #e67e22;') : ''}" onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                        <div class="collection-icon">${displayIcon}${wingEmoji}</div>
                        <div class="collection-name">${item.name}${item.isRecovered ? (item.recoveredFromDetails ? ' <span style="font-size: 0.7rem; color: #27ae60;">✓복구</span>' : ' <span style="font-size: 0.7rem; color: #e67e22;">복구</span>') : ''}</div>
                        <div style="font-size: 0.85rem; color: #666; margin-top: 4px;">본명: ${originalName}</div>
                        ${item.wingType ? `<div style="font-size: 0.85rem; color: #888; margin-top: 4px;">${item.wingType === 'butterfly' ? '나비의 날개' : item.wingType === 'moth' ? '나방의 날개' : '나비와 나방의 날개'}</div>` : ''}
                        ${desc ? `<div style="font-size: 0.85rem; color: #888; margin-top: 8px; line-height: 1.4;">${desc}</div>` : ''}
                        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; margin-top: 12px;">
                            <div class="param">💕 ${item.parameters.affection || 0}</div>
                            <div class="param">💪 ${item.parameters.strength}</div>
                            <div class="param">🧠 ${item.parameters.intelligence}</div>
                            <div class="param">💖 ${item.parameters.charm}</div>
                        </div>
                        <div style="font-size: 0.75rem; color: #999; margin-top: 12px; text-align: center;">📊 클릭하여 상세 정보 보기</div>
                    </div>
                `;
            }).join('');
            } catch (error) {
                console.error('앨범 렌더링 오류:', error);
                console.error('오류 스택:', error.stack);
                const grid = document.getElementById('collectionGrid');
                if (grid) {
                    grid.innerHTML = `
                        <div style="text-align: center; padding: 40px;">
                            <div style="color: #f44336; font-size: 1.2rem; margin-bottom: 20px;">⚠️ 앨범 렌더링 오류</div>
                            <div style="color: #666;">오류: ${error.message}</div>
                        </div>
                    `;
                }
            }
        }

        function switchTab(tab) {
            try {
                console.log('탭 전환:', tab);
                currentTab = tab; // 현재 탭 저장
                
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
                
                if (tab === 'garden') {
                    document.querySelector('.tab:nth-child(1)').classList.add('active');
                    document.getElementById('gardenSection').classList.add('active');
                    // 질병 튜토리얼: 육성 탭 열기 액션 체크
                    checkSickTutorialAction('openGarden');
                } else if (tab === 'terrarium') {
                    document.querySelector('.tab:nth-child(2)').classList.add('active');
                    document.getElementById('terrariumSection').classList.add('active');
                    renderTerrariumManagement();
                } else if (tab === 'lab') {
                    document.querySelector('.tab:nth-child(3)').classList.add('active');
                    document.getElementById('labSection').classList.add('active');
                    renderRecipeList();
                    updateLabUI();
                    checkRecipe();
                    // 연구실 튜토리얼: 연구실 탭 열기 액션 체크
                    checkLabTutorialAction('openLab');
                } else if (tab === 'shop') {
                    document.querySelector('.tab:nth-child(4)').classList.add('active');
                    document.getElementById('shopSection').classList.add('active');
                    renderShop();
                    // 질병 튜토리얼: 상점 탭 열기 액션 체크
                    checkSickTutorialAction('openShop');
                } else if (tab === 'minigame') {
                    document.querySelector('.tab:nth-child(5)').classList.add('active');
                    document.getElementById('minigameSection').classList.add('active');
                    // 미니게임 탭 전환 시 게임 중이면 일시정지
                    if (minigameActive) {
                        pauseMinigame();
                    }
                } else if (tab === 'encyclopedia') {
                    // 도감은 일지 탭의 서브탭으로 이동
                    document.querySelector('.tab:nth-child(6)').classList.add('active');
                    document.getElementById('journalSection').classList.add('active');
                    switchJournalTab('encyclopedia');
                } else if (tab === 'album') {
                    // 앨범은 일지 탭의 서브탭으로 이동
                    document.querySelector('.tab:nth-child(6)').classList.add('active');
                    document.getElementById('journalSection').classList.add('active');
                    switchJournalTab('album');
                } else if (tab === 'journal') {
                    document.querySelector('.tab:nth-child(6)').classList.add('active');
                    document.getElementById('journalSection').classList.add('active');
                    // 현재 서브탭 유지 또는 기본 도감 표시
                    switchJournalTab(currentJournalTab || 'encyclopedia');
                    checkAchievements();
                    // 튜토리얼2: 일지 탭 열기 액션 체크
                    checkTutorialAction('openJournal');
                } else if (tab === 'settings') {
                    // 설정은 탭 바에 없으므로 active 처리 안함
                    document.getElementById('settingsSection').classList.add('active');
                    updateSettingsInfo();
                }
            } catch (error) {
                console.error('탭 전환 오류:', error);
                console.error('오류 스택:', error.stack);
                showNotification('탭 전환 중 오류가 발생했습니다');
            }
        }

        // 설정 정보 업데이트
        function updateSettingsInfo() {
            // 다크모드 토글 상태 업데이트
            const toggle = document.getElementById('darkModeToggle');
            const slider = document.getElementById('darkModeSlider');
            if (toggle) {
                toggle.checked = darkModeLocked;
                if (darkModeLocked) {
                    slider.style.transform = 'translateX(28px)';
                    slider.parentElement.style.backgroundColor = '#4CAF50';
                } else {
                    slider.style.transform = 'translateX(0)';
                    slider.parentElement.style.backgroundColor = '#ccc';
                }
            }
        }
        
        // 이벤트 코드 사용
        async function redeemEventCode() {
            const input = document.getElementById('eventCodeInput');
            const code = input.value.trim();
            
            if (!code) {
                showNotification('❌ 이벤트 코드를 입력해주세요');
                return;
            }
            
            // 정령 슬롯 체크
            if (spirits.length >= 6) {
                showNotification('❌ 정원이 가득 찼습니다! (최대 6마리)');
                return;
            }
            
            const decoded = decodeEventCode(code);
            
            if (!decoded) {
                showNotification('❌ 유효하지 않은 이벤트 코드입니다');
                return;
            }
            
            if (decoded.expired) {
                showNotification('❌ 이벤트 기간이 종료되었습니다');
                return;
            }
            
            const event = decoded.event;
            
            const confirmed = await showConfirm('이벤트 코드 사용',
                `${event.icon} ${event.name} 알을 받으시겠습니까?\n\n${event.desc}\n\n🎁 이벤트 기간 동안 상점에서 특별 아이템을 구매할 수 있습니다!`);
            
            if (!confirmed) return;
            
            // 이벤트 정령 생성
            const newSpirit = createEventSpirit(decoded.eventType);
            if (!newSpirit) {
                showNotification('❌ 이벤트 정령 생성 실패');
                return;
            }
            
            spirits.push(newSpirit);
            
            // 이벤트 활성화 (상점에 아이템 추가)
            if (!activatedEvents) activatedEvents = [];
            if (!activatedEvents.includes(decoded.eventType)) {
                activatedEvents.push(decoded.eventType);
            }
            
            saveGame();
            renderSpirits();
            renderShop();
            
            input.value = '';
            showNotification(`🎄 ${event.name} 알이 태어났습니다! 상점에서 이벤트 아이템을 확인하세요!`);
            switchTab('garden');
        }
        
        // 다크 모드 고정 토글
        function toggleDarkModeLock() {
            darkModeLocked = !darkModeLocked;
            
            const slider = document.getElementById('darkModeSlider');
            if (darkModeLocked) {
                slider.style.transform = 'translateX(28px)';
                slider.parentElement.style.backgroundColor = '#4CAF50';
                showNotification('🌙 다크 모드가 고정되었습니다');
            } else {
                slider.style.transform = 'translateX(0)';
                slider.parentElement.style.backgroundColor = '#ccc';
                showNotification('🌓 조명에 따라 테마가 변경됩니다');
            }
            
            applyLightMode();
            saveGame();
        }
        
        // ===== 연구실 합성 시스템 함수 =====
        
        // 아이템 아이콘 가져오기
        function getItemIcon(type, category) {
            if (category === 'food') {
                // 합성 아이템인지 확인
                if (SYNTH_ITEMS[type]) {
                    return SYNTH_ITEMS[type].icon;
                }
                // 기본 먹이
                const icons = { fire: '🔥', water: '💧', wind: '🌬️', earth: '🌱', light: '✨', dark: '🌙' };
                return icons[type] || '❓';
            } else if (category === 'decoration') {
                // 합성 미니어처인지 확인
                if (SYNTH_ITEMS[type]) {
                    return SYNTH_ITEMS[type].icon;
                }
                // 기본 미니어처
                return DECORATION_TYPES[type]?.icon || '❓';
            }
            return '❓';
        }
        
        // 아이템 이름 가져오기
        function getItemName(type, category) {
            if (category === 'food') {
                if (SYNTH_ITEMS[type]) {
                    return SYNTH_ITEMS[type].name;
                }
                return FOOD_NAMES[type] || type;
            } else if (category === 'decoration') {
                if (SYNTH_ITEMS[type]) {
                    return SYNTH_ITEMS[type].name;
                }
                return DECORATION_TYPES[type]?.name || type;
            }
            return type;
        }
        
        // 인벤토리에서 아이템 개수 세기
        function countInventoryItem(type, category) {
            let count = 0;
            if (category === 'food') {
                count = inventory.food.filter(f => f === type).length;
            } else if (category === 'decoration') {
                count = inventory.decorations.filter(d => d === type).length;
            }
            return count;
        }
        
        // 가용량 체크 (슬롯에 올린 것 제외)
        function getAvailableCount(type, category) {
            let count = countInventoryItem(type, category);
            
            // 슬롯에 같은 재료가 올라가 있으면 빼기
            if (labSlot1 && labSlot1.type === type && labSlot1.category === category) {
                count -= labSlot1.count;
            }
            if (labSlot2 && labSlot2.type === type && labSlot2.category === category) {
                count -= labSlot2.count;
            }
            
            return Math.max(0, count);
        }
        
        // 연구실 슬롯 모달 열기
        function openLabSlotModal(slotNum) {
            currentLabSlot = slotNum;
            
            // 연구실 튜토리얼: 슬롯 클릭 액션 체크
            if (slotNum === 1) {
                checkLabTutorialAction('clickSlot1');
            }
            
            // 먹이와 미니어처 목록 생성 (현재 인벤토리 기준)
            const foodCounts = {};
            inventory.food.forEach(f => {
                foodCounts[f] = (foodCounts[f] || 0) + 1;
            });
            
            const decoCounts = {};
            inventory.decorations.forEach(d => {
                decoCounts[d] = (decoCounts[d] || 0) + 1;
            });
            
            // 다른 슬롯에 올린 재료는 가용량에서 제외 (현재 슬롯은 덮어쓰기 될 것이므로 포함)
            const otherSlot = currentLabSlot === 1 ? labSlot2 : labSlot1;
            if (otherSlot) {
                if (otherSlot.category === 'food') {
                    foodCounts[otherSlot.type] = (foodCounts[otherSlot.type] || 0) - otherSlot.count;
                    if (foodCounts[otherSlot.type] < 0) foodCounts[otherSlot.type] = 0;
                } else if (otherSlot.category === 'decoration') {
                    decoCounts[otherSlot.type] = (decoCounts[otherSlot.type] || 0) - otherSlot.count;
                    if (decoCounts[otherSlot.type] < 0) decoCounts[otherSlot.type] = 0;
                }
            }
            
            // 레시피에서 필요한 개수 가져오기 (한 슬롯당)
            // 같은 재료끼리 합성하는 레시피가 있으면 그 개수 우선
            function getNeededCount(type, category) {
                const otherSlot = currentLabSlot === 1 ? labSlot2 : labSlot1;
                const isSameMaterial = otherSlot && otherSlot.type === type && otherSlot.category === category;
                
                let needed = 999;
                let sameMatRecipeCount = null;
                
                // 같은 재료끼리 합성하는 레시피 확인
                Object.values(RECIPES).forEach(recipe => {
                    if (recipe.ingredients.length === 2 &&
                        recipe.ingredients[0].type === type &&
                        recipe.ingredients[0].category === category &&
                        recipe.ingredients[1].type === type &&
                        recipe.ingredients[1].category === category) {
                        sameMatRecipeCount = recipe.ingredients[0].count;
                    }
                });
                
                // 같은 재료 조합이거나, 슬롯1에 넣을 때 같은재료 레시피가 있으면 그 개수
                if (isSameMaterial && sameMatRecipeCount) {
                    needed = sameMatRecipeCount;
                } else if (!isSameMaterial && sameMatRecipeCount && currentLabSlot === 1) {
                    needed = sameMatRecipeCount;
                } else {
                    // 다른 재료 조합 - 최소 필요 개수
                    Object.values(RECIPES).forEach(recipe => {
                        recipe.ingredients.forEach(ing => {
                            if (ing.type === type && ing.category === category) {
                                needed = Math.min(needed, ing.count);
                            }
                        });
                    });
                }
                
                return needed === 999 ? 1 : needed;
            }
            
            let html = `
                <div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 10000; display: flex; justify-content: center; align-items: center;" onclick="if(event.target === this) closeLabModal()">
                    <div style="background: var(--card); padding: 20px; max-width: 500px; width: 90%; max-height: 80vh; overflow-y: auto;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                            <h3 style="font-family: 'Nanum Myeongjo', serif; margin: 0; font-size: 1.1rem;">재료 선택 (슬롯 ${slotNum})</h3>
                            <button onclick="closeLabModal()" style="background: none; border: none; font-size: 1.3rem; cursor: pointer;">✕</button>
                        </div>
                        
                        <div style="margin-bottom: 15px;">
                            <div style="font-weight: 600; margin-bottom: 8px; font-size: 0.95rem;">🍎 먹이</div>
                            <div style="display: flex; flex-wrap: wrap; gap: 6px;">
            `;
            
            // 먹이 버튼들
            const foodOrder = ['fire', 'water', 'wind', 'earth', 'light', 'dark'];
            let hasFood = false;
            foodOrder.forEach(type => {
                const count = foodCounts[type] || 0;
                if (count > 0) {
                    hasFood = true;
                    const needed = getNeededCount(type, 'food');
                    const isInsufficient = count < needed;
                    if (isInsufficient) {
                        html += `
                            <button onclick="showNotification('⚠️ ${FOOD_NAMES[type]} 부족! (보유: ${count}개, 필요: ${needed}개)')" style="padding: 8px 12px; border: 1px solid #e74c3c; background: var(--bg); cursor: pointer; display: flex; align-items: center; gap: 4px; opacity: 0.5; font-size: 0.85rem;">
                                ${getItemIcon(type, 'food')} ${FOOD_NAMES[type]} ×${count} <span style="color: #e74c3c; font-size: 0.7rem;">(${needed}개 필요)</span>
                            </button>
                        `;
                    } else {
                        html += `
                            <button onclick="selectLabItem('${type}', 'food')" style="padding: 8px 12px; border: 1px solid var(--border); background: var(--bg); cursor: pointer; display: flex; align-items: center; gap: 4px; font-size: 0.85rem;">
                                ${getItemIcon(type, 'food')} ${FOOD_NAMES[type]} ×${count}
                            </button>
                        `;
                    }
                }
            });
            
            // 합성 먹이도 표시
            Object.keys(SYNTH_ITEMS).forEach(type => {
                if (SYNTH_ITEMS[type].type === 'food') {
                    const count = foodCounts[type] || 0;
                    if (count > 0) {
                        hasFood = true;
                        html += `
                            <button onclick="selectLabItem('${type}', 'food')" style="padding: 8px 12px; border: 1px solid var(--border); background: var(--bg); cursor: pointer; display: flex; align-items: center; gap: 4px; font-size: 0.85rem;">
                                ${SYNTH_ITEMS[type].icon} ${SYNTH_ITEMS[type].name} ×${count}
                            </button>
                        `;
                    }
                }
            });
            
            if (!hasFood) {
                html += `<div style="color: #888; font-size: 0.85rem;">먹이가 없습니다</div>`;
            }
            
            html += `
                            </div>
                        </div>
                        
                        <div>
                            <div style="font-weight: 600; margin-bottom: 8px; font-size: 0.95rem;">🌳 미니어처</div>
                            <div style="display: flex; flex-wrap: wrap; gap: 6px;">
            `;
            
            // 미니어처 버튼들
            let hasDeco = false;
            Object.keys(decoCounts).forEach(type => {
                const count = decoCounts[type];
                const deco = DECORATION_TYPES[type] || SYNTH_ITEMS[type];
                if (deco && count > 0) {
                    hasDeco = true;
                    const needed = getNeededCount(type, 'decoration');
                    const isInsufficient = count < needed;
                    if (isInsufficient) {
                        html += `
                            <button onclick="showNotification('⚠️ ${deco.name} 부족! (보유: ${count}개, 필요: ${needed}개)')" style="padding: 8px 12px; border: 1px solid #e74c3c; background: var(--bg); cursor: pointer; display: flex; align-items: center; gap: 4px; opacity: 0.5; font-size: 0.85rem;">
                                ${deco.icon} ${deco.name} ×${count} <span style="color: #e74c3c; font-size: 0.7rem;">(${needed}개 필요)</span>
                            </button>
                        `;
                    } else {
                        html += `
                            <button onclick="selectLabItem('${type}', 'decoration')" style="padding: 8px 12px; border: 1px solid var(--border); background: var(--bg); cursor: pointer; display: flex; align-items: center; gap: 4px; font-size: 0.85rem;">
                                ${deco.icon} ${deco.name} ×${count}
                            </button>
                        `;
                    }
                }
            });
            
            if (!hasDeco) {
                html += `<div style="color: #888; font-size: 0.85rem;">미니어처가 없습니다</div>`;
            }
            
            html += `
                            </div>
                        </div>
                        
                        <div style="margin-top: 15px; text-align: center;">
                            <button onclick="clearLabSlot(${slotNum})" style="padding: 8px 16px; background: #e74c3c; color: white; border: none; cursor: pointer; font-size: 0.9rem;">슬롯 비우기</button>
                        </div>
                    </div>
                </div>
            `;
            
            // 모달 추가
            const modal = document.createElement('div');
            modal.id = 'labModal';
            modal.innerHTML = html;
            document.body.appendChild(modal);
        }
        
        // 연구실 모달 닫기
        function closeLabModal() {
            const modal = document.getElementById('labModal');
            if (modal) modal.remove();
        }
        
        // 연구실 슬롯에 아이템 선택
        function selectLabItem(type, category) {
            const totalCount = countInventoryItem(type, category);
            if (totalCount <= 0) {
                showNotification('해당 아이템이 없습니다');
                closeLabModal();
                return;
            }
            
            // 다른 슬롯에 이미 같은 재료가 있는지 확인
            const otherSlot = currentLabSlot === 1 ? labSlot2 : labSlot1;
            const isSameMaterial = otherSlot && otherSlot.type === type && otherSlot.category === category;
            
            // 가용량 계산 (다른 슬롯에 올린 것 제외)
            let availableCount = totalCount;
            if (otherSlot && otherSlot.type === type && otherSlot.category === category) {
                availableCount -= otherSlot.count;
            }
            
            // 레시피에서 필요한 개수 찾기
            let neededCount = 999;
            let sameMatRecipeCount = null; // 같은 재료끼리 합성하는 레시피의 개수
            
            // 먼저 같은 재료끼리 합성하는 레시피가 있는지 확인
            Object.values(RECIPES).forEach(recipe => {
                if (recipe.ingredients.length === 2 &&
                    recipe.ingredients[0].type === type &&
                    recipe.ingredients[0].category === category &&
                    recipe.ingredients[1].type === type &&
                    recipe.ingredients[1].category === category) {
                    sameMatRecipeCount = recipe.ingredients[0].count;
                }
            });
            
            // 같은 재료를 슬롯2에 넣거나, 슬롯1에 넣는데 같은재료 레시피가 있으면 그 개수 사용
            if (isSameMaterial && sameMatRecipeCount) {
                neededCount = sameMatRecipeCount;
            } else if (!isSameMaterial && sameMatRecipeCount && currentLabSlot === 1) {
                // 슬롯1에 넣을 때, 같은 재료 레시피가 있으면 그 개수 사용 (나중에 같은 재료 넣을 수 있으므로)
                neededCount = sameMatRecipeCount;
            } else {
                // 다른 재료 조합 - 최소 필요 개수 사용
                Object.values(RECIPES).forEach(recipe => {
                    recipe.ingredients.forEach(ing => {
                        if (ing.type === type && ing.category === category) {
                            neededCount = Math.min(neededCount, ing.count);
                        }
                    });
                });
            }
            
            if (neededCount === 999) neededCount = 1;
            
            // 재료 부족 체크 (가용량 기준)
            if (availableCount < neededCount) {
                const itemName = getItemName(type, category);
                showNotification(`⚠️ ${itemName} 부족! (사용 가능: ${availableCount}개, 필요: ${neededCount}개)`);
                closeLabModal();
                return;
            }
            
            // 필요 개수만큼 선택
            let selectedCount = neededCount;
            
            // 같은 재료를 슬롯2에 넣을 때, 슬롯1의 개수가 다르면 조정
            if (isSameMaterial && currentLabSlot === 2 && otherSlot.count !== neededCount) {
                // 총 재료가 충분한지 체크 (양쪽 슬롯 합계)
                if (totalCount < neededCount * 2) {
                    const itemName = getItemName(type, category);
                    showNotification(`⚠️ ${itemName} 부족! (보유: ${totalCount}개, 필요: ${neededCount * 2}개)`);
                    closeLabModal();
                    return;
                }
                
                // 슬롯1 개수만 조정 (인벤토리 조작 없음)
                labSlot1 = { type, category, count: neededCount };
            }
            
            // 슬롯에 정보만 기록 (인벤토리 차감은 합성 시점에)
            if (currentLabSlot === 1) {
                labSlot1 = { type, category, count: selectedCount };
                // 연구실 튜토리얼: 재료1 선택 액션 체크
                checkLabTutorialAction('selectIngredient1');
                // 슬롯2 자동 강조 (튜토리얼 진행 중이면)
                if (labTutorialActive && window.tutorialWaitingFor === null) {
                    setTimeout(() => {
                        window.tutorialWaitingFor = 'selectIngredient2';
                        highlightLabTutorialTarget('selectIngredient2');
                    }, 100);
                }
            } else {
                labSlot2 = { type, category, count: selectedCount };
                // 연구실 튜토리얼: 재료2 선택 액션 체크
                checkLabTutorialAction('selectIngredient2');
                
                // 슬롯2에 다른 재료를 넣었을 때, 슬롯1 개수가 레시피와 맞지 않으면 조정
                if (labSlot1 && !isSameMaterial) {
                    // 현재 조합에 맞는 레시피 찾기
                    let correctSlot1Count = null;
                    Object.values(RECIPES).forEach(recipe => {
                        const ing1 = recipe.ingredients[0];
                        const ing2 = recipe.ingredients[1];
                        
                        // 슬롯1-재료1, 슬롯2-재료2 매칭
                        if (labSlot1.type === ing1.type && labSlot1.category === ing1.category &&
                            type === ing2.type && category === ing2.category) {
                            correctSlot1Count = ing1.count;
                        }
                        // 슬롯1-재료2, 슬롯2-재료1 매칭
                        if (labSlot1.type === ing2.type && labSlot1.category === ing2.category &&
                            type === ing1.type && category === ing1.category) {
                            correctSlot1Count = ing2.count;
                        }
                    });
                    
                    // 슬롯1 개수가 레시피와 다르면 조정 (인벤토리 조작 없이)
                    if (correctSlot1Count !== null && labSlot1.count !== correctSlot1Count) {
                        labSlot1.count = correctSlot1Count;
                    }
                }
            }
            
            closeLabModal();
            updateLabUI();
            checkRecipe();
            renderInventory();
            saveGame();
        }
        
        // 슬롯 비우기 (인벤토리 변경 없음 - 합성 전까지 차감 안 함)
        function clearLabSlot(slotNum) {
            if (slotNum === 1) {
                labSlot1 = null;
            } else {
                labSlot2 = null;
            }
            closeLabModal();
            updateLabUI();
            checkRecipe();
            renderInventory();
            saveGame();
        }
        
        // 연구실 UI 업데이트
        function updateLabUI() {
            const slot1El = document.getElementById('labSlot1');
            const slot2El = document.getElementById('labSlot2');
            
            if (slot1El) {
                if (labSlot1) {
                    slot1El.innerHTML = `
                        <div style="font-size: 1.3rem; margin-bottom: 1px;">${getItemIcon(labSlot1.type, labSlot1.category)}</div>
                        <div style="font-size: 0.6rem; color: var(--text); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 60px;">${getItemName(labSlot1.type, labSlot1.category)}</div>
                        <div style="font-size: 0.65rem; color: #888;">×${labSlot1.count}</div>
                        <button onclick="event.stopPropagation(); clearLabSlotDirect(1)" style="position: absolute; top: 2px; right: 2px; width: 16px; height: 16px; border-radius: 50%; border: none; background: #e74c3c; color: white; font-size: 0.6rem; cursor: pointer; display: flex; align-items: center; justify-content: center; padding: 0;">✕</button>
                    `;
                    slot1El.style.borderStyle = 'solid';
                    slot1El.style.borderColor = '#9b59b6';
                    slot1El.style.position = 'relative';
                } else {
                    slot1El.innerHTML = `
                        <div style="font-size: 1.3rem; margin-bottom: 2px;">➕</div>
                        <div style="font-size: 0.65rem; color: #888;">재료1</div>
                    `;
                    slot1El.style.borderStyle = 'dashed';
                    slot1El.style.borderColor = 'var(--border)';
                }
            }
            
            if (slot2El) {
                if (labSlot2) {
                    slot2El.innerHTML = `
                        <div style="font-size: 1.3rem; margin-bottom: 1px;">${getItemIcon(labSlot2.type, labSlot2.category)}</div>
                        <div style="font-size: 0.6rem; color: var(--text); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 60px;">${getItemName(labSlot2.type, labSlot2.category)}</div>
                        <div style="font-size: 0.65rem; color: #888;">×${labSlot2.count}</div>
                        <button onclick="event.stopPropagation(); clearLabSlotDirect(2)" style="position: absolute; top: 2px; right: 2px; width: 16px; height: 16px; border-radius: 50%; border: none; background: #e74c3c; color: white; font-size: 0.6rem; cursor: pointer; display: flex; align-items: center; justify-content: center; padding: 0;">✕</button>
                    `;
                    slot2El.style.borderStyle = 'solid';
                    slot2El.style.borderColor = '#9b59b6';
                    slot2El.style.position = 'relative';
                } else {
                    slot2El.innerHTML = `
                        <div style="font-size: 1.3rem; margin-bottom: 2px;">➕</div>
                        <div style="font-size: 0.65rem; color: #888;">재료2</div>
                    `;
                    slot2El.style.borderStyle = 'dashed';
                    slot2El.style.borderColor = 'var(--border)';
                }
            }
        }
        
        // 슬롯 직접 비우기 (모달 없이)
        function clearLabSlotDirect(slotNum) {
            // 슬롯만 비우기 (현재 시스템은 슬롯에 올려도 인벤토리에서 차감 안 함)
            if (slotNum === 1) {
                labSlot1 = null;
            } else {
                labSlot2 = null;
            }
            
            updateLabUI();
            checkRecipe();
            renderInventory();
            saveGame();
        }
        
        // 레시피 체크
        function checkRecipe() {
            const resultSlot = document.getElementById('labResultSlot');
            const synthesizeBtn = document.getElementById('synthesizeBtn');
            const labMessage = document.getElementById('labMessage');
            
            if (!labSlot1 || !labSlot2) {
                if (resultSlot) {
                    resultSlot.innerHTML = `
                        <div style="font-size: 1.3rem; margin-bottom: 2px;">❓</div>
                        <div style="font-size: 0.65rem; color: #888;">결과</div>
                    `;
                }
                if (synthesizeBtn) {
                    synthesizeBtn.disabled = true;
                    synthesizeBtn.style.opacity = '0.5';
                }
                if (labMessage) labMessage.textContent = '재료를 선택해주세요';
                return null;
            }
            
            // 레시피 매칭
            for (const [recipeId, recipe] of Object.entries(RECIPES)) {
                const ing1 = recipe.ingredients[0];
                const ing2 = recipe.ingredients[1];
                
                // 슬롯1-재료1, 슬롯2-재료2 매칭 확인
                const match1 = (labSlot1.type === ing1.type && labSlot1.category === ing1.category && labSlot1.count >= ing1.count) &&
                              (labSlot2.type === ing2.type && labSlot2.category === ing2.category && labSlot2.count >= ing2.count);
                
                // 슬롯1-재료2, 슬롯2-재료1 매칭 확인 (순서 바꿔서)
                const match2 = (labSlot1.type === ing2.type && labSlot1.category === ing2.category && labSlot1.count >= ing2.count) &&
                              (labSlot2.type === ing1.type && labSlot2.category === ing1.category && labSlot2.count >= ing1.count);
                
                if (match1 || match2) {
                    // 레시피 발견!
                    const resultItem = SYNTH_ITEMS[recipe.result.type];
                    const isDiscovered = discoveredRecipes.includes(recipeId);
                    
                    if (resultSlot) {
                        if (isDiscovered) {
                            // 발견한 레시피 - 결과물 표시
                            resultSlot.innerHTML = `
                                <div style="font-size: 1.3rem; margin-bottom: 1px;">${resultItem.icon}</div>
                                <div style="font-size: 0.6rem; color: var(--text); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 60px;">${resultItem.name}</div>
                                <div style="font-size: 0.65rem; color: #9b59b6;">×${recipe.result.count}</div>
                            `;
                        } else {
                            // 미발견 레시피 - '?' 표시
                            resultSlot.innerHTML = `
                                <div style="font-size: 1.3rem; margin-bottom: 1px;">❓</div>
                                <div style="font-size: 0.6rem; color: #9b59b6;">새 레시피!</div>
                                <div style="font-size: 0.65rem; color: #888;">×?</div>
                            `;
                        }
                        resultSlot.style.borderColor = '#9b59b6';
                    }
                    if (synthesizeBtn) {
                        synthesizeBtn.disabled = false;
                        synthesizeBtn.style.opacity = '1';
                    }
                    if (labMessage) {
                        if (isDiscovered) {
                            labMessage.innerHTML = `<span style="color: #9b59b6;">✨ 합성 가능!</span>`;
                        } else {
                            labMessage.innerHTML = `<span style="color: #9b59b6;">✨ 새로운 레시피 발견?!</span>`;
                        }
                    }
                    return recipeId;
                }
            }
            
            // 매칭되는 레시피 없음
            if (resultSlot) {
                resultSlot.innerHTML = `
                    <div style="font-size: 1.3rem; margin-bottom: 2px;">💨</div>
                    <div style="font-size: 0.65rem; color: #888;">실패</div>
                `;
                resultSlot.style.borderColor = 'var(--border)';
            }
            if (synthesizeBtn) {
                synthesizeBtn.disabled = true;
                synthesizeBtn.style.opacity = '0.5';
            }
            if (labMessage) {
                labMessage.textContent = '이 조합으로는 만들 수 없습니다';
            }
            return null;
        }
        
        // 합성 실행
        function synthesize() {
            const recipeId = checkRecipe();
            if (!recipeId) {
                showNotification('합성할 수 없는 조합입니다');
                return;
            }
            
            const recipe = RECIPES[recipeId];
            
            // 재료 차감 (합성 시점에 인벤토리에서 제거)
            if (labSlot1) {
                if (labSlot1.category === 'food') {
                    for (let i = 0; i < labSlot1.count; i++) {
                        const idx = inventory.food.indexOf(labSlot1.type);
                        if (idx !== -1) inventory.food.splice(idx, 1);
                    }
                } else if (labSlot1.category === 'decoration') {
                    for (let i = 0; i < labSlot1.count; i++) {
                        const idx = inventory.decorations.indexOf(labSlot1.type);
                        if (idx !== -1) inventory.decorations.splice(idx, 1);
                    }
                }
            }
            
            if (labSlot2) {
                if (labSlot2.category === 'food') {
                    for (let i = 0; i < labSlot2.count; i++) {
                        const idx = inventory.food.indexOf(labSlot2.type);
                        if (idx !== -1) inventory.food.splice(idx, 1);
                    }
                } else if (labSlot2.category === 'decoration') {
                    for (let i = 0; i < labSlot2.count; i++) {
                        const idx = inventory.decorations.indexOf(labSlot2.type);
                        if (idx !== -1) inventory.decorations.splice(idx, 1);
                    }
                }
            }
            
            // 결과물 추가
            const resultItem = SYNTH_ITEMS[recipe.result.type];
            for (let i = 0; i < recipe.result.count; i++) {
                if (resultItem.type === 'food') {
                    inventory.food.push(recipe.result.type);
                } else if (resultItem.type === 'decoration') {
                    inventory.decorations.push(recipe.result.type);
                }
            }
            
            // 레시피 발견 기록
            if (!discoveredRecipes.includes(recipeId)) {
                discoveredRecipes.push(recipeId);
                // 직접 발견한 레시피로도 기록 (레시피북으로 해금되지 않은 경우)
                if (!selfDiscoveredRecipes.includes(recipeId)) {
                    selfDiscoveredRecipes.push(recipeId);
                }
                checkAchievements(); // 레시피 업적 체크
            }
            
            // 슬롯 초기화
            labSlot1 = null;
            labSlot2 = null;
            
            // UI 업데이트
            updateLabUI();
            checkRecipe();
            renderInventory();
            applyRecipeFilters(); // 현재 필터 유지하면서 레시피 목록 갱신
            saveGame();
            
            showNotification(`✨ ${resultItem.icon} ${resultItem.name} ×${recipe.result.count} 합성 성공!`);
            
            // 연구실 튜토리얼: 합성 액션 체크
            checkLabTutorialAction('synthesize');
        }
        
        // 합성 수량 선택 모달 열기
        let currentSynthRecipeId = null;
        let currentSynthMaxCount = 1;
        
        function openSynthesizeModal(recipeId, maxCount) {
            currentSynthRecipeId = recipeId;
            currentSynthMaxCount = maxCount;
            
            const recipe = RECIPES[recipeId];
            const resultItem = SYNTH_ITEMS[recipe.result.type];
            
            const modal = document.createElement('div');
            modal.id = 'synthesizeModal';
            const zIndex = getNextZIndex();
            modal.style.cssText = `position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: ${zIndex}; display: flex; justify-content: center; align-items: center;`;
            modal.onclick = (e) => { if (e.target === modal) closeSynthesizeModal(); };
            
            modal.innerHTML = `
                <div style="background: var(--card); padding: 24px; border-radius: 12px; max-width: 350px; width: 90%; border: 2px solid var(--border);">
                    <div style="text-align: center; margin-bottom: 20px;">
                        <span style="font-size: 2.5rem;">${resultItem.icon}</span>
                        <h3 style="font-family: 'Nanum Myeongjo', serif; margin-top: 8px; font-size: 1.2rem;">${resultItem.name} 제작</h3>
                        <div style="font-size: 0.85rem; color: #888; margin-top: 4px;">1회 제작 시 ${recipe.result.count}개 획득</div>
                    </div>
                    
                    <div style="display: flex; align-items: center; justify-content: center; gap: 8px; margin-bottom: 20px;">
                        <button onclick="setSynthCount(1)" style="padding: 8px 12px; background: var(--bg); border: 1px solid var(--border); font-size: 0.85rem; cursor: pointer; border-radius: 4px;">최소</button>
                        <button onclick="adjustSynthCount(-1)" style="width: 40px; height: 40px; background: var(--bg); border: 1px solid var(--border); font-size: 1.4rem; cursor: pointer; border-radius: 4px; display: flex; align-items: center; justify-content: center;">−</button>
                        <input type="number" id="synthCountInput" value="1" min="1" max="${maxCount}" 
                               style="width: 70px; height: 40px; text-align: center; font-size: 1.2rem; font-weight: 700; border: 2px solid #9b59b6; border-radius: 6px; background: var(--bg); color: var(--text);"
                               onchange="validateSynthCount()">
                        <button onclick="adjustSynthCount(1)" style="width: 40px; height: 40px; background: var(--bg); border: 1px solid var(--border); font-size: 1.4rem; cursor: pointer; border-radius: 4px; display: flex; align-items: center; justify-content: center;">+</button>
                        <button onclick="setSynthCount(${maxCount})" style="padding: 8px 12px; background: #27ae60; color: white; border: none; font-size: 0.85rem; cursor: pointer; border-radius: 4px; font-weight: 600;">최대</button>
                    </div>
                    
                    <div id="synthPreview" style="background: var(--bg); padding: 12px; border-radius: 8px; margin-bottom: 16px; font-size: 0.9rem;">
                        <!-- 미리보기 내용 -->
                    </div>
                    
                    <div style="display: flex; gap: 8px;">
                        <button onclick="closeSynthesizeModal()" style="flex: 1; padding: 12px; background: var(--bg); border: 1px solid var(--border); cursor: pointer; border-radius: 6px;">취소</button>
                        <button onclick="executeSynthesize()" style="flex: 1; padding: 12px; background: #9b59b6; color: white; border: none; cursor: pointer; border-radius: 6px; font-weight: 600;">🔮 제작</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            updateSynthPreview();
        }
        
        function closeSynthesizeModal() {
            const modal = document.getElementById('synthesizeModal');
            if (modal) modal.remove();
            currentSynthRecipeId = null;
        }
        
        function adjustSynthCount(delta) {
            const input = document.getElementById('synthCountInput');
            let value = parseInt(input.value) || 1;
            value = Math.max(1, Math.min(currentSynthMaxCount, value + delta));
            input.value = value;
            updateSynthPreview();
        }
        
        function setSynthCount(value) {
            const input = document.getElementById('synthCountInput');
            input.value = Math.max(1, Math.min(currentSynthMaxCount, value));
            updateSynthPreview();
        }
        
        function validateSynthCount() {
            const input = document.getElementById('synthCountInput');
            let value = parseInt(input.value) || 1;
            value = Math.max(1, Math.min(currentSynthMaxCount, value));
            input.value = value;
            updateSynthPreview();
        }
        
        function updateSynthPreview() {
            const preview = document.getElementById('synthPreview');
            if (!preview || !currentSynthRecipeId) return;
            
            const recipe = RECIPES[currentSynthRecipeId];
            const resultItem = SYNTH_ITEMS[recipe.result.type];
            const count = parseInt(document.getElementById('synthCountInput').value) || 1;
            
            const ing1 = recipe.ingredients[0];
            const ing2 = recipe.ingredients[1];
            const ing1Name = getItemName(ing1.type, ing1.category);
            const ing2Name = getItemName(ing2.type, ing2.category);
            
            const totalResult = recipe.result.count * count;
            const totalIng1 = ing1.count * count;
            const totalIng2 = ing2.count * count;
            
            // 같은 재료인 경우 합쳐서 표시
            let ingredientsHtml = '';
            if (ing1.type === ing2.type && ing1.category === ing2.category) {
                // 같은 재료면 합산
                ingredientsHtml = `<div>${ing1Name} ×${totalIng1 + totalIng2}</div>`;
            } else {
                // 다른 재료면 따로 표시
                ingredientsHtml = `
                    <div>${ing1Name} ×${totalIng1}</div>
                    <div>${ing2Name} ×${totalIng2}</div>
                `;
            }
            
            preview.innerHTML = `
                <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                    <span style="color: #888;">소모 재료:</span>
                </div>
                <div style="margin-left: 10px; margin-bottom: 8px;">
                    ${ingredientsHtml}
                </div>
                <div style="border-top: 1px solid var(--border); padding-top: 8px; display: flex; justify-content: space-between; align-items: center;">
                    <span style="color: #888;">획득:</span>
                    <span style="font-weight: 700; color: #9b59b6; font-size: 1.1rem;">${resultItem.icon} ${resultItem.name} ×${totalResult}</span>
                </div>
            `;
        }
        
        function executeSynthesize() {
            if (!currentSynthRecipeId) return;
            
            const count = parseInt(document.getElementById('synthCountInput').value) || 1;
            quickSynthesize(currentSynthRecipeId, count);
            closeSynthesizeModal();
        }
        
        // n회 즉시 합성 (내부 함수)
        function quickSynthesize(recipeId, times) {
            const recipe = RECIPES[recipeId];
            if (!recipe) {
                showNotification('레시피를 찾을 수 없습니다');
                return;
            }
            
            const ing1 = recipe.ingredients[0];
            const ing2 = recipe.ingredients[1];
            
            // 재료 보유량 체크
            const ing1Count = countInventoryItem(ing1.type, ing1.category);
            const ing2Count = countInventoryItem(ing2.type, ing2.category);
            
            // 최대 합성 가능 횟수 계산 (같은 재료인 경우 합산해서 계산)
            let maxCraftCount;
            if (ing1.type === ing2.type && ing1.category === ing2.category) {
                // 같은 재료: 총 필요량으로 계산
                const totalNeeded = ing1.count + ing2.count;
                maxCraftCount = Math.floor(ing1Count / totalNeeded);
            } else {
                // 다른 재료: 각각 계산
                const maxCraft1 = Math.floor(ing1Count / ing1.count);
                const maxCraft2 = Math.floor(ing2Count / ing2.count);
                maxCraftCount = Math.min(maxCraft1, maxCraft2);
            }
            
            // 실제 합성 횟수
            const actualTimes = Math.min(times, maxCraftCount);
            
            if (actualTimes <= 0) {
                showNotification('⚠️ 재료가 부족합니다');
                return;
            }
            
            // 재료 차감 (같은 재료인 경우 합산해서 차감)
            if (ing1.type === ing2.type && ing1.category === ing2.category) {
                // 같은 재료: 합산해서 한 번에 차감
                const totalToRemove = (ing1.count + ing2.count) * actualTimes;
                if (ing1.category === 'food') {
                    for (let i = 0; i < totalToRemove; i++) {
                        const idx = inventory.food.indexOf(ing1.type);
                        if (idx !== -1) inventory.food.splice(idx, 1);
                    }
                } else if (ing1.category === 'decoration') {
                    for (let i = 0; i < totalToRemove; i++) {
                        const idx = inventory.decorations.indexOf(ing1.type);
                        if (idx !== -1) inventory.decorations.splice(idx, 1);
                    }
                }
            } else {
                // 다른 재료: 각각 차감
                const ing1Total = ing1.count * actualTimes;
                const ing2Total = ing2.count * actualTimes;
                
                if (ing1.category === 'food') {
                    for (let i = 0; i < ing1Total; i++) {
                        const idx = inventory.food.indexOf(ing1.type);
                        if (idx !== -1) inventory.food.splice(idx, 1);
                    }
                } else if (ing1.category === 'decoration') {
                    for (let i = 0; i < ing1Total; i++) {
                        const idx = inventory.decorations.indexOf(ing1.type);
                        if (idx !== -1) inventory.decorations.splice(idx, 1);
                    }
                }
                
                if (ing2.category === 'food') {
                    for (let i = 0; i < ing2Total; i++) {
                        const idx = inventory.food.indexOf(ing2.type);
                        if (idx !== -1) inventory.food.splice(idx, 1);
                    }
                } else if (ing2.category === 'decoration') {
                    for (let i = 0; i < ing2Total; i++) {
                        const idx = inventory.decorations.indexOf(ing2.type);
                        if (idx !== -1) inventory.decorations.splice(idx, 1);
                    }
                }
            }
            
            // 결과물 추가
            const resultItem = SYNTH_ITEMS[recipe.result.type];
            const totalResult = recipe.result.count * actualTimes;
            
            for (let i = 0; i < totalResult; i++) {
                if (resultItem.type === 'food') {
                    inventory.food.push(recipe.result.type);
                } else if (resultItem.type === 'decoration') {
                    inventory.decorations.push(recipe.result.type);
                }
            }
            
            // 레시피 발견 기록
            if (!discoveredRecipes.includes(recipeId)) {
                discoveredRecipes.push(recipeId);
                // 직접 발견한 레시피로도 기록 (레시피북으로 해금되지 않은 경우)
                if (!selfDiscoveredRecipes.includes(recipeId)) {
                    selfDiscoveredRecipes.push(recipeId);
                }
                checkAchievements(); // 레시피 업적 체크
            }
            
            // 슬롯 초기화 (혹시 무언가 있을 경우)
            labSlot1 = null;
            labSlot2 = null;
            
            // UI 업데이트
            updateLabUI();
            checkRecipe();
            renderInventory();
            applyRecipeFilters(); // 현재 필터 유지하면서 레시피 목록 갱신
            saveGame();
            
            showNotification(`✨ ${resultItem.icon} ${resultItem.name} ×${totalResult} 합성 성공! (${actualTimes}회)`);
            
            // 연구실 튜토리얼: 합성 액션 체크
            checkLabTutorialAction('synthesize');
        }
        
        // 레시피 목록 렌더링
        function renderRecipeList(categoryFilter = 'all', attrFilter = 'all', qualityFilter = 'all') {
            const container = document.getElementById('recipeList');
            if (!container) return;
            
            let html = '';
            let filteredCount = 0;
            
            Object.entries(RECIPES).forEach(([recipeId, recipe]) => {
                // 발견한 레시피만 표시
                if (!discoveredRecipes.includes(recipeId)) return;
                
                const resultItem = SYNTH_ITEMS[recipe.result.type];
                if (!resultItem) return;
                
                // 카테고리 필터
                if (categoryFilter !== 'all' && recipe.category !== categoryFilter) return;
                
                // 속성 필터
                if (attrFilter !== 'all') {
                    if (attrFilter === 'all_attr') {
                        // 전속성 아이템만
                        if (resultItem.attr !== 'all') return;
                    } else {
                        // 단일 속성 또는 복합 속성에 포함
                        const itemAttr = resultItem.attr;
                        const dualAttrs = resultItem.dualAttr || [];
                        if (itemAttr !== attrFilter && !dualAttrs.includes(attrFilter)) return;
                    }
                }
                
                // 품질 필터 (미니어처만 해당)
                if (qualityFilter !== 'all') {
                    if (resultItem.type === 'decoration') {
                        if (resultItem.quality !== qualityFilter) return;
                    } else {
                        // 먹이는 품질이 없으므로 품질 필터 시 제외
                        return;
                    }
                }
                
                filteredCount++;
                const ing1 = recipe.ingredients[0];
                const ing2 = recipe.ingredients[1];
                
                const ing1Name = getItemName(ing1.type, ing1.category);
                const ing2Name = getItemName(ing2.type, ing2.category);
                const ing1Icon = getItemIcon(ing1.type, ing1.category);
                const ing2Icon = getItemIcon(ing2.type, ing2.category);
                
                // 재료 보유량 체크 (같은 재료인 경우 합산해서 계산)
                const ing1Count = countInventoryItem(ing1.type, ing1.category);
                const ing2Count = countInventoryItem(ing2.type, ing2.category);
                
                let canCraft, maxCraftCount;
                if (ing1.type === ing2.type && ing1.category === ing2.category) {
                    // 같은 재료: 총 필요량으로 계산
                    const totalNeeded = ing1.count + ing2.count;
                    canCraft = ing1Count >= totalNeeded;
                    maxCraftCount = Math.floor(ing1Count / totalNeeded);
                } else {
                    // 다른 재료: 각각 계산
                    canCraft = ing1Count >= ing1.count && ing2Count >= ing2.count;
                    const maxCraft1 = Math.floor(ing1Count / ing1.count);
                    const maxCraft2 = Math.floor(ing2Count / ing2.count);
                    maxCraftCount = Math.min(maxCraft1, maxCraft2);
                }
                
                // 효과 텍스트
                let effectText = '';
                if (resultItem.type === 'food') {
                    const effects = [];
                    if (resultItem.attrGain) {
                        if (resultItem.attr === 'all') {
                            effects.push(`전속성 +${resultItem.attrGain}`);
                        } else if (resultItem.attr === 'dual' && resultItem.dualAttr) {
                            effects.push(`${resultItem.dualAttr.join('+')} 각 +${resultItem.attrGain}`);
                        } else {
                            effects.push(`${resultItem.attr} +${resultItem.attrGain}`);
                        }
                    }
                    if (resultItem.affectionGain) effects.push(`애정도 +${resultItem.affectionGain}`);
                    if (resultItem.growthGain) effects.push(`성장 +${resultItem.growthGain}`);
                    effectText = effects.join(', ');
                } else if (resultItem.type === 'decoration') {
                    effectText = `${resultItem.attr} +${resultItem.power} (${resultItem.quality})`;
                }
                
                // 재료 보유량 표시 (같은 재료인 경우 합쳐서 표시)
                let ingredientDisplay;
                if (ing1.type === ing2.type && ing1.category === ing2.category) {
                    // 같은 재료: 합산해서 표시
                    const totalNeeded = ing1.count + ing2.count;
                    const statusColor = ing1Count >= totalNeeded ? '#27ae60' : '#e74c3c';
                    ingredientDisplay = `${ing1Icon} ${ing1Name} ×${totalNeeded} (<span style="color: ${statusColor};">${ing1Count}</span>)`;
                } else {
                    // 다른 재료: 따로 표시
                    const ing1Status = ing1Count >= ing1.count ? `<span style="color: #27ae60;">${ing1Count}</span>` : `<span style="color: #e74c3c;">${ing1Count}</span>`;
                    const ing2Status = ing2Count >= ing2.count ? `<span style="color: #27ae60;">${ing2Count}</span>` : `<span style="color: #e74c3c;">${ing2Count}</span>`;
                    ingredientDisplay = `${ing1Icon} ${ing1Name} ×${ing1.count} (${ing1Status}) + ${ing2Icon} ${ing2Name} ×${ing2.count} (${ing2Status})`;
                }
                
                // 결과물 보유량
                const resultCategory = resultItem.type === 'decoration' ? 'decoration' : 'food';
                const resultCount = countInventoryItem(recipe.result.type, resultCategory);
                
                // 직접 발견 vs 레시피북 해금 체크
                const isSelfDiscovered = selfDiscoveredRecipes.includes(recipeId);
                const discoveryTag = isSelfDiscovered 
                    ? '<span style="font-size: 0.65rem; background: #27ae60; color: white; padding: 2px 5px; border-radius: 3px; margin-left: 6px;">✨직접발견</span>'
                    : '<span style="font-size: 0.65rem; background: #888; color: white; padding: 2px 5px; border-radius: 3px; margin-left: 6px;">📖레시피북</span>';
                
                // 제작 버튼 (제작 가능할 때만)
                let craftButton = '';
                if (canCraft) {
                    craftButton = `
                        <div style="margin-top: 8px;" onclick="event.stopPropagation();">
                            <button onclick="openSynthesizeModal('${recipeId}', ${maxCraftCount})" style="width: 100%; padding: 8px; background: #9b59b6; color: white; border: none; font-size: 0.9rem; font-weight: 600; cursor: pointer;">
                                🔮 제작하기 (최대 ${maxCraftCount}회)
                            </button>
                        </div>
                    `;
                }
                
                html += `
                    <div onclick="autoFillRecipe('${recipeId}')" style="background: var(--bg); border: 2px solid ${canCraft ? '#27ae60' : 'var(--border)'}; padding: 12px; cursor: pointer; transition: all 0.2s; ${canCraft ? 'box-shadow: 0 0 8px rgba(39, 174, 96, 0.3);' : ''}" 
                         onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.15)';" 
                         onmouseout="this.style.transform=''; this.style.boxShadow='${canCraft ? '0 0 8px rgba(39, 174, 96, 0.3)' : ''}';">
                        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px; flex-wrap: wrap;">
                            <span style="font-size: 1.5rem;">${resultItem.icon}</span>
                            <span style="font-weight: 600;">${resultItem.name}</span>
                            ${discoveryTag}
                            <span style="color: #9b59b6; font-size: 0.85rem;">×${recipe.result.count}</span>
                            <span style="color: #888; font-size: 0.75rem; margin-left: 4px;">(보유: ${resultCount})</span>
                            ${canCraft ? '<span style="margin-left: auto; font-size: 0.75rem; background: #27ae60; color: white; padding: 2px 6px;">제작 가능</span>' : ''}
                        </div>
                        <div style="font-size: 0.85rem; color: #888; margin-bottom: 5px;">
                            ${ingredientDisplay}
                        </div>
                        <div style="font-size: 0.8rem; color: #9b59b6;">
                            효과: ${effectText}
                        </div>
                        ${craftButton}
                        ${!canCraft ? `<div style="font-size: 0.75rem; color: #888; margin-top: 5px; text-align: center;">👆 클릭하여 자동 배치</div>` : ''}
                    </div>
                `;
            });
            
            const totalRecipes = Object.keys(RECIPES).length;
            
            // 발견한 레시피 숫자를 상단에 표시
            const countDisplay = document.getElementById('recipeCountDisplay');
            if (countDisplay) {
                countDisplay.textContent = `${discoveredRecipes.length} / ${totalRecipes}`;
            }
            
            const noResultMsg = filteredCount === 0 && discoveredRecipes.length > 0 
                ? '<div style="color: #888; text-align: center; padding: 20px;">조건에 맞는 레시피가 없습니다.</div>'
                : '<div style="color: #888; text-align: center; padding: 20px;">아직 발견한 레시피가 없습니다.<br>재료를 조합해 새로운 레시피를 발견해보세요!</div>';
            
            container.innerHTML = html || noResultMsg;
        }
        
        // 레시피 자동 배치
        function autoFillRecipe(recipeId) {
            const recipe = RECIPES[recipeId];
            if (!recipe) {
                showNotification('레시피를 찾을 수 없습니다');
                return;
            }
            
            const ing1 = recipe.ingredients[0];
            const ing2 = recipe.ingredients[1];
            
            // 재료 보유량 체크 (같은 재료인 경우 합산해서 계산)
            const ing1Count = countInventoryItem(ing1.type, ing1.category);
            const ing2Count = countInventoryItem(ing2.type, ing2.category);
            
            let hasEnough;
            if (ing1.type === ing2.type && ing1.category === ing2.category) {
                // 같은 재료: 총 필요량으로 체크
                const totalNeeded = ing1.count + ing2.count;
                hasEnough = ing1Count >= totalNeeded;
                if (!hasEnough) {
                    const ing1Name = getItemName(ing1.type, ing1.category);
                    showNotification(`⚠️ 재료 부족: ${ing1Name} ${totalNeeded - ing1Count}개`);
                    return;
                }
            } else {
                // 다른 재료: 각각 체크
                hasEnough = ing1Count >= ing1.count && ing2Count >= ing2.count;
                if (!hasEnough) {
                    const ing1Name = getItemName(ing1.type, ing1.category);
                    const ing2Name = getItemName(ing2.type, ing2.category);
                    let missing = [];
                    if (ing1Count < ing1.count) missing.push(`${ing1Name} ${ing1.count - ing1Count}개`);
                    if (ing2Count < ing2.count) missing.push(`${ing2Name} ${ing2.count - ing2Count}개`);
                    showNotification(`⚠️ 재료 부족: ${missing.join(', ')}`);
                    return;
                }
            }
            
            // 슬롯에 정보만 기록 (인벤토리 차감은 합성 시점에)
            labSlot1 = { type: ing1.type, category: ing1.category, count: ing1.count };
            labSlot2 = { type: ing2.type, category: ing2.category, count: ing2.count };
            
            // UI 업데이트
            updateLabUI();
            checkRecipe();
            renderInventory();
            // 현재 필터 유지하면서 레시피 목록 갱신
            applyRecipeFilters();
            saveGame();
            
            // 팝업 없이 조용히 배치 (UI로 확인 가능)
        }
        
        // 레시피 필터 적용
        function applyRecipeFilters() {
            const categoryFilter = document.getElementById('recipeFilterSelect')?.value || 'all';
            const attrFilter = document.getElementById('recipeAttrFilter')?.value || 'all';
            const qualityFilter = document.getElementById('recipeQualityFilter')?.value || 'all';
            renderRecipeList(categoryFilter, attrFilter, qualityFilter);
        }
        
        // 레시피 필터 (하위 호환성)
        function filterRecipes(filter) {
            document.getElementById('recipeFilterSelect').value = filter;
            applyRecipeFilters();
        }
        
        // 게임 데이터 내보내기
        function exportGameData() {
            const gameData = {
                version: '2.2.0',
                exportDate: new Date().toISOString(),
                spirits: spirits,
                collection: collection,
                encyclopedia: encyclopedia,
                encyclopediaDetails: encyclopediaDetails,
                inventory: inventory,
                coins: coins,
                totalEggsCreated: totalEggsCreated,
                terrarium: terrarium,
                installedDecorations: installedDecorations,
                lightMode: lightMode,
                isPaused: isPaused,
                darkModeLocked: darkModeLocked,
                lowSatisfactionStartTime: lowSatisfactionStartTime,
                discoveredRecipes: discoveredRecipes,
                purchasedRecipeBooks: purchasedRecipeBooks,
                selfDiscoveredRecipes: selfDiscoveredRecipes,
                lockedItems: lockedItems,
                activatedEvents: activatedEvents,
                hasVisitedShop: hasVisitedShop,
                currentTitle: currentTitle,
                achievements: achievements,
                claimedAchievementRewards: claimedAchievementRewards,
                lastGatherTime: lastGatherTime,
                currentGatherLocation: currentGatherLocation
                // labSlot은 저장하지 않음 (새 시스템에서는 합성 전까지 인벤토리 차감 안 함)
            };
            
            try {
                const json = JSON.stringify(gameData);
                const base64 = btoa(unescape(encodeURIComponent(json)));
                const code = 'SGDATA-' + base64;
                
                // 코드 표시 모달
                const modal = document.createElement('div');
                modal.id = 'exportCodeModal';
                const zIndex = getNextZIndex();
                modal.style.cssText = `position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: ${zIndex}; display: flex; justify-content: center; align-items: center;`;
                modal.innerHTML = `
                    <div style="background: var(--card); padding: 24px; border-radius: 12px; max-width: 500px; width: 90%; border: 1px solid var(--border);">
                        <h3 style="margin-bottom: 16px;">📤 게임 데이터 내보내기</h3>
                        <p style="font-size: 0.9rem; color: #888; margin-bottom: 12px;">아래 코드를 복사해서 안전한 곳에 저장하세요.</p>
                        <div style="margin-bottom: 12px;">
                            <textarea id="exportCodeText" readonly style="width: 100%; height: 120px; padding: 10px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg); color: var(--text); font-family: monospace; font-size: 0.75rem; resize: none; box-sizing: border-box;">${code}</textarea>
                        </div>
                        <div style="display: flex; gap: 8px; margin-bottom: 12px;">
                            <button onclick="copyExportCode()" style="flex: 1; padding: 12px; background: var(--water); color: white; border: none; border-radius: 6px; cursor: pointer;">
                                📋 코드 복사
                            </button>
                            <button onclick="downloadExportCode()" style="flex: 1; padding: 12px; background: var(--earth); color: white; border: none; border-radius: 6px; cursor: pointer;">
                                💾 파일로 저장
                            </button>
                        </div>
                        <p style="font-size: 0.8rem; color: #888; text-align: center; margin-bottom: 12px;">
                            📊 정령: ${spirits.length}마리 | 앨범: ${collection.length}마리 | 레시피: ${discoveredRecipes.length}개 | 💰 ${coins}
                        </p>
                        <button onclick="closeExportCodeModal()" style="width: 100%; padding: 10px; background: var(--card); border: 1px solid var(--border); border-radius: 6px; cursor: pointer;">
                            닫기
                        </button>
                    </div>
                `;
                document.body.appendChild(modal);
            } catch (e) {
                console.error('데이터 내보내기 오류:', e);
                showNotification('❌ 데이터 내보내기 실패');
            }
        }
        
        function copyExportCode() {
            const textarea = document.getElementById('exportCodeText');
            textarea.select();
            document.execCommand('copy');
            showNotification('📋 코드가 복사되었습니다!');
        }
        
        function downloadExportCode() {
            const textarea = document.getElementById('exportCodeText');
            const code = textarea.value;
            const blob = new Blob([code], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `spirit-garden-backup-${new Date().toISOString().slice(0, 10)}.txt`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            showNotification('💾 파일로 저장되었습니다!');
        }
        
        function closeExportCodeModal() {
            const modal = document.getElementById('exportCodeModal');
            if (modal) modal.remove();
        }
        
        // 게임 데이터 불러오기
        function importGameData() {
            const modal = document.createElement('div');
            modal.id = 'importCodeModal';
            const zIndex = getNextZIndex();
            modal.style.cssText = `position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: ${zIndex}; display: flex; justify-content: center; align-items: center;`;
            modal.innerHTML = `
                <div style="background: var(--card); padding: 24px; border-radius: 12px; max-width: 500px; width: 90%; border: 1px solid var(--border);">
                    <h3 style="margin-bottom: 16px;">📥 게임 데이터 불러오기</h3>
                    <p style="font-size: 0.9rem; color: #888; margin-bottom: 12px;">백업 코드를 붙여넣거나 파일을 선택하세요.</p>
                    <div style="margin-bottom: 12px;">
                        <textarea id="importCodeText" placeholder="SGDATA-로 시작하는 코드를 붙여넣으세요..." style="width: 100%; height: 120px; padding: 10px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg); color: var(--text); font-family: monospace; font-size: 0.75rem; resize: none; box-sizing: border-box;"></textarea>
                    </div>
                    <div style="display: flex; gap: 8px; margin-bottom: 12px;">
                        <button onclick="executeImportCode()" style="flex: 1; padding: 12px; background: var(--water); color: white; border: none; border-radius: 6px; cursor: pointer;">
                            📥 코드로 불러오기
                        </button>
                        <button onclick="importFromFile()" style="flex: 1; padding: 12px; background: var(--earth); color: white; border: none; border-radius: 6px; cursor: pointer;">
                            📁 파일 선택
                        </button>
                    </div>
                    <p style="font-size: 0.8rem; color: #e74c3c; text-align: center; margin-bottom: 12px;">
                        ⚠️ 현재 데이터는 덮어씌워집니다!
                    </p>
                    <button onclick="closeImportCodeModal()" style="width: 100%; padding: 10px; background: var(--card); border: 1px solid var(--border); border-radius: 6px; cursor: pointer;">
                        닫기
                    </button>
                </div>
            `;
            document.body.appendChild(modal);
        }
        
        function closeImportCodeModal() {
            const modal = document.getElementById('importCodeModal');
            if (modal) modal.remove();
        }
        
        async function executeImportCode() {
            const textarea = document.getElementById('importCodeText');
            const code = textarea.value.trim();
            
            if (!code) {
                showNotification('❌ 코드를 입력해주세요');
                return;
            }
            
            try {
                let gameData;
                
                if (code.startsWith('SGDATA-')) {
                    // 코드 형식
                    const base64 = code.substring(7);
                    const json = decodeURIComponent(escape(atob(base64)));
                    gameData = JSON.parse(json);
                } else if (code.startsWith('{')) {
                    // JSON 형식 (하위 호환)
                    gameData = JSON.parse(code);
                } else {
                    throw new Error('올바른 형식이 아닙니다');
                }
                
                // 데이터 유효성 검사
                if (!gameData.spirits || !gameData.collection || !gameData.inventory) {
                    throw new Error('올바른 게임 데이터가 아닙니다');
                }
                
                const confirmed = await showConfirm(
                    '데이터 불러오기',
                    `백업 데이터를 불러오시겠습니까?\n\n백업 일시: ${new Date(gameData.exportDate).toLocaleString()}\n정령 수: ${gameData.spirits.length}\n앨범: ${gameData.collection.length}\n발견 레시피: ${(gameData.discoveredRecipes || []).length}개\n💰 ${gameData.coins}\n\n현재 데이터는 덮어씌워집니다.`
                );
                
                if (!confirmed) return;
                
                // 데이터 복원
                applyGameData(gameData);
                closeImportCodeModal();
                showNotification('✅ 게임 데이터를 불러왔습니다');
                switchTab('garden');
            } catch (error) {
                console.error('데이터 불러오기 오류:', error);
                showNotification('❌ 불러오기 실패: ' + error.message);
            }
        }
        
        function importFromFile() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json,.txt';
            
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                try {
                    const text = await file.text();
                    document.getElementById('importCodeText').value = text.trim();
                    showNotification('📁 파일을 불러왔습니다. "코드로 불러오기"를 클릭하세요.');
                } catch (error) {
                    showNotification('❌ 파일 읽기 실패');
                }
            };
            
            input.click();
        }
        
        function applyGameData(gameData) {
            spirits = gameData.spirits || [];
            
            // 문자열 id를 숫자 id로 변환 (연모 알 호환성)
            spirits.forEach(spirit => {
                if (typeof spirit.id === 'string') {
                    spirit.id = Date.now() + Math.floor(Math.random() * 10000);
                }
            });
            
            collection = gameData.collection || [];
            encyclopedia = gameData.encyclopedia || {};
            
            // 도감 데이터 형식 통일 (객체 → 숫자)
            Object.keys(encyclopedia).forEach(key => {
                if (typeof encyclopedia[key] === 'object' && encyclopedia[key] !== null) {
                    encyclopedia[key] = encyclopedia[key].count || 1;
                }
            });
            
            // ===== 스탯 타입 마이그레이션 (v41 이전 → v41+) =====
            // 이전 버전: intelligent-low, intelligent-mid, intelligent-high
            // 새 버전: intelligent
            const statLevelPattern = /^(intelligent|strong|beautiful)-(low|mid|high)$/;
            
            // 육성 중인 정령 마이그레이션
            spirits.forEach(spirit => {
                if (spirit.evolutionType && statLevelPattern.test(spirit.evolutionType)) {
                    spirit.evolutionType = spirit.evolutionType.replace(/-(low|mid|high)$/, '');
                }
                if (spirit.evolutionData && spirit.evolutionData.type && statLevelPattern.test(spirit.evolutionData.type)) {
                    spirit.evolutionData.type = spirit.evolutionData.type.replace(/-(low|mid|high)$/, '');
                }
            });
            
            // 앨범 마이그레이션
            collection.forEach(spirit => {
                if (spirit.type && statLevelPattern.test(spirit.type)) {
                    spirit.type = spirit.type.replace(/-(low|mid|high)$/, '');
                }
            });
            
            // 도감 마이그레이션 (키 변환 및 합산)
            const newEncyclopedia = {};
            Object.entries(encyclopedia).forEach(([key, count]) => {
                // 키에서 -low, -mid, -high 제거
                // 예: intelligent-mid-fire-butterfly → intelligent-fire-butterfly
                const newKey = key.replace(/-(low|mid|high)-/, '-');
                
                if (!newEncyclopedia[newKey]) {
                    newEncyclopedia[newKey] = 0;
                }
                newEncyclopedia[newKey] += count;
            });
            encyclopedia = newEncyclopedia;
            // ===== 마이그레이션 끝 =====
            
            inventory = gameData.inventory || { food: [], music: [], decorations: [], medicine: [] };
            coins = gameData.coins || 0;
            totalEggsCreated = gameData.totalEggsCreated || 0;
            
            // 기존 데이터 호환: totalEggsCreated가 없으면 앨범+현재정령 수로 추정
            if (gameData.totalEggsCreated === undefined) {
                totalEggsCreated = (collection.length || 0) + (spirits.length || 0);
            }
            
            terrarium = gameData.terrarium || { fire: 0, water: 0, wind: 0, earth: 0, light: 0, dark: 0 };
            installedDecorations = gameData.installedDecorations || [];
            lightMode = gameData.lightMode !== undefined ? gameData.lightMode : true;
            isPaused = gameData.isPaused || false;
            darkModeLocked = gameData.darkModeLocked || false;
            lowSatisfactionStartTime = gameData.lowSatisfactionStartTime || {};
            discoveredRecipes = gameData.discoveredRecipes || [];
            purchasedRecipeBooks = gameData.purchasedRecipeBooks || [];
            selfDiscoveredRecipes = gameData.selfDiscoveredRecipes || [];
            
            // 기존 데이터 호환: selfDiscoveredRecipes가 없으면 discoveredRecipes를 복사
            // (레시피북 시스템 도입 전에 발견한 레시피는 직접 발견으로 간주)
            if (gameData.selfDiscoveredRecipes === undefined && discoveredRecipes.length > 0) {
                selfDiscoveredRecipes = [...discoveredRecipes];
            }
            
            lockedItems = gameData.lockedItems || { food: [], decorations: [], music: [] };
            if (!lockedItems.music) lockedItems.music = []; // 기존 세이브 호환
            encyclopediaDetails = gameData.encyclopediaDetails || {};
            activatedEvents = gameData.activatedEvents || [];
            hasVisitedShop = gameData.hasVisitedShop || false;
            lastGatherTime = gameData.lastGatherTime || null;
            currentGatherLocation = gameData.currentGatherLocation || 'garden';
            currentTitle = gameData.currentTitle || 'none';
            achievements = gameData.achievements || {};
            claimedAchievementRewards = gameData.claimedAchievementRewards || [];
            
            // 슬롯 비우기 (현재 시스템은 슬롯에 올려도 인벤토리에서 차감 안 함)
            labSlot1 = null;
            labSlot2 = null;
            
            // 설치된 미니어처로 환경 재계산
            if (installedDecorations.length > 0) {
                recalculateTerrariumEnvironment();
            }
            
            // 기존 정령들의 만족도 초기화 및 배고픔 타이머 리셋
            const now = Date.now();
            spirits.forEach(spirit => {
                if (!spirit.satisfaction) {
                    spirit.satisfaction = 'mid';
                }
                // 불러오기 시 배고픔 타이머 리셋 (오프라인 동안 죽지 않도록)
                if (!spirit.isDead && !spirit.isCompleted) {
                    spirit.lastFed = now;
                }
            });
            
            saveGame();
            
            // UI 새로고침
            renderSpirits();
            renderInventory();
            updateCoinDisplay();
            applyLightMode();
            updateSettingsInfo();
            renderRecipeList(); // 레시피 목록도 갱신
            checkAchievements(); // 업적 체크 (기존 백업 데이터에 업적이 없을 경우 재계산)
            
            // 현재 일지 탭이 열려있으면 해당 서브탭도 갱신
            if (document.getElementById('journalSection')?.classList.contains('active')) {
                switchJournalTab(currentJournalTab || 'encyclopedia');
            }
            
            showNotification('💡 정령들의 배고픔 상태가 초기화되었습니다!');
        }

        function recalculateTerrariumEnvironment() {
            // 환경 초기화
            terrarium = {
                fire: 0,
                water: 0,
                wind: 0,
                earth: 0,
                light: 0,
                dark: 0
            };

            // 1단계: 모든 미니어처의 속성 합계 계산 (페널티 없이)
            installedDecorations.forEach(deco => {
                // 문자열 또는 객체 모두 지원
                const decoKey = typeof deco === 'string' ? deco : deco.type;
                const decoData = DECORATION_TYPES[decoKey] || SYNTH_ITEMS[decoKey];
                const eventItem = EVENT_ITEMS[decoKey];
                
                // 일반 미니어처 처리
                if (decoData) {
                    const attr = decoData.attr;
                    const power = decoData.power;
                    
                    // 복합 속성 미니어처 처리
                    if (attr === 'dual' && decoData.dualAttr) {
                        // 두 속성 모두 증가
                        decoData.dualAttr.forEach(dualAttr => {
                            terrarium[dualAttr] += power;
                        });
                    } else if (attr === 'all') {
                        // 모든 속성 증가
                        ['fire', 'water', 'wind', 'earth', 'light', 'dark'].forEach(allAttr => {
                            terrarium[allAttr] += power;
                        });
                    } else {
                        // 해당 속성 증가
                        terrarium[attr] += power;
                    }
                }
                
                // 이벤트 미니어처 처리 (effects 객체 사용)
                if (eventItem && eventItem.type === 'decoration' && eventItem.effects) {
                    Object.entries(eventItem.effects).forEach(([attr, power]) => {
                        if (terrarium.hasOwnProperty(attr) && power > 0) {
                            terrarium[attr] += power;
                        }
                    });
                }
            });
            
            // 2단계: 상극 속성끼리 상호 페널티 적용 (순서 무관)
            const oppositePairs = [
                ['fire', 'water'],
                ['wind', 'earth'],
                ['light', 'dark']
            ];
            
            oppositePairs.forEach(([attr1, attr2]) => {
                const val1 = terrarium[attr1];
                const val2 = terrarium[attr2];
                
                // 서로의 절반만큼 감소
                const penalty1 = Math.floor(val2 / 2);
                const penalty2 = Math.floor(val1 / 2);
                
                terrarium[attr1] = Math.max(0, val1 - penalty1);
                terrarium[attr2] = Math.max(0, val2 - penalty2);
            });
            
            // 3단계: 최대값 50으로 제한
            Object.keys(terrarium).forEach(attr => {
                terrarium[attr] = Math.min(50, terrarium[attr]);
            });
        }

        function toggleLight() {
            const now = Date.now();
            
            // 현재 조명 변경 기록
            lightToggleHistory.push(now);
            
            // 1분(60초) 이전 기록 제거
            lightToggleHistory = lightToggleHistory.filter(time => (now - time) < 60000);
            
            // 1분 이내 5회 이상 변경 체크
            const isSpamming = lightToggleHistory.length >= 5;
            
            lightMode = !lightMode;
            
            // 정령들 반응
            spirits.forEach(spirit => {
                if (!spirit.isDead && !spirit.isCompleted) {
                    if (isSpamming) {
                        // 조명 남용 시 화내거나 춤추기
                        const spamMessages = [
                            `${spirit.name}이(가) 당신의 장난에 화를 냅니다.`,
                            `${spirit.name}이(가) 격한 춤을 춥니다.`,
                            `${spirit.name}이(가) 조명 장난에 짜증을 냅니다.`,
                            `${spirit.name}이(가) 어지러워합니다!`
                        ];
                        spirit.status = spamMessages[Math.floor(Math.random() * spamMessages.length)];
                        
                        // 일지 추가
                        addLog(spirit, spirit.status);
                        
                        // 애정도 -1
                        spirit.parameters.affection = Math.max(0, spirit.parameters.affection - 1);
                    } else {
                        // 정상적인 조명 전환 반응
                        if (lightMode) {
                            // 조명 켜짐
                            spirit.status = `${spirit.name}이(가) 갑자기 주변이 환해져 깜짝 놀랍니다.`;
                        } else {
                            // 조명 꺼짐
                            spirit.status = `${spirit.name}이(가) 갑자기 주변이 어두워져 깜짝 놀랍니다.`;
                        }
                        
                        // 일지 추가
                        addLog(spirit, spirit.status);
                    }
                }
            });
            
            applyLightMode();
            recalculateTerrariumEnvironment();
            saveGame();
            updateAllSpiritCards();
            if (document.getElementById('terrariumSection').classList.contains('active')) {
                renderTerrariumManagement();
            }
            
            if (isSpamming) {
                showNotification(lightMode ? '☀️ 조명을 켰습니다 (정령이 화를 냅니다!)' : '🌙 조명을 껐습니다 (정령이 화를 냅니다!)');
            } else {
                showNotification(lightMode ? '☀️ 조명을 켰습니다' : '🌙 조명을 껐습니다');
            }
            
            // 튜토리얼 액션 체크
            checkTutorialAction('toggleLight');
        }

        function applyLightMode() {
            const lightIcon = document.getElementById('lightIcon');
            
            // 다크 모드 고정이 활성화되어 있으면 조명 상태 무시
            if (darkModeLocked) {
                document.body.classList.add('dark-mode');
                if (lightIcon) lightIcon.textContent = '🌙';
                return;
            }
            
            if (lightMode) {
                document.body.classList.remove('dark-mode');
                if (lightIcon) lightIcon.textContent = '☀️';
            } else {
                document.body.classList.add('dark-mode');
                if (lightIcon) lightIcon.textContent = '🌙';
            }
        }
        
        // 일시정지 토글
        function togglePause() {
            isPaused = !isPaused;
            const pauseBtn = document.getElementById('pauseBtn');
            
            if (isPaused) {
                pausedAt = Date.now(); // 일시정지 시작 시간 기록
                if (pauseBtn) {
                    pauseBtn.textContent = '▶️';
                    pauseBtn.style.background = '#4CAF50';
                }
                showNotification('⏸️ 게임이 일시정지되었습니다');
            } else {
                if (pausedAt) {
                    const pausedDuration = Date.now() - pausedAt;
                    // 일시정지했던 시간을 누적
                    totalPausedTime += pausedDuration;
                    
                    // 모든 정령의 lastInteraction 시간 보정 (일시정지 시간만큼 앞으로 당김)
                    spirits.forEach(spirit => {
                        if (spirit.lastInteraction) {
                            spirit.lastInteraction += pausedDuration;
                        }
                    });
                    
                    pausedAt = null;
                }
                if (pauseBtn) {
                    pauseBtn.textContent = '⏸️';
                    pauseBtn.style.background = '#ff9800';
                }
                showNotification('▶️ 게임이 재개되었습니다');
            }
            
            // 버튼 상태 업데이트
            updateGatherButton();
            updateAllSpiritCards();
            
            saveGame();
        }
        
        // 게임 리셋
        async function resetGame() {
            const confirm1 = await showConfirm(
                '게임 초기화',
                '정말로 게임을 초기화하시겠습니까?\n\n모든 정령, 미니어처, 먹이, 음악, 코인, 도감이 삭제됩니다.\n이 작업은 되돌릴 수 없습니다!'
            );
            
            if (!confirm1) {
                return;
            }
            
            const confirm2 = await showConfirm(
                '최종 확인',
                '다시 한 번 확인합니다.\n정말로 모든 데이터를 삭제하시겠습니까?'
            );
            
            if (!confirm2) {
                return;
            }
            
            // 모든 데이터 초기화
            spirits = [];
            collection = [];
            encyclopedia = {};
            inventory = {
                music: [],
                decorations: [],
                food: ['fire', 'fire', 'fire', 'water', 'water', 'water', 'wind', 'wind', 'wind', 'earth', 'earth', 'earth']
            };
            terrarium = {
                fire: 0,
                water: 0,
                wind: 0,
                earth: 0,
                light: 0,
                dark: 0
            };
            installedDecorations = [];
            lightMode = true;
            coins = 0;
            currentTitle = 'none';
            lastGatherTime = null;
            isPaused = false;
            pausedAt = null;
            totalPausedTime = 0;
            
            // 추가 변수 초기화
            discoveredRecipes = [];
            purchasedRecipeBooks = [];
            selfDiscoveredRecipes = [];
            achievements = {};
            claimedAchievementRewards = [];
            labSlot1 = null;
            labSlot2 = null;
            lockedItems = { food: [], decorations: [], music: [] };
            activatedEvents = [];
            lowSatisfactionStartTime = {};
            hasVisitedShop = false;
            darkModeLocked = false;
            
            // localStorage 삭제
            localStorage.removeItem('spiritGardenV2');
            localStorage.removeItem('spiritGarden_openingSeen'); // 오프닝도 다시 보이게
            localStorage.removeItem('spiritGarden_tutorialSeen'); // 튜토리얼도 다시 보이게
            localStorage.removeItem('spiritGarden_tutorial2Seen'); // 튜토리얼2도 다시 보이게
            localStorage.removeItem('spiritGarden_labTutorialSeen'); // 연구실 튜토리얼도 다시 보이게
            localStorage.removeItem('spiritGarden_sickTutorialSeen'); // 질병 튜토리얼도 다시 보이게
            localStorage.removeItem('spiritGarden_imbalanceTutorialSeen'); // 불균형 튜토리얼도 다시 보이게
            
            // UI 업데이트
            renderSpirits();
            renderInventory();
            renderShop();
            updateCoinDisplay();
            applyLightMode();
            renderEncyclopedia();
            renderCollection();
            renderRecipeList(); // 연구실 레시피 목록도 초기화
            
            const titleSelect = document.getElementById('titleSelect');
            if (titleSelect) {
                titleSelect.value = 'none';
            }
            
            const pauseBtn = document.getElementById('pauseBtn');
            if (pauseBtn) {
                pauseBtn.textContent = '⏸️';
                pauseBtn.classList.remove('paused');
            }
            
            showNotification('🔄 게임이 초기화되었습니다');
            
            // 육성 탭으로 이동 후 오프닝 표시 (약간의 딜레이)
            switchTab('garden');
            setTimeout(() => {
                console.log('오프닝 표시 시도...');
                showOpening();
            }, 500);
        }

        function renderTerrariumManagement() {
            // 환경 바 업데이트 (최대 50)
            Object.entries(terrarium).forEach(([attr, value]) => {
                const bar = document.getElementById(`terr${attr.charAt(0).toUpperCase() + attr.slice(1)}Bar`);
                const valueSpan = document.getElementById(`terr${attr.charAt(0).toUpperCase() + attr.slice(1)}Value`);
                if (bar) bar.style.width = `${(value / 50) * 100}%`;
                if (valueSpan) valueSpan.textContent = value;
            });
            
            // 품질 합계 업데이트
            const qualityEl = document.getElementById('terrariumQuality');
            if (qualityEl) {
                const totalQuality = calculateTerrariumQuality();
                
                qualityEl.textContent = totalQuality.toFixed(0);
                
                // 품질에 따른 색상 변경
                // 품질 점수: 일반=1, 희귀=3, 최상급=5, 합성=6, 전설=7
                if (totalQuality >= 35) {
                    qualityEl.style.color = '#9c27b0'; // 보라 (전설 5개)
                } else if (totalQuality >= 21) {
                    qualityEl.style.color = '#4caf50'; // 초록 (전설 3개)
                } else if (totalQuality >= 15) {
                    qualityEl.style.color = '#ff9800'; // 주황 (최상급 3개)
                } else {
                    qualityEl.style.color = '#f44336'; // 빨강
                }
            }

            // 설치된 미니어처 개수 업데이트
            const installedCountEl = document.getElementById('installedCount');
            if (installedCountEl) {
                installedCountEl.textContent = `${installedDecorations.length} / 20`;
            }
            
            // 전설 등급 개수 업데이트
            const legendaryCountEl = document.getElementById('legendaryCount');
            if (legendaryCountEl) {
                const legendaryCount = installedDecorations.filter(d => {
                    const type = typeof d === 'string' ? d : d.type;
                    const dData = DECORATION_TYPES[type] || SYNTH_ITEMS[type];
                    const eData = EVENT_ITEMS[type];
                    return (dData?.quality === 'legendary') || (eData?.quality === 'legendary');
                }).length;
                legendaryCountEl.textContent = legendaryCount;
                legendaryCountEl.style.color = legendaryCount >= 5 ? '#f44336' : '#9c27b0';
            }

            // 설치된 미니어처 목록
            const installedContainer = document.getElementById('installedDecorList');
            if (installedDecorations.length === 0) {
                installedContainer.innerHTML = '<p style="color: #888; text-align: center; padding: 20px;">설치된 미니어처가 없습니다</p>';
            } else {
                const installedCounts = {};
                installedDecorations.forEach(d => {
                    // 문자열 또는 객체 모두 지원
                    const decoType = typeof d === 'string' ? d : d.type;
                    installedCounts[decoType] = (installedCounts[decoType] || 0) + 1;
                });

                // 속성별, 이름별로 정렬 (순서 고정)
                const sortedEntries = Object.entries(installedCounts).sort((a, b) => {
                    const dataA = DECORATION_TYPES[a[0]] || SYNTH_ITEMS[a[0]] || EVENT_ITEMS[a[0]];
                    const dataB = DECORATION_TYPES[b[0]] || SYNTH_ITEMS[b[0]] || EVENT_ITEMS[b[0]];
                    if (!dataA || !dataB) return 0;
                    
                    // 이벤트 아이템은 맨 위로
                    const isEventA = !!EVENT_ITEMS[a[0]];
                    const isEventB = !!EVENT_ITEMS[b[0]];
                    if (isEventA && !isEventB) return -1;
                    if (!isEventA && isEventB) return 1;
                    
                    if (!isEventA && !isEventB) {
                        // 1. 속성별 정렬
                        const attrOrder = { fire: 0, water: 1, wind: 2, earth: 3, light: 4, dark: 5 };
                        const attrDiff = (attrOrder[dataA.attr] || 0) - (attrOrder[dataB.attr] || 0);
                        if (attrDiff !== 0) return attrDiff;
                        
                        // 2. 품질별 정렬 (높은 순)
                        const qualityOrder = { legendary: 0, epic: 1, rare: 2, common: 3 };
                        const qualityDiff = (qualityOrder[dataA.quality] || 3) - (qualityOrder[dataB.quality] || 3);
                        if (qualityDiff !== 0) return qualityDiff;
                        
                        // 3. 이름별 정렬
                        return dataA.name.localeCompare(dataB.name);
                    }
                    
                    return 0;
                });
                
                installedContainer.innerHTML = `
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                        ${sortedEntries.map(([key, count]) => {
                            // 일반/합성 미니어처 체크
                            const decoData = DECORATION_TYPES[key] || SYNTH_ITEMS[key];
                            if (decoData) {
                                const qualityLabel = decoData.quality === 'legendary' ? '👑' : decoData.quality === 'epic' ? '⭐' : decoData.quality === 'rare' ? '💎' : '';
                                const isSynth = SYNTH_ITEMS[key] && !DECORATION_TYPES[key];
                                const qualityBorderColor = isSynth ? '#9b59b6' : (decoData.quality === 'legendary' ? '#ffd700' : decoData.quality === 'epic' ? '#9b59b6' : decoData.quality === 'rare' ? '#3498db' : 'var(--border)');
                                return `
                                    <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px; background: var(--bg); border: 2px solid ${qualityBorderColor}; border-radius: 6px;">
                                        <div style="display: flex; align-items: center; gap: 8px;">
                                            <span style="font-size: 1.3rem;">${isSynth ? '🔬' : qualityLabel}${decoData.icon}</span>
                                            <div>
                                                <div style="font-weight: 700; font-size: 0.9rem;">${decoData.name} ×${count}${isSynth ? ' <span style="font-size: 0.7rem; color: #9b59b6;">합성</span>' : ''}</div>
                                                <div style="font-size: 0.75rem; color: #888;">${decoData.attr} +${decoData.power}</div>
                                            </div>
                                        </div>
                                        <button onclick="removeDecorationFromTerrarium('${key}')" style="padding: 6px 10px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.8rem;">
                                            회수
                                        </button>
                                    </div>
                                `;
                            }
                            
                            // 이벤트 미니어처 체크
                            const eventItem = EVENT_ITEMS[key];
                            if (eventItem && eventItem.type === 'decoration') {
                                const qualityLabel = eventItem.quality === 'legendary' ? '👑' : eventItem.quality === 'epic' ? '⭐' : eventItem.quality === 'rare' ? '💎' : '';
                                const qualityBorderColor = eventItem.quality === 'legendary' ? '#ffd700' : eventItem.quality === 'epic' ? '#9b59b6' : eventItem.quality === 'rare' ? '#3498db' : '#c41e3a';
                                // 효과 정보 생성
                                const effectsText = eventItem.effects ? Object.entries(eventItem.effects)
                                    .filter(([k, v]) => v > 0)
                                    .map(([k, v]) => {
                                        const attrNames = { fire: '🔥', water: '💧', wind: '🌪️', earth: '🌱', light: '✨', dark: '🌙' };
                                        return `${attrNames[k] || k}+${v}`;
                                    }).join(' ') : '특별 효과';
                                return `
                                    <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px; background: var(--bg); border: 2px solid ${qualityBorderColor}; border-radius: 6px;">
                                        <div style="display: flex; align-items: center; gap: 8px;">
                                            <span style="font-size: 1.3rem;">${qualityLabel}${eventItem.icon}</span>
                                            <div>
                                                <div style="font-weight: 700; font-size: 0.9rem;">${eventItem.name} ×${count}</div>
                                                <div style="font-size: 0.75rem; color: #888;">${effectsText}</div>
                                            </div>
                                        </div>
                                        <button onclick="removeDecorationFromTerrarium('${key}')" style="padding: 6px 10px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.8rem;">
                                            회수
                                        </button>
                                    </div>
                                `;
                            }
                            
                            return '';
                        }).join('')}
                    </div>
                `;
            }

            // 인벤토리 미니어처 목록
            const listContainer = document.getElementById('terrariumDecorList');
            const filterArea = document.getElementById('terrariumFilterArea');
            if (!inventory.decorations) inventory.decorations = [];
            
            // 필터 UI를 오른쪽 상단에 렌더링
            if (filterArea) {
                filterArea.innerHTML = `
                    <select id="terrariumAttrFilter" onchange="setTerrariumFilter(this.value, 'attr')" style="padding: 6px 10px; border: 1px solid var(--border); background: var(--bg); font-size: 0.85rem;">
                        <option value="all" ${terrariumInvFilter === 'all' ? 'selected' : ''}>속성</option>
                        <option value="event" ${terrariumInvFilter === 'event' ? 'selected' : ''}>🎄 이벤트</option>
                        <option value="fire" ${terrariumInvFilter === 'fire' ? 'selected' : ''}>🔥 불</option>
                        <option value="water" ${terrariumInvFilter === 'water' ? 'selected' : ''}>💧 물</option>
                        <option value="wind" ${terrariumInvFilter === 'wind' ? 'selected' : ''}>🌪️ 바람</option>
                        <option value="earth" ${terrariumInvFilter === 'earth' ? 'selected' : ''}>🌱 땅</option>
                        <option value="light" ${terrariumInvFilter === 'light' ? 'selected' : ''}>✨ 빛</option>
                        <option value="dark" ${terrariumInvFilter === 'dark' ? 'selected' : ''}>🌙 어둠</option>
                    </select>
                    <select id="terrariumQualityFilterSelect" onchange="setTerrariumFilter(this.value, 'quality')" style="padding: 6px 10px; border: 1px solid var(--border); background: var(--bg); font-size: 0.85rem;">
                        <option value="all" ${terrariumQualityFilter === 'all' ? 'selected' : ''}>품질</option>
                        <option value="common" ${terrariumQualityFilter === 'common' ? 'selected' : ''}>일반</option>
                        <option value="rare" ${terrariumQualityFilter === 'rare' ? 'selected' : ''}>💎 희귀</option>
                        <option value="epic" ${terrariumQualityFilter === 'epic' ? 'selected' : ''}>⭐ 최상급</option>
                        <option value="legendary" ${terrariumQualityFilter === 'legendary' ? 'selected' : ''}>👑 전설</option>
                    </select>
                `;
            }
            
            if (inventory.decorations.length === 0) {
                listContainer.innerHTML = '<p style="color: #888; text-align: center; padding: 20px;">보유한 미니어처가 없습니다</p>';
                return;
            }

            const decorCounts = {};
            inventory.decorations.forEach(d => {
                decorCounts[d] = (decorCounts[d] || 0) + 1;
            });

            const canInstall = installedDecorations.length < 20;
            
            // 전설 등급 현재 개수 계산
            const legendaryCount = installedDecorations.filter(d => {
                const type = typeof d === 'string' ? d : d.type;
                const dData = DECORATION_TYPES[type] || SYNTH_ITEMS[type];
                const eData = EVENT_ITEMS[type];
                return (dData?.quality === 'legendary') || (eData?.quality === 'legendary');
            }).length;
            const canInstallLegendary = legendaryCount < 5;

            // 속성별, 품질별, 이름별로 정렬 (순서 고정)
            let sortedDecorEntries = Object.entries(decorCounts).sort((a, b) => {
                const dataA = DECORATION_TYPES[a[0]] || SYNTH_ITEMS[a[0]] || EVENT_ITEMS[a[0]];
                const dataB = DECORATION_TYPES[b[0]] || SYNTH_ITEMS[b[0]] || EVENT_ITEMS[b[0]];
                if (!dataA || !dataB) return 0;
                
                // 이벤트 아이템은 맨 위로
                const isEventA = !!EVENT_ITEMS[a[0]];
                const isEventB = !!EVENT_ITEMS[b[0]];
                if (isEventA && !isEventB) return -1;
                if (!isEventA && isEventB) return 1;
                
                // 일반 미니어처 정렬
                if (!isEventA && !isEventB) {
                    // 1. 속성별 정렬
                    const attrOrder = { fire: 0, water: 1, wind: 2, earth: 3, light: 4, dark: 5 };
                    const attrDiff = (attrOrder[dataA.attr] || 0) - (attrOrder[dataB.attr] || 0);
                    if (attrDiff !== 0) return attrDiff;
                    
                    // 2. 품질별 정렬 (높은 순)
                    const qualityOrder = { legendary: 0, epic: 1, rare: 2, common: 3 };
                    const qualityDiff = (qualityOrder[dataA.quality] || 3) - (qualityOrder[dataB.quality] || 3);
                    if (qualityDiff !== 0) return qualityDiff;
                    
                    // 3. 이름별 정렬
                    return dataA.name.localeCompare(dataB.name);
                }
                
                return 0;
            });
            
            // 필터 적용
            sortedDecorEntries = sortedDecorEntries.filter(([key, count]) => {
                const decoData = DECORATION_TYPES[key] || SYNTH_ITEMS[key];
                const eventItem = EVENT_ITEMS[key];
                const isEvent = !!eventItem;
                
                // 속성 필터
                if (terrariumInvFilter !== 'all') {
                    if (terrariumInvFilter === 'event') {
                        if (!isEvent) return false;
                    } else {
                        if (isEvent) return false; // 이벤트 아이템은 속성 필터에서 제외
                        if (decoData && decoData.attr !== terrariumInvFilter) return false;
                    }
                }
                
                // 품질 필터
                if (terrariumQualityFilter !== 'all') {
                    if (isEvent) {
                        // 이벤트 아이템은 전설급으로 취급
                        if (terrariumQualityFilter !== 'legendary') return false;
                    } else {
                        if (decoData && decoData.quality !== terrariumQualityFilter) return false;
                    }
                }
                
                return true;
            });
            
            if (sortedDecorEntries.length === 0) {
                listContainer.innerHTML = '<p style="color: #888; text-align: center; padding: 20px;">조건에 맞는 미니어처가 없습니다</p>';
                return;
            }

            listContainer.innerHTML = `
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                    ${sortedDecorEntries.map(([key, count]) => {
                        // 일반/합성 미니어처 체크
                        const decoData = DECORATION_TYPES[key] || SYNTH_ITEMS[key];
                        if (decoData) {
                            const qualityLabel = decoData.quality === 'legendary' ? '👑' : decoData.quality === 'epic' ? '⭐' : decoData.quality === 'rare' ? '💎' : '';
                            const isLegendary = decoData.quality === 'legendary';
                            const canInstallThis = canInstall && (!isLegendary || canInstallLegendary);
                            const buttonText = !canInstall ? '가득' : (isLegendary && !canInstallLegendary) ? '제한' : '설치';
                            const isSynth = SYNTH_ITEMS[key] && !DECORATION_TYPES[key];
                            const qualityBorderColor = isSynth ? '#9b59b6' : (decoData.quality === 'legendary' ? '#ffd700' : decoData.quality === 'epic' ? '#9b59b6' : decoData.quality === 'rare' ? '#3498db' : 'var(--border)');
                            return `
                                <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px; background: var(--bg); border: 2px solid ${qualityBorderColor}; border-radius: 6px;">
                                    <div style="display: flex; align-items: center; gap: 8px;">
                                        <span style="font-size: 1.3rem;">${isSynth ? '🔬' : qualityLabel}${decoData.icon}</span>
                                        <div>
                                            <div style="font-weight: 700; font-size: 0.9rem;">${decoData.name} ×${count}${isSynth ? ' <span style="font-size: 0.7rem; color: #9b59b6;">합성</span>' : ''}</div>
                                            <div style="font-size: 0.75rem; color: #888;">${decoData.attr} +${decoData.power}</div>
                                        </div>
                                    </div>
                                    <button onclick="placeDecorationInTerrarium('${key}')" style="padding: 6px 10px; border: none; border-radius: 4px; cursor: pointer; font-size: 0.8rem;" ${!canInstallThis ? 'disabled' : ''}>
                                        ${buttonText}
                                    </button>
                                </div>
                            `;
                        }
                        
                        // 이벤트 미니어처 체크 (전설급 취급)
                        const eventItem = EVENT_ITEMS[key];
                        if (eventItem && eventItem.type === 'decoration') {
                            const qualityLabel = eventItem.quality === 'legendary' ? '👑' : eventItem.quality === 'epic' ? '⭐' : eventItem.quality === 'rare' ? '💎' : '';
                            const qualityBorderColor = eventItem.quality === 'legendary' ? '#ffd700' : eventItem.quality === 'epic' ? '#9b59b6' : eventItem.quality === 'rare' ? '#3498db' : '#c41e3a';
                            // 효과 정보 생성
                            const effectsText = eventItem.effects ? Object.entries(eventItem.effects)
                                .filter(([k, v]) => v > 0)
                                .map(([k, v]) => {
                                    const attrNames = { fire: '🔥', water: '💧', wind: '🌪️', earth: '🌱', light: '✨', dark: '🌙' };
                                    return `${attrNames[k] || k}+${v}`;
                                }).join(' ') : '특별 효과';
                            const isEventLegendary = eventItem.quality === 'legendary';
                            const canInstallThis = canInstall && (!isEventLegendary || canInstallLegendary);
                            const buttonText = !canInstall ? '가득' : (isEventLegendary && !canInstallLegendary) ? '제한' : '설치';
                            return `
                                <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px; background: var(--bg); border: 2px solid ${qualityBorderColor}; border-radius: 6px;">
                                    <div style="display: flex; align-items: center; gap: 8px;">
                                        <span style="font-size: 1.3rem;">${qualityLabel}${eventItem.icon}</span>
                                        <div>
                                            <div style="font-weight: 700; font-size: 0.9rem;">${eventItem.name} ×${count}</div>
                                            <div style="font-size: 0.75rem; color: #888;">${effectsText}</div>
                                        </div>
                                    </div>
                                    <button onclick="placeDecorationInTerrarium('${key}')" style="padding: 6px 10px; border: none; border-radius: 4px; cursor: pointer; font-size: 0.8rem;" ${!canInstallThis ? 'disabled' : ''}>
                                        ${buttonText}
                                    </button>
                                </div>
                            `;
                        }
                        
                        return '';
                    }).join('')}
                </div>
            `;
        }
        
        function setTerrariumFilter(value, type) {
            if (type === 'attr') {
                terrariumInvFilter = value;
            } else if (type === 'quality') {
                terrariumQualityFilter = value;
            }
            renderTerrariumManagement();
        }

        function placeDecorationInTerrarium(decorationType) {
            if (!inventory.decorations) inventory.decorations = [];
            
            // 최대 20개 체크
            if (installedDecorations.length >= 20) {
                showNotification('테라리움이 가득 찼습니다 (최대 20개)');
                return;
            }

            const invIndex = inventory.decorations.indexOf(decorationType);
            if (invIndex === -1) return;

            const decoData = DECORATION_TYPES[decorationType];
            const eventItem = EVENT_ITEMS[decorationType];
            const synthItem = SYNTH_ITEMS[decorationType];
            
            if (!decoData && !eventItem && !synthItem) return;
            
            // 전설 등급 미니어처 최대 5개 제한
            const itemQuality = decoData?.quality || eventItem?.quality || null;
            if (itemQuality === 'legendary') {
                const legendaryCount = installedDecorations.filter(d => {
                    const type = typeof d === 'string' ? d : d.type;
                    const dData = DECORATION_TYPES[type];
                    const eData = EVENT_ITEMS[type];
                    return (dData?.quality === 'legendary') || (eData?.quality === 'legendary');
                }).length;
                
                if (legendaryCount >= 5) {
                    showNotification('👑 전설 등급 미니어처은 최대 5개까지만 설치할 수 있습니다');
                    return;
                }
            }

            // 같은 타입의 미니어처가 있는지 확인 (위치 고정을 위해)
            const existingIndices = installedDecorations
                .map((d, i) => ({ type: typeof d === 'string' ? d : d.type, index: i }))
                .filter(d => d.type === decorationType)
                .map(d => d.index);
            
            let targetIndex = installedDecorations.length; // 기본값: 맨 뒤
            
            if (existingIndices.length > 0) {
                // 같은 타입이 있으면 그 다음 위치에 배치
                targetIndex = Math.max(...existingIndices) + 1;
            }

            // 인벤토리에서 제거
            inventory.decorations.splice(invIndex, 1);
            
            // 설치 목록에 추가 (위치 정보 포함)
            installedDecorations.splice(targetIndex, 0, { type: decorationType, index: targetIndex });
            
            // 인덱스 재정렬
            installedDecorations.forEach((d, i) => {
                if (typeof d === 'object') {
                    d.index = i;
                }
            });

            // 환경 재계산
            recalculateTerrariumEnvironment();

            // 만족도 즉시 업데이트
            spirits.forEach(spirit => {
                if (!spirit.isDead && !spirit.isCompleted) {
                    spirit.satisfaction = calculateSatisfaction(spirit);
                }
            });
            
            const itemData = decoData || eventItem || synthItem;
            saveGame();
            renderTerrariumManagement();
            renderInventory();
            renderSpirits();  // 만족도 변경 반영
            showNotification(`${itemData.icon} ${itemData.name} 설치 완료`);
            
            // 병균 침입 체크 (미니어처 10개 초과 시 5% 확률)
            checkGermInvasion();
        }

        function removeDecorationFromTerrarium(decorationType) {
            // 문자열 또는 객체 모두 지원
            const index = installedDecorations.findIndex(d => 
                (typeof d === 'string' ? d : d.type) === decorationType
            );
            if (index === -1) return;

            const decoData = DECORATION_TYPES[decorationType] || SYNTH_ITEMS[decorationType];
            const eventItem = EVENT_ITEMS[decorationType];
            const itemData = decoData || eventItem;
            
            if (!itemData) return;

            // 설치 목록에서 제거하고 인벤토리에 추가
            installedDecorations.splice(index, 1);
            
            // 인덱스 재정렬
            installedDecorations.forEach((d, i) => {
                if (typeof d === 'object') {
                    d.index = i;
                }
            });
            
            if (!inventory.decorations) inventory.decorations = [];
            inventory.decorations.push(decorationType);

            // 환경 재계산
            recalculateTerrariumEnvironment();
            
            // 정령들이 사라진 장식을 찾는 메시지 (3분 이내 랜덤)
            spirits.forEach(spirit => {
                if (!spirit.isDead && !spirit.isCompleted) {
                    const searchMessages = [
                        `${spirit.name}이(가) ${itemData.name}이(가) 어디갔는지 찾습니다.`,
                        `${spirit.name}이(가) ${itemData.name}을(를) 두리번거리며 찾습니다.`,
                        `${spirit.name}이(가) 사라진 ${itemData.name}을(를) 찾아 헤맵니다.`,
                        `${spirit.name}이(가) ${itemData.name}이(가) 없어져서 슬퍼합니다.`,
                        `${spirit.name}이(가) ${itemData.name}이(가) 그리워 보입니다.`
                    ];
                    const randomMessage = searchMessages[Math.floor(Math.random() * searchMessages.length)];
                    
                    // 0~180초(3분) 사이 랜덤 타이밍
                    const randomDelay = Math.random() * 180000; // 0 ~ 180000ms (0 ~ 3분)
                    
                    console.log(`${spirit.name}: ${randomDelay/1000}초 후에 "${randomMessage}" 표시 예정`);
                    
                    setTimeout(() => {
                        // 타임아웃 실행 시점에도 정령이 살아있고 완성되지 않았는지 재확인
                        const currentSpirit = spirits.find(s => s.id === spirit.id);
                        if (currentSpirit && !currentSpirit.isDead && !currentSpirit.isCompleted) {
                            console.log(`${currentSpirit.name}: 미니어처 반응 표시 - "${randomMessage}"`);
                            currentSpirit.status = randomMessage;
                            
                            // 일지 추가
                            addLog(currentSpirit, randomMessage);
                            
                            updateSpiritCard(currentSpirit);
                        }
                    }, randomDelay);
                }
            });

            // 만족도 즉시 업데이트
            spirits.forEach(spirit => {
                if (!spirit.isDead && !spirit.isCompleted) {
                    spirit.satisfaction = calculateSatisfaction(spirit);
                }
            });
            
            saveGame();
            renderTerrariumManagement();
            renderInventory();
            renderSpirits();  // 만족도 변경 반영
            showNotification(`${itemData.icon} ${itemData.name} 회수 완료`);
        }

        // 랜덤 메시지 생성
        function getRandomMessage(spirit) {
            if (spirit.isDead || spirit.isCompleted) return spirit.status;
            
            const affection = spirit.parameters.affection || 0;
            const now = Date.now();
            const timeSinceLastFed = spirit.lastFed ? (now - spirit.lastFed) / 1000 : Infinity;
            const timeSinceLastMusic = spirit.lastMusic ? (now - spirit.lastMusic) / 1000 : Infinity;
            const stage = getStage(spirit.growth);
            
            // 알/번데기 상태인지 확인
            const isEgg = stage === 'egg';
            const isPupa = stage === 'pupa';
            
            let availableMessages = [];
            
            // 크리스마스 이벤트 정령 체크 (알/번데기가 아닐 때만)
            if (!isEgg && !isPupa) {
                const hasChristmasSpirit = spirits.some(s => s.isEventSpirit && s.eventType === 'christmas2025' && !s.isDead && !s.isCompleted);
                const isChristmasSpirit = spirit.isEventSpirit && spirit.eventType === 'christmas2025';
                
                // 크리스마스 장식 체크
                const hasChristmasTree = installedDecorations.some(d => {
                    const decoType = typeof d === 'string' ? d : d.type;
                    return decoType === 'christmas_tree';
                });
                const hasChristmasGift = installedDecorations.some(d => {
                    const decoType = typeof d === 'string' ? d : d.type;
                    return decoType === 'christmas_gift';
                });
                
                // 크리스마스 이벤트 대사 (25% 확률로 우선 출력)
                if ((hasChristmasSpirit || isChristmasSpirit) && Math.random() < 0.25) {
                    let christmasMessages = [];
                    
                    // 이벤트 정령 개인 대사
                    if (isChristmasSpirit) {
                        christmasMessages.push(
                            `${spirit.name}이(가) 캐롤을 흥얼거립니다 🎵`,
                            `${spirit.name} 주변으로 눈송이가 내립니다 ❄️`,
                            `${spirit.name}이(가) 빨간 모자를 고쳐 씁니다 🎅`
                        );
                        if (hasChristmasGift) {
                            christmasMessages.push(`${spirit.name}이(가) 선물 상자를 궁금해합니다 🎁`);
                        }
                        if (hasChristmasTree) {
                            christmasMessages.push(`${spirit.name}이(가) 트리 위 반짝이는 별을 바라봅니다 ⭐`);
                        }
                    }
                    
                    // 크리스마스 정령 없어도 장식이 있으면 개인 반응
                    if (!isChristmasSpirit && hasChristmasSpirit) {
                        if (hasChristmasTree) {
                            christmasMessages.push(`${spirit.name}이(가) 크리스마스 트리를 신기하게 바라봅니다 🎄`);
                        }
                        if (hasChristmasGift) {
                            christmasMessages.push(`${spirit.name}이(가) 선물 상자 주변을 맴돕니다 🎁`);
                        }
                    }
                    
                    if (christmasMessages.length > 0) {
                        return christmasMessages[Math.floor(Math.random() * christmasMessages.length)];
                    }
                }
            }
            
            // === 알 상태 대사 ===
            if (isEgg) {
                // 배고픔 (5분 이상 안 먹임) - 70% 확률
                if (timeSinceLastFed > 300 && Math.random() < 0.7) {
                    availableMessages = [...RANDOM_MESSAGES.egg_hungry];
                }
                // 최근에 음악 들음 (5분 이내, 30% 확률)
                else if (timeSinceLastMusic < 300 && spirit.lastMusicType && Math.random() < 0.3) {
                    const musicData = MUSIC_TYPES[spirit.lastMusicType];
                    const musicName = musicData ? musicData.name : '음악';
                    availableMessages = RANDOM_MESSAGES.egg_music.map(msg => 
                        msg.replace('{music}', musicName)
                    );
                }
                // 잠 (15% 확률)
                else if (Math.random() < 0.15) {
                    if (lightMode) {
                        availableMessages = [...RANDOM_MESSAGES.egg_napLight];
                    } else {
                        availableMessages = [...RANDOM_MESSAGES.egg_sleepDark];
                    }
                }
                // 애정도 낮음 (20% 확률)
                else if (affection < 30 && Math.random() < 0.2) {
                    availableMessages = [...RANDOM_MESSAGES.egg_affectionLow];
                }
                // 기본 대사
                if (availableMessages.length === 0) {
                    availableMessages = [...RANDOM_MESSAGES.egg_basic];
                }
                
                const randomMessage = availableMessages[Math.floor(Math.random() * availableMessages.length)];
                return randomMessage.replace('{name}', spirit.name);
            }
            
            // === 번데기 상태 대사 ===
            if (isPupa) {
                // 배고픔 (5분 이상 안 먹임) - 70% 확률
                if (timeSinceLastFed > 300 && Math.random() < 0.7) {
                    availableMessages = [...RANDOM_MESSAGES.pupa_hungry];
                }
                // 최근에 음악 들음 (5분 이내, 30% 확률)
                else if (timeSinceLastMusic < 300 && spirit.lastMusicType && Math.random() < 0.3) {
                    const musicData = MUSIC_TYPES[spirit.lastMusicType];
                    const musicName = musicData ? musicData.name : '음악';
                    availableMessages = RANDOM_MESSAGES.pupa_music.map(msg => 
                        msg.replace('{music}', musicName)
                    );
                }
                // 잠 (15% 확률)
                else if (Math.random() < 0.15) {
                    if (lightMode) {
                        availableMessages = [...RANDOM_MESSAGES.pupa_napLight];
                    } else {
                        availableMessages = [...RANDOM_MESSAGES.pupa_sleepDark];
                    }
                }
                // 애정도 낮음 (20% 확률)
                else if (affection < 30 && Math.random() < 0.2) {
                    availableMessages = [...RANDOM_MESSAGES.pupa_affectionLow];
                }
                // 기본 대사
                if (availableMessages.length === 0) {
                    availableMessages = [...RANDOM_MESSAGES.pupa_basic];
                }
                
                const randomMessage = availableMessages[Math.floor(Math.random() * availableMessages.length)];
                return randomMessage.replace('{name}', spirit.name);
            }
            
            // === 애벌레 상태 대사 (기존 로직) ===
            // 배고픔 (5분=300초 이상 안 먹임) - 70% 확률로 배고픔 메시지
            if (timeSinceLastFed > 300 && Math.random() < 0.7) {
                availableMessages = [...RANDOM_MESSAGES.hungry];
            }
            // 배고픔이 아니거나, 배고픔이지만 30% 확률로 다른 메시지
            else {
                // 최근에 음악 들음 (5분=300초 이내, 30% 확률)
                if (timeSinceLastMusic < 300 && spirit.lastMusicType && Math.random() < 0.3) {
                    const musicName = MUSIC_TYPES[spirit.lastMusicType].name;
                    availableMessages = RANDOM_MESSAGES.music.map(msg => 
                        msg.replace('{music}', musicName)
                    );
                }
                // 미니어처 설치됨 (30% 확률)
                else if (installedDecorations.length > 0 && Math.random() < 0.3) {
                    const randomDeco = installedDecorations[Math.floor(Math.random() * installedDecorations.length)];
                    const decoType = typeof randomDeco === 'string' ? randomDeco : randomDeco.type;
                    if (RANDOM_MESSAGES.decorations[decoType]) {
                        availableMessages = [...RANDOM_MESSAGES.decorations[decoType]];
                    }
                }
                // 테라리움이 텅 비어있음 (30% 확률)
                else if (installedDecorations.length === 0 && Math.random() < 0.3) {
                    availableMessages = [
                        `${spirit.name}이(가) 텅 빈 테라리움 안을 빙글빙글 돌아다닙니다.`,
                        `${spirit.name}이(가) 심심해 보입니다.`,
                        `${spirit.name}이(가) 아무것도 없는 공간을 두리번거립니다.`,
                        `${spirit.name}이(가) 무료해 보입니다.`
                    ];
                }
                // 잠 (조명에 따라, 15% 확률)
                else if (Math.random() < 0.15) {
                    if (lightMode) {
                        availableMessages = [...RANDOM_MESSAGES.napLight];
                    } else {
                        availableMessages = [...RANDOM_MESSAGES.sleepDark];
                    }
                }
            }
            
            // 위 조건에 해당 안 되면 애정도별 메시지
            if (availableMessages.length === 0) {
                if (affection >= 100) {
                    availableMessages = [...RANDOM_MESSAGES.affectionVeryHigh, ...RANDOM_MESSAGES.basic];
                } else if (affection >= 50) {
                    availableMessages = [...RANDOM_MESSAGES.affectionHigh, ...RANDOM_MESSAGES.basic];
                } else if (affection >= 30) {
                    availableMessages = [...RANDOM_MESSAGES.affectionMedium, ...RANDOM_MESSAGES.basic];
                } else if (affection >= 10) {
                    availableMessages = [...RANDOM_MESSAGES.affectionLow, ...RANDOM_MESSAGES.basic];
                } else {
                    availableMessages = [...RANDOM_MESSAGES.affectionVeryLow, ...RANDOM_MESSAGES.basic];
                }
            }
            
            // 랜덤 선택
            const randomMessage = availableMessages[Math.floor(Math.random() * availableMessages.length)];
            return randomMessage.replace('{name}', spirit.name);
        }
        
        // 30초마다 랜덤 메시지 업데이트
        // 30초마다 랜덤 메시지 업데이트
        // 정령 간 상호작용
        function triggerSpiritInteraction() {
            
            if (isPaused) {
                return false;
            }
            
            // 살아있고 완성되지 않은 정령만 (알, 번데기 제외 - 움직일 수 없음)
            const activeSpirits = spirits.filter(s => {
                if (s.isDead || s.isCompleted) return false;
                const stage = getStage(s.growth);
                // 알(egg)과 번데기(pupa)는 움직일 수 없으므로 제외
                return stage === 'larva1' || stage === 'larva2' || stage === 'larva3';
            });
            
            // 2마리 이상일 때만 상호작용
            if (activeSpirits.length < 2) {
                return false;
            }
            
            // 기본 50% 확률, 매력 50 이상인 정령이 있으면 70%로 상승
            const hasCharmingSpirit = activeSpirits.some(s => s.parameters.charm >= 50);
            const interactionChance = hasCharmingSpirit ? 0.7 : 0.5;
            
            const randomValue = Math.random();
            if (randomValue > interactionChance) {
                return false;
            }
            
            
            // 랜덤하게 2마리 선택
            const spirit1 = activeSpirits[Math.floor(Math.random() * activeSpirits.length)];
            let spirit2;
            do {
                spirit2 = activeSpirits[Math.floor(Math.random() * activeSpirits.length)];
            } while (spirit2.id === spirit1.id);
            
            // 상호작용 종류 결정
            const interactionTypes = ['decoration', 'sharing', 'fight', 'rest', 'song', 'play', 'talk'];
            const weights = [20, 10, 5, 15, 10, 25, 15]; // 가중치 (%)
            
            let random = Math.random() * 100;
            let selectedType = 'play'; // 기본값
            let cumulative = 0;
            
            for (let i = 0; i < interactionTypes.length; i++) {
                cumulative += weights[i];
                if (random < cumulative) {
                    selectedType = interactionTypes[i];
                    break;
                }
            }
            
            
            // 메시지 선택 및 적용
            const messages = RANDOM_MESSAGES.interaction[selectedType];
            
            let message = messages[Math.floor(Math.random() * messages.length)];
            
            message = message
                .replace('{name1}', spirit1.name)
                .replace('{name2}', spirit2.name);
            
            
            // 미니어처 상호작용일 경우 미니어처 이름 추가
            if (selectedType === 'decoration') {
                if (installedDecorations.length > 0) {
                    const randomDeco = installedDecorations[Math.floor(Math.random() * installedDecorations.length)];
                    const decoType = typeof randomDeco === 'string' ? randomDeco : randomDeco.type;
                    const decoData = DECORATION_TYPES[decoType];
                    if (decoData) {
                        message = message.replace('{deco}', decoData.name);
                        console.log('[상호작用] 미니어처 이름 적용:', decoData.name);
                    } else {
                        return false; // 미니어처 데이터 없으면 취소
                    }
                } else {
                    return false; // 미니어처 없으면 취소
                }
            }
            
            // 효과 적용
            switch (selectedType) {
                case 'sharing': // 먹이 나눔 - 둘 다 성장 +1
                    spirit1.growth = Math.min(100, spirit1.growth + 1);
                    spirit2.growth = Math.min(100, spirit2.growth + 1);
                    break;
                    
                case 'song': // 노래 - 랜덤 스탯 +1
                    const statTypes = ['intelligence', 'strength', 'charm'];
                    const randomStat = statTypes[Math.floor(Math.random() * statTypes.length)];
                    spirit2.parameters[randomStat] += 1;
                    break;
                    
                case 'fight': // 싸움 - 약간의 스트레스, 애정도 -1
                    spirit1.parameters.affection = Math.max(0, spirit1.parameters.affection - 1);
                    spirit2.parameters.affection = Math.max(0, spirit2.parameters.affection - 1);
                    break;
                    
                case 'rest': // 휴식 - 만족도 회복
                    // 특별한 효과 없음, 메시지만
                    break;
            }
            
            // 두 정령 모두 같은 메시지 표시
            spirit1.status = message;
            spirit2.status = message;
            
            // 상호작용 시간 기록 (메시지 유지용)
            const now = Date.now();
            spirit1.lastSpiritInteraction = now;
            spirit2.lastSpiritInteraction = now;
            
            // 일지에 기록
            addLog(spirit1, message);
            
            // 성장도 체크 (100 이상이면 진화)
            if (spirit1.growth >= 100 && !spirit1.isCompleted) {
                completeSpirit(spirit1);
            }
            if (spirit2.growth >= 100 && !spirit2.isCompleted) {
                completeSpirit(spirit2);
            }
            
            saveGame();
            updateAllSpiritCards();
            
            return true; // 상호작용 발생!
        }

        function updateRandomMessages() {
            if (isPaused) return; // 일시정지 중이면 실행 안 함
            
            // 정령 간 상호작용 먼저 시도 (메시지 덮어쓰기 방지)
            const interactionOccurred = triggerSpiritInteraction();
            
            const now = Date.now();
            const activeSpirits = spirits.filter(s => !s.isDead && !s.isCompleted);
            
            // 전체 정령 메시지 먼저 결정 (크리스마스 정령이 있고 2마리 이상일 때)
            let globalMessage = null;
            const hasChristmasSpirit = spirits.some(s => s.isEventSpirit && s.eventType === 'christmas2025' && !s.isDead && !s.isCompleted);
            const hasChristmasTree = installedDecorations.some(d => {
                const decoType = typeof d === 'string' ? d : d.type;
                return decoType === 'christmas_tree';
            });
            
            if (hasChristmasSpirit && activeSpirits.length >= 2 && Math.random() < 0.15) {
                const globalMessages = [
                    `정령들이 다 같이 캐롤을 부릅니다 🎶`,
                    `정령들이 서로 선물을 교환하는 것 같습니다 🎁`,
                    `정령들이 함께 눈싸움을 합니다 ⛄`,
                    `정령들이 모두 모여 따뜻한 시간을 보냅니다 ☕`
                ];
                if (hasChristmasTree) {
                    globalMessages.push(`정령들이 다 같이 모여 크리스마스 트리를 구경합니다 🎄`);
                }
                globalMessage = globalMessages[Math.floor(Math.random() * globalMessages.length)];
            }
            
            // 전체 메시지가 선택되면 모든 정령에게 강제 적용
            if (globalMessage) {
                spirits.forEach(spirit => {
                    if (!spirit.isDead && !spirit.isCompleted) {
                        const oldStatus = spirit.status;
                        if (globalMessage !== oldStatus) {
                            addLog(spirit, globalMessage);
                        }
                        spirit.status = globalMessage;
                    }
                });
                updateAllSpiritCards();
                return;
            }
            
            // 전체 메시지가 없으면 개별 메시지 처리
            spirits.forEach(spirit => {
                if (!spirit.isDead && !spirit.isCompleted) {
                    // 정령 간 상호작용이 발생했으면 해당 정령 메시지 유지
                    if (interactionOccurred && spirit.lastSpiritInteraction && now - spirit.lastSpiritInteraction < 15000) {
                        return;
                    }
                    
                    // 최근 10초 이내에 플레이어 상호작용했으면 메시지 유지
                    const recentInteraction = (
                        (spirit.lastFeed && now - spirit.lastFeed < 10000) ||
                        (spirit.lastPat && now - spirit.lastPat < 10000) ||
                        (spirit.lastMusic && now - spirit.lastMusic < 10000)
                    );
                    
                    if (recentInteraction) {
                        return; // 메시지 유지
                    }
                    
                    const oldStatus = spirit.status;
                    const newStatus = getRandomMessage(spirit);
                    
                    // 메시지가 변경되었고, 특정 시스템 메시지가 아니면 일지에 기록
                    if (newStatus !== oldStatus && !newStatus.includes('듣고 있습니다')) {
                        addLog(spirit, newStatus);
                    }
                    
                    spirit.status = newStatus;
                }
            });
            
            updateAllSpiritCards();
        }
        
        // 5분 방치 체크 (애정도 감소)
        function checkNeglect() {
            if (isPaused) return; // 일시정지 중이면 실행 안 함
            if (tutorialActive) return; // 첫 튜토리얼 중이면 실행 안 함
            
            const now = Date.now();
            spirits.forEach(spirit => {
                if (spirit.isDead || spirit.isCompleted) return;
                
                // 알, 애벌레, 번데기 상태에서는 방치 체크 안 함
                if (!spirit.stage || spirit.stage === 'egg' || spirit.stage === 'larva' || spirit.stage === 'pupa') {
                    return;
                }
                
                // lastInteraction이 없으면 현재 시간으로 초기화 (구버전 호환)
                if (!spirit.lastInteraction) {
                    spirit.lastInteraction = now;
                    return;
                }
                
                // 일시정지 시간 제외한 실제 경과 시간 계산
                const currentPausedTime = isPaused ? (now - pausedAt) : 0;
                const effectivePausedTime = totalPausedTime + currentPausedTime;
                
                const timeSinceLastInteraction = (now - spirit.lastInteraction - effectivePausedTime) / 1000; // 초
                const minutesSinceInteraction = timeSinceLastInteraction / 60;
                
                // 5분마다 애정도 -1 감소
                // lastAffectionDrop이 없거나 5분 이상 지났으면 감소
                if (!spirit.lastAffectionDrop) {
                    spirit.lastAffectionDrop = now;
                }
                
                const timeSinceAffectionDrop = (now - spirit.lastAffectionDrop - effectivePausedTime) / 1000; // 초
                if (timeSinceAffectionDrop >= 300) { // 5분 = 300초
                    if (spirit.parameters.affection > 0) {
                        spirit.parameters.affection -= 1;
                        spirit.lastAffectionDrop = now;
                        addLog(spirit, '방치되어 애정도가 감소했습니다 (-1)');
                        saveGame();
                    }
                }
                
                // 아픈 상태에서 30분 방치 시 도망감
                if (spirit.isSick && !spirit.sickWarned && minutesSinceInteraction >= 30) {
                    spirit.sickWarned = true;
                    spirit.status = `${spirit.name}이(가) 아파서 괴로워합니다... 🤒💔`;
                    addLog(spirit, '아픈 상태로 오래 방치되고 있습니다!');
                    showNotification(`${spirit.name}이(가) 매우 괴로워합니다! 곧 떠날 수 있습니다!`);
                    saveGame();
                }
                
                // 아픈 상태에서 1시간 방치 시 도망감
                if (spirit.isSick && minutesSinceInteraction >= 60) {
                    spirit.status = `${spirit.name}이(가) 테라리움을 떠났습니다... 😢`;
                    addLog(spirit, '아픈 상태로 방치되어 떠났습니다');
                    showNotification(`😢 ${spirit.name}이(가) 테라리움을 떠났습니다...`);
                    deleteSpirit(spirit.id);
                    return;
                }
                
                // 건강한 상태에서 1시간(3600초) 방치 시 도망감
                if (!spirit.isSick && timeSinceLastInteraction >= 3600) {
                    spirit.status = `${spirit.name}이(가) 외로워서 테라리움을 떠났습니다... 😢`;
                    addLog(spirit, '오래 방치되어 떠났습니다');
                    showNotification(`😢 ${spirit.name}이(가) 외로워서 떠났습니다...`);
                    deleteSpirit(spirit.id);
                    return;
                }
            });
            updateAllSpiritCards();
        }

        // 데이터 백업 시스템
        function createBackup() {
            const backupData = {
                version: GAME_VERSION,
                collection: collection,
                encyclopedia: encyclopedia,
                timestamp: Date.now()
            };
            
            const backupJson = JSON.stringify(backupData, null, 2);
            const blob = new Blob([backupJson], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `spirit-garden-backup-${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            showNotification('백업 파일이 다운로드되었습니다!');
        }
        
        function importBackup() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const backupData = JSON.parse(event.target.result);
                        
                        // 백업 데이터 병합 (기존 데이터 유지)
                        if (backupData.collection && Array.isArray(backupData.collection)) {
                            backupData.collection.forEach(item => {
                                // 중복 체크 (같은 정령이 이미 있는지)
                                const exists = collection.some(c => 
                                    c.name === item.name && 
                                    c.originalName === item.originalName &&
                                    c.completedAt === item.completedAt
                                );
                                if (!exists) {
                                    collection.push(item);
                                }
                            });
                        }
                        
                        if (backupData.encyclopedia && typeof backupData.encyclopedia === 'object') {
                            // 도감 데이터 병합 (카운트 누적)
                            for (let key in backupData.encyclopedia) {
                                if (!encyclopedia[key]) {
                                    encyclopedia[key] = 0;
                                }
                                encyclopedia[key] += backupData.encyclopedia[key];
                            }
                        }
                        
                        saveGame();
                        renderCollection();
                        renderEncyclopedia();
                        showNotification(`백업 복원 완료! (앨범 ${backupData.collection?.length || 0}개 복원)`);
                    } catch (err) {
                        showNotification('백업 파일을 읽을 수 없습니다: ' + err.message);
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }

        function removeAllDecorations() {
            if (installedDecorations.length === 0) {
                showNotification('설치된 미니어처가 없습니다');
                return;
            }
            
            showConfirm(
                '미니어처 전체 해제',
                `설치된 미니어처 ${installedDecorations.length}개를 모두 해제하시겠습니까?`,
                () => {
                    // 모든 미니어처를 인벤토리로 반환
                installedDecorations.forEach(deco => {
                    // 문자열 또는 객체 모두 지원
                    const decoType = typeof deco === 'string' ? deco : deco.type;
                    inventory.decorations.push(decoType);
                    
                    // 테라리움 속성 감소
                    const decoData = DECORATION_TYPES[decoType];
                    if (decoData && terrarium[decoData.attr] !== undefined) {
                        terrarium[decoData.attr] = Math.max(0, terrarium[decoData.attr] - decoData.power);
                    }
                });
                
                installedDecorations = [];
                
                // 테라리움 환경 재계산
                recalculateTerrariumEnvironment();
                
                // 만족도 즉시 업데이트
                spirits.forEach(spirit => {
                    if (!spirit.isDead && !spirit.isCompleted) {
                        spirit.satisfaction = calculateSatisfaction(spirit);
                    }
                });
                
                saveGame();
                    renderTerrariumManagement();
                    renderInventory();
                    renderSpirits();  // 만족도 변경 반영
                    showNotification('모든 미니어처를 해제했습니다');
                }
            );
        }
        // ==================== 미니게임: 정령 지키기 ====================
        let minigameActive = false;
        let minigameScore = 0;
        let minigameLives = 3;
        let minigameWords = [];
        let minigameInterval = null;
        let minigameSpawnInterval = null;
        let minigameTimerInterval = null;
        let minigameTimeLeft = 60;
        let minigameDifficulty = 'normal';
        let minigameDefeated = 0;
        let minigamePaused = false;
        
        // 떨어지는 단어 목록 (해충, 독초, 잡초 등)
        const MINIGAME_ENEMIES = {
            easy: [
                // 해충
                { word: '애벌레', icon: '🐛' },
                { word: '해충', icon: '🪲' },
                { word: '바퀴', icon: '🪳' },
                { word: '진딧물', icon: '🐜' },
                { word: '달팽이', icon: '🐌' },
                { word: '지렁이', icon: '🪱' },
                { word: '딱정벌레', icon: '🪲' },
                { word: '메뚜기', icon: '🦗' },
                { word: '귀뚜라미', icon: '🦗' },
                { word: '하루살이', icon: '🪰' },
                { word: '나비유충', icon: '🐛' },
                // 독초/잡초
                { word: '독풀', icon: '🌿' },
                { word: '엉겅퀴', icon: '🌾' },
                { word: '쐐기풀', icon: '🌿' },
                { word: '덩굴', icon: '🌱' },
                { word: '가시덤불', icon: '🌵' },
                { word: '독버섯', icon: '🍄' },
                { word: '곰팡이', icon: '🦠' },
                { word: '이끼류', icon: '🪨' },
                // 기타
                { word: '거미줄', icon: '🕸️' },
                { word: '먼지', icon: '💨' }
            ],
            hard: [
                // 해충
                { word: '바퀴벌레', icon: '🪳' },
                { word: '집게벌레', icon: '🪲' },
                { word: '하늘소', icon: '🪲' },
                { word: '노린재', icon: '🪲' },
                { word: '총채벌레', icon: '🦟' },
                { word: '응애', icon: '🕷️' },
                { word: '진드기', icon: '🕷️' },
                { word: '독거미', icon: '🕷️' },
                { word: '지네', icon: '🐛' },
                { word: '그리마', icon: '🐛' },
                { word: '말벌', icon: '🐝' },
                { word: '땅벌', icon: '🐝' },
                { word: '쌀바구미', icon: '🪲' },
                { word: '흰개미', icon: '🐜' },
                { word: '기생충', icon: '🪱' },
                // 독초/잡초
                { word: '독미나리', icon: '🌿' },
                { word: '투구꽃', icon: '🌸' },
                { word: '미치광이풀', icon: '🌿' },
                { word: '협죽도', icon: '🌺' },
                { word: '천남성', icon: '🌱' },
                { word: '삿갓나물', icon: '🍀' },
                { word: '애기똥풀', icon: '🌼' },
                { word: '광대싸리', icon: '🌿' },
                { word: '독말풀', icon: '🌸' },
                { word: '곰팡이균', icon: '🦠' },
                // 기타
                { word: '해충떼', icon: '🪲' },
                { word: '독거미줄', icon: '🕸️' }
            ]
        };
        
        // 난이도별 설정
        const MINIGAME_SETTINGS = {
            easy: { spawnRate: 1700, fallSpeed: 2.2, maxWords: 5, coinMultiplier: 1 },
            hard: { spawnRate: 1200, fallSpeed: 2.8, maxWords: 8, coinMultiplier: 2 }
        };
        
        // 모바일 감지
        function isMobile() {
            return window.innerWidth <= 768;
        }
        
        // 모바일용 속도 조정 (화면이 작으니 더 느리게)
        function getMobileAdjustedSpeed(speed) {
            if (isMobile()) {
                return speed * 0.5; // 모바일에서 50% 속도
            }
            return speed;
        }
        
        function startMinigame() {
            minigameDifficulty = document.getElementById('minigameDifficulty').value;
            minigameActive = true;
            minigameScore = 0;
            minigameLives = 3;
            minigameWords = [];
            minigameDefeated = 0;
            minigamePaused = false;
            
            // 모바일 대응: body에 클래스 추가
            document.body.classList.add('minigame-active');
            
            // 화면 전환
            document.getElementById('minigameIntro').style.display = 'none';
            document.getElementById('minigamePlay').style.display = 'block';
            document.getElementById('minigameResult').style.display = 'none';
            
            // UI 초기화
            updateMinigameUI();
            
            // 입력 필드 초기화 (카운트다운 중에도 입력 가능)
            const input = document.getElementById('minigameInput');
            input.value = '';
            input.disabled = false; // 카운트다운 중에도 활성화
            
            // 바로 포커스 (카운트다운 중 준비 가능)
            setTimeout(() => {
                input.focus();
            }, 100);
            
            // 카운트다운 시작
            showMinigameCountdown(() => {
                // 카운트다운 완료 후 게임 시작
                
                // 모바일: 포커스 재확인
                setTimeout(() => {
                    input.focus();
                }, 100);
                
                // 입력 이벤트 리스너 (한글 조합 완료 후 처리)
                let isComposing = false;
                
                input.addEventListener('compositionstart', () => {
                    isComposing = true;
                });
                
                input.addEventListener('compositionend', (e) => {
                    isComposing = false;
                });
                
                // 스페이스바나 엔터로 단어 확정
                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        if (!isComposing) {
                            confirmMinigameInput();
                        }
                    }
                });
                
                // 게임 시작
                const settings = MINIGAME_SETTINGS[minigameDifficulty];
                
                // 모바일에서는 최대 단어 수 줄이기
                const maxWords = isMobile() ? Math.min(settings.maxWords, 3) : settings.maxWords;
                
                // 단어 생성 인터벌 (모바일에서는 더 느리게)
                const spawnRate = isMobile() ? settings.spawnRate * 1.3 : settings.spawnRate;
                
                minigameSpawnInterval = setInterval(() => {
                    if (!minigamePaused && minigameWords.length < maxWords) {
                        spawnMinigameWord();
                    }
                }, spawnRate);
                
                // 게임 루프 (단어 이동)
                minigameInterval = setInterval(() => {
                    if (!minigamePaused) {
                        updateMinigameWords();
                    }
                }, 50);
                
                // 타이머 시작 (1분 제한)
                minigameTimeLeft = 60;
                document.getElementById('minigameTimer').textContent = minigameTimeLeft;
                minigameTimerInterval = setInterval(() => {
                    if (!minigamePaused) {
                        minigameTimeLeft--;
                        document.getElementById('minigameTimer').textContent = minigameTimeLeft;
                        
                        // 10초 이하면 빨간색으로 표시
                        if (minigameTimeLeft <= 10) {
                            document.getElementById('minigameTimer').style.color = '#e74c3c';
                        }
                        
                        // 시간 종료
                        if (minigameTimeLeft <= 0) {
                            endMinigame();
                        }
                    }
                }, 1000);
                
                // 첫 단어 바로 생성
                spawnMinigameWord();
            });
        }
        
        // 미니게임 카운트다운
        function showMinigameCountdown(onComplete) {
            const gameArea = document.getElementById('minigameArea');
            
            // 카운트다운 오버레이 생성
            const overlay = document.createElement('div');
            overlay.id = 'minigameCountdown';
            overlay.style.cssText = `
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.8);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 1000;
            `;
            
            const countText = document.createElement('div');
            countText.style.cssText = `
                font-size: 5rem;
                font-weight: bold;
                color: white;
                text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
                animation: countPulse 0.5s ease-out;
            `;
            
            // 애니메이션 스타일 추가
            if (!document.getElementById('countdownStyle')) {
                const style = document.createElement('style');
                style.id = 'countdownStyle';
                style.textContent = `
                    @keyframes countPulse {
                        0% { transform: scale(1.5); opacity: 0; }
                        50% { transform: scale(1.1); opacity: 1; }
                        100% { transform: scale(1); opacity: 1; }
                    }
                `;
                document.head.appendChild(style);
            }
            
            overlay.appendChild(countText);
            gameArea.style.position = 'relative';
            gameArea.appendChild(overlay);
            
            const counts = ['3', '2', '1', '🎮 START!'];
            let index = 0;
            
            function showNext() {
                if (index < counts.length) {
                    countText.textContent = counts[index];
                    countText.style.animation = 'none';
                    countText.offsetHeight; // 리플로우 트리거
                    countText.style.animation = 'countPulse 0.5s ease-out';
                    
                    if (counts[index] === '🎮 START!') {
                        countText.style.fontSize = '3rem';
                        countText.style.color = '#2ecc71';
                    }
                    
                    index++;
                    
                    if (index < counts.length) {
                        setTimeout(showNext, 800);
                    } else {
                        // START! 표시 후 잠시 대기 후 제거
                        setTimeout(() => {
                            overlay.remove();
                            if (onComplete) onComplete();
                        }, 500);
                    }
                }
            }
            
            showNext();
        }
        
        function spawnMinigameWord() {
            const area = document.getElementById('minigameArea');
            const areaWidth = area.offsetWidth;
            const enemies = MINIGAME_ENEMIES[minigameDifficulty];
            const enemy = enemies[Math.floor(Math.random() * enemies.length)];
            
            // 단어 길이에 따른 예상 너비 계산 (글자당 약 18px + 패딩 + 아이콘)
            const estimatedWidth = (enemy.word.length * 18) + 60;
            // 최소 20px 여백, 최대 (화면너비 - 예상너비 - 20px)
            const maxX = Math.max(20, areaWidth - estimatedWidth - 20);
            
            // 모바일에서는 속도 감소
            const baseSpeed = MINIGAME_SETTINGS[minigameDifficulty].fallSpeed + (Math.random() * 0.5);
            const adjustedSpeed = getMobileAdjustedSpeed(baseSpeed);
            
            const wordObj = {
                id: Date.now() + Math.random(),
                word: enemy.word,
                icon: enemy.icon,
                x: Math.random() * maxX + 10,
                y: -50,
                speed: adjustedSpeed
            };
            
            // DOM 요소 생성
            const wordEl = document.createElement('div');
            wordEl.id = 'word-' + wordObj.id;
            wordEl.className = 'minigame-word';
            wordEl.style.cssText = `
                position: absolute;
                left: ${wordObj.x}px;
                top: ${wordObj.y}px;
                background: linear-gradient(135deg, #2c3e50, #34495e);
                color: white;
                padding: 8px 14px;
                border-radius: 20px;
                font-size: 1rem;
                font-weight: 600;
                white-space: nowrap;
                box-shadow: 0 4px 15px rgba(0,0,0,0.3);
                display: flex;
                align-items: center;
                gap: 6px;
                z-index: 10;
                transition: transform 0.1s;
            `;
            wordEl.innerHTML = `${enemy.word}`;
            
            area.appendChild(wordEl);
            minigameWords.push(wordObj);
        }
        
        function updateMinigameWords() {
            const area = document.getElementById('minigameArea');
            const areaHeight = area.offsetHeight;
            const settings = MINIGAME_SETTINGS[minigameDifficulty];
            
            minigameWords.forEach((wordObj, index) => {
                wordObj.y += wordObj.speed;
                
                const wordEl = document.getElementById('word-' + wordObj.id);
                if (wordEl) {
                    wordEl.style.top = wordObj.y + 'px';
                }
                
                // 바닥에 도달
                if (wordObj.y > areaHeight - 100) {
                    removeMinigameWord(wordObj.id, false);
                    minigameLives--;
                    
                    // 정령 피격 효과
                    const spirit = document.getElementById('minigameSpirit');
                    spirit.style.transform = 'translateX(-50%) scale(0.8)';
                    spirit.style.filter = 'drop-shadow(0 4px 8px rgba(0,0,0,0.3)) brightness(0.5)';
                    setTimeout(() => {
                        spirit.style.transform = 'translateX(-50%) scale(1)';
                        spirit.style.filter = 'drop-shadow(0 4px 8px rgba(0,0,0,0.3))';
                    }, 300);
                    
                    updateMinigameUI();
                    
                    if (minigameLives <= 0) {
                        endMinigame();
                    }
                }
            });
        }
        
        function confirmMinigameInput() {
            const input = document.getElementById('minigameInput');
            const typed = input.value.trim();
            
            if (!typed) return;
            
            // 정확히 일치하는 단어 찾기 (여러 개면 아래에 있는 것 우선)
            const exactMatches = minigameWords
                .filter(w => w.word === typed)
                .sort((a, b) => b.y - a.y);
            
            if (exactMatches.length > 0) {
                processMatchedWord(exactMatches[0], input);
            } else {
                // 일치하는 단어 없음 - 입력 초기화 (틀린 것)
                setTimeout(() => {
                    input.value = '';
                }, 0);
            }
        }
        
        function processMatchedWord(matched, input) {
            // 점수 계산 (단어 길이 + 빠른 처치 보너스)
            const lengthBonus = matched.word.length * 10;
            const speedBonus = Math.max(0, Math.floor((400 - matched.y) / 10));
            minigameScore += lengthBonus + speedBonus;
            minigameDefeated++;
            
            // 제거 효과
            removeMinigameWord(matched.id, true);
            
            // 보호막 효과
            const shield = document.getElementById('shieldEffect');
            shield.style.opacity = '1';
            setTimeout(() => {
                shield.style.opacity = '0';
            }, 200);
            
            // 입력 초기화 (setTimeout으로 조합 완료 후 클리어)
            setTimeout(() => {
                input.value = '';
            }, 0);
            
            updateMinigameUI();
        }
        
        function removeMinigameWord(id, success) {
            const wordEl = document.getElementById('word-' + id);
            if (wordEl) {
                if (success) {
                    // 성공 효과
                    wordEl.style.transform = 'scale(1.3)';
                    wordEl.style.opacity = '0';
                    wordEl.style.background = 'linear-gradient(135deg, #27ae60, #2ecc71)';
                    setTimeout(() => wordEl.remove(), 200);
                } else {
                    // 실패 효과 (빨간색)
                    wordEl.style.background = 'linear-gradient(135deg, #c0392b, #e74c3c)';
                    wordEl.style.transform = 'scale(0.5)';
                    wordEl.style.opacity = '0';
                    setTimeout(() => wordEl.remove(), 300);
                }
            }
            minigameWords = minigameWords.filter(w => w.id !== id);
        }
        
        function updateMinigameUI() {
            document.getElementById('minigameScore').textContent = minigameScore;
            
            let hearts = '';
            for (let i = 0; i < 3; i++) {
                hearts += i < minigameLives ? '❤️' : '🖤';
            }
            document.getElementById('minigameLives').textContent = hearts;
        }
        
        function pauseMinigame() {
            minigamePaused = true;
        }
        
        function resumeMinigame() {
            minigamePaused = false;
            document.getElementById('minigameInput').focus();
        }
        
        function endMinigame() {
            minigameActive = false;
            
            // 모바일 대응: body 클래스 제거
            document.body.classList.remove('minigame-active');
            
            // 인터벌 정리
            if (minigameInterval) {
                clearInterval(minigameInterval);
                minigameInterval = null;
            }
            if (minigameSpawnInterval) {
                clearInterval(minigameSpawnInterval);
                minigameSpawnInterval = null;
            }
            if (minigameTimerInterval) {
                clearInterval(minigameTimerInterval);
                minigameTimerInterval = null;
            }
            
            // 타이머 색상 초기화
            document.getElementById('minigameTimer').style.color = '';
            
            // 남은 단어 제거
            minigameWords.forEach(w => {
                const el = document.getElementById('word-' + w.id);
                if (el) el.remove();
            });
            minigameWords = [];
            
            // 결과 화면 표시
            document.getElementById('minigamePlay').style.display = 'none';
            document.getElementById('minigameResult').style.display = 'block';
            
            // 결과 업데이트
            document.getElementById('finalScore').textContent = minigameScore;
            document.getElementById('defeatedCount').textContent = minigameDefeated;
            
            // 결과 아이콘 & 메시지
            let icon, title;
            if (minigameScore >= 500) {
                icon = '🏆';
                title = '대단해요!';
            } else if (minigameScore >= 200) {
                icon = '🎉';
                title = '잘했어요!';
            } else if (minigameScore >= 100) {
                icon = '👍';
                title = '좋아요!';
            } else {
                icon = '💪';
                title = '다음엔 더 잘할 수 있어요!';
            }
            document.getElementById('resultIcon').textContent = icon;
            document.getElementById('resultTitle').textContent = title;
            
            // 보상 계산 (코인은 점수의 1/10 * 난이도 배수)
            const settings = MINIGAME_SETTINGS[minigameDifficulty];
            const coinReward = Math.floor(minigameScore / 10 * settings.coinMultiplier);
            document.getElementById('coinRewardAmount').textContent = '+' + coinReward;
        }
        
        function claimReward(type) {
            const settings = MINIGAME_SETTINGS[minigameDifficulty];
            
            if (type === 'coin') {
                const reward = Math.floor(minigameScore / 10 * settings.coinMultiplier);
                coins += reward;
                updateCoinDisplay();
                saveGame();
                showNotification(`💰 ${reward} 코인을 획득했습니다!`);
            } else if (type === 'item') {
                // 난이도와 점수에 따라 아이템 등급 결정
                let itemPool = [];
                
                if (minigameDifficulty === 'hard' && minigameScore >= 400) {
                    // 어려움 + 고득점: 전설급 아이템 (미니게임 전용)
                    itemPool = [
                        { type: 'decoration', item: 'fire_legendary', name: '태초의 불꽃' },
                        { type: 'decoration', item: 'water_legendary', name: '심해의 심장' },
                        { type: 'decoration', item: 'wind_legendary', name: '폭풍의 눈' },
                        { type: 'decoration', item: 'earth_legendary', name: '대지의 정수' },
                        { type: 'decoration', item: 'light_legendary', name: '천상의 광휘' },
                        { type: 'decoration', item: 'dark_legendary', name: '영원한 어둠' }
                    ];
                    showNotification('🌟 전설급 아이템 획득 기회!');
                } else if (minigameDifficulty === 'hard' && minigameScore >= 250) {
                    // 어려움 + 중간 점수: 에픽 아이템
                    itemPool = [
                        { type: 'decoration', item: 'fire_epic', name: '불사조 깃털' },
                        { type: 'decoration', item: 'water_epic', name: '인어의 눈물' },
                        { type: 'decoration', item: 'wind_epic', name: '하늘의 깃털' },
                        { type: 'decoration', item: 'earth_epic', name: '세계수 가지' },
                        { type: 'decoration', item: 'light_epic', name: '별의 파편' },
                        { type: 'decoration', item: 'dark_epic', name: '밤의 정수' },
                        { type: 'food', item: 'light', name: '빛나는 넥타' },
                        { type: 'food', item: 'dark', name: '검은 꽃가루' }
                    ];
                } else if (minigameScore >= 200) {
                    // 쉬움 고득점 또는 어려움 저득점: 레어 아이템
                    itemPool = [
                        { type: 'decoration', item: 'fire_rare1', name: '불꽃 조각상' },
                        { type: 'decoration', item: 'water_rare1', name: '산호 장식' },
                        { type: 'decoration', item: 'wind_rare1', name: '풍경' },
                        { type: 'decoration', item: 'earth_rare1', name: '나무 조각' },
                        { type: 'decoration', item: 'light_rare1', name: '빛나는 보석' },
                        { type: 'decoration', item: 'dark_rare1', name: '달빛석' },
                        { type: 'food', item: 'light', name: '빛나는 넥타' },
                        { type: 'food', item: 'dark', name: '검은 꽃가루' }
                    ];
                } else if (minigameScore >= 100) {
                    // 중간 점수: 일반 아이템
                    itemPool = [
                        { type: 'food', item: 'fire', name: '불꽃열매' },
                        { type: 'food', item: 'water', name: '맑은이슬' },
                        { type: 'food', item: 'wind', name: '바람꿀' },
                        { type: 'food', item: 'earth', name: '대지버섯' },
                        { type: 'decoration', item: 'fire_common1', name: '용암석' },
                        { type: 'decoration', item: 'water_common1', name: '분수' },
                        { type: 'decoration', item: 'wind_common1', name: '바람개비' },
                        { type: 'decoration', item: 'earth_common1', name: '화분' }
                    ];
                } else {
                    // 낮은 점수: 기본 먹이만
                    itemPool = [
                        { type: 'food', item: 'fire', name: '불꽃열매' },
                        { type: 'food', item: 'water', name: '맑은이슬' },
                        { type: 'food', item: 'wind', name: '바람꿀' },
                        { type: 'food', item: 'earth', name: '대지버섯' }
                    ];
                }
                
                const reward = itemPool[Math.floor(Math.random() * itemPool.length)];
                
                // 인벤토리에 추가
                if (reward.type === 'food') {
                    inventory.food.push(reward.item);
                } else if (reward.type === 'decoration') {
                    inventory.decorations.push(reward.item);
                } else if (reward.type === 'music') {
                    inventory.music.push(reward.item);
                }
                
                // 전설급 아이템이면 특별 알림
                const decoData = DECORATION_TYPES[reward.item];
                if (decoData && decoData.quality === 'legendary') {
                    showNotification(`🌟 전설급! ${decoData.icon} ${reward.name}을(를) 획득했습니다!`);
                } else {
                    showNotification(`🎁 ${reward.name}을(를) 획득했습니다!`);
                }
                
                saveGame();
                renderInventory();
            }
            
            // 보상 버튼 비활성화
            document.getElementById('rewardSection').innerHTML = `
                <div style="color: var(--wind); font-size: 1.2rem; font-weight: 700;">✓ 보상을 받았습니다!</div>
            `;
        }
        
        function backToMinigameIntro() {
            document.getElementById('minigameIntro').style.display = 'block';
            document.getElementById('minigamePlay').style.display = 'none';
            document.getElementById('minigameResult').style.display = 'none';
            
            // 보상 섹션 복구
            document.getElementById('rewardSection').innerHTML = `
                <h4 style="font-size: 1.2rem; margin-bottom: 20px; color: var(--text);">보상을 선택하세요</h4>
                <div style="display: flex; gap: 20px; justify-content: center; flex-wrap: wrap;">
                    <button onclick="claimReward('coin')" class="reward-btn" style="padding: 20px 30px; background: linear-gradient(135deg, #FFD700, #FFA500); color: #333; border: none; border-radius: 12px; cursor: pointer; min-width: 150px;">
                        <div style="font-size: 2rem; margin-bottom: 8px;">💰</div>
                        <div style="font-weight: 700;">코인 받기</div>
                        <div id="coinRewardAmount" style="font-size: 0.9rem; margin-top: 4px;">+0</div>
                    </button>
                    <button onclick="claimReward('item')" class="reward-btn" style="padding: 20px 30px; background: linear-gradient(135deg, #9B59B6, #8E44AD); color: white; border: none; border-radius: 12px; cursor: pointer; min-width: 150px;">
                        <div style="font-size: 2rem; margin-bottom: 8px;">🎁</div>
                        <div style="font-weight: 700;">아이템 받기</div>
                        <div style="font-size: 0.9rem; margin-top: 4px;">랜덤 보상</div>
                    </button>
                </div>
            `;
        }
        // ==================== 미니게임 끝 ====================

        function closeModal(modalId) {
            document.getElementById(modalId).classList.remove('active');
        }

        // 상점 알림용 변수
        let shopNotificationData = {
            element: null,
            itemName: null,
            action: null, // 'buy' or 'sell'
            count: 0,
            price: 0,
            timeout: null
        };
        
        function showShopNotification(itemName, action, price) {
            // 같은 아이템, 같은 액션이면 기존 알림 업데이트
            if (shopNotificationData.element && 
                shopNotificationData.itemName === itemName && 
                shopNotificationData.action === action) {
                
                shopNotificationData.count++;
                shopNotificationData.price += price;
                
                const actionText = action === 'sell' ? '판매' : '구매';
                shopNotificationData.element.textContent = `${itemName}(을)를 ${shopNotificationData.count}개 ${shopNotificationData.price}💰에 ${actionText}했습니다`;
                
                // 타이머 리셋
                if (shopNotificationData.timeout) {
                    clearTimeout(shopNotificationData.timeout);
                }
                shopNotificationData.timeout = setTimeout(() => {
                    if (shopNotificationData.element) {
                        shopNotificationData.element.style.animation = 'slideOut 0.3s ease-out';
                        setTimeout(() => {
                            if (shopNotificationData.element) {
                                shopNotificationData.element.remove();
                            }
                            shopNotificationData = { element: null, itemName: null, action: null, count: 0, price: 0, timeout: null };
                        }, 300);
                    }
                }, 2000);
                
                return;
            }
            
            // 기존 상점 알림이 있으면 즉시 제거
            if (shopNotificationData.element) {
                shopNotificationData.element.remove();
                if (shopNotificationData.timeout) {
                    clearTimeout(shopNotificationData.timeout);
                }
            }
            
            // 새 알림 생성
            const notif = document.createElement('div');
            notif.className = 'notification shop-notification';
            const actionText = action === 'sell' ? '판매' : '구매';
            notif.textContent = `${itemName}(을)를 1개 ${price}💰에 ${actionText}했습니다`;
            notif.style.top = '80px';
            document.body.appendChild(notif);
            
            shopNotificationData = {
                element: notif,
                itemName: itemName,
                action: action,
                count: 1,
                price: price,
                timeout: setTimeout(() => {
                    notif.style.animation = 'slideOut 0.3s ease-out';
                    setTimeout(() => {
                        notif.remove();
                        shopNotificationData = { element: null, itemName: null, action: null, count: 0, price: 0, timeout: null };
                    }, 300);
                }, 2000)
            };
        }
        
        function showNotification(message) {
            // 기존 알림들의 개수를 세서 위치 조정 (상점 알림 제외)
            const existingNotifs = document.querySelectorAll('.notification:not(.shop-notification)');
            const shopNotifExists = document.querySelector('.shop-notification') ? 1 : 0;
            const offset = (existingNotifs.length + shopNotifExists) * 70;
            
            const notif = document.createElement('div');
            notif.className = 'notification';
            notif.textContent = message;
            notif.style.top = `${80 + offset}px`;
            document.body.appendChild(notif);
            
            setTimeout(() => {
                notif.style.animation = 'slideOut 0.3s ease-out';
                setTimeout(() => notif.remove(), 300);
            }, 3000);
        }
        
        // 키워드 설명 표시 (모바일용 클릭/터치)
        function showKeywordDesc(keyword, desc) {
            if (!desc) return;
            
            // 기존 키워드 툴팁이 있으면 제거
            const existingTooltip = document.querySelector('.keyword-tooltip');
            if (existingTooltip) {
                existingTooltip.remove();
            }
            
            const tooltip = document.createElement('div');
            tooltip.className = 'keyword-tooltip';
            tooltip.innerHTML = `
                <div style="font-weight: 600; margin-bottom: 6px; color: var(--text);">${keyword}</div>
                <div style="color: #666; line-height: 1.5;">${desc}</div>
            `;
            tooltip.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: var(--card);
                border: 2px solid var(--border);
                border-radius: 12px;
                padding: 16px 20px;
                max-width: 300px;
                box-shadow: 0 4px 20px rgba(0,0,0,0.2);
                z-index: 10001;
                animation: fadeIn 0.2s ease-out;
            `;
            
            // 배경 오버레이
            const overlay = document.createElement('div');
            overlay.className = 'keyword-tooltip-overlay';
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.3);
                z-index: 10000;
            `;
            overlay.onclick = () => {
                tooltip.remove();
                overlay.remove();
            };
            
            document.body.appendChild(overlay);
            document.body.appendChild(tooltip);
            
            // 3초 후 자동 닫기
            setTimeout(() => {
                if (document.body.contains(tooltip)) {
                    tooltip.remove();
                    overlay.remove();
                }
            }, 5000);
        }

        function updateTimeDisplay() {
            const now = new Date();
            const timeStr = now.toLocaleTimeString('ko-KR', { 
                hour: '2-digit', 
                minute: '2-digit',
                second: '2-digit'
            });
            document.getElementById('timeDisplay').textContent = timeStr;
        }

        // 게임 루프
        setInterval(() => {
            saveGame();
        }, 5000);

        // 1초마다 버튼 상태 및 정령 상태 체크
        setInterval(() => {
            checkSpiritStatus();
            // garden 탭이 활성화된 경우에만 카드 업데이트
            if (currentTab === 'garden') {
                updateCooldownDisplay();  // 쿨타임 텍스트만 업데이트 (성능 최적화)
                spirits.forEach(spirit => {
                    updateSpiritCard(spirit);
                });
            }
            updateGatherButton();
        }, 1000);

        // 1분마다 성장도 증가
        setInterval(() => {
            applyGrowth();
        }, 60000);  // 60000ms = 1분

        // 5분마다 테라리움 환경 효과 적용
        setInterval(() => {
            applyTerrariumGrowth();
        }, 300000);  // 300000ms = 5분

        // 만족도 업데이트 (1분마다)
        setInterval(() => {
            if (isPaused) return; // 일시정지 중이면 실행 안 함
            if (tutorialActive) return; // 첫 튜토리얼 중이면 실행 안 함
            
            spirits.forEach(spirit => {
                if (spirit.isDead || spirit.isCompleted) return;
                
                // 성장도 체크 (100 이상이면 자동 진화)
                if (spirit.growth >= STAGE_REQUIREMENTS.adult && !spirit.isCompleted) {
                    completeSpirit(spirit);
                    return;
                }
                
                const oldSatisfaction = spirit.satisfaction || 'mid';
                const newSatisfaction = calculateSatisfaction(spirit);
                spirit.satisfaction = newSatisfaction;
                
                // 만족도에 따른 애정도 변화
                if (newSatisfaction === 'high') {
                    spirit.parameters.affection += 1;
                } else if (newSatisfaction === 'low') {
                    spirit.parameters.affection = Math.max(0, spirit.parameters.affection - 1);
                }
                
                // 만족도가 변경되었을 때 로그
                if (oldSatisfaction !== newSatisfaction) {
                    const satisfactionTexts = {
                        high: '매우 만족스러워 보입니다!',
                        mid: '평온해 보입니다.',
                        low: '불만족스러워 보입니다...'
                    };
                    addLog(spirit, satisfactionTexts[newSatisfaction]);
                }
            });
            saveGame();
            updateAllSpiritCards();
        }, 60000); // 60초마다

        setInterval(updateTimeDisplay, 1000);
        setInterval(updateRandomMessages, 15000); // 15초마다 랜덤 메시지 업데이트
        setInterval(checkNeglect, 60000); // 1분마다 방치 체크

        // 오프닝 스토리
        const OPENING_SCENES = [
            "먼 미래...",
            "인간들에 의한 오염으로\n지구에서 정령들의 서식지가\n줄어들기 시작했다.",
            "자연스럽게 정령들의 숫자는 줄어들어갔고\n지구의 자정작용은 기능을 잃게 된다.",
            "푸른 자연은 사라지고\n기계와 쓰레기의 산만 쌓여가던 어느 날...",
            "정령의 알이 열리는 식물을\n발견한 인간이 있었다.",
            "모두가 불가능하리라 예상했지만\n그는 작은 테라리움 안에서\n정령을 길러내는 데 성공한다.",
            "그 이후로도 그를 따라\n테라리움에서 정령을 인공사육하여\n자연으로 방사하는 사람들이 늘어갔다.",
            "다른 사람들은 그들을\n'테라리움 키퍼'라고 불렀다.",
            "이것은 작은 테라리움에서 시작되는\n당신의 이야기."
        ];
        
        let currentOpeningScene = 0;
        
        function showOpening() {
            console.log('showOpening 함수 실행됨');
            const modal = document.getElementById('openingModal');
            console.log('모달 요소:', modal);
            if (modal) {
                modal.style.display = 'flex';
                currentOpeningScene = 0;
                showOpeningText();
                console.log('오프닝 모달 표시됨');
            } else {
                console.error('오프닝 모달을 찾을 수 없음!');
            }
        }
        
        function showOpeningText() {
            const textEl = document.getElementById('openingText');
            const nextBtn = document.getElementById('openingNextBtn');
            
            textEl.style.opacity = '0';
            
            setTimeout(() => {
                textEl.innerHTML = OPENING_SCENES[currentOpeningScene].replace(/\n/g, '<br>');
                textEl.style.opacity = '1';
                
                setTimeout(() => {
                    nextBtn.style.display = 'inline-block';
                    if (currentOpeningScene === OPENING_SCENES.length - 1) {
                        nextBtn.textContent = '시작하기';
                    } else {
                        nextBtn.textContent = '다음';
                    }
                }, 500);
            }, 300);
        }
        
        function nextOpeningScene() {
            const nextBtn = document.getElementById('openingNextBtn');
            nextBtn.style.display = 'none';
            
            currentOpeningScene++;
            
            if (currentOpeningScene >= OPENING_SCENES.length) {
                closeOpening();
            } else {
                showOpeningText();
            }
        }
        
        function skipOpening() {
            closeOpening();
        }
        
        function closeOpening() {
            const modal = document.getElementById('openingModal');
            modal.style.opacity = '0';
            modal.style.transition = 'opacity 0.5s';
            
            setTimeout(() => {
                modal.style.display = 'none';
                modal.style.opacity = '1';
                // 오프닝 본 것으로 저장
                localStorage.setItem('spiritGarden_openingSeen', 'true');
                // 튜토리얼 시작
                startTutorial();
            }, 500);
        }
        
        // ========== 튜토리얼 시스템 ==========
        let tutorialStep = 0;
        let tutorialActive = false;
        
        const TUTORIAL_STEPS = [
            {
                type: 'dialog',
                text: '아, 새로 온 수습이 너구나? 어서와! 나는 이 연구소를 관리하는 테라리움 키퍼고 앞으로 널 책임질 선배야.'
            },
            {
                type: 'dialog',
                text: '일을 하는건 처음이니 기본적인 것들을 알려줄게. 잘 들어둬.'
            },
            {
                type: 'action',
                action: 'getEgg',
                text: '자, 먼저 정령 알을 받아보자. 아래로 내리면 "새로운 알 받기" 버튼이 있을거야.'
            },
            {
                type: 'dialog',
                text: '잘하는데? 정령들의 알은 정령나무의 열매라는거 알지? 이 알들은 기본적으로 무속성이야.'
            },
            {
                type: 'dialog',
                text: '그리고 먹이와 테라리움을 꾸며 속성을 가진 정령으로 자랄 수 있게 관리하는 게 우리 테라리움 키퍼들의 임무지.'
            },
            {
                type: 'action',
                action: 'feed',
                text: '아차, 말이 너무 길어졌네. 알이 배고파하는 것 같은데? "먹이주기" 버튼을 눌러서 먹이를 줘봐.'
            },
            {
                type: 'dialog',
                text: '먹이마다 다른 속성이 있어서, 어떤 먹이를 주느냐에 따라 정령의 속성치가 달라져.'
            },
            {
                type: 'action',
                action: 'music',
                text: '그리고 정령들의 언어가 노래라는 것도 학원에서 배웠겠지? 정령들은 노래를 들으며 세상의 지식을 흡수해. "음악 듣기"를 눌러봐.'
            },
            {
                type: 'dialog',
                text: '음악도 종류마다 다른 능력치를 올려줘. 클래식은 지력, 팝은 매력 같은 식이지.'
            },
            {
                type: 'action',
                action: 'pat',
                text: '어차피 떠나보내야 한다고 먹이만 주는 녀석들도 있지만... 우리 연구소는 정령과 교감하는 것도 중요하다고 생각해. "쓰다듬기"를 눌러봐.'
            },
            {
                type: 'action',
                action: 'clickName',
                text: '그리고 정령에게 이름을 지어줄 수도 있어. 정령 카드에서 노란색으로 강조된 이름 부분을 눌러봐.'
            },
            {
                type: 'action',
                action: 'rename',
                text: '자, 입력창에 새 이름을 지어주고 확인을 누르면 돼.'
            },
            {
                type: 'dialog',
                text: '잘했어. 꼭 이름을 지어줘야 하는 건 아니지만, 그래도 불러줄 이름이 있는 편이 훨씬 좋다고 생각하거든.'
            },
            {
                type: 'dialog',
                text: '이게 기본적인 정령 육성 방법이야. 테라리움 관리까지 생각하면 더 복잡하지만 그건 천천히 익히도록 해.'
            },
            {
                type: 'dialog',
                text: '아까 속성 이야기를 잠깐 했지? 이미 알고 있겠지만 복습할 겸 다시 이야기하자면.'
            },
            {
                type: 'dialog',
                text: '속성에는 <span style="color:#e74c3c;font-weight:bold;">불</span>, <span style="color:#3498db;font-weight:bold;">물</span>, <span style="color:#27ae60;font-weight:bold;">땅</span>, <span style="color:#1abc9c;font-weight:bold;">바람</span> 기본 4대원소와 희귀원소인 <span style="color:#f1c40f;font-weight:bold;">빛</span>, <span style="color:#9b59b6;font-weight:bold;">어둠</span>이 있어.'
            },
            {
                type: 'dialog',
                text: '유충 상태의 정령은 이 여섯 가지 속성의 영향을 받아 자라게 돼. 불속성을 많이 접하면 불의 정령이 되고, 물속성을 많이 접하면 물의 정령이 되지.'
            },
            {
                type: 'dialog',
                text: '가끔 두 가지 속성이 섞여 다른 속성의 정령으로 진화하기도 하지만, 처음엔 한 가지 속성에 집중하는 게 좋아.'
            },
            {
                type: 'dialog',
                text: '그리고 다른 속성이 두 개 더 있는데... 그건 바로 <span style="color:#f39c12;font-weight:bold;">태양</span>과 <span style="color:#95a5a6;font-weight:bold;">달</span>이야.'
            },
            {
                type: 'action',
                action: 'toggleLight',
                text: '탭 맨 오른쪽에 있는 태양 버튼을 눌러볼래?'
            },
            {
                type: 'dialog',
                text: '그 버튼으로 테라리움의 조도를 설정할 수 있어. 조도의 양에 따라 <span style="color:#95a5a6;font-weight:bold;">달</span>의 정령이 되는지 <span style="color:#f39c12;font-weight:bold;">태양</span>의 정령이 되는지 달라지니까 이것도 신경쓰는 게 좋아.'
            },
            {
                type: 'dialog',
                text: '그리고 먹이나 레코드, 테라리움을 장식할 장식품들은 채집으로 얻을 수 있어.'
            },
            {
                type: 'dialog',
                text: '도저히 찾을 수 없는 게 있다면 상점에 가면 되고.'
            },
            {
                type: 'dialog',
                text: '너무 쪼들린다면 아르바이트도 해야 하니까 각오해. 전세계 모든 테라리움 관리 연구소가 그렇지만 연구비가 넉넉치 않거든.'
            },
            {
                type: 'dialog',
                text: '자, 그럼 선배로서 설명해줄 건 여기까지야. 나머지는 직접 부딪혀 가면서 배우도록 해. 그럼 이만!'
            }
        ];
        
        // 튜토리얼 다시보기 목록 렌더링
        function renderTutorialReplayList() {
            const container = document.getElementById('tutorialReplayList');
            if (!container) return;
            
            const tutorials = [
                {
                    id: 'basic',
                    name: '기본 튜토리얼',
                    desc: '정령 육성의 기초를 배웁니다',
                    icon: '🥚',
                    gradient: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
                    seenKey: 'spiritGarden_tutorialSeen',
                    completedKey: 'spiritGarden_tutorialCompleted',
                    reward: 25,
                    alwaysUnlocked: true // 기본 튜토리얼은 항상 열려있음
                },
                {
                    id: 'album',
                    name: '앨범 & 도감 튜토리얼',
                    desc: '정령 완성 후 앨범과 도감 사용법',
                    icon: '💝',
                    gradient: 'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)',
                    seenKey: 'spiritGarden_tutorial2Seen',
                    completedKey: 'spiritGarden_tutorial2Completed',
                    reward: 25,
                    unlockCondition: () => collection.length > 0 // 앨범에 정령이 있어야 해금
                },
                {
                    id: 'sick',
                    name: '질병 튜토리얼',
                    desc: '정령이 아플 때 치료하는 방법',
                    icon: '💊',
                    gradient: 'linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)',
                    seenKey: 'spiritGarden_sickTutorialSeen',
                    completedKey: 'spiritGarden_sickTutorialCompleted',
                    reward: 25,
                    unlockCondition: () => localStorage.getItem('spiritGarden_tutorialSeen') // 기본 튜토리얼 완료 후
                },
                {
                    id: 'lab',
                    name: '연구실 튜토리얼',
                    desc: '합성과 연결 시스템 사용법',
                    icon: '🔬',
                    gradient: 'linear-gradient(135deg, #fa709a 0%, #fee140 100%)',
                    seenKey: 'spiritGarden_labTutorialSeen',
                    completedKey: 'spiritGarden_labTutorialCompleted',
                    reward: 25,
                    unlockCondition: () => collection.length >= 2 // 앨범에 정령 2마리 이상
                }
            ];
            
            let html = '';
            
            tutorials.forEach(tutorial => {
                const seen = localStorage.getItem(tutorial.seenKey);
                const completed = localStorage.getItem(tutorial.completedKey);
                // 이미 본 튜토리얼은 항상 해금 상태로 표시
                const isUnlocked = tutorial.alwaysUnlocked || seen || (tutorial.unlockCondition && tutorial.unlockCondition());
                
                if (!isUnlocked) {
                    // 잠긴 튜토리얼
                    html += `
                        <div style="padding: 16px; background: #333; color: #666; border: none; border-radius: 10px; font-size: 1rem; display: flex; align-items: center; gap: 12px; opacity: 0.6;">
                            <span style="font-size: 1.5rem;">🔒</span>
                            <div style="flex: 1;">
                                <div style="font-weight: 600;">${tutorial.name}</div>
                                <div style="font-size: 0.8rem; margin-top: 4px;">조건을 달성하면 해금됩니다</div>
                            </div>
                        </div>
                    `;
                } else {
                    // 해금된 튜토리얼
                    html += `
                        <div style="display: flex; gap: 10px; align-items: stretch;">
                            <button onclick="replayTutorial('${tutorial.id}')" style="flex: 1; padding: 16px; background: ${tutorial.gradient}; color: white; border: none; border-radius: 10px; font-size: 1rem; font-weight: 600; cursor: pointer; text-align: left; display: flex; align-items: center; gap: 12px;">
                                <span style="font-size: 1.5rem;">${tutorial.icon}</span>
                                <div>
                                    <div>${tutorial.name}</div>
                                    <div style="font-size: 0.8rem; opacity: 0.8; margin-top: 4px;">${tutorial.desc}</div>
                                </div>
                            </button>
                            ${completed ? 
                                `<div style="padding: 16px; background: #2d5a2d; color: #7fbf7f; border-radius: 10px; display: flex; align-items: center; justify-content: center; min-width: 90px; font-weight: 600;">
                                    ✓ 완료
                                </div>` :
                                (seen ?
                                    `<button onclick="claimTutorialReward('${tutorial.id}')" style="padding: 16px; background: linear-gradient(135deg, #f1c40f 0%, #f39c12 100%); color: #333; border: none; border-radius: 10px; cursor: pointer; min-width: 90px; font-weight: 700; font-size: 0.9rem;">
                                        💰 +${tutorial.reward}
                                    </button>` :
                                    `<div style="padding: 16px; background: #444; color: #888; border-radius: 10px; display: flex; align-items: center; justify-content: center; min-width: 90px; font-size: 0.85rem;">
                                        미완료
                                    </div>`
                                )
                            }
                        </div>
                    `;
                }
            });
            
            container.innerHTML = html;
        }
        
        // 튜토리얼 보상 받기
        function claimTutorialReward(tutorialId) {
            const rewardMap = {
                'basic': { completedKey: 'spiritGarden_tutorialCompleted', seenKey: 'spiritGarden_tutorialSeen', reward: 25, name: '기본 튜토리얼' },
                'album': { completedKey: 'spiritGarden_tutorial2Completed', seenKey: 'spiritGarden_tutorial2Seen', reward: 25, name: '앨범 & 도감 튜토리얼' },
                'sick': { completedKey: 'spiritGarden_sickTutorialCompleted', seenKey: 'spiritGarden_sickTutorialSeen', reward: 25, name: '질병 튜토리얼' },
                'lab': { completedKey: 'spiritGarden_labTutorialCompleted', seenKey: 'spiritGarden_labTutorialSeen', reward: 25, name: '연구실 튜토리얼' }
            };
            
            const info = rewardMap[tutorialId];
            if (!info) return;
            
            // 이미 보상을 받았는지 확인
            if (localStorage.getItem(info.completedKey)) {
                showNotification('⚠️ 이미 보상을 받았습니다');
                return;
            }
            
            // 튜토리얼을 완료했는지 확인
            if (!localStorage.getItem(info.seenKey)) {
                showNotification('⚠️ 튜토리얼을 먼저 완료해주세요');
                return;
            }
            
            // 보상 지급
            localStorage.setItem(info.completedKey, 'true');
            coins += info.reward;
            saveGame();
            updateCoinDisplay();
            showNotification(`🎓 ${info.name} 보상! +${info.reward}💰`);
            
            // UI 업데이트
            renderTutorialReplayList();
        }
        
        // 튜토리얼 다시보기 함수
        function replayTutorial(type) {
            // 진행 중인 튜토리얼이 있으면 중단
            if (tutorialActive || tutorial2Active || sickTutorialActive || labTutorialActive) {
                showNotification('⚠️ 진행 중인 튜토리얼이 있습니다');
                return;
            }
            
            switch(type) {
                case 'basic':
                    // 기본 튜토리얼 플래그 리셋
                    localStorage.removeItem('spiritGarden_tutorialSeen');
                    tutorialStep = 0;
                    tutorialActive = true;
                    switchTab('garden');
                    showTutorialStep();
                    break;
                    
                case 'album':
                    // 앨범/도감 튜토리얼 플래그 리셋
                    localStorage.removeItem('spiritGarden_tutorial2Seen');
                    tutorial2Step = 0;
                    tutorial2Active = true;
                    switchTab('garden');
                    showTutorial2Step();
                    break;
                    
                case 'sick':
                    // 질병 튜토리얼 플래그 리셋
                    localStorage.removeItem('spiritGarden_sickTutorialSeen');
                    sickTutorialStep = 0;
                    sickTutorialActive = true;
                    switchTab('garden');
                    showSickTutorialStep();
                    break;
                    
                case 'lab':
                    // 연구실 튜토리얼 플래그 리셋
                    localStorage.removeItem('spiritGarden_labTutorialSeen');
                    labTutorialStep = 0;
                    labTutorialActive = true;
                    switchTab('lab');
                    showLabTutorialStep();
                    break;
                    
                default:
                    showNotification('❌ 알 수 없는 튜토리얼입니다');
            }
        }
        
        function startTutorial() {
            const tutorialSeen = localStorage.getItem('spiritGarden_tutorialSeen');
            if (tutorialSeen) return;
            
            // 이미 기본 튜토리얼이 진행 중이면 시작하지 않음
            if (tutorialActive) return;
            
            // 다른 튜토리얼이 진행 중이면 시작하지 않음
            if (tutorial2Active || sickTutorialActive || imbalanceTutorialActive || labTutorialActive) return;
            
            // 튜토리얼용 기본 아이템 지급
            if (!inventory.food) inventory.food = [];
            if (!inventory.music) inventory.music = [];
            
            // 기본 먹이 3개 지급
            if (inventory.food.length === 0) {
                inventory.food.push('fire', 'water', 'earth');
            }
            // 클래식 레코드 1개 지급
            if (inventory.music.length === 0) {
                inventory.music.push('classic');
            }
            saveGame();
            renderInventory();
            
            tutorialStep = 0;
            tutorialActive = true;
            showTutorialStep();
        }
        
        function showTutorialStep() {
            console.log('showTutorialStep 호출됨, tutorialStep:', tutorialStep, '/ 전체:', TUTORIAL_STEPS.length);
            if (tutorialStep >= TUTORIAL_STEPS.length) {
                console.log('튜토리얼 완료 조건 충족, endTutorial 호출');
                endTutorial();
                return;
            }
            
            const step = TUTORIAL_STEPS[tutorialStep];
            
            if (step.type === 'dialog') {
                showTutorialDialog(step.text);
            } else if (step.type === 'action') {
                showTutorialAction(step.text, step.action);
            }
        }
        
        let tutorialCollapsed = false;
        
        function toggleTutorialCollapse() {
            tutorialCollapsed = !tutorialCollapsed;
            const content = document.getElementById('tutorialContent');
            const toggleBtn = document.getElementById('tutorialToggleBtn');
            
            if (tutorialCollapsed) {
                content.style.display = 'none';
                toggleBtn.textContent = '▼ 펼치기';
            } else {
                content.style.display = 'block';
                toggleBtn.textContent = '▲ 접기';
            }
        }
        
        function showTutorialDialog(text) {
            const modal = document.createElement('div');
            modal.id = 'tutorialModal';
            modal.style.cssText = `
                position: fixed;
                top: 10px;
                left: 50%;
                transform: translateX(-50%);
                width: 90%;
                max-width: 500px;
                background: var(--card);
                border: 2px solid #555;
                border-radius: 16px;
                padding: 15px;
                z-index: 100000;
                box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            `;
            
            modal.innerHTML = `
                <div style="display: flex; gap: 15px; align-items: flex-start;">
                    <img src="https://i.imgur.com/KSl4CWY.png" alt="선배" style="width: 150px; height: 150px; object-fit: cover; flex-shrink: 0;">
                    <div style="flex: 1;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: ${tutorialCollapsed ? '0' : '10px'};">
                            <span style="font-size: 1rem; font-weight: 600; color: #555;">선배</span>
                            <div style="display: flex; gap: 6px;">
                                <button onclick="skipTutorial()" style="padding: 4px 10px; background: var(--bg); border: 1px solid var(--border); border-radius: 6px; cursor: pointer; font-size: 0.75rem; color: var(--text-muted);">건너뛰기</button>
                                <button onclick="toggleTutorialCollapse()" style="padding: 4px 10px; background: var(--bg); border: 1px solid var(--border); border-radius: 6px; cursor: pointer; font-size: 0.75rem; color: var(--text-muted);">
                                    ${tutorialCollapsed ? '▼ 펼치기' : '▲ 접기'}
                                </button>
                            </div>
                        </div>
                        <div id="tutorialContent" style="display: ${tutorialCollapsed ? 'none' : 'block'};">
                            <div style="font-size: 0.95rem; line-height: 1.6; color: var(--text); margin-bottom: 12px; word-break: keep-all;">${text}</div>
                            <div style="display: flex; justify-content: flex-end;">
                                <button onclick="nextTutorialStep()" style="padding: 8px 20px; background: #333; color: white; border: none; border-radius: 6px; font-size: 0.9rem; cursor: pointer; font-weight: 600;">다음</button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            // 기존 튜토리얼 모달 제거
            const existing = document.getElementById('tutorialModal');
            if (existing) existing.remove();
            
            document.body.appendChild(modal);
        }
        
        function showTutorialAction(text, action) {
            const modal = document.createElement('div');
            modal.id = 'tutorialModal';
            modal.style.cssText = `
                position: fixed;
                top: 10px;
                left: 50%;
                transform: translateX(-50%);
                width: 90%;
                max-width: 500px;
                background: var(--card);
                border: 2px solid #f39c12;
                border-radius: 16px;
                padding: 15px;
                z-index: 100000;
                box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            `;
            
            modal.innerHTML = `
                <div style="display: flex; gap: 15px; align-items: flex-start;">
                    <img src="https://i.imgur.com/KSl4CWY.png" alt="선배" style="width: 150px; height: 150px; object-fit: cover; flex-shrink: 0;">
                    <div style="flex: 1;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: ${tutorialCollapsed ? '0' : '10px'};">
                            <span style="font-size: 1rem; font-weight: 600; color: #f39c12;">선배</span>
                            <div style="display: flex; gap: 6px;">
                                <button onclick="skipTutorial()" style="padding: 4px 10px; background: var(--bg); border: 1px solid var(--border); border-radius: 6px; cursor: pointer; font-size: 0.75rem; color: var(--text-muted);">건너뛰기</button>
                                <button onclick="toggleTutorialCollapse()" style="padding: 4px 10px; background: var(--bg); border: 1px solid var(--border); border-radius: 6px; cursor: pointer; font-size: 0.75rem; color: var(--text-muted);">
                                    ${tutorialCollapsed ? '▼ 펼치기' : '▲ 접기'}
                                </button>
                            </div>
                        </div>
                        <div id="tutorialContent" style="display: ${tutorialCollapsed ? 'none' : 'block'};">
                            <div style="font-size: 0.95rem; line-height: 1.6; color: var(--text); margin-bottom: 8px; word-break: keep-all;">${text}</div>
                            <div style="padding: 6px 10px; background: #f39c1222; border-radius: 6px; font-size: 0.8rem; color: #f39c12;">
                                👇 아래 버튼을 눌러보세요!
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            // 기존 튜토리얼 모달 제거
            const existing = document.getElementById('tutorialModal');
            if (existing) existing.remove();
            
            document.body.appendChild(modal);
            
            // 해당 액션을 기다림
            window.tutorialWaitingFor = action;
            
            // 강조할 요소 찾아서 하이라이트
            highlightTutorialTarget(action);
        }
        
        // 튜토리얼 대상 요소 강조
        function highlightTutorialTarget(action) {
            // 기존 강조 제거
            clearTutorialHighlight();
            
            let targetSelector = null;
            
            switch(action) {
                case 'getEgg':
                    targetSelector = '.new-spirit-btn';
                    break;
                case 'clickName':
                    targetSelector = '.spirit-name';
                    break;
                case 'rename':
                    targetSelector = '#nameInput';
                    break;
                case 'feed':
                    targetSelector = 'button[onclick*="openFeedModal"]';
                    break;
                case 'music':
                    targetSelector = 'button[onclick*="openMusicModal"]';
                    break;
                case 'pat':
                    targetSelector = 'button[onclick*="patSpirit"]';
                    break;
                case 'toggleLight':
                    targetSelector = '#lightBtn';
                    break;
                case 'openAlbum':
                    targetSelector = '#journalTabAlbum';
                    break;
                case 'openJournal':
                    targetSelector = '.tab:nth-child(6)';
                    break;
                case 'openAlbumDetail':
                    targetSelector = '.collection-card';
                    break;
            }
            
            if (targetSelector) {
                const target = document.querySelector(targetSelector);
                if (target) {
                    target.classList.add('tutorial-highlight');
                    // 해당 요소로 스크롤
                    target.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            }
        }
        
        // 튜토리얼 강조 제거
        function clearTutorialHighlight() {
            document.querySelectorAll('.tutorial-highlight').forEach(el => {
                el.classList.remove('tutorial-highlight');
            });
        }
        
        function checkTutorialAction(action) {
            if (!tutorialActive && !tutorial2Active) return;
            if (window.tutorialWaitingFor === action) {
                window.tutorialWaitingFor = null;
                clearTutorialHighlight();
                if (tutorial2Active) {
                    nextTutorial2Step();
                } else {
                    nextTutorialStep();
                }
            }
        }
        
        function nextTutorialStep() {
            tutorialStep++;
            showTutorialStep();
        }
        
        function skipTutorial() {
            // 건너뛰기는 보상 없이 종료
            tutorialActive = false;
            window.tutorialWaitingFor = null;
            clearTutorialHighlight();
            
            const modal = document.getElementById('tutorialModal');
            if (modal) {
                modal.style.opacity = '0';
                modal.style.transition = 'opacity 0.3s';
                setTimeout(() => modal.remove(), 300);
            }
            
            localStorage.setItem('spiritGarden_tutorialSeen', 'true');
            showNotification('튜토리얼을 건너뛰었습니다.');
        }
        
        function endTutorial() {
            console.log('endTutorial 호출됨');
            tutorialActive = false;
            window.tutorialWaitingFor = null;
            clearTutorialHighlight();
            
            const modal = document.getElementById('tutorialModal');
            if (modal) {
                modal.style.opacity = '0';
                modal.style.transition = 'opacity 0.3s';
                setTimeout(() => modal.remove(), 300);
            }
            
            localStorage.setItem('spiritGarden_tutorialSeen', 'true');
            
            // 보상 미수령 상태면 안내
            const alreadyCompleted = localStorage.getItem('spiritGarden_tutorialCompleted');
            if (!alreadyCompleted) {
                setTimeout(() => {
                    showNotification('🎓 튜토리얼 완료! 일지→도움말에서 보상을 받으세요');
                }, 500);
            }
        }
        
        // ===== 두 번째 튜토리얼 (첫 정령 완성 후) =====
        let tutorial2Step = 0;
        let tutorial2Active = false;
        
        const TUTORIAL2_STEPS = [
            {
                type: 'dialog',
                text: '축하해! 네가 키워낸 첫 번째 정령이네.'
            },
            {
                type: 'dialog',
                text: '성장한 정령은 자연으로 돌아가지만, 아예 다시 볼 수 없는 건 아니야.'
            },
            {
                type: 'action',
                action: 'openJournal',
                text: '일지 탭을 눌러봐.'
            },
            {
                type: 'action',
                action: 'openAlbum',
                text: '이제 앨범 버튼을 눌러봐.'
            },
            {
                type: 'dialog',
                text: '여기에서 네가 키운 정령들을 다시 볼 수 있어. 네가 얼마나 잘 키워냈는지도 확인할 수 있고.'
            },
            {
                type: 'dialog',
                text: '그리고 정령 간의 연결도 가능하지.'
            },
            {
                type: 'action',
                action: 'openAlbumDetail',
                text: '성장한 정령의 앨범을 눌러봐.'
            },
            {
                type: 'dialog',
                text: '아래에 보면 코드 생성과 연결하기가 있지? 정령의 코드를 복사해 다른 정령과 연결이 가능해.'
            },
            {
                type: 'dialog',
                text: '무속성 알로는 보지 못하는 정령들도 있으니까 나중에 시도해보도록 해.'
            },
            {
                type: 'dialog',
                text: '자, 이제 정말 혼자서도 잘 할 수 있을 거야. 앞으로도 화이팅!'
            }
        ];
        
        function startTutorial2() {
            // 이미 본 적 있으면 시작하지 않음
            if (localStorage.getItem('spiritGarden_tutorial2Seen')) return;
            
            // 이미 튜토리얼2가 진행 중이면 시작하지 않음
            if (tutorial2Active) return;
            
            // 다른 튜토리얼이 진행 중이면 시작하지 않음
            if (tutorialActive || sickTutorialActive || imbalanceTutorialActive || labTutorialActive) return;
            
            tutorial2Step = 0;
            tutorial2Active = true;
            showTutorial2Step();
        }
        
        function showTutorial2Step() {
            if (tutorial2Step >= TUTORIAL2_STEPS.length) {
                endTutorial2();
                return;
            }
            
            const step = TUTORIAL2_STEPS[tutorial2Step];
            
            if (step.type === 'dialog') {
                showTutorial2Dialog(step.text);
            } else if (step.type === 'action') {
                showTutorial2Action(step.text, step.action);
            }
        }
        
        function showTutorial2Dialog(text) {
            const modal = document.createElement('div');
            modal.id = 'tutorialModal';
            modal.style.cssText = `
                position: fixed;
                top: 10px;
                left: 50%;
                transform: translateX(-50%);
                width: 90%;
                max-width: 500px;
                background: var(--card);
                border: 2px solid #555;
                border-radius: 16px;
                padding: 15px;
                z-index: 100000;
                box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            `;
            
            modal.innerHTML = `
                <div style="display: flex; gap: 15px; align-items: flex-start;">
                    <img src="https://i.imgur.com/KSl4CWY.png" alt="선배" style="width: 150px; height: 150px; object-fit: cover; flex-shrink: 0;">
                    <div style="flex: 1;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: ${tutorialCollapsed ? '0' : '10px'};">
                            <span style="font-size: 1rem; font-weight: 600; color: #555;">선배</span>
                            <div style="display: flex; gap: 6px;">
                                <button onclick="skipTutorial2()" style="padding: 4px 10px; background: var(--bg); border: 1px solid var(--border); border-radius: 6px; cursor: pointer; font-size: 0.75rem; color: var(--text-muted);">건너뛰기</button>
                                <button onclick="toggleTutorialCollapse()" style="padding: 4px 10px; background: var(--bg); border: 1px solid var(--border); border-radius: 6px; cursor: pointer; font-size: 0.75rem; color: var(--text-muted);">
                                    ${tutorialCollapsed ? '▼ 펼치기' : '▲ 접기'}
                                </button>
                            </div>
                        </div>
                        <div id="tutorialContent" style="display: ${tutorialCollapsed ? 'none' : 'block'};">
                            <div style="font-size: 0.95rem; line-height: 1.6; color: var(--text); margin-bottom: 12px; word-break: keep-all;">${text}</div>
                            <div style="display: flex; justify-content: flex-end;">
                                <button onclick="nextTutorial2Step()" style="padding: 8px 20px; background: #333; color: white; border: none; border-radius: 6px; font-size: 0.9rem; cursor: pointer; font-weight: 600;">다음</button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            const existing = document.getElementById('tutorialModal');
            if (existing) existing.remove();
            
            document.body.appendChild(modal);
        }
        
        function showTutorial2Action(text, action) {
            const modal = document.createElement('div');
            modal.id = 'tutorialModal';
            modal.style.cssText = `
                position: fixed;
                top: 10px;
                left: 50%;
                transform: translateX(-50%);
                width: 90%;
                max-width: 500px;
                background: var(--card);
                border: 2px solid #f39c12;
                border-radius: 16px;
                padding: 15px;
                z-index: 100000;
                box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            `;
            
            modal.innerHTML = `
                <div style="display: flex; gap: 15px; align-items: flex-start;">
                    <img src="https://i.imgur.com/KSl4CWY.png" alt="선배" style="width: 150px; height: 150px; object-fit: cover; flex-shrink: 0;">
                    <div style="flex: 1;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: ${tutorialCollapsed ? '0' : '10px'};">
                            <span style="font-size: 1rem; font-weight: 600; color: #f39c12;">선배</span>
                            <div style="display: flex; gap: 6px;">
                                <button onclick="skipTutorial2()" style="padding: 4px 10px; background: var(--bg); border: 1px solid var(--border); border-radius: 6px; cursor: pointer; font-size: 0.75rem; color: var(--text-muted);">건너뛰기</button>
                                <button onclick="toggleTutorialCollapse()" style="padding: 4px 10px; background: var(--bg); border: 1px solid var(--border); border-radius: 6px; cursor: pointer; font-size: 0.75rem; color: var(--text-muted);">
                                    ${tutorialCollapsed ? '▼ 펼치기' : '▲ 접기'}
                                </button>
                            </div>
                        </div>
                        <div id="tutorialContent" style="display: ${tutorialCollapsed ? 'none' : 'block'};">
                            <div style="font-size: 0.95rem; line-height: 1.6; color: var(--text); margin-bottom: 8px; word-break: keep-all;">${text}</div>
                            <div style="padding: 6px 10px; background: #f39c1222; border-radius: 6px; font-size: 0.8rem; color: #f39c12;">
                                👇 해당 버튼을 눌러보세요!
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            const existing = document.getElementById('tutorialModal');
            if (existing) existing.remove();
            
            document.body.appendChild(modal);
            
            window.tutorialWaitingFor = action;
            
            // 강조할 요소 찾아서 하이라이트
            highlightTutorialTarget(action);
        }
        
        function nextTutorial2Step() {
            tutorial2Step++;
            showTutorial2Step();
        }
        
        function skipTutorial2() {
            // 건너뛰기는 보상 없이 종료
            tutorial2Active = false;
            window.tutorialWaitingFor = null;
            clearTutorialHighlight();
            
            const modal = document.getElementById('tutorialModal');
            if (modal) {
                modal.style.opacity = '0';
                modal.style.transition = 'opacity 0.3s';
                setTimeout(() => modal.remove(), 300);
            }
            
            localStorage.setItem('spiritGarden_tutorial2Seen', 'true');
            showNotification('튜토리얼을 건너뛰었습니다.');
        }
        
        function endTutorial2() {
            tutorial2Active = false;
            window.tutorialWaitingFor = null;
            clearTutorialHighlight();
            
            const modal = document.getElementById('tutorialModal');
            if (modal) {
                modal.style.opacity = '0';
                modal.style.transition = 'opacity 0.3s';
                setTimeout(() => modal.remove(), 300);
            }
            
            localStorage.setItem('spiritGarden_tutorial2Seen', 'true');
            
            // 보상 미수령 상태면 안내
            if (!localStorage.getItem('spiritGarden_tutorial2Completed')) {
                setTimeout(() => {
                    showNotification('🎓 튜토리얼 완료! 일지→도움말에서 보상을 받으세요');
                }, 500);
            }
        }
        
        // ===== 질병 튜토리얼 (첫 질병 발생 시) =====
        let sickTutorialStep = 0;
        let sickTutorialActive = false;
        let sickTutorialCollapsed = false;
        
        const SICK_TUTORIAL_STEPS = [
            {
                type: 'dialog',
                text: '정령이 질병에 걸렸구나. 유아기의 정령들은 약해서 종종 이런 일이 일어나곤 해.'
            },
            {
                type: 'dialog',
                text: '그래도 걱정하지마. 상점에서 약초를 사서 먹이면 되니까.'
            },
            {
                type: 'action',
                action: 'openShop',
                text: '상점 탭을 눌러볼래?'
            },
            {
                type: 'dialog',
                text: '안녕, 상점 주인. 오늘도 의욕이 없어보이네.'
            },
            {
                type: 'shopkeeper',
                text: '시비걸거면 가세요...'
            },
            {
                type: 'dialog',
                text: '저렇다니까. 아, 약초를 사러 왔었지. 구매하기에서 약초를 찾아 구매해봐.'
            },
            {
                type: 'action',
                action: 'buyMedicine',
                text: '약초를 구매해봐!'
            },
            {
                type: 'dialog',
                text: '약초를 샀으면 이제 육성탭으로 돌아가자.'
            },
            {
                type: 'action',
                action: 'openGarden',
                text: '육성 탭을 눌러봐.'
            },
            {
                type: 'action',
                action: 'useMedicine',
                text: '질병에 걸린 정령에게 약초 사용을 눌러봐.'
            },
            {
                type: 'dialog',
                text: '자, 금방 나았지? 앞으로도 당황하지말고 이렇게 하면 돼. 그럼 계속 힘내라고~'
            }
        ];
        
        function startSickTutorial() {
            // 이미 본 적 있으면 시작하지 않음
            if (localStorage.getItem('spiritGarden_sickTutorialSeen')) return;
            
            // 이미 질병 튜토리얼이 진행 중이면 시작하지 않음
            if (sickTutorialActive) return;
            
            // 다른 튜토리얼이 진행 중이면 시작하지 않음
            if (tutorialActive || tutorial2Active || imbalanceTutorialActive || labTutorialActive) return;
            
            // 약초 구매를 위한 코인 지급 (50코인 미만이면 50코인으로 맞춰줌)
            if (coins < 50) {
                coins = 50;
                updateCoinDisplay();
                saveGame();
            }
            
            // 육성 탭으로 이동
            switchTab('garden');
            
            sickTutorialStep = 0;
            sickTutorialActive = true;
            showSickTutorialStep();
        }
        
        function showSickTutorialStep() {
            if (sickTutorialStep >= SICK_TUTORIAL_STEPS.length) {
                endSickTutorial();
                return;
            }
            
            const step = SICK_TUTORIAL_STEPS[sickTutorialStep];
            
            if (step.type === 'dialog') {
                showSickTutorialDialog(step.text);
            } else if (step.type === 'shopkeeper') {
                showSickTutorialShopkeeper(step.text);
            } else if (step.type === 'action') {
                showSickTutorialAction(step.text, step.action);
            }
        }
        
        function showSickTutorialDialog(text) {
            const modal = document.createElement('div');
            modal.id = 'tutorialModal';
            modal.style.cssText = `
                position: fixed;
                top: 10px;
                left: 50%;
                transform: translateX(-50%);
                width: 90%;
                max-width: 500px;
                background: var(--card);
                border: 2px solid #f39c12;
                border-radius: 16px;
                padding: 15px;
                z-index: 100000;
                box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            `;
            
            modal.innerHTML = `
                <div style="display: flex; gap: 15px; align-items: flex-start;">
                    <img src="https://i.imgur.com/KSl4CWY.png" alt="선배" style="width: 150px; height: 150px; object-fit: cover; flex-shrink: 0;">
                    <div style="flex: 1;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: ${sickTutorialCollapsed ? '0' : '10px'};">
                            <span style="font-size: 1rem; font-weight: 600; color: #f39c12;">선배</span>
                            <div style="display: flex; gap: 6px;">
                                <button onclick="skipSickTutorial()" style="padding: 4px 10px; background: var(--bg); border: 1px solid var(--border); border-radius: 6px; cursor: pointer; font-size: 0.75rem; color: var(--text-muted);">건너뛰기</button>
                                <button onclick="toggleSickTutorialCollapse()" style="padding: 4px 10px; background: var(--bg); border: 1px solid var(--border); border-radius: 6px; cursor: pointer; font-size: 0.75rem; color: var(--text-muted);">
                                    ${sickTutorialCollapsed ? '▼ 펼치기' : '▲ 접기'}
                                </button>
                            </div>
                        </div>
                        <div id="sickTutorialContent" style="display: ${sickTutorialCollapsed ? 'none' : 'block'};">
                            <div style="font-size: 0.95rem; line-height: 1.6; color: var(--text); margin-bottom: 12px; word-break: keep-all;">${text}</div>
                            <div style="display: flex; justify-content: flex-end;">
                                <button onclick="nextSickTutorialStep()" style="padding: 8px 20px; background: #f39c12; color: white; border: none; border-radius: 6px; font-size: 0.9rem; cursor: pointer; font-weight: 600;">다음</button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            const existing = document.getElementById('tutorialModal');
            if (existing) existing.remove();
            
            document.body.appendChild(modal);
        }
        
        function showSickTutorialShopkeeper(text) {
            const modal = document.createElement('div');
            modal.id = 'tutorialModal';
            modal.style.cssText = `
                position: fixed;
                top: 10px;
                left: 50%;
                transform: translateX(-50%);
                width: 90%;
                max-width: 500px;
                background: var(--card);
                border: 2px solid #888;
                border-radius: 16px;
                padding: 15px;
                z-index: 100000;
                box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            `;
            
            modal.innerHTML = `
                <div style="display: flex; gap: 15px; align-items: flex-start;">
                    <img src="https://i.imgur.com/NxGyLzK.png" alt="상점 주인" style="width: 150px; height: 150px; object-fit: cover; flex-shrink: 0;">
                    <div style="flex: 1;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: ${sickTutorialCollapsed ? '0' : '10px'};">
                            <span style="font-size: 1rem; font-weight: 600; color: #888;">상점 주인</span>
                            <div style="display: flex; gap: 6px;">
                                <button onclick="skipSickTutorial()" style="padding: 4px 10px; background: var(--bg); border: 1px solid var(--border); border-radius: 6px; cursor: pointer; font-size: 0.75rem; color: var(--text-muted);">건너뛰기</button>
                                <button onclick="toggleSickTutorialCollapse()" style="padding: 4px 10px; background: var(--bg); border: 1px solid var(--border); border-radius: 6px; cursor: pointer; font-size: 0.75rem; color: var(--text-muted);">
                                    ${sickTutorialCollapsed ? '▼ 펼치기' : '▲ 접기'}
                                </button>
                            </div>
                        </div>
                        <div id="sickTutorialContent" style="display: ${sickTutorialCollapsed ? 'none' : 'block'};">
                            <div style="font-size: 0.95rem; line-height: 1.6; color: var(--text); margin-bottom: 12px; word-break: keep-all;">${text}</div>
                            <div style="display: flex; justify-content: flex-end;">
                                <button onclick="nextSickTutorialStep()" style="padding: 8px 20px; background: #888; color: white; border: none; border-radius: 6px; font-size: 0.9rem; cursor: pointer; font-weight: 600;">다음</button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            const existing = document.getElementById('tutorialModal');
            if (existing) existing.remove();
            
            document.body.appendChild(modal);
        }
        
        function showSickTutorialAction(text, action) {
            const modal = document.createElement('div');
            modal.id = 'tutorialModal';
            modal.style.cssText = `
                position: fixed;
                top: 10px;
                left: 50%;
                transform: translateX(-50%);
                width: 90%;
                max-width: 500px;
                background: var(--card);
                border: 2px solid #f39c12;
                border-radius: 16px;
                padding: 15px;
                z-index: 100000;
                box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            `;
            
            modal.innerHTML = `
                <div style="display: flex; gap: 15px; align-items: flex-start;">
                    <img src="https://i.imgur.com/KSl4CWY.png" alt="선배" style="width: 150px; height: 150px; object-fit: cover; flex-shrink: 0;">
                    <div style="flex: 1;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: ${sickTutorialCollapsed ? '0' : '10px'};">
                            <span style="font-size: 1rem; font-weight: 600; color: #f39c12;">선배</span>
                            <div style="display: flex; gap: 6px;">
                                <button onclick="skipSickTutorial()" style="padding: 4px 10px; background: var(--bg); border: 1px solid var(--border); border-radius: 6px; cursor: pointer; font-size: 0.75rem; color: var(--text-muted);">건너뛰기</button>
                                <button onclick="toggleSickTutorialCollapse()" style="padding: 4px 10px; background: var(--bg); border: 1px solid var(--border); border-radius: 6px; cursor: pointer; font-size: 0.75rem; color: var(--text-muted);">
                                    ${sickTutorialCollapsed ? '▼ 펼치기' : '▲ 접기'}
                                </button>
                            </div>
                        </div>
                        <div id="sickTutorialContent" style="display: ${sickTutorialCollapsed ? 'none' : 'block'};">
                            <div style="font-size: 0.95rem; line-height: 1.6; color: var(--text); margin-bottom: 8px; word-break: keep-all;">${text}</div>
                            <div style="padding: 6px 10px; background: #f39c1222; border-radius: 6px; font-size: 0.8rem; color: #f39c12;">
                                👇 해당 버튼을 눌러보세요!
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            const existing = document.getElementById('tutorialModal');
            if (existing) existing.remove();
            
            document.body.appendChild(modal);
            
            window.tutorialWaitingFor = action;
            
            // 강조할 요소 찾아서 하이라이트
            highlightSickTutorialTarget(action);
        }
        
        function highlightSickTutorialTarget(action) {
            clearTutorialHighlight();
            
            let targetSelector = '';
            
            if (action === 'openShop') {
                targetSelector = 'button.tab[onclick*="shop"]';
            } else if (action === 'buyMedicine') {
                targetSelector = 'button[onclick*="buyItem"][onclick*="medicine"]';
            } else if (action === 'openGarden') {
                targetSelector = 'button.tab[onclick*="garden"]';
            } else if (action === 'useMedicine') {
                targetSelector = 'button[onclick*="giveMedicine"]';
            }
            
            if (targetSelector) {
                const target = document.querySelector(targetSelector);
                if (target) {
                    target.classList.add('tutorial-highlight');
                    // 강조된 요소로 스크롤
                    setTimeout(() => {
                        target.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }, 100);
                }
            }
        }
        
        function nextSickTutorialStep() {
            sickTutorialStep++;
            showSickTutorialStep();
        }
        
        function toggleSickTutorialCollapse() {
            sickTutorialCollapsed = !sickTutorialCollapsed;
            showSickTutorialStep();
        }
        
        function skipSickTutorial() {
            // 건너뛰기는 보상 없이 종료
            sickTutorialActive = false;
            window.tutorialWaitingFor = null;
            clearTutorialHighlight();
            
            const modal = document.getElementById('tutorialModal');
            if (modal) {
                modal.style.opacity = '0';
                modal.style.transition = 'opacity 0.3s';
                setTimeout(() => modal.remove(), 300);
            }
            
            localStorage.setItem('spiritGarden_sickTutorialSeen', 'true');
            showNotification('튜토리얼을 건너뛰었습니다.');
        }
        
        function endSickTutorial() {
            sickTutorialActive = false;
            window.tutorialWaitingFor = null;
            clearTutorialHighlight();
            
            const modal = document.getElementById('tutorialModal');
            if (modal) {
                modal.style.opacity = '0';
                modal.style.transition = 'opacity 0.3s';
                setTimeout(() => modal.remove(), 300);
            }
            
            localStorage.setItem('spiritGarden_sickTutorialSeen', 'true');
            
            // 보상 미수령 상태면 안내
            if (!localStorage.getItem('spiritGarden_sickTutorialCompleted')) {
                setTimeout(() => {
                    showNotification('🎓 튜토리얼 완료! 일지→도움말에서 보상을 받으세요');
                }, 500);
            }
        }
        
        // 질병 튜토리얼용 액션 체크
        function checkSickTutorialAction(action) {
            if (!sickTutorialActive) return;
            if (window.tutorialWaitingFor !== action) return;
            
            clearTutorialHighlight();
            sickTutorialStep++;
            showSickTutorialStep();
        }
        
        // ===== 속성 불균형 튜토리얼 (첫 불균형 발생 시) =====
        let imbalanceTutorialStep = 0;
        let imbalanceTutorialActive = false;
        let imbalanceTutorialCollapsed = false;
        
        const IMBALANCE_TUTORIAL_STEPS = [
            {
                type: 'dialog',
                text: '처음엔 한 속성에만 신경쓰는게 좋다고 했더니 그 말을 아주 잘 들었구나, 후배...'
            },
            {
                type: 'dialog',
                text: '자, 봐. 속성 수치를 보면 높은 속성이 50이상, 낮은 속성은 10 이하지?'
            },
            {
                type: 'dialog',
                text: '이런 경우엔 정령에게 속성 불균형이 찾아와.'
            },
            {
                type: 'dialog',
                text: '자연에서는 모든 속성을 골고루 쌓을 수 있지만 인공 테라리움에선 그러기 쉽지 않거든.'
            },
            {
                type: 'dialog',
                text: '속성 불균형은 낮은 속성을 10 이상으로 올려주면 자연스럽게 풀릴거야.'
            },
            {
                type: 'dialog',
                text: '...그런거면 처음부터 말해달라고? 이 녀석이.'
            },
            {
                type: 'dialog',
                text: '일단 난 설명해줬으니 간다. 힘내라~'
            }
        ];
        
        function startImbalanceTutorial() {
            // 이미 본 적 있으면 시작하지 않음
            if (localStorage.getItem('spiritGarden_imbalanceTutorialSeen')) return;
            
            // 이미 불균형 튜토리얼이 진행 중이면 시작하지 않음
            if (imbalanceTutorialActive) return;
            
            // 다른 튜토리얼이 진행 중이면 시작하지 않음
            if (tutorialActive || tutorial2Active || sickTutorialActive || labTutorialActive) return;
            
            // 육성 탭으로 이동
            switchTab('garden');
            
            imbalanceTutorialStep = 0;
            imbalanceTutorialActive = true;
            showImbalanceTutorialStep();
        }
        
        function showImbalanceTutorialStep() {
            if (imbalanceTutorialStep >= IMBALANCE_TUTORIAL_STEPS.length) {
                endImbalanceTutorial();
                return;
            }
            
            const step = IMBALANCE_TUTORIAL_STEPS[imbalanceTutorialStep];
            showImbalanceTutorialDialog(step.text);
        }
        
        function showImbalanceTutorialDialog(text) {
            const modal = document.createElement('div');
            modal.id = 'tutorialModal';
            modal.style.cssText = `
                position: fixed;
                top: 10px;
                left: 50%;
                transform: translateX(-50%);
                width: 90%;
                max-width: 500px;
                background: var(--card);
                border: 2px solid #f39c12;
                border-radius: 16px;
                padding: 15px;
                z-index: 100000;
                box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            `;
            
            modal.innerHTML = `
                <div style="display: flex; gap: 15px; align-items: flex-start;">
                    <img src="https://i.imgur.com/KSl4CWY.png" alt="선배" style="width: 150px; height: 150px; object-fit: cover; flex-shrink: 0;">
                    <div style="flex: 1;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: ${imbalanceTutorialCollapsed ? '0' : '10px'};">
                            <span style="font-size: 1rem; font-weight: 600; color: #f39c12;">선배</span>
                            <div style="display: flex; gap: 6px;">
                                <button onclick="skipImbalanceTutorial()" style="padding: 4px 10px; background: var(--bg); border: 1px solid var(--border); border-radius: 6px; cursor: pointer; font-size: 0.75rem; color: var(--text-muted);">건너뛰기</button>
                                <button onclick="toggleImbalanceTutorialCollapse()" style="padding: 4px 10px; background: var(--bg); border: 1px solid var(--border); border-radius: 6px; cursor: pointer; font-size: 0.75rem; color: var(--text-muted);">
                                    ${imbalanceTutorialCollapsed ? '▼ 펼치기' : '▲ 접기'}
                                </button>
                            </div>
                        </div>
                        <div id="imbalanceTutorialContent" style="display: ${imbalanceTutorialCollapsed ? 'none' : 'block'};">
                            <div style="font-size: 0.95rem; line-height: 1.6; color: var(--text); margin-bottom: 12px; word-break: keep-all;">${text}</div>
                            <div style="display: flex; justify-content: flex-end;">
                                <button onclick="nextImbalanceTutorialStep()" style="padding: 8px 20px; background: #f39c12; color: white; border: none; border-radius: 6px; font-size: 0.9rem; cursor: pointer; font-weight: 600;">다음</button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            const existing = document.getElementById('tutorialModal');
            if (existing) existing.remove();
            
            document.body.appendChild(modal);
        }
        
        function nextImbalanceTutorialStep() {
            imbalanceTutorialStep++;
            showImbalanceTutorialStep();
        }
        
        function toggleImbalanceTutorialCollapse() {
            imbalanceTutorialCollapsed = !imbalanceTutorialCollapsed;
            showImbalanceTutorialStep();
        }
        
        function skipImbalanceTutorial() {
            // 건너뛰기 (보상 없음)
            imbalanceTutorialActive = false;
            
            const modal = document.getElementById('tutorialModal');
            if (modal) {
                modal.style.opacity = '0';
                modal.style.transition = 'opacity 0.3s';
                setTimeout(() => modal.remove(), 300);
            }
            
            localStorage.setItem('spiritGarden_imbalanceTutorialSeen', 'true');
            showNotification('튜토리얼을 건너뛰었습니다.');
        }
        
        function endImbalanceTutorial() {
            imbalanceTutorialActive = false;
            
            const modal = document.getElementById('tutorialModal');
            if (modal) {
                modal.style.opacity = '0';
                modal.style.transition = 'opacity 0.3s';
                setTimeout(() => modal.remove(), 300);
            }
            
            localStorage.setItem('spiritGarden_imbalanceTutorialSeen', 'true');
        }
        
        // 속성 불균형 체크 함수 (최종 속성 기준)
        function checkImbalanceAndTutorial(spirit) {
            if (!spirit || !spirit.hiddenAttributes) return;
            if (localStorage.getItem('spiritGarden_imbalanceTutorialSeen')) return;
            
            // 다른 튜토리얼이 진행 중이면 체크하지 않음
            if (tutorialActive || tutorial2Active || sickTutorialActive || labTutorialActive || imbalanceTutorialActive) return;
            
            // 먹이 속성
            const foodAttrs = spirit.hiddenAttributes;
            // 테라리움 속성
            const terrariumAttrs = terrarium || { fire: 0, water: 0, wind: 0, earth: 0, light: 0, dark: 0 };
            
            // 최종 속성 계산 (먹이 70% + 테라리움 30%)
            const finalAttrs = {};
            for (let attr in foodAttrs) {
                finalAttrs[attr] = (foodAttrs[attr] * 0.7) + ((terrariumAttrs[attr] || 0) * 0.3);
            }
            
            const attrValues = Object.values(finalAttrs);
            const maxAttr = Math.max(...attrValues);
            const minAttr = Math.min(...attrValues);
            
            // 불균형 조건: 최고 50 이상 & 최저 10 이하
            if (maxAttr >= 50 && minAttr <= 10) {
                setTimeout(() => {
                    startImbalanceTutorial();
                }, 500);
            }
        }
        
        // ===== 연구실 튜토리얼 (소지품 100개 이상) =====
        let labTutorialStep = 0;
        let labTutorialActive = false;
        let labTutorialCollapsed = false;
        
        const LAB_TUTORIAL_STEPS = [
            {
                type: 'dialog',
                text: '이제 슬슬 인벤토리에 있는 먹이랑 장식품때문에 골치가 아프지?'
            },
            {
                type: 'action',
                action: 'openLab',
                text: '그 녀석들을 처리할 수 있는 방법을 알려줄게. 연구실 탭을 눌러봐.'
            },
            {
                type: 'dialog',
                text: '여기에선 먹이와 장식품을 합성해서 새로운 먹이와 장식품을 얻을 수 있어.'
            },
            {
                type: 'dialog',
                text: '효과도 원재료와 다르니까 잘 이용해봐.'
            },
            {
                type: 'action',
                action: 'clickSlot1',
                text: '재료1을 눌러봐.'
            },
            {
                type: 'action',
                action: 'selectIngredient1',
                text: '먹이 중에 5개 이상 있는 재료를 선택해.'
            },
            {
                type: 'action',
                action: 'selectIngredient2',
                text: '그리고 재료2에도 똑같이 먹이를 넣어봐.'
            },
            {
                type: 'action',
                action: 'synthesize',
                text: '잘했어. 이제 합성하기 버튼을 눌러.'
            },
            {
                type: 'dialog',
                text: '짠, 완성! 이제 하는 방법을 알겠지?'
            },
            {
                type: 'dialog',
                text: '뭐? 레시피는 없냐고? 당연히 있지.'
            },
            {
                type: 'dialog',
                text: '안줄거냐고? 응 안줄건데.'
            },
            {
                type: 'dialog',
                text: '......'
            },
            {
                type: 'dialog',
                text: '농담이고, 얼마전에 부탁해서 곧 상점에 들어올거야.'
            },
            {
                type: 'dialog',
                text: '그래도 직접 레시피를 찾는 재미도 있으니까 정말 도저히 모르겠으면 그때 사 봐.'
            },
            {
                type: 'dialog',
                text: '그럼 연구 힘내라~'
            }
        ];
        
        function startLabTutorial() {
            const tutorialSeen = localStorage.getItem('spiritGarden_labTutorialSeen');
            if (tutorialSeen) return;
            
            // 이미 연구실 튜토리얼이 진행 중이면 시작하지 않음
            if (labTutorialActive) return;
            
            // 다른 튜토리얼이 진행 중이면 시작하지 않음
            if (tutorialActive || tutorial2Active || sickTutorialActive || imbalanceTutorialActive) return;
            
            labTutorialStep = 0;
            labTutorialActive = true;
            showLabTutorialStep();
        }
        
        function showLabTutorialStep() {
            if (labTutorialStep >= LAB_TUTORIAL_STEPS.length) {
                endLabTutorial();
                return;
            }
            
            const step = LAB_TUTORIAL_STEPS[labTutorialStep];
            
            if (step.type === 'dialog') {
                showLabTutorialDialog(step.text);
            } else if (step.type === 'action') {
                showLabTutorialAction(step.text, step.action);
            }
        }
        
        function showLabTutorialDialog(text) {
            const modal = document.createElement('div');
            modal.id = 'tutorialModal';
            modal.style.cssText = `
                position: fixed;
                top: 10px;
                left: 50%;
                transform: translateX(-50%);
                width: 90%;
                max-width: 500px;
                background: var(--card);
                border: 2px solid #555;
                border-radius: 16px;
                padding: 15px;
                z-index: 100000;
                box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            `;
            
            modal.innerHTML = `
                <div style="display: flex; gap: 15px; align-items: flex-start;">
                    <img src="https://i.imgur.com/KSl4CWY.png" alt="선배" style="width: 150px; height: 150px; object-fit: cover; flex-shrink: 0;">
                    <div style="flex: 1;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: ${labTutorialCollapsed ? '0' : '10px'};">
                            <span style="font-size: 1rem; font-weight: 600; color: #555;">선배</span>
                            <div style="display: flex; gap: 6px;">
                                <button onclick="skipLabTutorial()" style="padding: 4px 10px; background: var(--bg); border: 1px solid var(--border); border-radius: 6px; cursor: pointer; font-size: 0.75rem; color: var(--text-muted);">건너뛰기</button>
                                <button onclick="toggleLabTutorialCollapse()" style="padding: 4px 10px; background: var(--bg); border: 1px solid var(--border); border-radius: 6px; cursor: pointer; font-size: 0.75rem; color: var(--text-muted);">
                                    ${labTutorialCollapsed ? '▼ 펼치기' : '▲ 접기'}
                                </button>
                            </div>
                        </div>
                        <div id="labTutorialContent" style="display: ${labTutorialCollapsed ? 'none' : 'block'};">
                            <div style="font-size: 0.95rem; line-height: 1.6; color: var(--text); margin-bottom: 12px; word-break: keep-all;">${text}</div>
                            <div style="display: flex; justify-content: flex-end;">
                                <button onclick="nextLabTutorialStep()" style="padding: 8px 20px; background: #333; color: white; border: none; border-radius: 6px; font-size: 0.9rem; cursor: pointer; font-weight: 600;">다음</button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            const existing = document.getElementById('tutorialModal');
            if (existing) existing.remove();
            
            document.body.appendChild(modal);
        }
        
        function showLabTutorialAction(text, action) {
            const modal = document.createElement('div');
            modal.id = 'tutorialModal';
            modal.style.cssText = `
                position: fixed;
                top: 10px;
                left: 50%;
                transform: translateX(-50%);
                width: 90%;
                max-width: 500px;
                background: var(--card);
                border: 2px solid #555;
                border-radius: 16px;
                padding: 15px;
                z-index: 100000;
                box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            `;
            
            modal.innerHTML = `
                <div style="display: flex; gap: 15px; align-items: flex-start;">
                    <img src="https://i.imgur.com/KSl4CWY.png" alt="선배" style="width: 150px; height: 150px; object-fit: cover; flex-shrink: 0;">
                    <div style="flex: 1;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: ${labTutorialCollapsed ? '0' : '10px'};">
                            <span style="font-size: 1rem; font-weight: 600; color: #555;">선배</span>
                            <div style="display: flex; gap: 6px;">
                                <button onclick="skipLabTutorial()" style="padding: 4px 10px; background: var(--bg); border: 1px solid var(--border); border-radius: 6px; cursor: pointer; font-size: 0.75rem; color: var(--text-muted);">건너뛰기</button>
                                <button onclick="toggleLabTutorialCollapse()" style="padding: 4px 10px; background: var(--bg); border: 1px solid var(--border); border-radius: 6px; cursor: pointer; font-size: 0.75rem; color: var(--text-muted);">
                                    ${labTutorialCollapsed ? '▼ 펼치기' : '▲ 접기'}
                                </button>
                            </div>
                        </div>
                        <div id="labTutorialContent" style="display: ${labTutorialCollapsed ? 'none' : 'block'};">
                            <div style="font-size: 0.95rem; line-height: 1.6; color: var(--text); word-break: keep-all;">${text}</div>
                        </div>
                    </div>
                </div>
            `;
            
            const existing = document.getElementById('tutorialModal');
            if (existing) existing.remove();
            
            document.body.appendChild(modal);
            
            window.tutorialWaitingFor = action;
            highlightLabTutorialTarget(action);
        }
        
        function highlightLabTutorialTarget(action) {
            clearTutorialHighlight();
            
            let targetSelector = null;
            switch(action) {
                case 'openLab':
                    targetSelector = 'button[onclick*="switchTab(\'lab\')"]';
                    break;
                case 'clickSlot1':
                    targetSelector = '#labSlot1';
                    break;
                case 'selectIngredient1':
                    targetSelector = '.lab-item-btn';
                    break;
                case 'selectIngredient2':
                    targetSelector = '#labSlot2';
                    break;
                case 'synthesize':
                    targetSelector = '#synthesizeBtn';
                    break;
            }
            
            if (targetSelector) {
                const target = document.querySelector(targetSelector);
                if (target) {
                    target.classList.add('tutorial-highlight');
                    target.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            }
        }
        
        function checkLabTutorialAction(action) {
            if (!labTutorialActive) return;
            if (window.tutorialWaitingFor === action) {
                window.tutorialWaitingFor = null;
                clearTutorialHighlight();
                nextLabTutorialStep();
            }
        }
        
        function nextLabTutorialStep() {
            labTutorialStep++;
            showLabTutorialStep();
        }
        
        function toggleLabTutorialCollapse() {
            labTutorialCollapsed = !labTutorialCollapsed;
            showLabTutorialStep();
        }
        
        function skipLabTutorial() {
            // 건너뛰기는 보상 없이 종료
            labTutorialActive = false;
            window.tutorialWaitingFor = null;
            clearTutorialHighlight();
            
            const modal = document.getElementById('tutorialModal');
            if (modal) {
                modal.style.opacity = '0';
                modal.style.transition = 'opacity 0.3s';
                setTimeout(() => modal.remove(), 300);
            }
            
            localStorage.setItem('spiritGarden_labTutorialSeen', 'true');
            showNotification('튜토리얼을 건너뛰었습니다.');
        }
        
        function endLabTutorial() {
            labTutorialActive = false;
            window.tutorialWaitingFor = null;
            clearTutorialHighlight();
            
            const modal = document.getElementById('tutorialModal');
            if (modal) {
                modal.style.opacity = '0';
                modal.style.transition = 'opacity 0.3s';
                setTimeout(() => modal.remove(), 300);
            }
            
            localStorage.setItem('spiritGarden_labTutorialSeen', 'true');
            
            // 보상 미수령 상태면 안내
            if (!localStorage.getItem('spiritGarden_labTutorialCompleted')) {
                setTimeout(() => {
                    showNotification('🎓 튜토리얼 완료! 일지→도움말에서 보상을 받으세요');
                }, 500);
            }
        }
        
        // 소지품 개수 체크 및 연구실 튜토리얼 시작
        function checkInventoryAndLabTutorial() {
            if (localStorage.getItem('spiritGarden_labTutorialSeen')) return;
            
            // 이미 연구실 튜토리얼이 진행 중이면 체크하지 않음
            if (labTutorialActive) return;
            
            // 총 소지품 개수 계산
            const foodCount = (inventory.food || []).length;
            const decoCount = (inventory.decorations || []).length;
            const totalCount = foodCount + decoCount;
            
            if (totalCount >= 100) {
                setTimeout(() => {
                    startLabTutorial();
                }, 500);
            }
        }
        
        function checkAndShowOpening() {
            const seen = localStorage.getItem('spiritGarden_openingSeen');
            if (!seen) {
                showOpening();
            } else {
                // 오프닝은 봤지만 튜토리얼은 안 본 경우
                const tutorialSeen = localStorage.getItem('spiritGarden_tutorialSeen');
                if (!tutorialSeen) {
                    startTutorial();
                }
            }
        }

        // 모바일 디버깅 정보
        console.log('=== 모바일 디버깅 정보 ===');
        console.log('현재 시간:', new Date().toISOString());
        
        // 초기화
        try {
            console.log('게임 초기화 시작...');
            loadGame();
            renderSpirits();
            renderInventory();
            renderShop();
            updateTimeDisplay();
            applyLightMode();
            updateCoinDisplay();
            updateInventoryCollapseUI(); // 소지품 접힘 상태 적용
            startAutoGather(); // 자동 채집 시작
            checkAndShowOpening(); // 오프닝 체크
            checkAchievements(); // 업적 체크 (기존 데이터용)
            
            // 연구실 튜토리얼 체크 (약간의 딜레이로 다른 튜토리얼과 충돌 방지)
            setTimeout(() => {
                checkInventoryAndLabTutorial();
            }, 3000);
            
            console.log('🎉 게임 초기화 완료!');
        } catch (error) {
            console.error('❌ 초기화 오류:', error);
            console.error('오류 스택:', error.stack);
            alert('게임 초기화 중 오류가 발생했습니다: ' + error.message);
        }

        // 모달 배경 클릭 시 닫기
        document.querySelectorAll('.modal').forEach(modal => {
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.classList.remove('active');
                }
            });
        });
    </script>
    
    <!-- 플로팅 스크롤 버튼 -->
    <div class="scroll-buttons">
        <button class="scroll-btn" onclick="window.scrollTo({top: 0, behavior: 'smooth'})" title="맨 위로">⬆️</button>
        <button class="scroll-btn" onclick="window.scrollTo({top: document.body.scrollHeight, behavior: 'smooth'})" title="맨 아래로">⬇️</button>
    </div>
</body>
</html>
